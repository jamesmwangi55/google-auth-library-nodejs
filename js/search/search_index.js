var COMPODOC_SEARCH_INDEX = {
    "index": {"version":"2.3.5","fields":["title","body"],"fieldVectors":[["title/interfaces/ADCCallback.html",[0,0.3,1,1.996]],["body/interfaces/ADCCallback.html",[0,0.52,1,3.217,2,0.169,3,0.15,4,0.278,5,1.626,6,0.094,7,0.433,8,1.427,9,1.639,10,0.021,11,0.878,12,0.815,13,0.645,14,0.638,15,1.1,16,1.438,17,0.365,18,0.59,19,0.919,20,0.717,21,0.689,22,0.505,23,0.81,24,2.527,25,1.746,26,0.915,27,2.527,28,1.626,29,1.427,30,0.982,31,0.999,32,2.971,33,3.352,34,1.166,35,0.965,36,0.887,37,2.363,38,0.942,39,2.369,40,2.527,41,2.369,42,1.552,43,1.521,44,2.766,45,1.746,46,2.418,47,1.521,48,1.746,49,1.037,50,1.246,51,2.201,52,1.746,53,0.333,54,3.217,55,0.887,56,0.781,57,3.032,58,0.014,59,2.527,60,2.354,61,2.766,62,3.101,63,0.915,64,2.527,65,1.074,66,2.527,67,1.626,68,0.566,69,0.566,70,2.409,71,1.926,72,0.274,73,0.671,74,1.746,75,0.944,76,0.765,77,0.915,78,1.307,79,1.109,80,0.683,81,2.354,82,1.626,83,1.626,84,0.11,85,1.626,86,2.587,87,0.689,88,0.476,89,0.942,90,0.888,91,2.527,92,3.009,93,0.588,94,2.587,95,0.856,96,1.746,97,0.689,98,2.354,99,0.819,100,1.746,101,1.521,102,1.746,103,1.746,104,0.598,105,1.746,106,3.602,107,3.256,108,1.746,109,1.319,110,1.746,111,1.626,112,0.598,113,1.746,114,1.746,115,1.746,116,1.746,117,0.774,118,0.566,119,1.013,120,2.971,121,1.746,122,3.256,123,1.746,124,1.626,125,3.354,126,0.632,127,3.602,128,1.746,129,0.534,130,0.395,131,0.566,132,1.521,133,1.267,134,0.376,135,2.201,136,0.505,137,1.427,138,2.527,139,1.075,140,1.746,141,0.918,142,2.527,143,0.81,144,1.057,145,2.971,146,1.013,147,0.911,148,0.781,149,0.753,150,0.426,151,1.257,152,2.286,153,2.527,154,1.746,155,1.746,156,2.527,157,0.762,158,0.535,159,1.746,160,2.857,161,1.746,162,1.746,163,1.746,164,1.746,165,2.241,166,2.766,167,2.658,168,2.428,169,2.971,170,2.825,171,2.527,172,2.201,173,3.455,174,0.942,175,2.971,176,0.824,177,1.746,178,2.156,179,0.843,180,1.746,181,1.327,182,1.746,183,1.746,184,1.746,185,2.527,186,0.804,187,0.814,188,1.626,189,2.112,190,1.626,191,0.682,192,2.527,193,1.746,194,2.527,195,3.804,196,1.746,197,0.819,198,1.746,199,0.689,200,0.762,201,1.746,202,2.527,203,0.667,204,2.527,205,1.746,206,1.265,207,1.746,208,1.746,209,0.632,210,3.988,211,1.746,212,0.963,213,1.377,214,2.354,215,0.598,216,4.068,217,1.746,218,0.632,219,1.521,220,2.527,221,1.075,222,2.527,223,3.256,224,2.354,225,2.766,226,2.971,227,1.746,228,1.234,229,0.667,230,2.527,231,0.867,232,1.746,233,1.626,234,0.632,235,0.667,236,0.632,237,1.746,238,1.075,239,3.543,240,1.746,241,1.746,242,0.505,243,0.535,244,0.395,245,0.632,246,1.626,247,1.746,248,1.746,249,1.746,250,1.746,251,2.766,252,1.746,253,2.971,254,1.746,255,1.746,256,3.032,257,1.746,258,2.971,259,1.746,260,3.354,261,0.566,262,1.746,263,0.866,264,1.746,265,1.343,266,1.626,267,0.076,268,1.746,269,2.354,270,1.746,271,1.746,272,1.746,273,2.527,274,1.746,275,1.746,276,1.521,277,1.746,278,1.746,279,2.527,280,1.746,281,1.746,282,1.746,283,1.746,284,0.82,285,1.746,286,1.746,287,0.804,288,3.804,289,1.746,290,0.688,291,0.915,292,1.746,293,0.632,294,0.632,295,1.746,296,1.626,297,1.746,298,1.746,299,0.667,300,1.746,301,1.746,302,1.746,303,1.746,304,3.037,305,0.632,306,1.626,307,1.746,308,1.746,309,1.746,310,1.746,311,1.746,312,1.521,313,1.746,314,1.746,315,0.535,316,1.343,317,1.521,318,1.267,319,0.505,320,1.746,321,1.746,322,1.746,323,0.543,324,2.286,325,2.662,326,1.746,327,1.206,328,1.427,329,1.746,330,0.609,331,1.626,332,1.626,333,1.746,334,1.746,335,2.527,336,1.746,337,2.825,338,2.428,339,1.168,340,2.201,341,1.746,342,2.066,343,1.746,344,1.746,345,1.343,346,1.427,347,1.427,348,1.427,349,2.066,350,1.427,351,1.427,352,1.427,353,1.746,354,1.521,355,0.632,356,1.626,357,1.746,358,2.766,359,2.527,360,2.066,361,1.746,362,2.527,363,1.746,364,1.746,365,1.521,366,1.746,367,1.746,368,1.746,369,0.819,370,0.345,371,1.184,372,3.455,373,1.746,374,2.527,375,0.963,376,1.521,377,1.746,378,1.746,379,1.746,380,1.746,381,1.521,382,0.667,383,1.626,384,1.746,385,2.527,386,1.746,387,1.746,388,0.571,389,1.746,390,2.971,391,1.746,392,1.746,393,1.746,394,1.746,395,1.626,396,1.626,397,1.746,398,1.746,399,2.527,400,1.746,401,1.746,402,2.066,403,1.746,404,1.746,405,1.746,406,1.746,407,1.746,408,1.746,409,1.746,410,1.746,411,1.746,412,1.746,413,0.965,414,3.032,415,0.345,416,2.201,417,1.746,418,1.746,419,1.746,420,1.746,421,1.746,422,1.746,423,0.716,424,1.343,425,0.667,426,1.343,427,1.626,428,1.746,429,1.746,430,0.632,431,1.746,432,1.746,433,1.746,434,2.527,435,1.746,436,0.963,437,0.598,438,0.689,439,1.132,440,1.746,441,1.746,442,1.746,443,1.746,444,1.746,445,1.746,446,1.746,447,1.746,448,1.746,449,0.421,450,0.369,451,0.632,452,3.455,453,1.746,454,0.395,455,0.632,456,2.527,457,2.354,458,0.598,459,1.746,460,0.81,461,0.566,462,1.746,463,1.746,464,0.535,465,1.746,466,1.197,467,1.197,468,1.197,469,0.535,470,1.746,471,0.395,472,1.304,473,1.626,474,1.267,475,1.746,476,1.746,477,1.746,478,0.667,479,1.746,480,1.746,481,0.667,482,2.527,483,1.521,484,1.746,485,1.746,486,1.746,487,0.421,488,1.746,489,0.667,490,1.746,491,1.746,492,1.746,493,1.746,494,1.626,495,0.012]],["title/interfaces/ADCResponse.html",[0,0.3,60,1.996]],["body/interfaces/ADCResponse.html",[0,0.52,1,3.032,2,0.169,3,0.15,4,0.278,5,1.626,6,0.094,7,0.415,9,1.132,10,0.021,11,0.873,12,0.809,13,0.645,14,0.639,15,1.121,16,1.45,17,0.366,18,0.589,19,0.911,20,0.717,21,0.689,22,0.505,23,0.81,24,2.527,25,1.746,26,0.915,27,2.527,28,1.626,29,1.427,30,0.982,31,0.999,32,2.97,33,3.352,34,1.165,35,0.965,36,0.886,37,2.362,38,0.941,39,2.368,40,2.527,41,2.368,42,1.552,43,1.52,44,2.766,45,1.746,46,2.418,47,1.52,48,1.746,49,1.037,50,1.246,51,2.201,52,1.746,53,0.333,54,3.217,55,0.886,56,0.781,57,3.032,58,0.014,59,2.527,60,2.766,61,2.766,62,3.101,63,0.915,64,2.527,65,1.074,66,2.527,67,1.626,68,0.566,69,0.566,70,2.409,71,1.926,72,0.274,73,0.671,74,1.746,75,0.944,76,0.765,77,0.915,78,1.307,79,1.109,80,0.683,81,2.353,82,1.626,83,1.626,84,0.11,85,1.626,86,2.587,87,0.689,88,0.476,89,0.942,90,0.887,91,2.527,92,3.009,93,0.588,94,2.587,95,0.856,96,1.746,97,0.689,98,2.353,99,0.819,100,1.746,101,1.52,102,1.746,103,1.746,104,0.598,105,1.746,106,3.602,107,3.256,108,1.746,109,1.319,110,1.746,111,1.626,112,0.598,113,1.746,114,1.746,115,1.746,116,1.746,117,0.774,118,0.566,119,1.013,120,2.97,121,1.746,122,3.256,123,1.746,124,1.626,125,3.354,126,0.632,127,3.602,128,1.746,129,0.534,130,0.395,131,0.566,132,1.52,133,1.267,134,0.376,135,2.201,136,0.505,137,1.427,138,2.527,139,1.075,140,1.746,141,0.918,142,2.527,143,0.81,144,1.057,145,2.97,146,1.013,147,0.911,148,0.781,149,0.753,150,0.426,151,1.257,152,2.285,153,2.527,154,1.746,155,1.746,156,2.527,157,0.762,158,0.535,159,1.746,160,2.857,161,1.746,162,1.746,163,1.746,164,1.746,165,2.241,166,2.766,167,2.658,168,2.428,169,2.97,170,2.824,171,2.527,172,2.201,173,3.455,174,0.942,175,2.97,176,0.824,177,1.746,178,2.155,179,0.843,180,1.746,181,1.327,182,1.746,183,1.746,184,1.746,185,2.527,186,0.804,187,0.814,188,1.626,189,2.111,190,1.626,191,0.682,192,2.527,193,1.746,194,2.527,195,3.804,196,1.746,197,0.819,198,1.746,199,0.689,200,0.762,201,1.746,202,2.527,203,0.667,204,2.527,205,1.746,206,1.265,207,1.746,208,1.746,209,0.632,210,3.987,211,1.746,212,0.963,213,1.377,214,2.353,215,0.598,216,4.068,217,1.746,218,0.632,219,1.52,220,2.527,221,1.075,222,2.527,223,3.256,224,2.353,225,2.766,226,2.97,227,1.746,228,1.234,229,0.667,230,2.527,231,0.867,232,1.746,233,1.626,234,0.632,235,0.667,236,0.632,237,1.746,238,1.075,239,3.542,240,1.746,241,1.746,242,0.505,243,0.535,244,0.395,245,0.632,246,1.626,247,1.746,248,1.746,249,1.746,250,1.746,251,2.766,252,1.746,253,2.97,254,1.746,255,1.746,256,3.032,257,1.746,258,2.97,259,1.746,260,3.354,261,0.566,262,1.746,263,0.866,264,1.746,265,1.343,266,1.626,267,0.129,268,1.746,269,2.353,270,1.746,271,1.746,272,1.746,273,2.527,274,1.746,275,1.746,276,1.52,277,1.746,278,1.746,279,2.527,280,1.746,281,1.746,282,1.746,283,1.746,284,0.82,285,1.746,286,1.746,287,0.804,288,3.804,289,1.746,290,0.688,291,0.915,292,1.746,293,0.632,294,0.632,295,1.746,296,1.626,297,1.746,298,1.746,299,0.667,300,1.746,301,1.746,302,1.746,303,1.746,304,3.037,305,0.632,306,1.626,307,1.746,308,1.746,309,1.746,310,1.746,311,1.746,312,1.52,313,1.746,314,1.746,315,0.535,316,1.343,317,1.52,318,1.267,319,0.505,320,1.746,321,1.746,322,1.746,323,0.543,324,2.285,325,2.662,326,1.746,327,1.206,328,1.427,329,1.746,330,0.609,331,1.626,332,1.626,333,1.746,334,1.746,335,2.527,336,1.746,337,2.824,338,2.428,339,1.168,340,2.201,341,1.746,342,2.066,343,1.746,344,1.746,345,1.343,346,1.427,347,1.427,348,1.427,349,2.066,350,1.427,351,1.427,352,1.427,353,1.746,354,1.52,355,0.632,356,1.626,357,1.746,358,2.766,359,2.527,360,2.066,361,1.746,362,2.527,363,1.746,364,1.746,365,1.52,366,1.746,367,1.746,368,1.746,369,0.819,370,0.344,371,1.184,372,3.455,373,1.746,374,2.527,375,0.963,376,1.52,377,1.746,378,1.746,379,1.746,380,1.746,381,1.52,382,0.667,383,1.626,384,1.746,385,2.527,386,1.746,387,1.746,388,0.571,389,1.746,390,2.97,391,1.746,392,1.746,393,1.746,394,1.746,395,1.626,396,1.626,397,1.746,398,1.746,399,2.527,400,1.746,401,1.746,402,2.066,403,1.746,404,1.746,405,1.746,406,1.746,407,1.746,408,1.746,409,1.746,410,1.746,411,1.746,412,1.746,413,0.965,414,3.032,415,0.344,416,2.201,417,1.746,418,1.746,419,1.746,420,1.746,421,1.746,422,1.746,423,0.716,424,1.343,425,0.667,426,1.343,427,1.626,428,1.746,429,1.746,430,0.632,431,1.746,432,1.746,433,1.746,434,2.527,435,1.746,436,0.963,437,0.598,438,0.689,439,1.132,440,1.746,441,1.746,442,1.746,443,1.746,444,1.746,445,1.746,446,1.746,447,1.746,448,1.746,449,0.421,450,0.369,451,0.632,452,3.455,453,1.746,454,0.395,455,0.632,456,2.527,457,2.353,458,0.598,459,1.746,460,0.81,461,0.566,462,1.746,463,1.746,464,0.535,465,1.746,466,1.197,467,1.197,468,1.197,469,0.535,470,1.746,471,0.395,472,1.304,473,1.626,474,1.267,475,1.746,476,1.746,477,1.746,478,0.667,479,1.746,480,1.746,481,0.667,482,2.527,483,1.52,484,1.746,485,1.746,486,1.746,487,0.421,488,1.746,489,0.667,490,1.746,491,1.746,492,1.746,493,1.746,494,1.626,495,0.012]],["title/interfaces/BodyResponseCallback.html",[0,0.3,496,0.863]],["body/interfaces/BodyResponseCallback.html",[0,0.561,2,0.284,3,0.251,4,0.188,6,0.157,7,0.463,8,2.392,9,1.897,10,0.021,11,0.848,12,0.825,13,0.605,17,0.306,18,0.56,19,0.906,20,0.607,21,1.186,22,1.114,23,1.093,37,2.123,38,1.032,53,0.344,55,0.751,58,0.017,68,0.561,69,0.46,72,0.46,75,0.807,76,0.825,80,0.672,84,0.127,93,0.498,95,0.577,117,0.896,119,1.093,134,0.389,141,0.91,143,0.797,144,0.973,147,0.661,149,0.707,150,0.418,157,0.751,160,2.123,165,2.314,176,0.577,179,0.755,186,0.619,187,0.906,191,0.704,199,0.797,231,0.755,267,0.127,284,0.577,287,0.619,290,0.755,323,0.46,330,0.705,370,0.577,388,0.661,415,0.791,424,2.251,439,2.497,464,1.093,466,2.446,467,2.446,468,2.64,469,1.281,471,0.661,487,1.008,495,0.017,496,1.685,497,3.16,498,1.551,499,1.615,500,1.059,501,2.123,502,3.16,503,2.925,504,3.492,505,4.234,506,3.16,507,3.16,508,3.16,509,3.16,510,3.855,511,1.516,512,4.838,513,3.443,514,3.443,515,1.243,516,4.16,517,1.059,518,4.2,519,1.059,520,2.925,521,3.443,522,3.443,523,3.16,524,3.443,525,3.443,526,1.223,527,3.16,528,3.443,529,3.443,530,3.443,531,3.443,532,1.243,533,3.443,534,3.443,535,2.251,536,3.443,537,4.532,538,4.532,539,4.2,540,3.443,541,1.179,542,3.443,543,3.443,544,3.443,545,3.16,546,1.243,547,3.16,548,3.443,549,4.2,550,3.443,551,3.443,552,3.443,553,3.443,554,3.443,555,3.443,556,3.443,557,0.896,558,3.443,559,1.243,560,1.179,561,4.532,562,1.551,563,3.443,564,4.719,565,4.719,566,3.855,567,3.443,568,3.443,569,3.443,570,4.2,571,3.443,572,3.443,573,3.443,574,3.16,575,3.443,576,3.443,577,3.443,578,1.059]],["title/interfaces/ComputeOptions.html",[0,0.3,579,3.128]],["body/interfaces/ComputeOptions.html",[0,0.507,2,0.291,3,0.257,4,0.193,6,0.161,7,0.435,10,0.021,12,0.715,13,0.569,14,0.598,15,1.126,17,0.355,18,0.563,20,0.705,21,0.987,22,1.048,23,0.817,28,2.792,29,2.451,30,0.987,36,0.929,39,2.993,50,1.193,53,0.311,58,0.017,72,0.569,73,0.936,75,0.678,80,0.612,84,0.131,88,0.987,89,0.817,93,0.51,94,3.739,95,0.592,97,0.817,109,0.919,118,0.972,130,0.678,134,0.378,147,0.88,149,0.55,150,0.351,174,0.817,176,0.715,179,0.634,181,0.919,186,0.634,187,0.97,189,2.784,206,0.919,231,0.766,234,1.463,242,0.867,251,3.373,261,1.262,263,1.027,267,0.131,276,2.612,319,1.048,323,0.471,324,3.111,370,0.768,423,1.026,436,0.972,449,0.998,450,0.919,487,0.998,495,0.017,498,1.208,499,1.459,517,1.409,535,2.787,557,0.919,560,1.459,562,1.568,566,3.239,579,5.681,580,5.113,581,6.042,582,1.384,583,1.539,584,1.145,585,1.273,586,1.742,587,1.027,588,5.113,589,5.113,590,1.208,591,1.386,592,1.384,593,4.376,594,1.414,595,1.085,596,1.085,597,1.027,598,4.376,599,5.113,600,5.113,601,3.529,602,2.612,603,5.113,604,5.113,605,1.273,606,4.376,607,1.027,608,5.113,609,1.342,610,5.113,611,0.919,612,1.342,613,5.113,614,5.113,615,5.113,616,1.8,617,1.49,618,1.49,619,1.414,620,1.49,621,1.49,622,1.414,623,1.49,624,1.622,625,5.113,626,5.113,627,1.49,628,7.172,629,1.49,630,5.113,631,6.177,632,1.414,633,3.914,634,1.414,635,5.113,636,5.113]],["title/interfaces/CredentialBody.html",[0,0.3,41,1.469]],["body/interfaces/CredentialBody.html",[0,0.597,2,0.327,3,0.29,4,0.217,6,0.181,7,0.467,10,0.021,14,0.488,17,0.385,41,2.663,42,2.073,53,0.361,56,0.95,58,0.018,70,2.77,71,2.77,150,0.408,267,0.178,495,0.018,584,1.289,595,1.222,597,1.402,637,3.973,638,3.973,639,1.484,640,4.197,641,4.197,642,1.434,643,1.222,644,3.376,645,3.647,646,1.157,647,1.289]],["title/interfaces/CredentialCallback.html",[0,0.3,57,1.996]],["body/interfaces/CredentialCallback.html",[0,0.52,1,3.033,2,0.169,3,0.15,4,0.278,5,1.627,6,0.094,7,0.433,8,1.428,9,1.64,10,0.021,11,0.878,12,0.815,13,0.64,14,0.638,15,1.074,16,1.431,17,0.363,18,0.59,19,0.92,20,0.718,21,0.689,22,0.505,23,0.81,24,2.528,25,1.747,26,0.915,27,2.528,28,1.627,29,1.428,30,0.982,31,0.999,32,2.971,33,3.352,34,1.166,35,0.966,36,0.887,37,2.363,38,0.942,39,2.369,40,2.528,41,2.369,42,1.553,43,1.521,44,2.767,45,1.747,46,2.449,47,1.521,48,1.747,49,1.037,50,1.246,51,2.588,52,1.747,53,0.333,54,3.218,55,0.887,56,0.781,57,3.218,58,0.015,59,2.528,60,2.354,61,2.767,62,3.101,63,0.915,64,2.528,65,1.074,66,2.528,67,1.627,68,0.566,69,0.566,70,2.41,71,1.927,72,0.275,73,0.672,74,1.747,75,0.944,76,0.765,77,0.915,78,1.307,79,1.109,80,0.683,81,2.354,82,1.627,83,1.627,84,0.11,85,1.627,86,2.588,87,0.689,88,0.476,89,0.942,90,0.888,91,2.528,92,3.01,93,0.588,94,2.588,95,0.856,96,1.747,97,0.689,98,2.354,99,0.82,100,1.747,101,1.521,102,1.747,103,1.747,104,0.599,105,1.747,106,3.603,107,3.257,108,1.747,109,1.319,110,1.747,111,1.627,112,0.599,113,1.747,114,1.747,115,1.747,116,1.747,117,0.775,118,0.566,119,1.013,120,2.971,121,1.747,122,3.257,123,1.747,124,1.627,125,3.355,126,0.632,127,3.603,128,1.747,129,0.535,130,0.395,131,0.566,132,1.521,133,1.268,134,0.376,135,2.202,136,0.505,137,1.428,138,2.528,139,1.075,140,1.747,141,0.918,142,2.528,143,0.81,144,1.057,145,2.971,146,1.013,147,0.911,148,0.781,149,0.753,150,0.426,151,1.257,152,2.286,153,2.528,154,1.747,155,1.747,156,2.528,157,0.762,158,0.535,159,1.747,160,2.857,161,1.747,162,1.747,163,1.747,164,1.747,165,2.241,166,2.767,167,2.659,168,2.429,169,2.971,170,2.825,171,2.528,172,2.202,173,3.456,174,0.942,175,2.971,176,0.824,177,1.747,178,2.156,179,0.843,180,1.747,181,1.327,182,1.747,183,1.747,184,1.747,185,2.528,186,0.805,187,0.814,188,1.627,189,2.112,190,1.627,191,0.682,192,2.528,193,1.747,194,2.528,195,3.805,196,1.747,197,0.82,198,1.747,199,0.689,200,0.762,201,1.747,202,2.528,203,0.667,204,2.528,205,1.747,206,1.265,207,1.747,208,1.747,209,0.632,210,3.988,211,1.747,212,0.963,213,1.377,214,2.354,215,0.599,216,4.068,217,1.747,218,0.632,219,1.521,220,2.528,221,1.075,222,2.528,223,3.257,224,2.354,225,2.767,226,2.971,227,1.747,228,1.235,229,0.667,230,2.528,231,0.867,232,1.747,233,1.627,234,0.632,235,0.667,236,0.632,237,1.747,238,1.075,239,3.543,240,1.747,241,1.747,242,0.505,243,0.535,244,0.395,245,0.632,246,1.627,247,1.747,248,1.747,249,1.747,250,1.747,251,2.767,252,1.747,253,2.971,254,1.747,255,1.747,256,3.033,257,1.747,258,2.971,259,1.747,260,3.355,261,0.566,262,1.747,263,0.866,264,1.747,265,1.344,266,1.627,267,0.076,268,1.747,269,2.354,270,1.747,271,1.747,272,1.747,273,2.528,274,1.747,275,1.747,276,1.521,277,1.747,278,1.747,279,2.528,280,1.747,281,1.747,282,1.747,283,1.747,284,0.82,285,1.747,286,1.747,287,0.805,288,3.805,289,1.747,290,0.689,291,0.915,292,1.747,293,0.632,294,0.632,295,1.747,296,1.627,297,1.747,298,1.747,299,0.667,300,1.747,301,1.747,302,1.747,303,1.747,304,3.037,305,0.632,306,1.627,307,1.747,308,1.747,309,1.747,310,1.747,311,1.747,312,1.521,313,1.747,314,1.747,315,0.535,316,1.344,317,1.521,318,1.268,319,0.505,320,1.747,321,1.747,322,1.747,323,0.543,324,2.286,325,2.662,326,1.747,327,1.206,328,1.428,329,1.747,330,0.609,331,1.627,332,1.627,333,1.747,334,1.747,335,2.528,336,1.747,337,2.825,338,2.429,339,1.168,340,2.202,341,1.747,342,2.067,343,1.747,344,1.747,345,1.344,346,1.428,347,1.428,348,1.428,349,2.067,350,1.428,351,1.428,352,1.428,353,1.747,354,1.521,355,0.632,356,1.627,357,1.747,358,2.767,359,2.528,360,2.067,361,1.747,362,2.528,363,1.747,364,1.747,365,1.521,366,1.747,367,1.747,368,1.747,369,0.82,370,0.345,371,1.184,372,3.456,373,1.747,374,2.528,375,0.963,376,1.521,377,1.747,378,1.747,379,1.747,380,1.747,381,1.521,382,0.667,383,1.627,384,1.747,385,2.528,386,1.747,387,1.747,388,0.571,389,1.747,390,2.971,391,1.747,392,1.747,393,1.747,394,1.747,395,1.627,396,1.627,397,1.747,398,1.747,399,2.528,400,1.747,401,1.747,402,2.067,403,1.747,404,1.747,405,1.747,406,1.747,407,1.747,408,1.747,409,1.747,410,1.747,411,1.747,412,1.747,413,0.966,414,3.033,415,0.345,416,2.202,417,1.747,418,1.747,419,1.747,420,1.747,421,1.747,422,1.747,423,0.716,424,1.344,425,0.667,426,1.344,427,1.627,428,1.747,429,1.747,430,0.632,431,1.747,432,1.747,433,1.747,434,2.528,435,1.747,436,0.963,437,0.599,438,0.689,439,1.133,440,1.747,441,1.747,442,1.747,443,1.747,444,1.747,445,1.747,446,1.747,447,1.747,448,1.747,449,0.421,450,0.369,451,0.632,452,3.456,453,1.747,454,0.395,455,0.632,456,2.528,457,2.354,458,0.599,459,1.747,460,0.81,461,0.566,462,1.747,463,1.747,464,0.535,465,1.747,466,1.198,467,1.198,468,1.198,469,0.535,470,1.747,471,0.395,472,1.304,473,1.627,474,1.268,475,1.747,476,1.747,477,1.747,478,0.667,479,1.747,480,1.747,481,0.667,482,2.528,483,1.521,484,1.747,485,1.747,486,1.747,487,0.421,488,1.747,489,0.667,490,1.747,491,1.747,492,1.747,493,1.747,494,1.627,495,0.012]],["title/interfaces/CredentialRequest.html",[0,0.3,584,0.819]],["body/interfaces/CredentialRequest.html",[0,0.596,2,0.324,3,0.286,4,0.214,6,0.179,7,0.464,10,0.021,14,0.482,17,0.386,41,2.287,42,2.049,53,0.359,56,0.946,58,0.018,70,2.502,71,2.502,150,0.428,267,0.188,495,0.018,584,1.474,595,1.207,597,1.476,637,3.926,638,3.926,639,1.627,640,4.601,641,4.601,642,1.778,643,1.473,644,3.336,645,3.604,646,1.143,647,1.274]],["title/interfaces/Credentials.html",[0,0.3,14,0.31]],["body/interfaces/Credentials.html",[0,0.591,2,0.314,3,0.278,4,0.244,6,0.174,7,0.456,10,0.021,13,0.691,14,0.548,17,0.385,41,2.22,42,1.989,53,0.356,56,0.937,58,0.018,70,2.459,71,2.459,72,0.509,93,0.551,134,0.314,146,0.883,148,0.732,150,0.426,152,2.491,267,0.186,316,2.491,495,0.018,584,1.237,587,1.11,595,1.501,597,1.467,633,3.498,637,3.811,638,3.811,639,1.614,640,4.565,641,4.565,642,1.375,643,1.455,644,3.238,645,3.498,646,1.11,647,1.237,648,3.238,649,3.811,650,4.726,651,4.202,652,3.498,653,4.202,654,4.35,655,4.344,656,3.498,657,3.498,658,1.172,659,3.811,660,3.811,661,3.238,662,3.811,663,4.202,664,3.811,665,3.811,666,3.811,667,3.811,668,4.097,669,3.811,670,3.811,671,3.811,672,3.811,673,3.811,674,3.811,675,3.498,676,3.811,677,3.811]],["title/classes/DefaultTransporter.html",[37,1.555,84,0.093]],["body/classes/DefaultTransporter.html",[0,0.528,2,0.272,3,0.24,4,0.18,6,0.151,7,0.418,10,0.021,11,0.799,12,0.801,13,0.44,17,0.298,18,0.569,19,0.918,20,0.591,21,1.212,22,1.005,23,1.107,37,2.521,38,1.005,53,0.339,55,0.718,58,0.016,68,0.546,69,0.44,72,0.44,75,0.785,76,0.866,80,0.666,84,0.151,87,0.947,93,0.477,95,0.552,117,1.157,119,1.156,129,0.735,134,0.394,141,0.925,143,0.763,144,0.947,147,0.893,149,0.693,150,0.429,157,0.718,160,2.032,165,2.253,176,0.552,179,0.735,186,0.592,187,0.893,191,0.745,199,0.763,231,0.735,267,0.185,284,0.552,287,0.735,290,0.835,323,0.44,330,0.675,370,0.552,388,0.633,415,0.801,424,2.154,439,2.72,464,1.064,466,2.381,467,2.381,468,2.589,469,1.309,471,0.633,487,0.979,495,0.016,496,1.722,497,3.025,498,1.522,499,1.69,500,1.013,501,2.946,502,3.025,503,2.8,504,3.44,505,4.239,506,3.025,507,3.025,508,3.025,509,3.025,510,3.753,511,1.475,512,4.778,513,3.295,514,3.295,515,1.189,516,4.08,517,1.013,518,4.088,519,1.013,520,2.8,521,3.295,522,3.295,523,3.025,524,3.295,525,3.295,526,1.19,527,3.025,528,3.295,529,3.295,530,3.295,531,3.295,532,1.604,533,4.647,534,4.088,535,2.673,536,4.088,537,4.445,538,4.445,539,4.088,540,3.295,541,1.399,542,3.295,543,3.295,544,3.295,545,3.025,546,1.189,547,3.025,548,3.295,549,4.088,550,3.295,551,3.295,552,3.295,553,3.295,554,3.295,555,3.295,556,3.295,557,0.858,558,3.295,559,1.189,560,1.128,561,4.445,562,1.522,563,3.295,564,4.647,565,4.647,566,3.753,567,3.295,568,3.295,569,3.295,570,4.088,571,3.295,572,3.295,573,3.295,574,3.025,575,3.295,576,3.295,577,3.295,578,1.013,611,1.285,648,3.474,678,3.781,679,4.774,680,4.774,681,4.774,682,5.512,683,4.774,684,4.088,685,4.774]],["title/interfaces/FederatedSignonCertsResponse.html",[0,0.3,686,1.065]],["body/interfaces/FederatedSignonCertsResponse.html",[0,0.578,2,0.29,3,0.126,4,0.094,6,0.144,7,0.267,10,0.021,11,0.783,12,0.634,13,0.568,14,0.568,15,0.642,16,0.502,17,0.379,18,0.577,19,0.919,20,0.642,21,0.875,22,0.864,23,0.399,26,0.803,30,0.399,31,0.775,34,0.68,35,0.559,36,0.569,38,0.424,49,1.083,50,0.68,53,0.357,55,0.569,56,0.764,58,0.015,63,0.53,65,0.929,68,0.505,69,0.349,72,0.47,73,0.913,75,0.837,76,0.841,77,0.53,78,0.719,79,1.06,80,0.685,84,0.064,87,1.174,88,0.73,89,0.605,90,0.605,93,0.669,95,0.807,97,0.73,99,0.475,104,0.76,109,1.261,112,0.76,117,1.108,118,0.475,119,0.875,126,0.803,129,0.783,130,0.502,131,0.475,134,0.416,136,0.929,139,1.162,141,0.925,143,1.009,144,1.101,146,0.73,147,0.675,148,0.947,149,0.772,150,0.405,151,0.475,157,0.767,158,0.449,174,0.986,176,0.816,179,0.632,181,1.175,186,0.469,187,0.837,191,0.693,197,0.475,199,0.73,200,0.569,203,1.023,206,1.191,209,0.53,212,0.969,213,0.803,215,0.502,218,0.53,221,0.803,228,0.76,229,0.559,231,0.84,234,0.53,235,0.559,236,0.53,238,0.53,242,0.424,243,0.449,244,0.675,245,0.53,261,1.041,263,1.1,267,0.153,284,0.667,287,0.632,290,0.566,291,0.53,293,0.53,294,0.53,299,0.559,305,0.969,315,0.916,319,1.045,323,0.349,327,1.035,330,0.892,339,0.475,355,0.53,369,0.969,370,0.289,371,0.76,375,0.719,382,0.559,388,0.726,413,0.559,415,0.843,423,0.846,425,0.559,430,0.803,436,0.719,437,0.918,438,1.009,449,1.041,450,0.941,451,0.53,454,0.947,455,0.53,458,0.502,460,1.072,461,0.719,464,0.68,469,0.821,471,0.889,472,0.969,478,0.848,481,1.341,487,1.01,489,1.023,495,0.016,496,1.414,498,0.894,499,1.204,500,1.162,511,1.138,515,1.603,517,0.803,519,0.53,526,0.502,532,1.535,541,0.59,546,0.942,557,0.449,559,1.138,560,1.204,562,0.59,578,1.308,582,1.023,583,1.138,584,0.559,585,0.622,586,1.199,587,0.76,590,1.456,591,1.394,592,1.023,594,1.656,595,0.969,596,0.803,597,1.158,605,1.435,607,0.502,609,0.993,611,1.228,612,0.656,616,1.485,617,1.103,618,1.485,619,1.41,620,1.485,621,1.103,622,1.047,623,0.728,624,1.437,627,0.728,629,1.485,632,0.691,634,0.691,639,1.141,642,0.622,643,1.27,646,1.203,647,0.848,658,0.969,686,1.103,687,0.691,688,1.744,689,1.78,690,1.047,691,1.331,692,1.338,693,0.656,694,0.728,695,1.103,696,1.485,697,1.485,698,1.485,699,1.403,700,1.095,701,1.162,702,1.103,703,1.403,704,1.331,705,1.515,706,1.838,707,0.691,708,0.691,709,1.199,710,0.767,711,1.162,712,1.264,713,1.657,714,0.691,715,1.138,716,0.767,717,1.513,718,0.767,719,0.728,720,1.047,721,1.491,722,0.767,723,0.767,724,1.162,725,1.41,726,1.485,727,0.767,728,0.767,729,1.047,730,0.942,731,0.691,732,0.942,733,1.364,734,1.338,735,1.079,736,1.361,737,0.656,738,1.437,739,0.691,740,1.338,741,0.656,742,0.691,743,0.656,744,1.047,745,1.596,746,1.162,747,1.485,748,1.162,749,1.565,750,1.331,751,0.728,752,0.993,753,1.162,754,1.364,755,1.338,756,1.047,757,1.41,758,0.767,759,1.656,760,0.767,761,1.264,762,1.199,763,1.199,764,0.767,765,1.331,766,1.162,767,1.403,768,1.515,769,1.138,770,0.767,771,1.047,772,0.767,773,1.047,774,1.162,775,0.728,776,0.728,777,0.767,778,0.767,779,0.728,780,0.767,781,1.162,782,1.103,783,0.767,784,1.338,785,0.767,786,0.767,787,1.162,788,1.162,789,1.403,790,1.047,791,0.691,792,1.797,793,1.162,794,0.993,795,0.767,796,0.767,797,0.767,798,0.767,799,1.162,800,0.767,801,1.199,802,0.993,803,0.656,804,1.403,805,0.767,806,1.103,807,0.767,808,1.403,809,1.103,810,0.767,811,0.767,812,0.767,813,0.767,814,1.596,815,0.767,816,0.767,817,1.403,818,0.767,819,1.162,820,1.047,821,0.767,822,0.767,823,0.767,824,0.767,825,0.691,826,1.103,827,0.691,828,0.691,829,0.767,830,0.993,831,1.047,832,1.047,833,0.767,834,0.767,835,0.767,836,0.656,837,1.162,838,1.108,839,0.767,840,1.744,841,0.767,842,0.767,843,0.767,844,0.767,845,0.767,846,0.691,847,0.656,848,0.691,849,0.767,850,0.767,851,0.656,852,0.767,853,0.767,854,0.767,855,0.728,856,0.767,857,0.728,858,1.162,859,0.767,860,0.767,861,1.204,862,0.767,863,0.622,864,0.767,865,0.767,866,0.767,867,1.596,868,0.728,869,0.767,870,0.767,871,1.682,872,1.162,873,1.682,874,1.565,875,0.767,876,1.103,877,1.103,878,1.485,879,1.682,880,1.403,881,1.331,882,0.728,883,1.331,884,0.728,885,0.656,886,1.331,887,1.331,888,0.728,889,1.103,890,1.596,891,1.162,892,1.403,893,1.103,894,1.264,895,1.596,896,1.679,897,0.767,898,0.767,899,0.767,900,0.767,901,0.767,902,1.162,903,1.162,904,1.103,905,0.767,906,0.767,907,0.767,908,0.767,909,0.767,910,1.331,911,1.047,912,0.767,913,0.767,914,0.622,915,0.656,916,0.767,917,0.728,918,1.596,919,0.767,920,0.728,921,1.485,922,0.728,923,1.331,924,0.728,925,1.403,926,0.767,927,0.767,928,0.691,929,0.728,930,0.767,931,0.767,932,1.565,933,0.767,934,0.767,935,0.767,936,0.767,937,1.682,938,0.767,939,0.767,940,0.767,941,0.728,942,0.767,943,0.767,944,0.767,945,0.993,946,0.767,947,0.767,948,0.767,949,0.767,950,0.767,951,0.767,952,0.767,953,1.047,954,0.767,955,0.691,956,0.691,957,0.942,958,0.767,959,0.767,960,0.767,961,0.767,962,1.162,963,1.162,964,1.162,965,0.767,966,1.162,967,0.767,968,0.767,969,0.728,970,1.162,971,0.767,972,0.728,973,0.767,974,0.767,975,1.331,976,1.331,977,0.767,978,0.767,979,0.767,980,0.767,981,0.767,982,0.767,983,0.767,984,0.728,985,1.162,986,0.767,987,0.728,988,0.767,989,1.162,990,0.767,991,0.767,992,0.767,993,0.767,994,0.767,995,0.767,996,0.767,997,0.767,998,1.162,999,0.767,1000,0.767,1001,0.767,1002,1.162,1003,1.162,1004,1.162,1005,0.767,1006,0.767,1007,1.403,1008,0.767,1009,1.565,1010,1.893,1011,0.767,1012,0.767,1013,1.162,1014,0.767,1015,0.767,1016,0.767,1017,1.162,1018,0.767,1019,0.767,1020,1.403,1021,0.767,1022,1.162,1023,1.162,1024,1.162,1025,0.767,1026,1.162,1027,0.767,1028,0.767,1029,1.403,1030,1.162,1031,0.767,1032,0.767,1033,0.767,1034,0.767,1035,0.767,1036,0.848,1037,0.622,1038,1.162,1039,0.767,1040,0.767,1041,1.403,1042,0.767,1043,1.515,1044,1.485,1045,0.767,1046,1.103,1047,0.691,1048,0.656,1049,1.162,1050,0.767,1051,0.767,1052,0.767,1053,1.162,1054,1.565,1055,1.162,1056,1.162,1057,0.767,1058,1.264,1059,0.767,1060,1.331,1061,0.767,1062,0.767,1063,1.162,1064,0.767,1065,0.728,1066,1.264,1067,0.767,1068,0.767,1069,0.728,1070,0.767,1071,1.403,1072,0.767,1073,1.485,1074,1.403,1075,0.767,1076,0.767,1077,1.162,1078,1.403,1079,0.767,1080,0.767,1081,0.767,1082,1.162,1083,0.767,1084,0.767,1085,0.767,1086,1.162,1087,0.728,1088,0.767,1089,1.162,1090,0.767,1091,0.767,1092,0.767,1093,0.767,1094,0.691,1095,1.331,1096,0.728,1097,0.691,1098,0.767,1099,0.767,1100,1.162,1101,1.403,1102,0.767,1103,1.162,1104,0.767,1105,0.767,1106,0.767,1107,1.403,1108,0.622,1109,0.767,1110,0.767,1111,0.767,1112,0.622,1113,0.767,1114,0.767,1115,0.767,1116,0.767,1117,0.767,1118,0.728,1119,1.162,1120,1.162,1121,1.162,1122,0.767,1123,1.162,1124,0.993,1125,1.047,1126,0.767,1127,0.767,1128,1.331,1129,0.993,1130,0.767,1131,0.728,1132,0.767,1133,0.767,1134,0.59,1135,0.767,1136,0.767,1137,0.767,1138,1.162,1139,1.162,1140,0.767,1141,0.767,1142,0.767,1143,0.767,1144,0.767,1145,1.103,1146,0.728,1147,1.162,1148,0.767,1149,0.767,1150,0.767,1151,0.767,1152,0.767,1153,0.767,1154,0.767,1155,0.767,1156,0.656,1157,0.767,1158,0.767,1159,1.162,1160,0.767,1161,0.767,1162,0.767,1163,1.162,1164,0.767,1165,0.767,1166,0.728,1167,1.162,1168,0.767,1169,0.656,1170,1.162,1171,1.331,1172,0.767,1173,0.767,1174,1.162,1175,1.162,1176,0.767,1177,0.728,1178,0.993,1179,0.767,1180,1.403,1181,0.767,1182,0.767,1183,0.691,1184,0.767,1185,0.767,1186,0.767,1187,0.767,1188,0.767,1189,1.403]],["title/interfaces/GetAccessTokenCallback.html",[0,0.3,881,1.065]],["body/interfaces/GetAccessTokenCallback.html",[0,0.578,2,0.29,3,0.126,4,0.094,6,0.144,7,0.322,8,1.198,9,0.95,10,0.021,11,0.798,12,0.634,13,0.582,14,0.568,15,0.642,16,0.502,17,0.38,18,0.578,19,0.925,20,0.642,21,0.875,22,0.775,23,0.399,26,0.803,30,0.399,31,0.775,34,0.68,35,0.56,36,0.569,38,0.424,49,1.083,50,0.68,53,0.357,55,0.569,56,0.764,58,0.015,63,0.53,65,0.929,68,0.505,69,0.349,72,0.47,73,0.913,75,0.837,76,0.841,77,0.53,78,0.719,79,1.06,80,0.685,84,0.064,87,1.174,88,0.73,89,0.605,90,0.605,93,0.669,95,0.807,97,0.73,99,0.475,104,0.761,109,1.261,112,0.761,117,1.108,118,0.475,119,0.875,126,0.803,129,0.783,130,0.502,131,0.475,134,0.416,136,0.929,139,1.162,141,0.925,143,1.009,144,1.101,146,0.73,147,0.676,148,0.947,149,0.772,150,0.401,151,0.475,157,0.767,158,0.449,174,0.986,176,0.816,179,0.632,181,1.175,186,0.469,187,0.837,191,0.693,197,0.475,199,0.73,200,0.569,203,1.023,206,1.191,209,0.53,212,0.969,213,0.803,215,0.502,218,0.53,221,0.803,228,0.761,229,0.56,231,0.84,234,0.53,235,0.56,236,0.53,238,0.53,242,0.424,243,0.449,244,0.676,245,0.53,261,1.041,263,1.1,267,0.14,284,0.667,287,0.632,290,0.567,291,0.53,293,0.53,294,0.53,299,0.56,305,0.97,315,0.916,319,1.046,323,0.349,327,1.035,330,0.892,339,0.475,355,0.53,369,0.969,370,0.289,371,0.761,375,0.719,382,0.56,388,0.726,413,0.56,415,0.843,423,0.846,425,0.56,430,0.803,436,0.719,437,0.918,438,1.009,449,1.041,450,0.942,451,0.53,454,0.947,455,0.53,458,0.502,460,1.072,461,0.719,464,0.68,469,0.821,471,0.889,472,0.97,478,0.848,481,1.341,487,1.002,489,1.023,495,0.016,496,1.414,498,1.079,499,1.204,500,1.162,511,1.138,515,1.603,517,0.803,519,0.53,526,0.502,532,1.536,541,0.59,546,0.943,557,0.449,559,1.138,560,1.204,562,0.59,578,1.308,582,1.023,583,1.138,584,0.56,585,0.622,586,1.199,587,0.761,590,1.457,591,1.394,592,1.023,594,1.656,595,0.97,596,0.803,597,1.158,605,1.435,607,0.502,609,0.993,611,1.228,612,0.656,616,1.485,617,1.103,618,1.485,619,1.41,620,1.485,621,1.103,622,1.047,623,0.728,624,1.438,627,0.728,629,1.485,632,0.691,634,0.691,639,1.142,642,0.622,643,1.27,646,1.203,647,0.848,658,0.97,686,0.728,687,0.691,688,1.485,689,1.705,690,1.047,691,1.332,692,1.338,693,0.656,694,0.728,695,1.103,696,1.485,697,1.485,698,1.485,699,1.403,700,1.095,701,1.162,702,1.103,703,1.403,704,1.332,705,1.515,706,1.838,707,0.691,708,0.691,709,1.199,710,0.767,711,1.162,712,1.264,713,1.657,714,0.691,715,1.138,716,0.767,717,1.513,718,0.767,719,0.728,720,1.047,721,1.491,722,0.767,723,0.767,724,1.162,725,1.41,726,1.485,727,0.767,728,0.767,729,1.047,730,0.943,731,0.691,732,0.943,733,1.364,734,1.338,735,1.079,736,1.361,737,0.656,738,1.438,739,0.691,740,1.338,741,0.656,742,0.691,743,0.656,744,1.047,745,1.596,746,1.162,747,1.485,748,1.162,749,1.565,750,1.332,751,0.728,752,0.993,753,1.162,754,1.364,755,1.338,756,1.047,757,1.41,758,0.767,759,1.656,760,0.767,761,1.264,762,1.199,763,1.199,764,0.767,765,1.332,766,1.162,767,1.403,768,1.515,769,1.138,770,0.767,771,1.047,772,0.767,773,1.047,774,1.162,775,0.728,776,0.728,777,0.767,778,0.767,779,0.728,780,0.767,781,1.162,782,1.103,783,0.767,784,1.338,785,0.767,786,0.767,787,1.162,788,1.162,789,1.403,790,1.047,791,0.691,792,1.797,793,1.162,794,0.993,795,0.767,796,0.767,797,0.767,798,0.767,799,1.162,800,0.767,801,1.199,802,0.993,803,0.656,804,1.403,805,0.767,806,1.103,807,0.767,808,1.403,809,1.103,810,0.767,811,0.767,812,0.767,813,0.767,814,1.596,815,0.767,816,0.767,817,1.403,818,0.767,819,1.162,820,1.047,821,0.767,822,0.767,823,0.767,824,0.767,825,0.691,826,1.103,827,0.691,828,0.691,829,0.767,830,0.993,831,1.047,832,1.047,833,0.767,834,0.767,835,0.767,836,0.656,837,1.162,838,1.108,839,0.767,840,1.745,841,0.767,842,0.767,843,0.767,844,0.767,845,0.767,846,0.691,847,0.656,848,0.691,849,0.767,850,0.767,851,0.656,852,0.767,853,0.767,854,0.767,855,0.728,856,0.767,857,0.728,858,1.162,859,0.767,860,0.767,861,1.204,862,0.767,863,0.622,864,0.767,865,0.767,866,0.767,867,1.596,868,0.728,869,0.767,870,0.767,871,1.682,872,1.162,873,1.682,874,1.565,875,0.767,876,1.103,877,1.103,878,1.485,879,1.682,880,1.403,881,1.485,882,0.728,883,1.332,884,0.728,885,0.656,886,1.332,887,1.332,888,0.728,889,1.103,890,1.596,891,1.162,892,1.403,893,1.103,894,1.264,895,1.596,896,1.679,897,0.767,898,0.767,899,0.767,900,0.767,901,0.767,902,1.162,903,1.162,904,1.103,905,0.767,906,0.767,907,0.767,908,0.767,909,0.767,910,1.332,911,1.047,912,0.767,913,0.767,914,0.622,915,0.656,916,0.767,917,0.728,918,1.596,919,0.767,920,0.728,921,1.485,922,0.728,923,1.332,924,0.728,925,1.403,926,0.767,927,0.767,928,0.691,929,0.728,930,0.767,931,0.767,932,1.565,933,0.767,934,0.767,935,0.767,936,0.767,937,1.682,938,0.767,939,0.767,940,0.767,941,0.728,942,0.767,943,0.767,944,0.767,945,0.993,946,0.767,947,0.767,948,0.767,949,0.767,950,0.767,951,0.767,952,0.767,953,1.047,954,0.767,955,0.691,956,0.691,957,0.943,958,0.767,959,0.767,960,0.767,961,0.767,962,1.162,963,1.162,964,1.162,965,0.767,966,1.162,967,0.767,968,0.767,969,0.728,970,1.162,971,0.767,972,0.728,973,0.767,974,0.767,975,1.332,976,1.332,977,0.767,978,0.767,979,0.767,980,0.767,981,0.767,982,0.767,983,0.767,984,0.728,985,1.162,986,0.767,987,0.728,988,0.767,989,1.162,990,0.767,991,0.767,992,0.767,993,0.767,994,0.767,995,0.767,996,0.767,997,0.767,998,1.162,999,0.767,1000,0.767,1001,0.767,1002,1.162,1003,1.162,1004,1.162,1005,0.767,1006,0.767,1007,1.403,1008,0.767,1009,1.565,1010,1.893,1011,0.767,1012,0.767,1013,1.162,1014,0.767,1015,0.767,1016,0.767,1017,1.162,1018,0.767,1019,0.767,1020,1.403,1021,0.767,1022,1.162,1023,1.162,1024,1.162,1025,0.767,1026,1.162,1027,0.767,1028,0.767,1029,1.403,1030,1.162,1031,0.767,1032,0.767,1033,0.767,1034,0.767,1035,0.767,1036,0.848,1037,0.622,1038,1.162,1039,0.767,1040,0.767,1041,1.403,1042,0.767,1043,1.515,1044,1.485,1045,0.767,1046,1.103,1047,0.691,1048,0.656,1049,1.162,1050,0.767,1051,0.767,1052,0.767,1053,1.162,1054,1.565,1055,1.162,1056,1.162,1057,0.767,1058,1.264,1059,0.767,1060,1.332,1061,0.767,1062,0.767,1063,1.162,1064,0.767,1065,0.728,1066,1.264,1067,0.767,1068,0.767,1069,0.728,1070,0.767,1071,1.403,1072,0.767,1073,1.485,1074,1.403,1075,0.767,1076,0.767,1077,1.162,1078,1.403,1079,0.767,1080,0.767,1081,0.767,1082,1.162,1083,0.767,1084,0.767,1085,0.767,1086,1.162,1087,0.728,1088,0.767,1089,1.162,1090,0.767,1091,0.767,1092,0.767,1093,0.767,1094,0.691,1095,1.332,1096,0.728,1097,0.691,1098,0.767,1099,0.767,1100,1.162,1101,1.403,1102,0.767,1103,1.162,1104,0.767,1105,0.767,1106,0.767,1107,1.403,1108,0.622,1109,0.767,1110,0.767,1111,0.767,1112,0.622,1113,0.767,1114,0.767,1115,0.767,1116,0.767,1117,0.767,1118,0.728,1119,1.162,1120,1.162,1121,1.162,1122,0.767,1123,1.162,1124,0.993,1125,1.047,1126,0.767,1127,0.767,1128,1.332,1129,0.993,1130,0.767,1131,0.728,1132,0.767,1133,0.767,1134,0.59,1135,0.767,1136,0.767,1137,0.767,1138,1.162,1139,1.162,1140,0.767,1141,0.767,1142,0.767,1143,0.767,1144,0.767,1145,1.103,1146,0.728,1147,1.162,1148,0.767,1149,0.767,1150,0.767,1151,0.767,1152,0.767,1153,0.767,1154,0.767,1155,0.767,1156,0.656,1157,0.767,1158,0.767,1159,1.162,1160,0.767,1161,0.767,1162,0.767,1163,1.162,1164,0.767,1165,0.767,1166,0.728,1167,1.162,1168,0.767,1169,0.656,1170,1.162,1171,1.332,1172,0.767,1173,0.767,1174,1.162,1175,1.162,1176,0.767,1177,0.728,1178,0.993,1179,0.767,1180,1.403,1181,0.767,1182,0.767,1183,0.691,1184,0.767,1185,0.767,1186,0.767,1187,0.767,1188,0.767,1189,1.403]],["title/interfaces/GetAccessTokenResponse.html",[0,0.3,882,1.065]],["body/interfaces/GetAccessTokenResponse.html",[0,0.578,2,0.29,3,0.126,4,0.094,6,0.144,7,0.266,10,0.021,11,0.782,12,0.633,13,0.593,14,0.568,15,0.641,16,0.501,17,0.38,18,0.577,19,0.919,20,0.642,21,0.875,22,0.864,23,0.399,26,0.802,30,0.399,31,0.774,34,0.679,35,0.559,36,0.569,38,0.423,49,1.083,50,0.679,53,0.357,55,0.569,56,0.763,58,0.015,63,0.53,65,0.928,68,0.505,69,0.349,72,0.47,73,0.913,75,0.836,76,0.841,77,0.53,78,0.719,79,1.059,80,0.685,84,0.064,87,1.174,88,0.73,89,0.604,90,0.604,93,0.669,95,0.807,97,0.73,99,0.474,104,0.76,109,1.26,112,0.76,117,1.107,118,0.474,119,0.875,126,0.802,129,0.782,130,0.501,131,0.474,134,0.416,136,0.928,139,1.162,141,0.925,143,1.009,144,1.101,146,0.73,147,0.675,148,0.946,149,0.771,150,0.408,151,0.474,157,0.766,158,0.448,174,0.985,176,0.816,179,0.632,181,1.174,186,0.469,187,0.836,191,0.692,197,0.474,199,0.73,200,0.569,203,1.022,206,1.191,209,0.53,212,0.968,213,0.802,215,0.501,218,0.53,221,0.802,228,0.76,229,0.559,231,0.84,234,0.53,235,0.559,236,0.53,238,0.53,242,0.423,243,0.448,244,0.675,245,0.53,261,1.04,263,1.1,267,0.153,284,0.666,287,0.632,290,0.566,291,0.53,293,0.53,294,0.53,299,0.559,305,0.969,315,0.915,319,1.045,323,0.349,327,1.035,330,0.892,339,0.474,355,0.53,369,0.968,370,0.289,371,0.76,375,0.719,382,0.559,388,0.725,413,0.559,415,0.843,423,0.846,425,0.559,430,0.802,436,0.719,437,0.917,438,1.009,449,1.041,450,0.942,451,0.53,454,0.946,455,0.53,458,0.501,460,1.072,461,0.719,464,0.679,469,0.82,471,0.889,472,0.969,478,0.847,481,1.34,487,1.009,489,1.022,495,0.016,496,1.414,498,0.893,499,1.203,500,1.162,511,1.137,515,1.602,517,0.802,519,0.53,526,0.501,532,1.535,541,0.589,546,0.942,557,0.448,559,1.137,560,1.203,562,0.589,578,1.308,582,1.022,583,1.137,584,0.559,585,0.621,586,1.198,587,0.76,590,1.456,591,1.393,592,1.022,594,1.655,595,0.969,596,0.802,597,1.157,605,1.435,607,0.501,609,0.992,611,1.227,612,0.655,616,1.484,617,1.102,618,1.484,619,1.409,620,1.484,621,1.102,622,1.046,623,0.727,624,1.437,627,0.727,629,1.484,632,0.69,634,0.69,639,1.141,642,0.621,643,1.27,646,1.202,647,0.847,658,0.969,686,0.727,687,0.69,688,1.484,689,1.705,690,1.046,691,1.33,692,1.337,693,0.655,694,0.727,695,1.102,696,1.484,697,1.484,698,1.484,699,1.402,700,1.095,701,1.161,702,1.102,703,1.402,704,1.33,705,1.514,706,1.838,707,0.69,708,0.69,709,1.198,710,0.766,711,1.161,712,1.263,713,1.656,714,0.69,715,1.137,716,0.766,717,1.512,718,0.766,719,0.727,720,1.046,721,1.49,722,0.766,723,0.766,724,1.161,725,1.409,726,1.484,727,0.766,728,0.766,729,1.046,730,0.942,731,0.69,732,0.942,733,1.363,734,1.337,735,1.078,736,1.361,737,0.655,738,1.437,739,0.69,740,1.337,741,0.655,742,0.69,743,0.655,744,1.046,745,1.595,746,1.161,747,1.484,748,1.161,749,1.564,750,1.33,751,0.727,752,0.992,753,1.161,754,1.363,755,1.337,756,1.046,757,1.409,758,0.766,759,1.655,760,0.766,761,1.263,762,1.198,763,1.198,764,0.766,765,1.33,766,1.161,767,1.402,768,1.514,769,1.137,770,0.766,771,1.046,772,0.766,773,1.046,774,1.161,775,0.727,776,0.727,777,0.766,778,0.766,779,0.727,780,0.766,781,1.161,782,1.102,783,0.766,784,1.337,785,0.766,786,0.766,787,1.161,788,1.161,789,1.402,790,1.046,791,0.69,792,1.796,793,1.161,794,0.992,795,0.766,796,0.766,797,0.766,798,0.766,799,1.161,800,0.766,801,1.198,802,0.992,803,0.655,804,1.402,805,0.766,806,1.102,807,0.766,808,1.402,809,1.102,810,0.766,811,0.766,812,0.766,813,0.766,814,1.595,815,0.766,816,0.766,817,1.402,818,0.766,819,1.161,820,1.046,821,0.766,822,0.766,823,0.766,824,0.766,825,0.69,826,1.102,827,0.69,828,0.69,829,0.766,830,0.992,831,1.046,832,1.046,833,0.766,834,0.766,835,0.766,836,0.655,837,1.161,838,1.107,839,0.766,840,1.744,841,0.766,842,0.766,843,0.766,844,0.766,845,0.766,846,0.69,847,0.655,848,0.69,849,0.766,850,0.766,851,0.655,852,0.766,853,0.766,854,0.766,855,0.727,856,0.766,857,0.727,858,1.161,859,0.766,860,0.766,861,1.203,862,0.766,863,0.621,864,0.766,865,0.766,866,0.766,867,1.595,868,0.727,869,0.766,870,0.766,871,1.681,872,1.161,873,1.681,874,1.564,875,0.766,876,1.102,877,1.102,878,1.484,879,1.681,880,1.402,881,1.33,882,1.102,883,1.33,884,0.727,885,0.655,886,1.33,887,1.33,888,0.727,889,1.102,890,1.595,891,1.161,892,1.402,893,1.102,894,1.263,895,1.595,896,1.679,897,0.766,898,0.766,899,0.766,900,0.766,901,0.766,902,1.161,903,1.161,904,1.102,905,0.766,906,0.766,907,0.766,908,0.766,909,0.766,910,1.33,911,1.046,912,0.766,913,0.766,914,0.621,915,0.655,916,0.766,917,0.727,918,1.595,919,0.766,920,0.727,921,1.484,922,0.727,923,1.33,924,0.727,925,1.402,926,0.766,927,0.766,928,0.69,929,0.727,930,0.766,931,0.766,932,1.564,933,0.766,934,0.766,935,0.766,936,0.766,937,1.681,938,0.766,939,0.766,940,0.766,941,0.727,942,0.766,943,0.766,944,0.766,945,0.992,946,0.766,947,0.766,948,0.766,949,0.766,950,0.766,951,0.766,952,0.766,953,1.046,954,0.766,955,0.69,956,0.69,957,0.942,958,0.766,959,0.766,960,0.766,961,0.766,962,1.161,963,1.161,964,1.161,965,0.766,966,1.161,967,0.766,968,0.766,969,0.727,970,1.161,971,0.766,972,0.727,973,0.766,974,0.766,975,1.33,976,1.33,977,0.766,978,0.766,979,0.766,980,0.766,981,0.766,982,0.766,983,0.766,984,0.727,985,1.161,986,0.766,987,0.727,988,0.766,989,1.161,990,0.766,991,0.766,992,0.766,993,0.766,994,0.766,995,0.766,996,0.766,997,0.766,998,1.161,999,0.766,1000,0.766,1001,0.766,1002,1.161,1003,1.161,1004,1.161,1005,0.766,1006,0.766,1007,1.402,1008,0.766,1009,1.564,1010,1.893,1011,0.766,1012,0.766,1013,1.161,1014,0.766,1015,0.766,1016,0.766,1017,1.161,1018,0.766,1019,0.766,1020,1.402,1021,0.766,1022,1.161,1023,1.161,1024,1.161,1025,0.766,1026,1.161,1027,0.766,1028,0.766,1029,1.402,1030,1.161,1031,0.766,1032,0.766,1033,0.766,1034,0.766,1035,0.766,1036,0.847,1037,0.621,1038,1.161,1039,0.766,1040,0.766,1041,1.402,1042,0.766,1043,1.514,1044,1.484,1045,0.766,1046,1.102,1047,0.69,1048,0.655,1049,1.161,1050,0.766,1051,0.766,1052,0.766,1053,1.161,1054,1.564,1055,1.161,1056,1.161,1057,0.766,1058,1.263,1059,0.766,1060,1.33,1061,0.766,1062,0.766,1063,1.161,1064,0.766,1065,0.727,1066,1.263,1067,0.766,1068,0.766,1069,0.727,1070,0.766,1071,1.402,1072,0.766,1073,1.484,1074,1.402,1075,0.766,1076,0.766,1077,1.161,1078,1.402,1079,0.766,1080,0.766,1081,0.766,1082,1.161,1083,0.766,1084,0.766,1085,0.766,1086,1.161,1087,0.727,1088,0.766,1089,1.161,1090,0.766,1091,0.766,1092,0.766,1093,0.766,1094,0.69,1095,1.33,1096,0.727,1097,0.69,1098,0.766,1099,0.766,1100,1.161,1101,1.402,1102,0.766,1103,1.161,1104,0.766,1105,0.766,1106,0.766,1107,1.402,1108,0.621,1109,0.766,1110,0.766,1111,0.766,1112,0.621,1113,0.766,1114,0.766,1115,0.766,1116,0.766,1117,0.766,1118,0.727,1119,1.161,1120,1.161,1121,1.161,1122,0.766,1123,1.161,1124,0.992,1125,1.046,1126,0.766,1127,0.766,1128,1.33,1129,0.992,1130,0.766,1131,0.727,1132,0.766,1133,0.766,1134,0.589,1135,0.766,1136,0.766,1137,0.766,1138,1.161,1139,1.161,1140,0.766,1141,0.766,1142,0.766,1143,0.766,1144,0.766,1145,1.102,1146,0.727,1147,1.161,1148,0.766,1149,0.766,1150,0.766,1151,0.766,1152,0.766,1153,0.766,1154,0.766,1155,0.766,1156,0.655,1157,0.766,1158,0.766,1159,1.161,1160,0.766,1161,0.766,1162,0.766,1163,1.161,1164,0.766,1165,0.766,1166,0.727,1167,1.161,1168,0.766,1169,0.655,1170,1.161,1171,1.33,1172,0.766,1173,0.766,1174,1.161,1175,1.161,1176,0.766,1177,0.727,1178,0.992,1179,0.766,1180,1.402,1181,0.766,1182,0.766,1183,0.69,1184,0.766,1185,0.766,1186,0.766,1187,0.766,1188,0.766,1189,1.402]],["title/interfaces/GetFederatedSignonCertsCallback.html",[0,0.3,887,1.065]],["body/interfaces/GetFederatedSignonCertsCallback.html",[0,0.579,2,0.29,3,0.126,4,0.094,6,0.144,7,0.322,8,1.198,9,0.95,10,0.021,11,0.798,12,0.634,13,0.568,14,0.569,15,0.642,16,0.502,17,0.379,18,0.578,19,0.925,20,0.642,21,0.876,22,0.775,23,0.4,26,0.803,30,0.4,31,0.775,34,0.68,35,0.56,36,0.57,38,0.424,49,1.083,50,0.68,53,0.357,55,0.57,56,0.764,58,0.015,63,0.53,65,0.929,68,0.505,69,0.349,72,0.47,73,0.913,75,0.837,76,0.841,77,0.53,78,0.72,79,1.06,80,0.685,84,0.064,87,1.174,88,0.731,89,0.605,90,0.605,93,0.669,95,0.807,97,0.731,99,0.475,104,0.761,109,1.261,112,0.761,117,1.108,118,0.475,119,0.876,126,0.803,129,0.783,130,0.502,131,0.475,134,0.416,136,0.929,139,1.162,141,0.925,143,1.009,144,1.101,146,0.731,147,0.676,148,0.947,149,0.772,150,0.401,151,0.475,157,0.767,158,0.449,174,0.986,176,0.816,179,0.632,181,1.175,186,0.469,187,0.837,191,0.693,197,0.475,199,0.731,200,0.57,203,1.024,206,1.191,209,0.53,212,0.969,213,0.803,215,0.502,218,0.53,221,0.803,228,0.761,229,0.56,231,0.84,234,0.53,235,0.56,236,0.53,238,0.53,242,0.424,243,0.449,244,0.676,245,0.53,261,1.041,263,1.101,267,0.14,284,0.667,287,0.632,290,0.567,291,0.53,293,0.53,294,0.53,299,0.56,305,0.97,315,0.916,319,1.046,323,0.349,327,1.035,330,0.892,339,0.475,355,0.53,369,0.969,370,0.289,371,0.761,375,0.72,382,0.56,388,0.726,413,0.56,415,0.843,423,0.846,425,0.56,430,0.803,436,0.72,437,0.918,438,1.009,449,1.041,450,0.941,451,0.53,454,0.947,455,0.53,458,0.502,460,1.072,461,0.72,464,0.68,469,0.821,471,0.889,472,0.97,478,0.848,481,1.341,487,0.997,489,1.024,495,0.016,496,1.414,498,1.08,499,1.204,500,1.162,511,1.138,515,1.603,517,0.803,519,0.53,526,0.502,532,1.536,541,0.59,546,0.943,557,0.449,559,1.138,560,1.204,562,0.59,578,1.34,582,1.024,583,1.138,584,0.56,585,0.622,586,1.2,587,0.761,590,1.457,591,1.394,592,1.024,594,1.656,595,0.97,596,0.803,597,1.158,605,1.435,607,0.502,609,0.994,611,1.228,612,0.656,616,1.486,617,1.103,618,1.486,619,1.41,620,1.486,621,1.103,622,1.047,623,0.728,624,1.438,627,0.728,629,1.486,632,0.691,634,0.691,639,1.142,642,0.622,643,1.271,646,1.203,647,0.848,658,0.97,686,0.728,687,0.691,688,1.596,689,1.746,690,1.047,691,1.332,692,1.338,693,0.656,694,0.728,695,1.103,696,1.486,697,1.486,698,1.486,699,1.403,700,1.096,701,1.163,702,1.103,703,1.403,704,1.332,705,1.515,706,1.839,707,0.691,708,0.691,709,1.2,710,0.768,711,1.163,712,1.264,713,1.657,714,0.691,715,1.138,716,0.768,717,1.513,718,0.768,719,0.728,720,1.047,721,1.491,722,0.768,723,0.768,724,1.163,725,1.41,726,1.486,727,0.768,728,0.768,729,1.047,730,0.943,731,0.691,732,0.943,733,1.364,734,1.338,735,1.08,736,1.362,737,0.656,738,1.438,739,0.691,740,1.338,741,0.656,742,0.691,743,0.656,744,1.047,745,1.596,746,1.163,747,1.486,748,1.163,749,1.566,750,1.332,751,0.728,752,0.994,753,1.163,754,1.364,755,1.338,756,1.047,757,1.41,758,0.768,759,1.656,760,0.768,761,1.264,762,1.2,763,1.2,764,0.768,765,1.332,766,1.163,767,1.403,768,1.515,769,1.138,770,0.768,771,1.047,772,0.768,773,1.047,774,1.163,775,0.728,776,0.728,777,0.768,778,0.768,779,0.728,780,0.768,781,1.163,782,1.103,783,0.768,784,1.338,785,0.768,786,0.768,787,1.163,788,1.163,789,1.403,790,1.047,791,0.691,792,1.797,793,1.163,794,0.994,795,0.768,796,0.768,797,0.768,798,0.768,799,1.163,800,0.768,801,1.2,802,0.994,803,0.656,804,1.403,805,0.768,806,1.103,807,0.768,808,1.403,809,1.103,810,0.768,811,0.768,812,0.768,813,0.768,814,1.596,815,0.768,816,0.768,817,1.403,818,0.768,819,1.163,820,1.047,821,0.768,822,0.768,823,0.768,824,0.768,825,0.691,826,1.103,827,0.691,828,0.691,829,0.768,830,0.994,831,1.047,832,1.047,833,0.768,834,0.768,835,0.768,836,0.656,837,1.163,838,1.108,839,0.768,840,1.745,841,0.768,842,0.768,843,0.768,844,0.768,845,0.768,846,0.691,847,0.656,848,0.691,849,0.768,850,0.768,851,0.656,852,0.768,853,0.768,854,0.768,855,0.728,856,0.768,857,0.728,858,1.163,859,0.768,860,0.768,861,1.204,862,0.768,863,0.622,864,0.768,865,0.768,866,0.768,867,1.596,868,0.728,869,0.768,870,0.768,871,1.682,872,1.163,873,1.682,874,1.566,875,0.768,876,1.103,877,1.103,878,1.486,879,1.682,880,1.403,881,1.332,882,0.728,883,1.332,884,0.728,885,0.656,886,1.332,887,1.486,888,0.728,889,1.103,890,1.596,891,1.163,892,1.403,893,1.103,894,1.264,895,1.596,896,1.68,897,0.768,898,0.768,899,0.768,900,0.768,901,0.768,902,1.163,903,1.163,904,1.103,905,0.768,906,0.768,907,0.768,908,0.768,909,0.768,910,1.332,911,1.047,912,0.768,913,0.768,914,0.622,915,0.656,916,0.768,917,0.728,918,1.596,919,0.768,920,0.728,921,1.486,922,0.728,923,1.332,924,0.728,925,1.403,926,0.768,927,0.768,928,0.691,929,0.728,930,0.768,931,0.768,932,1.566,933,0.768,934,0.768,935,0.768,936,0.768,937,1.682,938,0.768,939,0.768,940,0.768,941,0.728,942,0.768,943,0.768,944,0.768,945,0.994,946,0.768,947,0.768,948,0.768,949,0.768,950,0.768,951,0.768,952,0.768,953,1.047,954,0.768,955,0.691,956,0.691,957,0.943,958,0.768,959,0.768,960,0.768,961,0.768,962,1.163,963,1.163,964,1.163,965,0.768,966,1.163,967,0.768,968,0.768,969,0.728,970,1.163,971,0.768,972,0.728,973,0.768,974,0.768,975,1.332,976,1.332,977,0.768,978,0.768,979,0.768,980,0.768,981,0.768,982,0.768,983,0.768,984,0.728,985,1.163,986,0.768,987,0.728,988,0.768,989,1.163,990,0.768,991,0.768,992,0.768,993,0.768,994,0.768,995,0.768,996,0.768,997,0.768,998,1.163,999,0.768,1000,0.768,1001,0.768,1002,1.163,1003,1.163,1004,1.163,1005,0.768,1006,0.768,1007,1.403,1008,0.768,1009,1.566,1010,1.894,1011,0.768,1012,0.768,1013,1.163,1014,0.768,1015,0.768,1016,0.768,1017,1.163,1018,0.768,1019,0.768,1020,1.403,1021,0.768,1022,1.163,1023,1.163,1024,1.163,1025,0.768,1026,1.163,1027,0.768,1028,0.768,1029,1.403,1030,1.163,1031,0.768,1032,0.768,1033,0.768,1034,0.768,1035,0.768,1036,0.848,1037,0.622,1038,1.163,1039,0.768,1040,0.768,1041,1.403,1042,0.768,1043,1.515,1044,1.486,1045,0.768,1046,1.103,1047,0.691,1048,0.656,1049,1.163,1050,0.768,1051,0.768,1052,0.768,1053,1.163,1054,1.566,1055,1.163,1056,1.163,1057,0.768,1058,1.264,1059,0.768,1060,1.332,1061,0.768,1062,0.768,1063,1.163,1064,0.768,1065,0.728,1066,1.264,1067,0.768,1068,0.768,1069,0.728,1070,0.768,1071,1.403,1072,0.768,1073,1.486,1074,1.403,1075,0.768,1076,0.768,1077,1.163,1078,1.403,1079,0.768,1080,0.768,1081,0.768,1082,1.163,1083,0.768,1084,0.768,1085,0.768,1086,1.163,1087,0.728,1088,0.768,1089,1.163,1090,0.768,1091,0.768,1092,0.768,1093,0.768,1094,0.691,1095,1.332,1096,0.728,1097,0.691,1098,0.768,1099,0.768,1100,1.163,1101,1.403,1102,0.768,1103,1.163,1104,0.768,1105,0.768,1106,0.768,1107,1.403,1108,0.622,1109,0.768,1110,0.768,1111,0.768,1112,0.622,1113,0.768,1114,0.768,1115,0.768,1116,0.768,1117,0.768,1118,0.728,1119,1.163,1120,1.163,1121,1.163,1122,0.768,1123,1.163,1124,0.994,1125,1.047,1126,0.768,1127,0.768,1128,1.332,1129,0.994,1130,0.768,1131,0.728,1132,0.768,1133,0.768,1134,0.59,1135,0.768,1136,0.768,1137,0.768,1138,1.163,1139,1.163,1140,0.768,1141,0.768,1142,0.768,1143,0.768,1144,0.768,1145,1.103,1146,0.728,1147,1.163,1148,0.768,1149,0.768,1150,0.768,1151,0.768,1152,0.768,1153,0.768,1154,0.768,1155,0.768,1156,0.656,1157,0.768,1158,0.768,1159,1.163,1160,0.768,1161,0.768,1162,0.768,1163,1.163,1164,0.768,1165,0.768,1166,0.728,1167,1.163,1168,0.768,1169,0.656,1170,1.163,1171,1.332,1172,0.768,1173,0.768,1174,1.163,1175,1.163,1176,0.768,1177,0.728,1178,0.994,1179,0.768,1180,1.403,1181,0.768,1182,0.768,1183,0.691,1184,0.768,1185,0.768,1186,0.768,1187,0.768,1188,0.768,1189,1.403]],["title/interfaces/GetTokenCallback.html",[0,0.3,878,1.065]],["body/interfaces/GetTokenCallback.html",[0,0.578,2,0.29,3,0.126,4,0.094,6,0.144,7,0.322,8,1.198,9,0.95,10,0.021,11,0.798,12,0.634,13,0.582,14,0.574,15,0.642,16,0.502,17,0.379,18,0.578,19,0.925,20,0.642,21,0.875,22,0.775,23,0.399,26,0.803,30,0.399,31,0.775,34,0.68,35,0.56,36,0.569,38,0.424,49,1.083,50,0.68,53,0.357,55,0.569,56,0.764,58,0.015,63,0.53,65,0.929,68,0.505,69,0.349,72,0.47,73,0.913,75,0.837,76,0.841,77,0.53,78,0.719,79,1.06,80,0.685,84,0.064,87,1.174,88,0.73,89,0.605,90,0.605,93,0.669,95,0.807,97,0.73,99,0.475,104,0.761,109,1.261,112,0.761,117,1.108,118,0.475,119,0.875,126,0.803,129,0.783,130,0.502,131,0.475,134,0.416,136,0.929,139,1.162,141,0.925,143,1.009,144,1.101,146,0.73,147,0.676,148,0.947,149,0.772,150,0.401,151,0.475,157,0.767,158,0.449,174,0.986,176,0.816,179,0.632,181,1.175,186,0.469,187,0.837,191,0.693,197,0.475,199,0.73,200,0.569,203,1.023,206,1.191,209,0.53,212,0.969,213,0.803,215,0.502,218,0.53,221,0.803,228,0.761,229,0.56,231,0.84,234,0.53,235,0.56,236,0.53,238,0.53,242,0.424,243,0.449,244,0.676,245,0.53,261,1.041,263,1.1,267,0.14,284,0.667,287,0.632,290,0.567,291,0.53,293,0.53,294,0.53,299,0.56,305,0.97,315,0.916,319,1.046,323,0.349,327,1.035,330,0.892,339,0.475,355,0.53,369,0.969,370,0.289,371,0.761,375,0.719,382,0.56,388,0.726,413,0.56,415,0.843,423,0.846,425,0.56,430,0.803,436,0.719,437,0.918,438,1.009,449,1.041,450,0.942,451,0.53,454,0.947,455,0.53,458,0.502,460,1.072,461,0.719,464,0.68,469,0.821,471,0.889,472,0.97,478,0.848,481,1.341,487,1.002,489,1.023,495,0.016,496,1.414,498,1.079,499,1.204,500,1.162,511,1.138,515,1.603,517,0.803,519,0.53,526,0.502,532,1.536,541,0.59,546,0.943,557,0.449,559,1.138,560,1.204,562,0.59,578,1.308,582,1.023,583,1.138,584,0.56,585,0.622,586,1.199,587,0.761,590,1.457,591,1.394,592,1.023,594,1.656,595,0.97,596,0.803,597,1.158,605,1.435,607,0.502,609,0.993,611,1.228,612,0.656,616,1.485,617,1.103,618,1.485,619,1.41,620,1.485,621,1.103,622,1.047,623,0.728,624,1.438,627,0.728,629,1.485,632,0.691,634,0.691,639,1.142,642,0.622,643,1.27,646,1.203,647,0.848,658,0.97,686,0.728,687,0.691,688,1.485,689,1.705,690,1.047,691,1.332,692,1.338,693,0.656,694,0.728,695,1.103,696,1.485,697,1.485,698,1.485,699,1.403,700,1.095,701,1.162,702,1.103,703,1.403,704,1.332,705,1.515,706,1.838,707,0.691,708,0.691,709,1.199,710,0.767,711,1.162,712,1.264,713,1.657,714,0.691,715,1.138,716,0.767,717,1.513,718,0.767,719,0.728,720,1.047,721,1.491,722,0.767,723,0.767,724,1.162,725,1.41,726,1.485,727,0.767,728,0.767,729,1.047,730,0.943,731,0.691,732,0.943,733,1.364,734,1.338,735,1.079,736,1.361,737,0.656,738,1.438,739,0.691,740,1.338,741,0.656,742,0.691,743,0.656,744,1.047,745,1.596,746,1.162,747,1.485,748,1.162,749,1.565,750,1.332,751,0.728,752,0.993,753,1.162,754,1.364,755,1.338,756,1.047,757,1.41,758,0.767,759,1.656,760,0.767,761,1.264,762,1.199,763,1.199,764,0.767,765,1.332,766,1.162,767,1.403,768,1.515,769,1.138,770,0.767,771,1.047,772,0.767,773,1.047,774,1.162,775,0.728,776,0.728,777,0.767,778,0.767,779,0.728,780,0.767,781,1.162,782,1.103,783,0.767,784,1.338,785,0.767,786,0.767,787,1.162,788,1.162,789,1.403,790,1.047,791,0.691,792,1.797,793,1.162,794,0.993,795,0.767,796,0.767,797,0.767,798,0.767,799,1.162,800,0.767,801,1.199,802,0.993,803,0.656,804,1.403,805,0.767,806,1.103,807,0.767,808,1.403,809,1.103,810,0.767,811,0.767,812,0.767,813,0.767,814,1.596,815,0.767,816,0.767,817,1.403,818,0.767,819,1.162,820,1.047,821,0.767,822,0.767,823,0.767,824,0.767,825,0.691,826,1.103,827,0.691,828,0.691,829,0.767,830,0.993,831,1.047,832,1.047,833,0.767,834,0.767,835,0.767,836,0.656,837,1.162,838,1.108,839,0.767,840,1.745,841,0.767,842,0.767,843,0.767,844,0.767,845,0.767,846,0.691,847,0.656,848,0.691,849,0.767,850,0.767,851,0.656,852,0.767,853,0.767,854,0.767,855,0.728,856,0.767,857,0.728,858,1.162,859,0.767,860,0.767,861,1.204,862,0.767,863,0.622,864,0.767,865,0.767,866,0.767,867,1.596,868,0.728,869,0.767,870,0.767,871,1.682,872,1.162,873,1.682,874,1.565,875,0.767,876,1.103,877,1.103,878,1.596,879,1.682,880,1.403,881,1.332,882,0.728,883,1.332,884,0.728,885,0.656,886,1.332,887,1.332,888,0.728,889,1.103,890,1.596,891,1.162,892,1.403,893,1.103,894,1.264,895,1.596,896,1.679,897,0.767,898,0.767,899,0.767,900,0.767,901,0.767,902,1.162,903,1.162,904,1.103,905,0.767,906,0.767,907,0.767,908,0.767,909,0.767,910,1.332,911,1.047,912,0.767,913,0.767,914,0.622,915,0.656,916,0.767,917,0.728,918,1.596,919,0.767,920,0.728,921,1.485,922,0.728,923,1.332,924,0.728,925,1.403,926,0.767,927,0.767,928,0.691,929,0.728,930,0.767,931,0.767,932,1.565,933,0.767,934,0.767,935,0.767,936,0.767,937,1.682,938,0.767,939,0.767,940,0.767,941,0.728,942,0.767,943,0.767,944,0.767,945,0.993,946,0.767,947,0.767,948,0.767,949,0.767,950,0.767,951,0.767,952,0.767,953,1.047,954,0.767,955,0.691,956,0.691,957,0.943,958,0.767,959,0.767,960,0.767,961,0.767,962,1.162,963,1.162,964,1.162,965,0.767,966,1.162,967,0.767,968,0.767,969,0.728,970,1.162,971,0.767,972,0.728,973,0.767,974,0.767,975,1.332,976,1.332,977,0.767,978,0.767,979,0.767,980,0.767,981,0.767,982,0.767,983,0.767,984,0.728,985,1.162,986,0.767,987,0.728,988,0.767,989,1.162,990,0.767,991,0.767,992,0.767,993,0.767,994,0.767,995,0.767,996,0.767,997,0.767,998,1.162,999,0.767,1000,0.767,1001,0.767,1002,1.162,1003,1.162,1004,1.162,1005,0.767,1006,0.767,1007,1.403,1008,0.767,1009,1.565,1010,1.893,1011,0.767,1012,0.767,1013,1.162,1014,0.767,1015,0.767,1016,0.767,1017,1.162,1018,0.767,1019,0.767,1020,1.403,1021,0.767,1022,1.162,1023,1.162,1024,1.162,1025,0.767,1026,1.162,1027,0.767,1028,0.767,1029,1.403,1030,1.162,1031,0.767,1032,0.767,1033,0.767,1034,0.767,1035,0.767,1036,0.848,1037,0.622,1038,1.162,1039,0.767,1040,0.767,1041,1.403,1042,0.767,1043,1.515,1044,1.485,1045,0.767,1046,1.103,1047,0.691,1048,0.656,1049,1.162,1050,0.767,1051,0.767,1052,0.767,1053,1.162,1054,1.565,1055,1.162,1056,1.162,1057,0.767,1058,1.264,1059,0.767,1060,1.332,1061,0.767,1062,0.767,1063,1.162,1064,0.767,1065,0.728,1066,1.264,1067,0.767,1068,0.767,1069,0.728,1070,0.767,1071,1.403,1072,0.767,1073,1.485,1074,1.403,1075,0.767,1076,0.767,1077,1.162,1078,1.403,1079,0.767,1080,0.767,1081,0.767,1082,1.162,1083,0.767,1084,0.767,1085,0.767,1086,1.162,1087,0.728,1088,0.767,1089,1.162,1090,0.767,1091,0.767,1092,0.767,1093,0.767,1094,0.691,1095,1.332,1096,0.728,1097,0.691,1098,0.767,1099,0.767,1100,1.162,1101,1.403,1102,0.767,1103,1.162,1104,0.767,1105,0.767,1106,0.767,1107,1.403,1108,0.622,1109,0.767,1110,0.767,1111,0.767,1112,0.622,1113,0.767,1114,0.767,1115,0.767,1116,0.767,1117,0.767,1118,0.728,1119,1.162,1120,1.162,1121,1.162,1122,0.767,1123,1.162,1124,0.993,1125,1.047,1126,0.767,1127,0.767,1128,1.332,1129,0.993,1130,0.767,1131,0.728,1132,0.767,1133,0.767,1134,0.59,1135,0.767,1136,0.767,1137,0.767,1138,1.162,1139,1.162,1140,0.767,1141,0.767,1142,0.767,1143,0.767,1144,0.767,1145,1.103,1146,0.728,1147,1.162,1148,0.767,1149,0.767,1150,0.767,1151,0.767,1152,0.767,1153,0.767,1154,0.767,1155,0.767,1156,0.656,1157,0.767,1158,0.767,1159,1.162,1160,0.767,1161,0.767,1162,0.767,1163,1.162,1164,0.767,1165,0.767,1166,0.728,1167,1.162,1168,0.767,1169,0.656,1170,1.162,1171,1.332,1172,0.767,1173,0.767,1174,1.162,1175,1.162,1176,0.767,1177,0.728,1178,0.993,1179,0.767,1180,1.403,1181,0.767,1182,0.767,1183,0.691,1184,0.767,1185,0.767,1186,0.767,1187,0.767,1188,0.767,1189,1.403]],["title/interfaces/GetTokenOptions.html",[0,0.3,698,1.065]],["body/interfaces/GetTokenOptions.html",[0,0.578,2,0.289,3,0.125,4,0.093,6,0.143,7,0.265,10,0.021,11,0.781,12,0.631,13,0.529,14,0.567,15,0.637,16,0.497,17,0.381,18,0.577,19,0.918,20,0.641,21,0.872,22,0.637,23,0.396,26,0.797,30,0.396,31,0.77,34,0.675,35,0.554,36,0.565,38,0.42,49,1.081,50,0.675,53,0.356,55,0.565,56,0.761,58,0.015,63,0.525,65,0.925,68,0.503,69,0.346,72,0.468,73,0.911,75,0.851,76,0.84,77,0.525,78,0.714,79,1.07,80,0.685,84,0.063,87,1.177,88,0.726,89,0.601,90,0.601,93,0.668,95,0.806,97,0.726,99,0.47,104,0.755,109,1.259,112,0.755,117,1.104,118,0.47,119,0.872,126,0.797,129,0.781,130,0.498,131,0.47,134,0.417,136,0.925,139,1.157,141,0.924,143,1.006,144,1.099,146,0.726,147,0.672,148,0.949,149,0.771,150,0.412,151,0.47,157,0.763,158,0.445,174,1.006,176,0.815,179,0.629,181,1.172,186,0.466,187,0.834,191,0.755,197,0.47,199,0.726,200,0.565,203,1.017,206,1.188,209,0.525,212,0.964,213,0.797,215,0.497,218,0.525,221,0.797,228,0.913,229,0.554,231,0.838,234,0.525,235,0.554,236,0.525,238,0.525,242,0.42,243,0.445,244,0.672,245,0.525,261,1.037,263,1.096,267,0.161,284,0.69,287,0.629,290,0.563,291,0.525,293,0.525,294,0.525,299,0.554,305,0.964,315,0.911,319,1.042,323,0.346,327,1.031,330,0.89,339,0.47,355,0.525,369,0.964,370,0.286,371,0.755,375,0.714,382,0.554,388,0.723,413,0.554,415,0.846,423,0.843,425,0.554,430,0.797,436,0.714,437,0.913,438,1.043,449,1.041,450,0.941,451,0.525,454,0.949,455,0.525,458,0.497,460,1.07,461,0.714,464,0.675,469,0.816,471,0.911,472,0.964,478,0.841,481,1.336,487,0.996,489,1.017,495,0.017,496,1.409,498,0.888,499,1.198,500,1.157,511,1.131,515,1.599,517,0.797,519,0.525,526,0.497,532,1.531,541,0.585,546,0.936,557,0.445,559,1.131,560,1.198,562,0.585,578,1.305,582,1.017,583,1.131,584,0.554,585,0.616,586,1.192,587,0.755,590,1.452,591,1.391,592,1.221,594,1.65,595,0.964,596,0.797,597,1.154,605,1.43,607,0.497,609,0.986,611,1.226,612,0.649,616,1.478,617,1.095,618,1.478,619,1.403,620,1.478,621,1.095,622,1.039,623,0.721,624,1.431,627,0.721,629,1.478,632,0.684,634,0.684,639,1.136,642,0.616,643,1.266,646,1.311,647,0.841,658,0.964,686,0.721,687,0.684,688,1.478,689,1.7,690,1.039,691,1.324,692,1.331,693,0.649,694,0.721,695,1.095,696,1.478,697,1.478,698,1.589,699,1.763,700,1.169,701,1.558,702,1.478,703,1.558,704,1.478,705,1.588,706,2.004,707,0.684,708,0.684,709,1.192,710,0.76,711,1.154,712,1.256,713,1.652,714,0.684,715,1.131,716,0.76,717,1.507,718,0.76,719,0.721,720,1.039,721,1.486,722,0.76,723,0.76,724,1.154,725,1.403,726,1.478,727,0.76,728,0.76,729,1.039,730,0.936,731,0.684,732,0.936,733,1.358,734,1.331,735,1.073,736,1.356,737,0.649,738,1.431,739,0.684,740,1.331,741,0.649,742,0.684,743,0.649,744,1.039,745,1.589,746,1.154,747,1.478,748,1.154,749,1.558,750,1.324,751,0.721,752,0.986,753,1.154,754,1.358,755,1.331,756,1.039,757,1.403,758,0.76,759,1.65,760,0.76,761,1.256,762,1.192,763,1.192,764,0.76,765,1.324,766,1.154,767,1.395,768,1.508,769,1.131,770,0.76,771,1.039,772,0.76,773,1.039,774,1.154,775,0.721,776,0.721,777,0.76,778,0.76,779,0.721,780,0.76,781,1.154,782,1.095,783,0.76,784,1.331,785,0.76,786,0.76,787,1.154,788,1.154,789,1.395,790,1.039,791,0.684,792,1.792,793,1.154,794,0.986,795,0.76,796,0.76,797,0.76,798,0.76,799,1.154,800,0.76,801,1.192,802,0.986,803,0.649,804,1.395,805,0.76,806,1.095,807,0.76,808,1.395,809,1.095,810,0.76,811,0.76,812,0.76,813,0.76,814,1.589,815,0.76,816,0.76,817,1.395,818,0.76,819,1.154,820,1.039,821,0.76,822,0.76,823,0.76,824,0.76,825,0.684,826,1.095,827,0.684,828,0.684,829,0.76,830,0.986,831,1.039,832,1.039,833,0.76,834,0.76,835,0.76,836,0.649,837,1.154,838,1.104,839,0.76,840,1.739,841,0.76,842,0.76,843,0.76,844,0.76,845,0.76,846,0.684,847,0.649,848,0.684,849,0.76,850,0.76,851,0.649,852,0.76,853,0.76,854,0.76,855,0.721,856,0.76,857,0.721,858,1.154,859,0.76,860,0.76,861,1.198,862,0.76,863,0.616,864,0.76,865,0.76,866,0.76,867,1.589,868,0.721,869,0.76,870,0.76,871,1.675,872,1.154,873,1.675,874,1.558,875,0.76,876,1.095,877,1.095,878,1.478,879,1.675,880,1.395,881,1.324,882,0.721,883,1.324,884,0.721,885,0.649,886,1.324,887,1.324,888,0.721,889,1.095,890,1.589,891,1.154,892,1.395,893,1.095,894,1.256,895,1.589,896,1.673,897,0.76,898,0.76,899,0.76,900,0.76,901,0.76,902,1.154,903,1.154,904,1.095,905,0.76,906,0.76,907,0.76,908,0.76,909,0.76,910,1.324,911,1.039,912,0.76,913,0.76,914,0.616,915,0.649,916,0.76,917,0.721,918,1.589,919,0.76,920,0.721,921,1.478,922,0.721,923,1.324,924,0.721,925,1.395,926,0.76,927,0.76,928,0.684,929,0.721,930,0.76,931,0.76,932,1.558,933,0.76,934,0.76,935,0.76,936,0.76,937,1.675,938,0.76,939,0.76,940,0.76,941,0.721,942,0.76,943,0.76,944,0.76,945,0.986,946,0.76,947,0.76,948,0.76,949,0.76,950,0.76,951,0.76,952,0.76,953,1.039,954,0.76,955,0.684,956,0.684,957,0.936,958,0.76,959,0.76,960,0.76,961,0.76,962,1.154,963,1.154,964,1.154,965,0.76,966,1.154,967,0.76,968,0.76,969,0.721,970,1.154,971,0.76,972,0.721,973,0.76,974,0.76,975,1.324,976,1.324,977,0.76,978,0.76,979,0.76,980,0.76,981,0.76,982,0.76,983,0.76,984,0.721,985,1.154,986,0.76,987,0.721,988,0.76,989,1.154,990,0.76,991,0.76,992,0.76,993,0.76,994,0.76,995,0.76,996,0.76,997,0.76,998,1.154,999,0.76,1000,0.76,1001,0.76,1002,1.154,1003,1.154,1004,1.154,1005,0.76,1006,0.76,1007,1.395,1008,0.76,1009,1.558,1010,1.888,1011,0.76,1012,0.76,1013,1.154,1014,0.76,1015,0.76,1016,0.76,1017,1.154,1018,0.76,1019,0.76,1020,1.395,1021,0.76,1022,1.154,1023,1.154,1024,1.154,1025,0.76,1026,1.154,1027,0.76,1028,0.76,1029,1.395,1030,1.154,1031,0.76,1032,0.76,1033,0.76,1034,0.76,1035,0.76,1036,0.841,1037,0.616,1038,1.154,1039,0.76,1040,0.76,1041,1.395,1042,0.76,1043,1.508,1044,1.478,1045,0.76,1046,1.095,1047,0.684,1048,0.649,1049,1.154,1050,0.76,1051,0.76,1052,0.76,1053,1.154,1054,1.558,1055,1.154,1056,1.154,1057,0.76,1058,1.256,1059,0.76,1060,1.324,1061,0.76,1062,0.76,1063,1.154,1064,0.76,1065,0.721,1066,1.256,1067,0.76,1068,0.76,1069,0.721,1070,0.76,1071,1.395,1072,0.76,1073,1.478,1074,1.395,1075,0.76,1076,0.76,1077,1.154,1078,1.395,1079,0.76,1080,0.76,1081,0.76,1082,1.154,1083,0.76,1084,0.76,1085,0.76,1086,1.154,1087,0.721,1088,0.76,1089,1.154,1090,0.76,1091,0.76,1092,0.76,1093,0.76,1094,0.684,1095,1.324,1096,0.721,1097,0.684,1098,0.76,1099,0.76,1100,1.154,1101,1.395,1102,0.76,1103,1.154,1104,0.76,1105,0.76,1106,0.76,1107,1.395,1108,0.616,1109,0.76,1110,0.76,1111,0.76,1112,0.616,1113,0.76,1114,0.76,1115,0.76,1116,0.76,1117,0.76,1118,0.721,1119,1.154,1120,1.154,1121,1.154,1122,0.76,1123,1.154,1124,0.986,1125,1.039,1126,0.76,1127,0.76,1128,1.324,1129,0.986,1130,0.76,1131,0.721,1132,0.76,1133,0.76,1134,0.585,1135,0.76,1136,0.76,1137,0.76,1138,1.154,1139,1.154,1140,0.76,1141,0.76,1142,0.76,1143,0.76,1144,0.76,1145,1.095,1146,0.721,1147,1.154,1148,0.76,1149,0.76,1150,0.76,1151,0.76,1152,0.76,1153,0.76,1154,0.76,1155,0.76,1156,0.649,1157,0.76,1158,0.76,1159,1.154,1160,0.76,1161,0.76,1162,0.76,1163,1.154,1164,0.76,1165,0.76,1166,0.721,1167,1.154,1168,0.76,1169,0.649,1170,1.154,1171,1.324,1172,0.76,1173,0.76,1174,1.154,1175,1.154,1176,0.76,1177,0.721,1178,0.986,1179,0.76,1180,1.395,1181,0.76,1182,0.76,1183,0.684,1184,0.76,1185,0.76,1186,0.76,1187,0.76,1188,0.76,1189,1.395]],["title/interfaces/GetTokenResponse.html",[0,0.3,585,0.91]],["body/interfaces/GetTokenResponse.html",[0,0.579,2,0.29,3,0.126,4,0.094,6,0.144,7,0.267,10,0.021,11,0.783,12,0.634,13,0.568,14,0.579,15,0.642,16,0.502,17,0.379,18,0.577,19,0.919,20,0.642,21,0.876,22,0.864,23,0.399,26,0.803,30,0.399,31,0.775,34,0.68,35,0.56,36,0.569,38,0.424,49,1.083,50,0.68,53,0.357,55,0.569,56,0.764,58,0.015,63,0.53,65,0.929,68,0.505,69,0.349,72,0.47,73,0.913,75,0.837,76,0.841,77,0.53,78,0.72,79,1.06,80,0.685,84,0.064,87,1.174,88,0.73,89,0.605,90,0.605,93,0.669,95,0.807,97,0.73,99,0.475,104,0.761,109,1.261,112,0.761,117,1.108,118,0.475,119,0.876,126,0.803,129,0.783,130,0.502,131,0.475,134,0.416,136,0.929,139,1.162,141,0.925,143,1.009,144,1.101,146,0.73,147,0.676,148,0.947,149,0.772,150,0.401,151,0.475,157,0.767,158,0.449,174,0.986,176,0.816,179,0.632,181,1.175,186,0.469,187,0.837,191,0.693,197,0.475,199,0.73,200,0.569,203,1.023,206,1.191,209,0.53,212,0.969,213,0.803,215,0.502,218,0.53,221,0.803,228,0.761,229,0.56,231,0.84,234,0.53,235,0.56,236,0.53,238,0.53,242,0.424,243,0.449,244,0.676,245,0.53,261,1.041,263,1.101,267,0.153,284,0.667,287,0.632,290,0.567,291,0.53,293,0.53,294,0.53,299,0.56,305,0.97,315,0.916,319,1.046,323,0.349,327,1.035,330,0.892,339,0.475,355,0.53,369,0.969,370,0.289,371,0.761,375,0.72,382,0.56,388,0.726,413,0.56,415,0.843,423,0.846,425,0.56,430,0.803,436,0.72,437,0.918,438,1.009,449,1.041,450,0.942,451,0.53,454,0.947,455,0.53,458,0.502,460,1.072,461,0.72,464,0.68,469,0.821,471,0.889,472,0.97,478,0.848,481,1.341,487,1.01,489,1.023,495,0.016,496,1.414,498,0.894,499,1.204,500,1.162,511,1.138,515,1.603,517,0.803,519,0.53,526,0.502,532,1.536,541,0.59,546,0.943,557,0.449,559,1.138,560,1.204,562,0.59,578,1.309,582,1.023,583,1.138,584,0.56,585,0.943,586,1.199,587,0.761,590,1.457,591,1.394,592,1.023,594,1.656,595,0.97,596,0.803,597,1.158,605,1.435,607,0.502,609,0.994,611,1.228,612,0.656,616,1.486,617,1.103,618,1.486,619,1.41,620,1.486,621,1.103,622,1.047,623,0.728,624,1.438,627,0.728,629,1.486,632,0.691,634,0.691,639,1.142,642,0.622,643,1.271,646,1.203,647,0.848,658,0.97,686,0.728,687,0.691,688,1.486,689,1.705,690,1.047,691,1.332,692,1.338,693,0.656,694,0.728,695,1.103,696,1.486,697,1.486,698,1.486,699,1.403,700,1.096,701,1.162,702,1.103,703,1.403,704,1.332,705,1.515,706,1.839,707,0.691,708,0.691,709,1.199,710,0.767,711,1.162,712,1.264,713,1.657,714,0.691,715,1.138,716,0.767,717,1.513,718,0.767,719,0.728,720,1.047,721,1.491,722,0.767,723,0.767,724,1.162,725,1.41,726,1.486,727,0.767,728,0.767,729,1.047,730,0.943,731,0.691,732,0.943,733,1.364,734,1.338,735,1.079,736,1.361,737,0.656,738,1.438,739,0.691,740,1.338,741,0.656,742,0.691,743,0.656,744,1.047,745,1.596,746,1.162,747,1.486,748,1.162,749,1.565,750,1.332,751,0.728,752,0.994,753,1.162,754,1.364,755,1.338,756,1.047,757,1.41,758,0.767,759,1.656,760,0.767,761,1.264,762,1.199,763,1.199,764,0.767,765,1.332,766,1.162,767,1.403,768,1.515,769,1.138,770,0.767,771,1.047,772,0.767,773,1.047,774,1.162,775,0.728,776,0.728,777,0.767,778,0.767,779,0.728,780,0.767,781,1.162,782,1.103,783,0.767,784,1.338,785,0.767,786,0.767,787,1.162,788,1.162,789,1.403,790,1.047,791,0.691,792,1.797,793,1.162,794,0.994,795,0.767,796,0.767,797,0.767,798,0.767,799,1.162,800,0.767,801,1.199,802,0.994,803,0.656,804,1.403,805,0.767,806,1.103,807,0.767,808,1.403,809,1.103,810,0.767,811,0.767,812,0.767,813,0.767,814,1.596,815,0.767,816,0.767,817,1.403,818,0.767,819,1.162,820,1.047,821,0.767,822,0.767,823,0.767,824,0.767,825,0.691,826,1.103,827,0.691,828,0.691,829,0.767,830,0.994,831,1.047,832,1.047,833,0.767,834,0.767,835,0.767,836,0.656,837,1.162,838,1.108,839,0.767,840,1.745,841,0.767,842,0.767,843,0.767,844,0.767,845,0.767,846,0.691,847,0.656,848,0.691,849,0.767,850,0.767,851,0.656,852,0.767,853,0.767,854,0.767,855,0.728,856,0.767,857,0.728,858,1.162,859,0.767,860,0.767,861,1.204,862,0.767,863,0.622,864,0.767,865,0.767,866,0.767,867,1.596,868,0.728,869,0.767,870,0.767,871,1.682,872,1.162,873,1.682,874,1.565,875,0.767,876,1.103,877,1.103,878,1.486,879,1.682,880,1.403,881,1.332,882,0.728,883,1.332,884,0.728,885,0.656,886,1.332,887,1.332,888,0.728,889,1.103,890,1.596,891,1.162,892,1.403,893,1.103,894,1.264,895,1.596,896,1.68,897,0.767,898,0.767,899,0.767,900,0.767,901,0.767,902,1.162,903,1.162,904,1.103,905,0.767,906,0.767,907,0.767,908,0.767,909,0.767,910,1.332,911,1.047,912,0.767,913,0.767,914,0.622,915,0.656,916,0.767,917,0.728,918,1.596,919,0.767,920,0.728,921,1.486,922,0.728,923,1.332,924,0.728,925,1.403,926,0.767,927,0.767,928,0.691,929,0.728,930,0.767,931,0.767,932,1.565,933,0.767,934,0.767,935,0.767,936,0.767,937,1.682,938,0.767,939,0.767,940,0.767,941,0.728,942,0.767,943,0.767,944,0.767,945,0.994,946,0.767,947,0.767,948,0.767,949,0.767,950,0.767,951,0.767,952,0.767,953,1.047,954,0.767,955,0.691,956,0.691,957,0.943,958,0.767,959,0.767,960,0.767,961,0.767,962,1.162,963,1.162,964,1.162,965,0.767,966,1.162,967,0.767,968,0.767,969,0.728,970,1.162,971,0.767,972,0.728,973,0.767,974,0.767,975,1.332,976,1.332,977,0.767,978,0.767,979,0.767,980,0.767,981,0.767,982,0.767,983,0.767,984,0.728,985,1.162,986,0.767,987,0.728,988,0.767,989,1.162,990,0.767,991,0.767,992,0.767,993,0.767,994,0.767,995,0.767,996,0.767,997,0.767,998,1.162,999,0.767,1000,0.767,1001,0.767,1002,1.162,1003,1.162,1004,1.162,1005,0.767,1006,0.767,1007,1.403,1008,0.767,1009,1.565,1010,1.894,1011,0.767,1012,0.767,1013,1.162,1014,0.767,1015,0.767,1016,0.767,1017,1.162,1018,0.767,1019,0.767,1020,1.403,1021,0.767,1022,1.162,1023,1.162,1024,1.162,1025,0.767,1026,1.162,1027,0.767,1028,0.767,1029,1.403,1030,1.162,1031,0.767,1032,0.767,1033,0.767,1034,0.767,1035,0.767,1036,0.848,1037,0.622,1038,1.162,1039,0.767,1040,0.767,1041,1.403,1042,0.767,1043,1.515,1044,1.486,1045,0.767,1046,1.103,1047,0.691,1048,0.656,1049,1.162,1050,0.767,1051,0.767,1052,0.767,1053,1.162,1054,1.565,1055,1.162,1056,1.162,1057,0.767,1058,1.264,1059,0.767,1060,1.332,1061,0.767,1062,0.767,1063,1.162,1064,0.767,1065,0.728,1066,1.264,1067,0.767,1068,0.767,1069,0.728,1070,0.767,1071,1.403,1072,0.767,1073,1.486,1074,1.403,1075,0.767,1076,0.767,1077,1.162,1078,1.403,1079,0.767,1080,0.767,1081,0.767,1082,1.162,1083,0.767,1084,0.767,1085,0.767,1086,1.162,1087,0.728,1088,0.767,1089,1.162,1090,0.767,1091,0.767,1092,0.767,1093,0.767,1094,0.691,1095,1.332,1096,0.728,1097,0.691,1098,0.767,1099,0.767,1100,1.162,1101,1.403,1102,0.767,1103,1.162,1104,0.767,1105,0.767,1106,0.767,1107,1.403,1108,0.622,1109,0.767,1110,0.767,1111,0.767,1112,0.622,1113,0.767,1114,0.767,1115,0.767,1116,0.767,1117,0.767,1118,0.728,1119,1.162,1120,1.162,1121,1.162,1122,0.767,1123,1.162,1124,0.994,1125,1.047,1126,0.767,1127,0.767,1128,1.332,1129,0.994,1130,0.767,1131,0.728,1132,0.767,1133,0.767,1134,0.59,1135,0.767,1136,0.767,1137,0.767,1138,1.162,1139,1.162,1140,0.767,1141,0.767,1142,0.767,1143,0.767,1144,0.767,1145,1.103,1146,0.728,1147,1.162,1148,0.767,1149,0.767,1150,0.767,1151,0.767,1152,0.767,1153,0.767,1154,0.767,1155,0.767,1156,0.656,1157,0.767,1158,0.767,1159,1.162,1160,0.767,1161,0.767,1162,0.767,1163,1.162,1164,0.767,1165,0.767,1166,0.728,1167,1.162,1168,0.767,1169,0.656,1170,1.162,1171,1.332,1172,0.767,1173,0.767,1174,1.162,1175,1.162,1176,0.767,1177,0.728,1178,0.994,1179,0.767,1180,1.403,1181,0.767,1182,0.767,1183,0.691,1184,0.767,1185,0.767,1186,0.767,1187,0.767,1188,0.767,1189,1.403]],["title/interfaces/GoogleAuthOptions.html",[0,0.3,61,1.996]],["body/interfaces/GoogleAuthOptions.html",[0,0.518,1,3.014,2,0.167,3,0.148,4,0.278,5,1.606,6,0.093,7,0.431,9,1.118,10,0.021,11,0.871,12,0.807,13,0.632,14,0.639,15,1.07,16,1.448,17,0.372,18,0.589,19,0.909,20,0.716,21,0.683,22,0.499,23,0.804,24,2.504,25,1.724,26,0.906,27,2.504,28,1.606,29,1.41,30,0.978,31,0.994,32,2.949,33,3.39,34,1.161,35,0.957,36,0.882,37,2.349,38,0.936,39,2.357,40,2.504,41,2.537,42,1.538,43,1.502,44,2.746,45,1.724,46,2.411,47,1.502,48,1.724,49,1.033,50,1.243,51,2.181,52,1.724,53,0.332,54,3.201,55,0.882,56,0.777,57,3.014,58,0.014,59,2.504,60,2.332,61,3.014,62,3.148,63,1.171,64,3.237,65,1.118,66,3.438,67,3.014,68,0.582,69,0.582,70,2.459,71,2.099,72,0.394,73,0.836,74,2.504,75,0.947,76,0.775,77,0.906,78,1.316,79,1.115,80,0.683,81,2.332,82,1.606,83,1.606,84,0.109,85,1.606,86,2.569,87,0.683,88,0.47,89,0.937,90,0.882,91,2.504,92,2.994,93,0.585,94,2.569,95,0.855,96,1.724,97,0.683,98,2.332,99,0.812,100,1.724,101,1.502,102,1.724,103,1.724,104,0.591,105,1.724,106,3.586,107,3.237,108,1.724,109,1.318,110,1.724,111,1.606,112,0.591,113,1.724,114,1.724,115,1.724,116,1.724,117,0.767,118,0.559,119,1.009,120,2.949,121,1.724,122,3.237,123,1.724,124,1.606,125,3.34,126,0.624,127,3.586,128,1.724,129,0.53,130,0.39,131,0.559,132,1.502,133,1.251,134,0.375,135,2.181,136,0.499,137,1.41,138,2.504,139,1.067,140,1.724,141,0.917,142,2.504,143,0.804,144,1.054,145,2.949,146,1.009,147,0.909,148,0.777,149,0.751,150,0.429,151,1.253,152,2.269,153,2.504,154,1.724,155,1.724,156,2.504,157,0.757,158,0.528,159,1.724,160,2.849,161,1.724,162,1.724,163,1.724,164,1.724,165,2.23,166,2.746,167,2.645,168,2.411,169,2.949,170,2.811,171,2.504,172,2.181,173,3.438,174,0.937,175,2.949,176,0.823,177,1.724,178,2.14,179,0.841,180,1.724,181,1.326,182,1.724,183,1.724,184,1.724,185,2.504,186,0.802,187,0.811,188,1.606,189,2.099,190,1.606,191,0.678,192,2.504,193,1.724,194,2.504,195,3.791,196,1.724,197,0.812,198,1.724,199,0.683,200,0.757,201,1.724,202,2.504,203,0.659,204,2.504,205,1.724,206,1.262,207,1.724,208,1.724,209,0.624,210,3.977,211,1.724,212,0.956,213,1.372,214,2.332,215,0.591,216,4.059,217,1.724,218,0.624,219,1.502,220,2.504,221,1.067,222,2.504,223,3.237,224,2.332,225,2.746,226,2.949,227,1.724,228,1.229,229,0.659,230,2.504,231,0.865,232,1.724,233,1.606,234,0.624,235,0.659,236,0.624,237,1.724,238,1.067,239,3.53,240,1.724,241,1.724,242,0.499,243,0.528,244,0.39,245,0.624,246,1.606,247,1.724,248,1.724,249,1.724,250,1.724,251,2.746,252,1.724,253,2.949,254,1.724,255,1.724,256,3.014,257,1.724,258,2.949,259,1.724,260,3.34,261,0.559,262,1.724,263,0.858,264,1.724,265,1.327,266,1.606,267,0.156,268,1.724,269,2.332,270,1.724,271,1.724,272,1.724,273,2.504,274,1.724,275,1.724,276,1.502,277,1.724,278,1.724,279,2.504,280,1.724,281,1.724,282,1.724,283,1.724,284,0.818,285,1.724,286,1.724,287,0.802,288,3.791,289,1.724,290,0.684,291,0.906,292,1.724,293,0.624,294,0.624,295,1.724,296,1.606,297,1.724,298,1.724,299,0.659,300,1.724,301,1.724,302,1.724,303,1.724,304,3.025,305,0.624,306,1.606,307,1.724,308,1.724,309,1.724,310,1.724,311,1.724,312,1.502,313,1.724,314,1.724,315,0.528,316,1.327,317,1.502,318,1.251,319,0.499,320,1.724,321,1.724,322,1.724,323,0.54,324,2.269,325,2.646,326,1.724,327,1.203,328,1.41,329,1.724,330,0.604,331,1.606,332,1.606,333,1.724,334,1.724,335,2.504,336,1.724,337,2.811,338,2.411,339,1.163,340,2.181,341,1.724,342,2.047,343,1.724,344,1.724,345,1.327,346,1.41,347,1.41,348,1.41,349,2.047,350,1.41,351,1.41,352,1.41,353,1.724,354,1.502,355,0.624,356,1.606,357,1.724,358,2.746,359,2.504,360,2.047,361,1.724,362,2.504,363,1.724,364,1.724,365,1.502,366,1.724,367,1.724,368,1.724,369,0.812,370,0.34,371,1.178,372,3.438,373,1.724,374,2.504,375,0.956,376,1.502,377,1.724,378,1.724,379,1.724,380,1.724,381,1.502,382,0.659,383,1.606,384,1.724,385,2.504,386,1.724,387,1.724,388,0.566,389,1.724,390,2.949,391,1.724,392,1.724,393,1.724,394,1.724,395,1.606,396,1.606,397,1.724,398,1.724,399,2.504,400,1.724,401,1.724,402,2.047,403,1.724,404,1.724,405,1.724,406,1.724,407,1.724,408,1.724,409,1.724,410,1.724,411,1.724,412,1.724,413,0.957,414,3.014,415,0.34,416,2.181,417,1.724,418,1.724,419,1.724,420,1.724,421,1.724,422,1.724,423,0.711,424,1.327,425,0.659,426,1.327,427,1.606,428,1.724,429,1.724,430,0.624,431,1.724,432,1.724,433,1.724,434,2.504,435,1.724,436,0.956,437,0.591,438,0.683,439,1.118,440,1.724,441,1.724,442,1.724,443,1.724,444,1.724,445,1.724,446,1.724,447,1.724,448,1.724,449,0.416,450,0.365,451,0.624,452,3.438,453,1.724,454,0.39,455,0.624,456,2.504,457,2.332,458,0.591,459,1.724,460,0.804,461,0.559,462,1.724,463,1.724,464,0.528,465,1.724,466,1.182,467,1.182,468,1.182,469,0.528,470,1.724,471,0.39,472,1.298,473,1.606,474,1.251,475,1.724,476,1.724,477,1.724,478,0.659,479,1.724,480,1.724,481,0.659,482,2.504,483,1.502,484,1.724,485,1.724,486,1.724,487,0.416,488,1.724,489,0.659,490,1.724,491,1.724,492,1.724,493,1.724,494,1.606,495,0.012]],["title/classes/IAMAuth.html",[84,0.093,1190,2.781]],["body/classes/IAMAuth.html",[0,0.515,2,0.299,3,0.264,4,0.198,6,0.165,7,0.442,10,0.021,11,0.778,12,0.607,13,0.578,14,0.603,17,0.381,18,0.56,19,0.89,20,0.524,30,1.073,31,1.064,36,0.944,49,1.003,53,0.316,55,0.79,56,0.696,58,0.017,68,0.578,69,0.578,72,0.655,73,0.89,76,0.805,84,0.16,88,1.003,89,1.003,97,0.839,101,3.631,129,0.778,130,0.832,134,0.382,141,0.862,149,0.749,150,0.357,191,0.726,200,0.79,267,0.178,290,0.778,323,0.578,370,0.777,450,0.939,454,0.986,474,3.19,495,0.017,501,2.67,535,2.831,592,1.405,601,4.33,602,3.552,607,1.261,611,1.127,648,3.68,678,3.94,700,1.193,838,1.127,1036,1.558,1190,4.775,1191,4.492,1192,6.467,1193,3.936,1194,5.248,1195,5.248,1196,6.274,1197,5.248,1198,5.248,1199,4.775,1200,6.176,1201,6.176,1202,5.248,1203,6.176,1204,5.248,1205,5.108,1206,5.248,1207,5.37,1208,5.37,1209,4.492,1210,5.37,1211,5.37,1212,4.492,1213,4.492,1214,4.492,1215,4.492,1216,4.492]],["title/classes/JWTAccess.html",[84,0.093,1217,2.143]],["body/classes/JWTAccess.html",[2,0.241,3,0.213,4,0.207,6,0.173,7,0.43,10,0.021,11,0.828,12,0.817,13,0.672,14,0.614,15,0.719,16,1.296,17,0.379,18,0.575,19,0.946,20,0.683,34,1.251,36,0.827,42,2.322,46,2.509,49,1.176,53,0.277,56,0.907,58,0.015,62,3.143,65,1.248,68,0.676,69,0.594,70,1.612,71,1.612,72,0.562,73,0.808,79,0.878,80,0.668,84,0.14,86,3.113,88,0.878,89,0.878,90,0.878,95,0.792,97,0.878,109,1.158,129,0.681,130,0.728,133,1.804,134,0.42,136,0.719,141,0.899,147,0.562,149,0.775,150,0.424,151,0.806,176,0.833,178,2.338,179,0.526,186,0.526,189,2.602,191,0.705,197,0.806,200,0.827,231,0.799,244,0.562,267,0.186,287,0.799,304,2.634,323,0.663,324,2.909,325,3.385,327,0.762,328,2.634,330,0.967,337,3.202,338,3.281,339,1.368,340,3.495,342,2.033,345,1.913,346,2.033,347,2.033,348,2.033,349,2.634,350,2.033,351,2.033,352,2.033,354,2.166,370,0.705,371,0.852,388,0.946,423,0.967,438,0.678,449,0.998,450,0.913,454,0.936,455,1.166,460,1.031,461,1.159,472,1.452,495,0.015,501,2.964,526,0.852,535,2.479,582,1.598,590,1.523,591,1.296,592,1.231,596,0.9,601,3.791,602,3.293,607,1.104,611,1.251,619,1.52,648,3.917,678,3.981,684,4.723,700,0.806,709,1.442,715,1.368,733,1.368,735,1.745,752,1.442,836,1.442,838,0.762,851,1.692,863,1.368,885,1.6,915,1.113,929,1.601,945,1.113,1036,1.365,1047,1.783,1048,1.692,1058,1.686,1060,1.601,1066,1.173,1169,1.6,1178,1.828,1193,3.222,1217,4.14,1218,3.226,1219,6.107,1220,5.493,1221,5.493,1222,4.239,1223,5.493,1224,4.702,1225,4.239,1226,4.239,1227,4.239,1228,4.239,1229,4.239,1230,4.239,1231,4.239,1232,4.239,1233,4.239,1234,6.272,1235,4.239,1236,4.239,1237,4.702,1238,4.702,1239,5.216,1240,3.629,1241,3.629,1242,3.629,1243,3.629,1244,4.239,1245,3.629,1246,4.239,1247,5.518,1248,5.216,1249,5.518,1250,4.239,1251,4.239,1252,4.239,1253,4.239,1254,6.094,1255,4.239,1256,4.239,1257,4.239,1258,5.493,1259,4.239,1260,3.791,1261,5.493,1262,4.239,1263,4.239,1264,4.239,1265,4.239,1266,4.239,1267,2.926,1268,5.493,1269,4.239,1270,4.239,1271,4.702,1272,4.702,1273,2.926,1274,3.629,1275,3.629,1276,3.629,1277,3.629,1278,3.226,1279,3.226,1280,3.629]],["title/interfaces/JWTInput.html",[0,0.3,42,1.316]],["body/interfaces/JWTInput.html",[0,0.594,2,0.32,3,0.283,4,0.212,6,0.177,7,0.461,10,0.021,14,0.477,17,0.388,41,2.261,42,2.354,53,0.358,56,0.943,58,0.018,70,2.754,71,2.754,150,0.433,267,0.193,495,0.018,584,1.259,595,1.193,597,1.473,637,3.881,638,3.881,639,1.464,640,4.14,641,4.14,642,1.401,643,1.193,644,4.171,645,4.506,646,1.429,647,1.593]],["title/interfaces/JWTOptions.html",[0,0.3,47,1.867]],["body/interfaces/JWTOptions.html",[0,0.448,2,0.239,3,0.212,4,0.229,6,0.133,7,0.385,10,0.021,11,0.797,12,0.744,13,0.504,14,0.617,15,1.03,17,0.385,18,0.58,19,0.934,20,0.682,30,0.673,33,2.017,34,1.197,36,0.822,41,1.691,42,1.969,46,2.566,47,3.101,49,0.971,50,1.091,53,0.275,55,0.967,56,0.558,58,0.019,62,3.081,65,1.271,67,3.997,68,0.63,69,0.614,70,2.309,71,2.309,72,0.388,73,0.994,75,0.805,76,0.703,77,1.414,79,0.673,80,0.663,84,0.107,87,0.673,88,0.673,89,0.673,90,0.874,95,0.804,109,1.249,118,0.8,119,0.673,124,2.297,125,3.51,126,0.893,130,0.558,134,0.401,139,0.893,141,0.898,143,0.673,144,0.673,146,0.874,149,0.791,150,0.423,151,1.039,176,0.838,178,2.326,179,0.522,181,1.197,186,0.522,187,0.558,188,2.297,189,2.445,191,0.632,197,0.8,199,0.874,206,1.155,209,0.893,212,1.039,213,0.893,221,0.893,228,0.845,231,0.862,244,0.558,256,2.985,261,0.8,267,0.182,284,0.632,287,0.678,304,2.621,319,0.927,323,0.63,324,2.9,325,3.082,327,0.756,328,2.017,330,0.858,337,3.082,338,2.017,339,1.222,340,2.792,342,2.017,345,1.898,346,2.017,347,2.017,348,2.017,349,2.621,350,2.017,351,2.017,352,2.017,355,1.289,356,2.297,358,2.297,370,0.632,402,2.017,414,2.985,416,2.149,423,0.909,438,0.971,449,0.909,450,0.883,454,0.805,460,0.874,461,1.039,466,1.691,467,1.691,468,1.691,483,2.149,487,0.595,495,0.015,517,1.289,519,0.893,535,1.898,582,1.631,585,1.048,586,1.104,591,0.845,592,1.224,594,1.512,595,1.16,596,0.893,597,0.845,598,4.679,602,2.149,609,1.104,612,1.104,622,1.164,639,0.942,640,2.665,641,2.665,661,2.467,700,1.039,715,1.361,725,1.68,733,1.048,736,0.994,784,1.435,836,1.435,838,0.756,861,0.994,863,1.361,885,1.104,928,1.164,1043,1.164,1044,1.226,1058,1.164,1066,1.512,1069,1.226,1073,1.593,1217,3.77,1219,6.098,1234,5.951,1247,5.845,1248,6.033,1249,5.502,1260,2.903,1271,4.679,1272,4.679,1273,2.903,1274,3.601,1275,3.601,1276,3.601,1277,3.601,1278,3.202,1279,3.202,1281,4.207,1282,6.151,1283,4.679,1284,6.428,1285,5.951,1286,4.679,1287,4.207,1288,4.207,1289,4.207,1290,6.662,1291,4.207,1292,4.207,1293,4.207,1294,6.428,1295,4.207,1296,4.207,1297,6.072,1298,4.207,1299,6.828,1300,4.207,1301,4.207,1302,4.207,1303,3.601,1304,5.466,1305,5.466,1306,4.679,1307,4.207,1308,5.466,1309,4.207,1310,4.207,1311,4.207,1312,4.679,1313,4.207,1314,4.207,1315,5.466,1316,4.207,1317,4.207,1318,4.207,1319,4.207,1320,4.207,1321,5.466,1322,4.207,1323,4.207,1324,4.207,1325,5.466,1326,4.207,1327,4.207,1328,5.466,1329,4.207,1330,4.207,1331,4.207,1332,4.207,1333,4.207,1334,6.072,1335,4.207,1336,4.207,1337,4.207,1338,4.207,1339,4.207]],["title/classes/LoginTicket.html",[84,0.093,692,0.959]],["body/classes/LoginTicket.html",[0,0.371,2,0.258,3,0.228,4,0.216,6,0.143,10,0.021,13,0.417,17,0.382,18,0.582,46,2.38,53,0.288,58,0.016,65,0.972,69,0.528,72,0.417,73,0.923,76,0.828,78,0.861,79,1.209,80,0.417,84,0.178,87,0.916,93,0.68,95,0.663,97,0.724,99,1.296,129,0.71,134,0.411,146,0.724,148,0.876,149,0.617,150,0.258,152,2.043,157,0.681,174,0.724,187,0.6,215,0.91,244,0.759,267,0.116,284,0.524,287,0.561,316,2.043,319,0.972,323,0.609,365,2.313,369,0.861,370,0.524,388,0.937,415,0.866,423,0.81,438,1.144,449,0.934,450,0.941,454,0.6,460,0.916,495,0.016,500,0.961,501,3.044,526,0.91,557,0.813,578,0.961,582,1.48,583,1.128,587,0.91,590,1.07,591,1.37,596,0.961,605,1.698,607,1.151,611,0.813,633,2.868,643,1.216,646,1.151,648,3.36,649,3.125,650,3.875,651,3.446,652,2.868,653,3.446,654,4.196,655,3.983,656,2.868,657,2.868,658,1.216,659,3.125,660,3.125,661,2.655,662,3.125,663,3.446,664,3.125,665,3.125,666,3.125,667,3.125,668,3.63,669,3.125,670,3.125,671,3.125,672,3.125,673,3.125,674,3.125,675,2.868,676,3.125,677,3.125,678,3.722,684,3.954,692,1.504,693,1.878,700,1.089,705,1.252,708,1.252,709,1.189,712,1.997,713,1.931,714,1.585,717,1.734,720,1.585,721,1.427,729,1.739,730,1.761,731,1.252,732,1.427,733,1.566,734,1.189,735,1.729,736,1.07,737,1.189,738,1.504,739,1.252,740,1.65,741,1.189,742,1.252,743,1.189,744,1.252,752,1.189,755,1.189,756,1.585,757,1.585,759,1.585,761,1.252,762,1.189,769,1.128,790,1.956,794,1.65,801,1.189,803,1.189,820,1.252,828,1.585,830,1.189,831,1.252,832,1.252,838,0.813,847,1.504,848,1.585,861,1.485,863,1.427,945,1.504,953,1.585,955,1.252,956,1.252,957,1.128,1048,1.189,1097,1.252,1108,1.128,1112,1.128,1124,1.504,1125,1.252,1156,1.189,1169,1.189,1178,1.896,1260,3.125,1273,4.56,1340,3.875,1341,5.655,1342,5.655,1343,5.655,1344,5.655,1345,4.904,1346,5.833,1347,4.527,1348,5.028,1349,4.784,1350,6.052,1351,4.527,1352,4.36,1353,4.904,1354,4.904,1355,4.527,1356,4.527,1357,4.527,1358,4.904,1359,4.904,1360,4.904,1361,4.904,1362,3.875,1363,3.875,1364,3.954,1365,3.875,1366,3.446,1367,3.875,1368,3.446,1369,3.446,1370,3.875,1371,3.875,1372,3.875,1373,5.187,1374,5.833,1375,5.833,1376,5.833,1377,5.38,1378,3.875,1379,3.875,1380,3.875,1381,4.36,1382,4.904,1383,4.904,1384,3.875,1385,3.875]],["title/interfaces/OAuth2ClientOptions.html",[0,0.3,893,1.065]],["body/interfaces/OAuth2ClientOptions.html",[0,0.578,2,0.29,3,0.126,4,0.094,6,0.144,7,0.266,10,0.021,11,0.782,12,0.633,13,0.531,14,0.568,15,0.641,16,0.501,17,0.381,18,0.577,19,0.919,20,0.642,21,0.875,22,0.641,23,0.399,26,0.802,30,0.399,31,0.774,34,0.679,35,0.559,36,0.569,38,0.423,49,1.082,50,0.82,53,0.357,55,0.569,56,0.763,58,0.015,63,0.529,65,0.928,68,0.504,69,0.348,72,0.469,73,0.913,75,0.836,76,0.841,77,0.529,78,0.718,79,1.059,80,0.685,84,0.064,87,1.174,88,0.729,89,0.604,90,0.604,93,0.669,95,0.807,97,0.729,99,0.474,104,0.759,109,1.26,112,0.759,117,1.107,118,0.474,119,0.875,126,0.802,129,0.782,130,0.501,131,0.474,134,0.416,136,0.928,139,1.161,141,0.925,143,1.009,144,1.101,146,0.729,147,0.675,148,0.946,149,0.771,150,0.41,151,0.474,157,0.766,158,0.448,174,0.985,176,0.816,179,0.631,181,1.174,186,0.469,187,0.836,191,0.692,197,0.474,199,0.729,200,0.569,203,1.022,206,1.19,209,0.529,212,0.968,213,0.802,215,0.501,218,0.529,221,0.802,228,0.759,229,0.559,231,0.84,234,0.529,235,0.559,236,0.529,238,0.529,242,0.423,243,0.448,244,0.675,245,0.529,261,1.04,263,1.1,267,0.157,284,0.666,287,0.631,290,0.566,291,0.529,293,0.529,294,0.529,299,0.559,305,0.968,315,0.915,319,1.045,323,0.348,327,1.035,330,0.892,339,0.474,355,0.529,369,0.968,370,0.289,371,0.759,375,0.718,382,0.559,388,0.725,413,0.559,415,0.843,423,0.846,425,0.559,430,0.802,436,0.718,437,0.917,438,1.009,449,1.041,450,0.941,451,0.529,454,0.946,455,0.529,458,0.501,460,1.072,461,0.718,464,0.679,469,0.82,471,0.889,472,0.968,478,0.846,481,1.34,487,0.997,489,1.022,495,0.016,496,1.413,498,0.893,499,1.203,500,1.161,511,1.137,515,1.602,517,0.968,519,0.529,526,0.501,532,1.535,541,0.589,546,0.941,557,0.448,559,1.137,560,1.203,562,0.589,578,1.308,582,1.022,583,1.137,584,0.559,585,0.621,586,1.198,587,0.759,590,1.456,591,1.393,592,1.022,594,1.655,595,0.968,596,0.802,597,1.157,605,1.434,607,0.501,609,0.992,611,1.227,612,0.655,616,1.484,617,1.101,618,1.484,619,1.408,620,1.484,621,1.101,622,1.045,623,0.727,624,1.436,627,0.727,629,1.484,632,0.69,634,0.69,639,1.14,642,0.621,643,1.27,646,1.202,647,0.846,658,0.968,686,0.727,687,0.69,688,1.484,689,1.704,690,1.045,691,1.33,692,1.337,693,0.655,694,0.727,695,1.101,696,1.484,697,1.484,698,1.484,699,1.401,700,1.095,701,1.161,702,1.101,703,1.401,704,1.33,705,1.514,706,1.837,707,0.69,708,0.69,709,1.198,710,0.766,711,1.161,712,1.262,713,1.656,714,0.69,715,1.137,716,0.766,717,1.512,718,0.766,719,0.727,720,1.045,721,1.49,722,0.766,723,0.766,724,1.161,725,1.408,726,1.484,727,0.766,728,0.766,729,1.045,730,0.941,731,0.69,732,0.941,733,1.363,734,1.337,735,1.078,736,1.36,737,0.655,738,1.436,739,0.69,740,1.337,741,0.655,742,0.69,743,0.655,744,1.045,745,1.595,746,1.161,747,1.484,748,1.161,749,1.564,750,1.33,751,0.727,752,0.992,753,1.161,754,1.363,755,1.337,756,1.045,757,1.408,758,0.766,759,1.655,760,0.766,761,1.262,762,1.198,763,1.198,764,0.766,765,1.33,766,1.161,767,1.401,768,1.514,769,1.137,770,0.766,771,1.045,772,0.766,773,1.045,774,1.161,775,0.727,776,0.727,777,0.766,778,0.766,779,0.727,780,0.766,781,1.161,782,1.101,783,0.766,784,1.337,785,0.766,786,0.766,787,1.161,788,1.161,789,1.401,790,1.045,791,0.69,792,1.796,793,1.161,794,0.992,795,0.766,796,0.766,797,0.766,798,0.766,799,1.161,800,0.766,801,1.198,802,0.992,803,0.655,804,1.401,805,0.766,806,1.101,807,0.766,808,1.401,809,1.101,810,0.766,811,0.766,812,0.766,813,0.766,814,1.595,815,0.766,816,0.766,817,1.401,818,0.766,819,1.161,820,1.045,821,0.766,822,0.766,823,0.766,824,0.766,825,0.69,826,1.101,827,0.69,828,0.69,829,0.766,830,0.992,831,1.045,832,1.045,833,0.766,834,0.766,835,0.766,836,0.655,837,1.161,838,1.107,839,0.766,840,1.743,841,0.766,842,0.766,843,0.766,844,0.766,845,0.766,846,0.69,847,0.655,848,0.69,849,0.766,850,0.766,851,0.655,852,0.766,853,0.766,854,0.766,855,0.727,856,0.766,857,0.727,858,1.161,859,0.766,860,0.766,861,1.203,862,0.766,863,0.621,864,0.766,865,0.766,866,0.766,867,1.595,868,0.727,869,0.766,870,0.766,871,1.68,872,1.161,873,1.68,874,1.564,875,0.766,876,1.101,877,1.101,878,1.484,879,1.68,880,1.401,881,1.33,882,0.727,883,1.33,884,0.727,885,0.655,886,1.33,887,1.33,888,0.727,889,1.101,890,1.595,891,1.161,892,1.401,893,1.33,894,1.593,895,1.796,896,1.839,897,0.766,898,0.766,899,0.766,900,0.766,901,0.766,902,1.161,903,1.161,904,1.101,905,0.766,906,0.766,907,0.766,908,0.766,909,0.766,910,1.33,911,1.045,912,0.766,913,0.766,914,0.621,915,0.655,916,0.766,917,0.727,918,1.595,919,0.766,920,0.727,921,1.484,922,0.727,923,1.33,924,0.727,925,1.401,926,0.766,927,0.766,928,0.69,929,0.727,930,0.766,931,0.766,932,1.564,933,0.766,934,0.766,935,0.766,936,0.766,937,1.68,938,0.766,939,0.766,940,0.766,941,0.727,942,0.766,943,0.766,944,0.766,945,0.992,946,0.766,947,0.766,948,0.766,949,0.766,950,0.766,951,0.766,952,0.766,953,1.045,954,0.766,955,0.69,956,0.69,957,0.941,958,0.766,959,0.766,960,0.766,961,0.766,962,1.161,963,1.161,964,1.161,965,0.766,966,1.161,967,0.766,968,0.766,969,0.727,970,1.161,971,0.766,972,0.727,973,0.766,974,0.766,975,1.33,976,1.33,977,0.766,978,0.766,979,0.766,980,0.766,981,0.766,982,0.766,983,0.766,984,0.727,985,1.161,986,0.766,987,0.727,988,0.766,989,1.161,990,0.766,991,0.766,992,0.766,993,0.766,994,0.766,995,0.766,996,0.766,997,0.766,998,1.161,999,0.766,1000,0.766,1001,0.766,1002,1.161,1003,1.161,1004,1.161,1005,0.766,1006,0.766,1007,1.401,1008,0.766,1009,1.564,1010,1.892,1011,0.766,1012,0.766,1013,1.161,1014,0.766,1015,0.766,1016,0.766,1017,1.161,1018,0.766,1019,0.766,1020,1.401,1021,0.766,1022,1.161,1023,1.161,1024,1.161,1025,0.766,1026,1.161,1027,0.766,1028,0.766,1029,1.401,1030,1.161,1031,0.766,1032,0.766,1033,0.766,1034,0.766,1035,0.766,1036,0.846,1037,0.621,1038,1.161,1039,0.766,1040,0.766,1041,1.401,1042,0.766,1043,1.514,1044,1.484,1045,0.766,1046,1.101,1047,0.69,1048,0.655,1049,1.161,1050,0.766,1051,0.766,1052,0.766,1053,1.161,1054,1.564,1055,1.161,1056,1.161,1057,0.766,1058,1.262,1059,0.766,1060,1.33,1061,0.766,1062,0.766,1063,1.161,1064,0.766,1065,0.727,1066,1.262,1067,0.766,1068,0.766,1069,0.727,1070,0.766,1071,1.401,1072,0.766,1073,1.484,1074,1.401,1075,0.766,1076,0.766,1077,1.161,1078,1.401,1079,0.766,1080,0.766,1081,0.766,1082,1.161,1083,0.766,1084,0.766,1085,0.766,1086,1.161,1087,0.727,1088,0.766,1089,1.161,1090,0.766,1091,0.766,1092,0.766,1093,0.766,1094,0.69,1095,1.33,1096,0.727,1097,0.69,1098,0.766,1099,0.766,1100,1.161,1101,1.401,1102,0.766,1103,1.161,1104,0.766,1105,0.766,1106,0.766,1107,1.401,1108,0.621,1109,0.766,1110,0.766,1111,0.766,1112,0.621,1113,0.766,1114,0.766,1115,0.766,1116,0.766,1117,0.766,1118,0.727,1119,1.161,1120,1.161,1121,1.161,1122,0.766,1123,1.161,1124,0.992,1125,1.045,1126,0.766,1127,0.766,1128,1.33,1129,0.992,1130,0.766,1131,0.727,1132,0.766,1133,0.766,1134,0.589,1135,0.766,1136,0.766,1137,0.766,1138,1.161,1139,1.161,1140,0.766,1141,0.766,1142,0.766,1143,0.766,1144,0.766,1145,1.101,1146,0.727,1147,1.161,1148,0.766,1149,0.766,1150,0.766,1151,0.766,1152,0.766,1153,0.766,1154,0.766,1155,0.766,1156,0.655,1157,0.766,1158,0.766,1159,1.161,1160,0.766,1161,0.766,1162,0.766,1163,1.161,1164,0.766,1165,0.766,1166,0.727,1167,1.161,1168,0.766,1169,0.655,1170,1.161,1171,1.33,1172,0.766,1173,0.766,1174,1.161,1175,1.161,1176,0.766,1177,0.727,1178,0.992,1179,0.766,1180,1.401,1181,0.766,1182,0.766,1183,0.69,1184,0.766,1185,0.766,1186,0.766,1187,0.766,1188,0.766,1189,1.401]],["title/classes/PemVerifier.html",[84,0.093,690,1.011]],["body/classes/PemVerifier.html",[2,0.33,3,0.292,4,0.218,6,0.183,9,2.732,10,0.021,17,0.376,18,0.516,20,0.579,26,1.412,53,0.292,58,0.018,80,0.535,84,0.17,129,0.825,150,0.33,267,0.148,327,1.257,495,0.018,501,2.469,611,1.042,678,3.168,690,1.841,840,2.093,1124,1.885,1183,1.841,1386,5.802,1387,5.802,1388,6.997,1389,5.802,1390,6.654,1391,5.802,1392,5.802,1393,5.802,1394,5.802]],["title/interfaces/ProjectIdCallback.html",[0,0.3,54,1.996]],["body/interfaces/ProjectIdCallback.html",[0,0.52,1,3.033,2,0.169,3,0.15,4,0.278,5,1.627,6,0.094,7,0.433,8,1.428,9,1.64,10,0.021,11,0.878,12,0.815,13,0.645,14,0.638,15,1.074,16,1.438,17,0.365,18,0.59,19,0.92,20,0.718,21,0.689,22,0.505,23,0.81,24,2.528,25,1.747,26,0.915,27,2.528,28,1.627,29,1.428,30,0.982,31,0.999,32,2.971,33,3.352,34,1.166,35,0.966,36,0.887,37,2.363,38,0.942,39,2.369,40,2.528,41,2.369,42,1.553,43,1.521,44,2.767,45,1.747,46,2.418,47,1.521,48,1.747,49,1.037,50,1.246,51,2.202,52,1.747,53,0.333,54,3.355,55,0.887,56,0.781,57,3.033,58,0.014,59,2.528,60,2.354,61,2.767,62,3.101,63,0.915,64,2.528,65,1.074,66,2.528,67,1.627,68,0.566,69,0.566,70,2.41,71,1.927,72,0.275,73,0.672,74,1.747,75,0.944,76,0.765,77,0.915,78,1.307,79,1.109,80,0.683,81,2.354,82,1.627,83,1.627,84,0.11,85,1.627,86,2.588,87,0.689,88,0.476,89,0.942,90,0.888,91,2.528,92,3.01,93,0.588,94,2.588,95,0.856,96,1.747,97,0.689,98,2.354,99,0.82,100,1.747,101,1.521,102,1.747,103,1.747,104,0.599,105,1.747,106,3.603,107,3.257,108,1.747,109,1.319,110,1.747,111,1.627,112,0.599,113,1.747,114,1.747,115,1.747,116,1.747,117,0.775,118,0.566,119,1.013,120,2.971,121,1.747,122,3.257,123,1.747,124,1.627,125,3.355,126,0.632,127,3.603,128,1.747,129,0.535,130,0.395,131,0.566,132,1.521,133,1.268,134,0.376,135,2.202,136,0.505,137,1.428,138,2.528,139,1.075,140,1.747,141,0.918,142,2.528,143,0.81,144,1.057,145,2.971,146,1.013,147,0.911,148,0.781,149,0.753,150,0.426,151,1.257,152,2.286,153,2.528,154,1.747,155,1.747,156,2.528,157,0.762,158,0.535,159,1.747,160,2.857,161,1.747,162,1.747,163,1.747,164,1.747,165,2.241,166,2.767,167,2.659,168,2.429,169,2.971,170,2.825,171,2.528,172,2.202,173,3.456,174,0.942,175,2.971,176,0.824,177,1.747,178,2.156,179,0.843,180,1.747,181,1.327,182,1.747,183,1.747,184,1.747,185,2.528,186,0.805,187,0.814,188,1.627,189,2.112,190,1.627,191,0.682,192,2.528,193,1.747,194,2.528,195,3.805,196,1.747,197,0.82,198,1.747,199,0.689,200,0.762,201,1.747,202,2.528,203,0.667,204,2.528,205,1.747,206,1.265,207,1.747,208,1.747,209,0.632,210,3.988,211,1.747,212,0.963,213,1.377,214,2.354,215,0.599,216,4.068,217,1.747,218,0.632,219,1.521,220,2.528,221,1.075,222,2.528,223,3.257,224,2.354,225,2.767,226,2.971,227,1.747,228,1.235,229,0.667,230,2.528,231,0.867,232,1.747,233,1.627,234,0.632,235,0.667,236,0.632,237,1.747,238,1.075,239,3.543,240,1.747,241,1.747,242,0.505,243,0.535,244,0.395,245,0.632,246,1.627,247,1.747,248,1.747,249,1.747,250,1.747,251,2.767,252,1.747,253,2.971,254,1.747,255,1.747,256,3.033,257,1.747,258,2.971,259,1.747,260,3.355,261,0.566,262,1.747,263,0.866,264,1.747,265,1.344,266,1.627,267,0.076,268,1.747,269,2.354,270,1.747,271,1.747,272,1.747,273,2.528,274,1.747,275,1.747,276,1.521,277,1.747,278,1.747,279,2.528,280,1.747,281,1.747,282,1.747,283,1.747,284,0.82,285,1.747,286,1.747,287,0.805,288,3.805,289,1.747,290,0.689,291,0.915,292,1.747,293,0.632,294,0.632,295,1.747,296,1.627,297,1.747,298,1.747,299,0.667,300,1.747,301,1.747,302,1.747,303,1.747,304,3.037,305,0.632,306,1.627,307,1.747,308,1.747,309,1.747,310,1.747,311,1.747,312,1.521,313,1.747,314,1.747,315,0.535,316,1.344,317,1.521,318,1.268,319,0.505,320,1.747,321,1.747,322,1.747,323,0.543,324,2.286,325,2.662,326,1.747,327,1.206,328,1.428,329,1.747,330,0.609,331,1.627,332,1.627,333,1.747,334,1.747,335,2.528,336,1.747,337,2.825,338,2.429,339,1.168,340,2.202,341,1.747,342,2.067,343,1.747,344,1.747,345,1.344,346,1.428,347,1.428,348,1.428,349,2.067,350,1.428,351,1.428,352,1.428,353,1.747,354,1.521,355,0.632,356,1.627,357,1.747,358,2.767,359,2.528,360,2.067,361,1.747,362,2.528,363,1.747,364,1.747,365,1.521,366,1.747,367,1.747,368,1.747,369,0.82,370,0.345,371,1.184,372,3.456,373,1.747,374,2.528,375,0.963,376,1.521,377,1.747,378,1.747,379,1.747,380,1.747,381,1.521,382,0.667,383,1.627,384,1.747,385,2.528,386,1.747,387,1.747,388,0.571,389,1.747,390,2.971,391,1.747,392,1.747,393,1.747,394,1.747,395,1.627,396,1.627,397,1.747,398,1.747,399,2.528,400,1.747,401,1.747,402,2.067,403,1.747,404,1.747,405,1.747,406,1.747,407,1.747,408,1.747,409,1.747,410,1.747,411,1.747,412,1.747,413,0.966,414,3.033,415,0.345,416,2.202,417,1.747,418,1.747,419,1.747,420,1.747,421,1.747,422,1.747,423,0.716,424,1.344,425,0.667,426,1.344,427,1.627,428,1.747,429,1.747,430,0.632,431,1.747,432,1.747,433,1.747,434,2.528,435,1.747,436,0.963,437,0.599,438,0.689,439,1.133,440,1.747,441,1.747,442,1.747,443,1.747,444,1.747,445,1.747,446,1.747,447,1.747,448,1.747,449,0.421,450,0.369,451,0.632,452,3.456,453,1.747,454,0.395,455,0.632,456,2.528,457,2.354,458,0.599,459,1.747,460,0.81,461,0.566,462,1.747,463,1.747,464,0.535,465,1.747,466,1.198,467,1.198,468,1.198,469,0.535,470,1.747,471,0.395,472,1.304,473,1.627,474,1.268,475,1.747,476,1.747,477,1.747,478,0.667,479,1.747,480,1.747,481,0.667,482,2.528,483,1.521,484,1.747,485,1.747,486,1.747,487,0.421,488,1.747,489,0.667,490,1.747,491,1.747,492,1.747,493,1.747,494,1.627,495,0.012]],["title/interfaces/RefreshAccessTokenCallback.html",[0,0.3,883,1.065]],["body/interfaces/RefreshAccessTokenCallback.html",[0,0.578,2,0.29,3,0.126,4,0.094,6,0.144,7,0.322,8,1.198,9,0.95,10,0.021,11,0.798,12,0.634,13,0.582,14,0.579,15,0.642,16,0.502,17,0.379,18,0.578,19,0.925,20,0.642,21,0.875,22,0.775,23,0.399,26,0.803,30,0.399,31,0.775,34,0.68,35,0.56,36,0.569,38,0.424,49,1.083,50,0.68,53,0.357,55,0.569,56,0.764,58,0.015,63,0.53,65,0.929,68,0.505,69,0.349,72,0.47,73,0.913,75,0.837,76,0.841,77,0.53,78,0.719,79,1.06,80,0.685,84,0.064,87,1.174,88,0.73,89,0.605,90,0.605,93,0.669,95,0.807,97,0.73,99,0.475,104,0.761,109,1.261,112,0.761,117,1.108,118,0.475,119,0.875,126,0.803,129,0.783,130,0.502,131,0.475,134,0.416,136,0.929,139,1.162,141,0.925,143,1.009,144,1.101,146,0.73,147,0.676,148,0.947,149,0.772,150,0.401,151,0.475,157,0.767,158,0.449,174,0.986,176,0.816,179,0.632,181,1.175,186,0.469,187,0.837,191,0.693,197,0.475,199,0.73,200,0.569,203,1.023,206,1.191,209,0.53,212,0.969,213,0.803,215,0.502,218,0.53,221,0.803,228,0.761,229,0.56,231,0.84,234,0.53,235,0.56,236,0.53,238,0.53,242,0.424,243,0.449,244,0.676,245,0.53,261,1.041,263,1.1,267,0.14,284,0.667,287,0.632,290,0.567,291,0.53,293,0.53,294,0.53,299,0.56,305,0.97,315,0.916,319,1.046,323,0.349,327,1.035,330,0.892,339,0.475,355,0.53,369,0.969,370,0.289,371,0.761,375,0.719,382,0.56,388,0.726,413,0.56,415,0.843,423,0.846,425,0.56,430,0.803,436,0.719,437,0.918,438,1.009,449,1.041,450,0.941,451,0.53,454,0.947,455,0.53,458,0.502,460,1.072,461,0.719,464,0.68,469,0.821,471,0.889,472,0.97,478,0.848,481,1.341,487,1.002,489,1.023,495,0.016,496,1.414,498,1.079,499,1.204,500,1.162,511,1.138,515,1.603,517,0.803,519,0.53,526,0.502,532,1.536,541,0.59,546,0.943,557,0.449,559,1.138,560,1.204,562,0.59,578,1.308,582,1.023,583,1.138,584,0.56,585,0.622,586,1.199,587,0.761,590,1.457,591,1.394,592,1.023,594,1.656,595,0.97,596,0.803,597,1.158,605,1.435,607,0.502,609,0.993,611,1.228,612,0.656,616,1.485,617,1.103,618,1.485,619,1.41,620,1.485,621,1.103,622,1.047,623,0.728,624,1.438,627,0.728,629,1.485,632,0.691,634,0.691,639,1.142,642,0.622,643,1.27,646,1.203,647,0.848,658,0.97,686,0.728,687,0.691,688,1.485,689,1.705,690,1.047,691,1.332,692,1.338,693,0.656,694,0.728,695,1.103,696,1.485,697,1.485,698,1.485,699,1.403,700,1.095,701,1.162,702,1.103,703,1.403,704,1.332,705,1.515,706,1.838,707,0.691,708,0.691,709,1.199,710,0.767,711,1.162,712,1.264,713,1.657,714,0.691,715,1.138,716,0.767,717,1.513,718,0.767,719,0.728,720,1.047,721,1.491,722,0.767,723,0.767,724,1.162,725,1.41,726,1.485,727,0.767,728,0.767,729,1.047,730,0.943,731,0.691,732,0.943,733,1.364,734,1.338,735,1.079,736,1.361,737,0.656,738,1.438,739,0.691,740,1.338,741,0.656,742,0.691,743,0.656,744,1.047,745,1.596,746,1.162,747,1.485,748,1.162,749,1.565,750,1.332,751,0.728,752,0.993,753,1.162,754,1.364,755,1.338,756,1.047,757,1.41,758,0.767,759,1.656,760,0.767,761,1.264,762,1.199,763,1.199,764,0.767,765,1.332,766,1.162,767,1.403,768,1.515,769,1.138,770,0.767,771,1.047,772,0.767,773,1.047,774,1.162,775,0.728,776,0.728,777,0.767,778,0.767,779,0.728,780,0.767,781,1.162,782,1.103,783,0.767,784,1.338,785,0.767,786,0.767,787,1.162,788,1.162,789,1.403,790,1.047,791,0.691,792,1.797,793,1.162,794,0.993,795,0.767,796,0.767,797,0.767,798,0.767,799,1.162,800,0.767,801,1.199,802,0.993,803,0.656,804,1.403,805,0.767,806,1.103,807,0.767,808,1.403,809,1.103,810,0.767,811,0.767,812,0.767,813,0.767,814,1.596,815,0.767,816,0.767,817,1.403,818,0.767,819,1.162,820,1.047,821,0.767,822,0.767,823,0.767,824,0.767,825,0.691,826,1.103,827,0.691,828,0.691,829,0.767,830,0.993,831,1.047,832,1.047,833,0.767,834,0.767,835,0.767,836,0.656,837,1.162,838,1.108,839,0.767,840,1.745,841,0.767,842,0.767,843,0.767,844,0.767,845,0.767,846,0.691,847,0.656,848,0.691,849,0.767,850,0.767,851,0.656,852,0.767,853,0.767,854,0.767,855,0.728,856,0.767,857,0.728,858,1.162,859,0.767,860,0.767,861,1.204,862,0.767,863,0.622,864,0.767,865,0.767,866,0.767,867,1.596,868,0.728,869,0.767,870,0.767,871,1.682,872,1.162,873,1.682,874,1.565,875,0.767,876,1.103,877,1.103,878,1.485,879,1.682,880,1.403,881,1.332,882,0.728,883,1.485,884,0.728,885,0.656,886,1.332,887,1.332,888,0.728,889,1.103,890,1.596,891,1.162,892,1.403,893,1.103,894,1.264,895,1.596,896,1.679,897,0.767,898,0.767,899,0.767,900,0.767,901,0.767,902,1.162,903,1.162,904,1.103,905,0.767,906,0.767,907,0.767,908,0.767,909,0.767,910,1.332,911,1.047,912,0.767,913,0.767,914,0.622,915,0.656,916,0.767,917,0.728,918,1.596,919,0.767,920,0.728,921,1.485,922,0.728,923,1.332,924,0.728,925,1.403,926,0.767,927,0.767,928,0.691,929,0.728,930,0.767,931,0.767,932,1.565,933,0.767,934,0.767,935,0.767,936,0.767,937,1.682,938,0.767,939,0.767,940,0.767,941,0.728,942,0.767,943,0.767,944,0.767,945,0.993,946,0.767,947,0.767,948,0.767,949,0.767,950,0.767,951,0.767,952,0.767,953,1.047,954,0.767,955,0.691,956,0.691,957,0.943,958,0.767,959,0.767,960,0.767,961,0.767,962,1.162,963,1.162,964,1.162,965,0.767,966,1.162,967,0.767,968,0.767,969,0.728,970,1.162,971,0.767,972,0.728,973,0.767,974,0.767,975,1.332,976,1.332,977,0.767,978,0.767,979,0.767,980,0.767,981,0.767,982,0.767,983,0.767,984,0.728,985,1.162,986,0.767,987,0.728,988,0.767,989,1.162,990,0.767,991,0.767,992,0.767,993,0.767,994,0.767,995,0.767,996,0.767,997,0.767,998,1.162,999,0.767,1000,0.767,1001,0.767,1002,1.162,1003,1.162,1004,1.162,1005,0.767,1006,0.767,1007,1.403,1008,0.767,1009,1.565,1010,1.893,1011,0.767,1012,0.767,1013,1.162,1014,0.767,1015,0.767,1016,0.767,1017,1.162,1018,0.767,1019,0.767,1020,1.403,1021,0.767,1022,1.162,1023,1.162,1024,1.162,1025,0.767,1026,1.162,1027,0.767,1028,0.767,1029,1.403,1030,1.162,1031,0.767,1032,0.767,1033,0.767,1034,0.767,1035,0.767,1036,0.848,1037,0.622,1038,1.162,1039,0.767,1040,0.767,1041,1.403,1042,0.767,1043,1.515,1044,1.485,1045,0.767,1046,1.103,1047,0.691,1048,0.656,1049,1.162,1050,0.767,1051,0.767,1052,0.767,1053,1.162,1054,1.565,1055,1.162,1056,1.162,1057,0.767,1058,1.264,1059,0.767,1060,1.332,1061,0.767,1062,0.767,1063,1.162,1064,0.767,1065,0.728,1066,1.264,1067,0.767,1068,0.767,1069,0.728,1070,0.767,1071,1.403,1072,0.767,1073,1.485,1074,1.403,1075,0.767,1076,0.767,1077,1.162,1078,1.403,1079,0.767,1080,0.767,1081,0.767,1082,1.162,1083,0.767,1084,0.767,1085,0.767,1086,1.162,1087,0.728,1088,0.767,1089,1.162,1090,0.767,1091,0.767,1092,0.767,1093,0.767,1094,0.691,1095,1.332,1096,0.728,1097,0.691,1098,0.767,1099,0.767,1100,1.162,1101,1.403,1102,0.767,1103,1.162,1104,0.767,1105,0.767,1106,0.767,1107,1.403,1108,0.622,1109,0.767,1110,0.767,1111,0.767,1112,0.622,1113,0.767,1114,0.767,1115,0.767,1116,0.767,1117,0.767,1118,0.728,1119,1.162,1120,1.162,1121,1.162,1122,0.767,1123,1.162,1124,0.993,1125,1.047,1126,0.767,1127,0.767,1128,1.332,1129,0.993,1130,0.767,1131,0.728,1132,0.767,1133,0.767,1134,0.59,1135,0.767,1136,0.767,1137,0.767,1138,1.162,1139,1.162,1140,0.767,1141,0.767,1142,0.767,1143,0.767,1144,0.767,1145,1.103,1146,0.728,1147,1.162,1148,0.767,1149,0.767,1150,0.767,1151,0.767,1152,0.767,1153,0.767,1154,0.767,1155,0.767,1156,0.656,1157,0.767,1158,0.767,1159,1.162,1160,0.767,1161,0.767,1162,0.767,1163,1.162,1164,0.767,1165,0.767,1166,0.728,1167,1.162,1168,0.767,1169,0.656,1170,1.162,1171,1.332,1172,0.767,1173,0.767,1174,1.162,1175,1.162,1176,0.767,1177,0.728,1178,0.993,1179,0.767,1180,1.403,1181,0.767,1182,0.767,1183,0.691,1184,0.767,1185,0.767,1186,0.767,1187,0.767,1188,0.767,1189,1.403]],["title/interfaces/RefreshAccessTokenResponse.html",[0,0.3,884,1.065]],["body/interfaces/RefreshAccessTokenResponse.html",[0,0.579,2,0.29,3,0.126,4,0.094,6,0.144,7,0.267,10,0.021,11,0.783,12,0.634,13,0.568,14,0.592,15,0.642,16,0.502,17,0.379,18,0.577,19,0.919,20,0.642,21,0.876,22,0.864,23,0.399,26,0.803,30,0.399,31,0.775,34,0.68,35,0.56,36,0.569,38,0.424,49,1.083,50,0.68,53,0.357,55,0.569,56,0.764,58,0.015,63,0.53,65,0.929,68,0.505,69,0.349,72,0.47,73,0.913,75,0.837,76,0.841,77,0.53,78,0.72,79,1.06,80,0.685,84,0.064,87,1.174,88,0.73,89,0.605,90,0.605,93,0.669,95,0.807,97,0.73,99,0.475,104,0.761,109,1.261,112,0.761,117,1.108,118,0.475,119,0.876,126,0.803,129,0.783,130,0.502,131,0.475,134,0.416,136,0.929,139,1.162,141,0.925,143,1.009,144,1.101,146,0.73,147,0.676,148,0.947,149,0.772,150,0.401,151,0.475,157,0.767,158,0.449,174,0.986,176,0.816,179,0.632,181,1.175,186,0.469,187,0.837,191,0.693,197,0.475,199,0.73,200,0.569,203,1.023,206,1.191,209,0.53,212,0.969,213,0.803,215,0.502,218,0.53,221,0.803,228,0.761,229,0.56,231,0.84,234,0.53,235,0.56,236,0.53,238,0.53,242,0.424,243,0.449,244,0.676,245,0.53,261,1.041,263,1.101,267,0.153,284,0.667,287,0.632,290,0.567,291,0.53,293,0.53,294,0.53,299,0.56,305,0.97,315,0.916,319,1.046,323,0.349,327,1.035,330,0.892,339,0.475,355,0.53,369,0.969,370,0.289,371,0.761,375,0.72,382,0.56,388,0.726,413,0.56,415,0.843,423,0.846,425,0.56,430,0.803,436,0.72,437,0.918,438,1.009,449,1.041,450,0.941,451,0.53,454,0.947,455,0.53,458,0.502,460,1.072,461,0.72,464,0.68,469,0.821,471,0.889,472,0.97,478,0.848,481,1.341,487,1.01,489,1.023,495,0.016,496,1.414,498,0.894,499,1.204,500,1.162,511,1.138,515,1.603,517,0.803,519,0.53,526,0.502,532,1.536,541,0.59,546,0.943,557,0.449,559,1.138,560,1.204,562,0.59,578,1.309,582,1.023,583,1.138,584,0.56,585,0.622,586,1.199,587,0.761,590,1.457,591,1.394,592,1.023,594,1.656,595,0.97,596,0.803,597,1.158,605,1.435,607,0.502,609,0.994,611,1.228,612,0.656,616,1.486,617,1.103,618,1.486,619,1.41,620,1.486,621,1.103,622,1.047,623,0.728,624,1.438,627,0.728,629,1.486,632,0.691,634,0.691,639,1.142,642,0.622,643,1.271,646,1.203,647,0.848,658,0.97,686,0.728,687,0.691,688,1.486,689,1.705,690,1.047,691,1.332,692,1.338,693,0.656,694,0.728,695,1.103,696,1.486,697,1.486,698,1.486,699,1.403,700,1.096,701,1.162,702,1.103,703,1.403,704,1.332,705,1.515,706,1.839,707,0.691,708,0.691,709,1.199,710,0.767,711,1.162,712,1.264,713,1.657,714,0.691,715,1.138,716,0.767,717,1.513,718,0.767,719,0.728,720,1.047,721,1.491,722,0.767,723,0.767,724,1.162,725,1.41,726,1.486,727,0.767,728,0.767,729,1.047,730,0.943,731,0.691,732,0.943,733,1.364,734,1.338,735,1.079,736,1.361,737,0.656,738,1.438,739,0.691,740,1.338,741,0.656,742,0.691,743,0.656,744,1.047,745,1.596,746,1.162,747,1.486,748,1.162,749,1.565,750,1.332,751,0.728,752,0.994,753,1.162,754,1.364,755,1.338,756,1.047,757,1.41,758,0.767,759,1.656,760,0.767,761,1.264,762,1.199,763,1.199,764,0.767,765,1.332,766,1.162,767,1.403,768,1.515,769,1.138,770,0.767,771,1.047,772,0.767,773,1.047,774,1.162,775,0.728,776,0.728,777,0.767,778,0.767,779,0.728,780,0.767,781,1.162,782,1.103,783,0.767,784,1.338,785,0.767,786,0.767,787,1.162,788,1.162,789,1.403,790,1.047,791,0.691,792,1.797,793,1.162,794,0.994,795,0.767,796,0.767,797,0.767,798,0.767,799,1.162,800,0.767,801,1.199,802,0.994,803,0.656,804,1.403,805,0.767,806,1.103,807,0.767,808,1.403,809,1.103,810,0.767,811,0.767,812,0.767,813,0.767,814,1.596,815,0.767,816,0.767,817,1.403,818,0.767,819,1.162,820,1.047,821,0.767,822,0.767,823,0.767,824,0.767,825,0.691,826,1.103,827,0.691,828,0.691,829,0.767,830,0.994,831,1.047,832,1.047,833,0.767,834,0.767,835,0.767,836,0.656,837,1.162,838,1.108,839,0.767,840,1.745,841,0.767,842,0.767,843,0.767,844,0.767,845,0.767,846,0.691,847,0.656,848,0.691,849,0.767,850,0.767,851,0.656,852,0.767,853,0.767,854,0.767,855,0.728,856,0.767,857,0.728,858,1.162,859,0.767,860,0.767,861,1.204,862,0.767,863,0.622,864,0.767,865,0.767,866,0.767,867,1.596,868,0.728,869,0.767,870,0.767,871,1.682,872,1.162,873,1.682,874,1.565,875,0.767,876,1.103,877,1.103,878,1.486,879,1.682,880,1.403,881,1.332,882,0.728,883,1.332,884,1.103,885,0.656,886,1.332,887,1.332,888,0.728,889,1.103,890,1.596,891,1.162,892,1.403,893,1.103,894,1.264,895,1.596,896,1.68,897,0.767,898,0.767,899,0.767,900,0.767,901,0.767,902,1.162,903,1.162,904,1.103,905,0.767,906,0.767,907,0.767,908,0.767,909,0.767,910,1.332,911,1.047,912,0.767,913,0.767,914,0.622,915,0.656,916,0.767,917,0.728,918,1.596,919,0.767,920,0.728,921,1.486,922,0.728,923,1.332,924,0.728,925,1.403,926,0.767,927,0.767,928,0.691,929,0.728,930,0.767,931,0.767,932,1.565,933,0.767,934,0.767,935,0.767,936,0.767,937,1.682,938,0.767,939,0.767,940,0.767,941,0.728,942,0.767,943,0.767,944,0.767,945,0.994,946,0.767,947,0.767,948,0.767,949,0.767,950,0.767,951,0.767,952,0.767,953,1.047,954,0.767,955,0.691,956,0.691,957,0.943,958,0.767,959,0.767,960,0.767,961,0.767,962,1.162,963,1.162,964,1.162,965,0.767,966,1.162,967,0.767,968,0.767,969,0.728,970,1.162,971,0.767,972,0.728,973,0.767,974,0.767,975,1.332,976,1.332,977,0.767,978,0.767,979,0.767,980,0.767,981,0.767,982,0.767,983,0.767,984,0.728,985,1.162,986,0.767,987,0.728,988,0.767,989,1.162,990,0.767,991,0.767,992,0.767,993,0.767,994,0.767,995,0.767,996,0.767,997,0.767,998,1.162,999,0.767,1000,0.767,1001,0.767,1002,1.162,1003,1.162,1004,1.162,1005,0.767,1006,0.767,1007,1.403,1008,0.767,1009,1.565,1010,1.894,1011,0.767,1012,0.767,1013,1.162,1014,0.767,1015,0.767,1016,0.767,1017,1.162,1018,0.767,1019,0.767,1020,1.403,1021,0.767,1022,1.162,1023,1.162,1024,1.162,1025,0.767,1026,1.162,1027,0.767,1028,0.767,1029,1.403,1030,1.162,1031,0.767,1032,0.767,1033,0.767,1034,0.767,1035,0.767,1036,0.848,1037,0.622,1038,1.162,1039,0.767,1040,0.767,1041,1.403,1042,0.767,1043,1.515,1044,1.486,1045,0.767,1046,1.103,1047,0.691,1048,0.656,1049,1.162,1050,0.767,1051,0.767,1052,0.767,1053,1.162,1054,1.565,1055,1.162,1056,1.162,1057,0.767,1058,1.264,1059,0.767,1060,1.332,1061,0.767,1062,0.767,1063,1.162,1064,0.767,1065,0.728,1066,1.264,1067,0.767,1068,0.767,1069,0.728,1070,0.767,1071,1.403,1072,0.767,1073,1.486,1074,1.403,1075,0.767,1076,0.767,1077,1.162,1078,1.403,1079,0.767,1080,0.767,1081,0.767,1082,1.162,1083,0.767,1084,0.767,1085,0.767,1086,1.162,1087,0.728,1088,0.767,1089,1.162,1090,0.767,1091,0.767,1092,0.767,1093,0.767,1094,0.691,1095,1.332,1096,0.728,1097,0.691,1098,0.767,1099,0.767,1100,1.162,1101,1.403,1102,0.767,1103,1.162,1104,0.767,1105,0.767,1106,0.767,1107,1.403,1108,0.622,1109,0.767,1110,0.767,1111,0.767,1112,0.622,1113,0.767,1114,0.767,1115,0.767,1116,0.767,1117,0.767,1118,0.728,1119,1.162,1120,1.162,1121,1.162,1122,0.767,1123,1.162,1124,0.994,1125,1.047,1126,0.767,1127,0.767,1128,1.332,1129,0.994,1130,0.767,1131,0.728,1132,0.767,1133,0.767,1134,0.59,1135,0.767,1136,0.767,1137,0.767,1138,1.162,1139,1.162,1140,0.767,1141,0.767,1142,0.767,1143,0.767,1144,0.767,1145,1.103,1146,0.728,1147,1.162,1148,0.767,1149,0.767,1150,0.767,1151,0.767,1152,0.767,1153,0.767,1154,0.767,1155,0.767,1156,0.656,1157,0.767,1158,0.767,1159,1.162,1160,0.767,1161,0.767,1162,0.767,1163,1.162,1164,0.767,1165,0.767,1166,0.728,1167,1.162,1168,0.767,1169,0.656,1170,1.162,1171,1.332,1172,0.767,1173,0.767,1174,1.162,1175,1.162,1176,0.767,1177,0.728,1178,0.994,1179,0.767,1180,1.403,1181,0.767,1182,0.767,1183,0.691,1184,0.767,1185,0.767,1186,0.767,1187,0.767,1188,0.767,1189,1.403]],["title/interfaces/RefreshOptions.html",[0,0.3,50,0.657]],["body/interfaces/RefreshOptions.html",[0,0.579,2,0.29,3,0.126,4,0.094,6,0.144,7,0.267,10,0.021,11,0.783,12,0.634,13,0.532,14,0.569,15,0.643,16,0.503,17,0.379,18,0.577,19,0.92,20,0.643,21,0.876,22,0.643,23,0.4,26,0.804,30,0.4,31,0.776,34,0.681,35,0.561,36,0.57,38,0.424,49,1.083,50,0.822,53,0.357,55,0.57,56,0.764,58,0.015,63,0.531,65,0.929,68,0.505,69,0.349,72,0.47,73,0.913,75,0.837,76,0.841,77,0.531,78,0.72,79,1.06,80,0.685,84,0.064,87,1.174,88,0.731,89,0.606,90,0.606,93,0.67,95,0.808,97,0.731,99,0.476,104,0.762,109,1.261,112,0.762,117,1.108,118,0.476,119,0.876,126,0.804,129,0.783,130,0.502,131,0.476,134,0.416,136,0.929,139,1.163,141,0.925,143,1.01,144,1.101,146,0.731,147,0.676,148,0.947,149,0.772,150,0.405,151,0.476,157,0.768,158,0.45,174,0.986,176,0.816,179,0.633,181,1.175,186,0.47,187,0.837,191,0.693,197,0.476,199,0.731,200,0.57,203,1.024,206,1.191,209,0.531,212,0.97,213,0.804,215,0.503,218,0.531,221,0.804,228,0.762,229,0.561,231,0.84,234,0.531,235,0.561,236,0.531,238,0.531,242,0.424,243,0.45,244,0.676,245,0.531,261,1.042,263,1.101,267,0.147,284,0.667,287,0.633,290,0.567,291,0.531,293,0.531,294,0.531,299,0.561,305,0.971,315,0.917,319,1.046,323,0.349,327,1.036,330,0.893,339,0.476,355,0.531,369,0.97,370,0.29,371,0.762,375,0.72,382,0.561,388,0.726,413,0.561,415,0.843,423,0.847,425,0.561,430,0.804,436,0.72,437,0.919,438,1.01,449,1.042,450,0.941,451,0.531,454,0.947,455,0.531,458,0.503,460,1.072,461,0.72,464,0.681,469,0.822,471,0.889,472,0.971,478,0.849,481,1.342,487,0.997,489,1.024,495,0.016,496,1.415,498,0.895,499,1.205,500,1.163,511,1.139,515,1.604,517,0.804,519,0.531,526,0.503,532,1.536,541,0.591,546,0.944,557,0.45,559,1.139,560,1.205,562,0.591,578,1.309,582,1.024,583,1.139,584,0.561,585,0.623,586,1.201,587,0.762,590,1.457,591,1.394,592,1.024,594,1.657,595,0.971,596,0.804,597,1.159,605,1.436,607,0.503,609,0.995,611,1.228,612,0.657,616,1.487,617,1.105,618,1.487,619,1.411,620,1.487,621,1.105,622,1.048,623,0.73,624,1.439,627,0.73,629,1.487,632,0.692,634,0.692,639,1.143,642,0.623,643,1.34,646,1.204,647,0.849,658,0.971,686,0.73,687,0.692,688,1.487,689,1.706,690,1.048,691,1.333,692,1.339,693,0.657,694,0.73,695,1.105,696,1.487,697,1.487,698,1.487,699,1.405,700,1.096,701,1.164,702,1.105,703,1.405,704,1.333,705,1.516,706,1.84,707,0.692,708,0.692,709,1.201,710,0.769,711,1.164,712,1.265,713,1.658,714,0.692,715,1.139,716,0.769,717,1.514,718,0.769,719,0.73,720,1.048,721,1.492,722,0.769,723,0.769,724,1.164,725,1.411,726,1.487,727,0.769,728,0.769,729,1.048,730,0.944,731,0.692,732,0.944,733,1.365,734,1.339,735,1.081,736,1.362,737,0.657,738,1.439,739,0.692,740,1.339,741,0.657,742,0.692,743,0.657,744,1.048,745,1.597,746,1.164,747,1.487,748,1.164,749,1.567,750,1.333,751,0.73,752,0.995,753,1.164,754,1.365,755,1.339,756,1.048,757,1.411,758,0.769,759,1.657,760,0.769,761,1.265,762,1.201,763,1.201,764,0.769,765,1.333,766,1.164,767,1.405,768,1.516,769,1.139,770,0.769,771,1.048,772,0.769,773,1.048,774,1.164,775,0.73,776,0.73,777,0.769,778,0.769,779,0.73,780,0.769,781,1.164,782,1.105,783,0.769,784,1.339,785,0.769,786,0.769,787,1.164,788,1.164,789,1.405,790,1.048,791,0.692,792,1.798,793,1.164,794,0.995,795,0.769,796,0.769,797,0.769,798,0.769,799,1.164,800,0.769,801,1.201,802,0.995,803,0.657,804,1.405,805,0.769,806,1.105,807,0.769,808,1.405,809,1.105,810,0.769,811,0.769,812,0.769,813,0.769,814,1.597,815,0.769,816,0.769,817,1.405,818,0.769,819,1.164,820,1.048,821,0.769,822,0.769,823,0.769,824,0.769,825,0.692,826,1.105,827,0.692,828,0.692,829,0.769,830,0.995,831,1.048,832,1.048,833,0.769,834,0.769,835,0.769,836,0.657,837,1.164,838,1.108,839,0.769,840,1.746,841,0.769,842,0.769,843,0.769,844,0.769,845,0.769,846,0.692,847,0.657,848,0.692,849,0.769,850,0.769,851,0.657,852,0.769,853,0.769,854,0.769,855,0.73,856,0.769,857,0.73,858,1.164,859,0.769,860,0.769,861,1.205,862,0.769,863,0.623,864,0.769,865,0.769,866,0.769,867,1.597,868,0.73,869,0.769,870,0.769,871,1.683,872,1.164,873,1.683,874,1.567,875,0.769,876,1.105,877,1.105,878,1.487,879,1.683,880,1.405,881,1.333,882,0.73,883,1.333,884,0.73,885,0.657,886,1.333,887,1.333,888,0.73,889,1.105,890,1.597,891,1.164,892,1.405,893,1.105,894,1.265,895,1.597,896,1.681,897,0.769,898,0.769,899,0.769,900,0.769,901,0.769,902,1.164,903,1.164,904,1.597,905,0.769,906,0.769,907,0.769,908,0.769,909,0.769,910,1.333,911,1.048,912,0.769,913,0.769,914,0.623,915,0.657,916,0.769,917,0.73,918,1.597,919,0.769,920,0.73,921,1.487,922,0.73,923,1.333,924,0.73,925,1.405,926,0.769,927,0.769,928,0.692,929,0.73,930,0.769,931,0.769,932,1.567,933,0.769,934,0.769,935,0.769,936,0.769,937,1.683,938,0.769,939,0.769,940,0.769,941,0.73,942,0.769,943,0.769,944,0.769,945,0.995,946,0.769,947,0.769,948,0.769,949,0.769,950,0.769,951,0.769,952,0.769,953,1.048,954,0.769,955,0.692,956,0.692,957,0.944,958,0.769,959,0.769,960,0.769,961,0.769,962,1.164,963,1.164,964,1.164,965,0.769,966,1.164,967,0.769,968,0.769,969,0.73,970,1.164,971,0.769,972,0.73,973,0.769,974,0.769,975,1.333,976,1.333,977,0.769,978,0.769,979,0.769,980,0.769,981,0.769,982,0.769,983,0.769,984,0.73,985,1.164,986,0.769,987,0.73,988,0.769,989,1.164,990,0.769,991,0.769,992,0.769,993,0.769,994,0.769,995,0.769,996,0.769,997,0.769,998,1.164,999,0.769,1000,0.769,1001,0.769,1002,1.164,1003,1.164,1004,1.164,1005,0.769,1006,0.769,1007,1.405,1008,0.769,1009,1.567,1010,1.895,1011,0.769,1012,0.769,1013,1.164,1014,0.769,1015,0.769,1016,0.769,1017,1.164,1018,0.769,1019,0.769,1020,1.405,1021,0.769,1022,1.164,1023,1.164,1024,1.164,1025,0.769,1026,1.164,1027,0.769,1028,0.769,1029,1.405,1030,1.164,1031,0.769,1032,0.769,1033,0.769,1034,0.769,1035,0.769,1036,0.849,1037,0.623,1038,1.164,1039,0.769,1040,0.769,1041,1.405,1042,0.769,1043,1.516,1044,1.487,1045,0.769,1046,1.105,1047,0.692,1048,0.657,1049,1.164,1050,0.769,1051,0.769,1052,0.769,1053,1.164,1054,1.567,1055,1.164,1056,1.164,1057,0.769,1058,1.265,1059,0.769,1060,1.333,1061,0.769,1062,0.769,1063,1.164,1064,0.769,1065,0.73,1066,1.265,1067,0.769,1068,0.769,1069,0.73,1070,0.769,1071,1.405,1072,0.769,1073,1.487,1074,1.405,1075,0.769,1076,0.769,1077,1.164,1078,1.405,1079,0.769,1080,0.769,1081,0.769,1082,1.164,1083,0.769,1084,0.769,1085,0.769,1086,1.164,1087,0.73,1088,0.769,1089,1.164,1090,0.769,1091,0.769,1092,0.769,1093,0.769,1094,0.692,1095,1.333,1096,0.73,1097,0.692,1098,0.769,1099,0.769,1100,1.164,1101,1.405,1102,0.769,1103,1.164,1104,0.769,1105,0.769,1106,0.769,1107,1.405,1108,0.623,1109,0.769,1110,0.769,1111,0.769,1112,0.623,1113,0.769,1114,0.769,1115,0.769,1116,0.769,1117,0.769,1118,0.73,1119,1.164,1120,1.164,1121,1.164,1122,0.769,1123,1.164,1124,0.995,1125,1.048,1126,0.769,1127,0.769,1128,1.333,1129,0.995,1130,0.769,1131,0.73,1132,0.769,1133,0.769,1134,0.591,1135,0.769,1136,0.769,1137,0.769,1138,1.164,1139,1.164,1140,0.769,1141,0.769,1142,0.769,1143,0.769,1144,0.769,1145,1.105,1146,0.73,1147,1.164,1148,0.769,1149,0.769,1150,0.769,1151,0.769,1152,0.769,1153,0.769,1154,0.769,1155,0.769,1156,0.657,1157,0.769,1158,0.769,1159,1.164,1160,0.769,1161,0.769,1162,0.769,1163,1.164,1164,0.769,1165,0.769,1166,0.73,1167,1.164,1168,0.769,1169,0.657,1170,1.164,1171,1.333,1172,0.769,1173,0.769,1174,1.164,1175,1.164,1176,0.769,1177,0.73,1178,0.995,1179,0.769,1180,1.405,1181,0.769,1182,0.769,1183,0.692,1184,0.769,1185,0.769,1186,0.769,1187,0.769,1188,0.769,1189,1.405]],["title/interfaces/RequestError.html",[0,0.3,516,2.315]],["body/interfaces/RequestError.html",[0,0.561,2,0.284,3,0.252,4,0.188,6,0.158,7,0.43,10,0.021,11,0.815,12,0.855,13,0.461,17,0.307,18,0.553,19,0.871,20,0.608,21,1.187,22,1.033,23,1.094,37,2.128,38,1.033,53,0.344,55,0.752,58,0.017,68,0.562,69,0.461,72,0.461,75,0.808,76,0.826,80,0.672,84,0.128,93,0.499,95,0.579,117,0.898,119,1.094,134,0.389,141,0.911,143,0.799,144,0.974,147,0.663,149,0.708,150,0.418,157,0.752,160,2.128,165,2.318,176,0.579,179,0.756,186,0.62,187,0.907,191,0.705,199,0.799,231,0.756,267,0.156,284,0.579,287,0.62,290,0.756,323,0.461,330,0.707,370,0.579,388,0.663,415,0.792,424,2.256,439,2.5,464,1.095,466,2.45,467,2.45,468,2.643,469,1.282,471,0.663,487,0.992,495,0.017,496,1.657,497,3.168,498,1.617,499,1.617,500,1.061,501,2.128,502,3.168,503,2.932,504,3.495,505,4.236,506,3.168,507,3.168,508,3.168,509,3.168,510,3.861,511,1.518,512,4.841,513,3.451,514,3.451,515,1.245,516,4.335,517,1.293,518,4.206,519,1.061,520,2.932,521,3.451,522,3.451,523,3.168,524,3.451,525,3.451,526,1.225,527,3.168,528,3.451,529,3.451,530,3.451,531,3.451,532,1.245,533,3.451,534,3.451,535,2.256,536,3.451,537,4.537,538,4.537,539,4.206,540,3.451,541,1.181,542,3.451,543,3.451,544,3.451,545,3.168,546,1.245,547,3.168,548,3.451,549,4.206,550,3.451,551,3.451,552,3.451,553,3.451,554,3.451,555,3.451,556,3.451,557,0.898,558,3.451,559,1.245,560,1.181,561,4.537,562,1.553,563,3.451,564,4.722,565,4.722,566,3.861,567,3.451,568,3.451,569,3.451,570,4.206,571,3.451,572,3.451,573,3.451,574,3.168,575,3.451,576,3.451,577,3.451,578,1.061]],["title/interfaces/RequestMetadata.html",[0,0.3,1205,2.781]],["body/interfaces/RequestMetadata.html",[0,0.56,2,0.311,3,0.275,4,0.206,6,0.173,7,0.453,10,0.021,11,0.679,14,0.579,17,0.373,18,0.53,19,0.725,20,0.546,30,1.028,31,0.928,36,0.968,49,0.875,53,0.324,55,0.823,56,0.725,58,0.018,68,0.505,69,0.505,72,0.63,73,0.853,76,0.744,84,0.14,88,0.875,89,0.875,101,2.796,130,0.853,134,0.366,141,0.798,149,0.759,191,0.633,267,0.164,290,0.679,323,0.505,370,0.744,450,0.928,454,0.999,474,3.214,495,0.018,535,2.469,592,1.226,601,3.777,602,2.796,607,1.1,700,1.04,838,0.983,1036,1.226,1190,4.165,1191,4.684,1192,6.404,1193,3.21,1199,4.165,1200,6.404,1201,6.404,1203,5.848,1205,5.199,1207,4.684,1208,4.684,1209,4.684,1210,5.506,1211,5.506,1212,4.684,1213,4.684,1214,4.684,1215,4.684,1216,4.684]],["title/interfaces/RequestMetadataCallback.html",[0,0.3,886,1.065]],["body/interfaces/RequestMetadataCallback.html",[0,0.579,2,0.29,3,0.126,4,0.094,6,0.144,7,0.322,8,1.198,9,0.95,10,0.021,11,0.798,12,0.634,13,0.568,14,0.569,15,0.642,16,0.502,17,0.379,18,0.578,19,0.925,20,0.642,21,0.876,22,0.775,23,0.4,26,0.803,30,0.4,31,0.775,34,0.68,35,0.56,36,0.57,38,0.424,49,1.101,50,0.68,53,0.357,55,0.57,56,0.764,58,0.015,63,0.53,65,0.929,68,0.505,69,0.349,72,0.47,73,0.913,75,0.837,76,0.841,77,0.53,78,0.72,79,1.06,80,0.685,84,0.064,87,1.174,88,0.731,89,0.605,90,0.605,93,0.669,95,0.807,97,0.731,99,0.475,104,0.761,109,1.261,112,0.761,117,1.108,118,0.475,119,0.876,126,0.803,129,0.783,130,0.502,131,0.475,134,0.416,136,0.929,139,1.162,141,0.925,143,1.009,144,1.101,146,0.731,147,0.676,148,0.947,149,0.772,150,0.401,151,0.475,157,0.767,158,0.449,174,0.986,176,0.816,179,0.632,181,1.175,186,0.469,187,0.837,191,0.693,197,0.475,199,0.731,200,0.57,203,1.024,206,1.191,209,0.53,212,0.969,213,0.803,215,0.502,218,0.53,221,0.803,228,0.761,229,0.56,231,0.84,234,0.53,235,0.56,236,0.53,238,0.53,242,0.424,243,0.449,244,0.676,245,0.53,261,1.041,263,1.101,267,0.14,284,0.667,287,0.632,290,0.567,291,0.53,293,0.53,294,0.53,299,0.56,305,0.97,315,0.916,319,1.046,323,0.349,327,1.035,330,0.892,339,0.475,355,0.53,369,0.969,370,0.289,371,0.761,375,0.72,382,0.56,388,0.726,413,0.56,415,0.843,423,0.846,425,0.56,430,0.803,436,0.72,437,0.918,438,1.009,449,1.041,450,0.941,451,0.53,454,0.947,455,0.53,458,0.502,460,1.072,461,0.72,464,0.68,469,0.821,471,0.889,472,0.97,478,0.848,481,1.341,487,1.002,489,1.024,495,0.016,496,1.414,498,1.08,499,1.204,500,1.162,511,1.138,515,1.603,517,0.803,519,0.53,526,0.502,532,1.536,541,0.59,546,0.943,557,0.449,559,1.138,560,1.204,562,0.59,578,1.309,582,1.024,583,1.138,584,0.56,585,0.622,586,1.2,587,0.761,590,1.457,591,1.394,592,1.024,594,1.656,595,0.97,596,0.803,597,1.158,605,1.435,607,0.502,609,0.994,611,1.228,612,0.656,616,1.486,617,1.103,618,1.486,619,1.41,620,1.486,621,1.103,622,1.047,623,0.728,624,1.438,627,0.728,629,1.486,632,0.691,634,0.691,639,1.142,642,0.622,643,1.271,646,1.203,647,0.848,658,0.97,686,0.728,687,0.691,688,1.486,689,1.706,690,1.047,691,1.332,692,1.338,693,0.656,694,0.728,695,1.103,696,1.486,697,1.486,698,1.486,699,1.403,700,1.096,701,1.163,702,1.103,703,1.403,704,1.332,705,1.515,706,1.839,707,0.691,708,0.691,709,1.2,710,0.768,711,1.163,712,1.264,713,1.657,714,0.691,715,1.138,716,0.768,717,1.513,718,0.768,719,0.728,720,1.047,721,1.491,722,0.768,723,0.768,724,1.163,725,1.41,726,1.486,727,0.768,728,0.768,729,1.047,730,0.943,731,0.691,732,0.943,733,1.364,734,1.338,735,1.08,736,1.362,737,0.656,738,1.438,739,0.691,740,1.338,741,0.656,742,0.691,743,0.656,744,1.047,745,1.596,746,1.163,747,1.486,748,1.163,749,1.566,750,1.332,751,0.728,752,0.994,753,1.163,754,1.364,755,1.338,756,1.047,757,1.41,758,0.768,759,1.656,760,0.768,761,1.264,762,1.2,763,1.2,764,0.768,765,1.332,766,1.163,767,1.403,768,1.515,769,1.138,770,0.768,771,1.047,772,0.768,773,1.047,774,1.163,775,0.728,776,0.728,777,0.768,778,0.768,779,0.728,780,0.768,781,1.163,782,1.103,783,0.768,784,1.338,785,0.768,786,0.768,787,1.163,788,1.163,789,1.403,790,1.047,791,0.691,792,1.797,793,1.163,794,0.994,795,0.768,796,0.768,797,0.768,798,0.768,799,1.163,800,0.768,801,1.2,802,0.994,803,0.656,804,1.403,805,0.768,806,1.103,807,0.768,808,1.403,809,1.103,810,0.768,811,0.768,812,0.768,813,0.768,814,1.596,815,0.768,816,0.768,817,1.403,818,0.768,819,1.163,820,1.047,821,0.768,822,0.768,823,0.768,824,0.768,825,0.691,826,1.103,827,0.691,828,0.691,829,0.768,830,0.994,831,1.047,832,1.047,833,0.768,834,0.768,835,0.768,836,0.656,837,1.163,838,1.108,839,0.768,840,1.745,841,0.768,842,0.768,843,0.768,844,0.768,845,0.768,846,0.691,847,0.656,848,0.691,849,0.768,850,0.768,851,0.656,852,0.768,853,0.768,854,0.768,855,0.728,856,0.768,857,0.728,858,1.163,859,0.768,860,0.768,861,1.204,862,0.768,863,0.622,864,0.768,865,0.768,866,0.768,867,1.596,868,0.728,869,0.768,870,0.768,871,1.682,872,1.163,873,1.682,874,1.566,875,0.768,876,1.103,877,1.103,878,1.486,879,1.682,880,1.403,881,1.332,882,0.728,883,1.332,884,0.728,885,0.656,886,1.486,887,1.332,888,0.728,889,1.103,890,1.596,891,1.163,892,1.403,893,1.103,894,1.264,895,1.596,896,1.68,897,0.768,898,0.768,899,0.768,900,0.768,901,0.768,902,1.163,903,1.163,904,1.103,905,0.768,906,0.768,907,0.768,908,0.768,909,0.768,910,1.332,911,1.047,912,0.768,913,0.768,914,0.622,915,0.656,916,0.768,917,0.728,918,1.596,919,0.768,920,0.728,921,1.486,922,0.728,923,1.332,924,0.728,925,1.403,926,0.768,927,0.768,928,0.691,929,0.728,930,0.768,931,0.768,932,1.566,933,0.768,934,0.768,935,0.768,936,0.768,937,1.682,938,0.768,939,0.768,940,0.768,941,0.728,942,0.768,943,0.768,944,0.768,945,0.994,946,0.768,947,0.768,948,0.768,949,0.768,950,0.768,951,0.768,952,0.768,953,1.047,954,0.768,955,0.691,956,0.691,957,0.943,958,0.768,959,0.768,960,0.768,961,0.768,962,1.163,963,1.163,964,1.163,965,0.768,966,1.163,967,0.768,968,0.768,969,0.728,970,1.163,971,0.768,972,0.728,973,0.768,974,0.768,975,1.332,976,1.332,977,0.768,978,0.768,979,0.768,980,0.768,981,0.768,982,0.768,983,0.768,984,0.728,985,1.163,986,0.768,987,0.728,988,0.768,989,1.163,990,0.768,991,0.768,992,0.768,993,0.768,994,0.768,995,0.768,996,0.768,997,0.768,998,1.163,999,0.768,1000,0.768,1001,0.768,1002,1.163,1003,1.163,1004,1.163,1005,0.768,1006,0.768,1007,1.403,1008,0.768,1009,1.566,1010,1.894,1011,0.768,1012,0.768,1013,1.163,1014,0.768,1015,0.768,1016,0.768,1017,1.163,1018,0.768,1019,0.768,1020,1.403,1021,0.768,1022,1.163,1023,1.163,1024,1.163,1025,0.768,1026,1.163,1027,0.768,1028,0.768,1029,1.403,1030,1.163,1031,0.768,1032,0.768,1033,0.768,1034,0.768,1035,0.768,1036,0.848,1037,0.622,1038,1.163,1039,0.768,1040,0.768,1041,1.403,1042,0.768,1043,1.515,1044,1.486,1045,0.768,1046,1.103,1047,0.691,1048,0.656,1049,1.163,1050,0.768,1051,0.768,1052,0.768,1053,1.163,1054,1.566,1055,1.163,1056,1.163,1057,0.768,1058,1.264,1059,0.768,1060,1.332,1061,0.768,1062,0.768,1063,1.163,1064,0.768,1065,0.728,1066,1.264,1067,0.768,1068,0.768,1069,0.728,1070,0.768,1071,1.403,1072,0.768,1073,1.486,1074,1.403,1075,0.768,1076,0.768,1077,1.163,1078,1.403,1079,0.768,1080,0.768,1081,0.768,1082,1.163,1083,0.768,1084,0.768,1085,0.768,1086,1.163,1087,0.728,1088,0.768,1089,1.163,1090,0.768,1091,0.768,1092,0.768,1093,0.768,1094,0.691,1095,1.332,1096,0.728,1097,0.691,1098,0.768,1099,0.768,1100,1.163,1101,1.403,1102,0.768,1103,1.163,1104,0.768,1105,0.768,1106,0.768,1107,1.403,1108,0.622,1109,0.768,1110,0.768,1111,0.768,1112,0.622,1113,0.768,1114,0.768,1115,0.768,1116,0.768,1117,0.768,1118,0.728,1119,1.163,1120,1.163,1121,1.163,1122,0.768,1123,1.163,1124,0.994,1125,1.047,1126,0.768,1127,0.768,1128,1.332,1129,0.994,1130,0.768,1131,0.728,1132,0.768,1133,0.768,1134,0.59,1135,0.768,1136,0.768,1137,0.768,1138,1.163,1139,1.163,1140,0.768,1141,0.768,1142,0.768,1143,0.768,1144,0.768,1145,1.103,1146,0.728,1147,1.163,1148,0.768,1149,0.768,1150,0.768,1151,0.768,1152,0.768,1153,0.768,1154,0.768,1155,0.768,1156,0.656,1157,0.768,1158,0.768,1159,1.163,1160,0.768,1161,0.768,1162,0.768,1163,1.163,1164,0.768,1165,0.768,1166,0.728,1167,1.163,1168,0.768,1169,0.656,1170,1.163,1171,1.332,1172,0.768,1173,0.768,1174,1.163,1175,1.163,1176,0.768,1177,0.728,1178,0.994,1179,0.768,1180,1.403,1181,0.768,1182,0.768,1183,0.691,1184,0.768,1185,0.768,1186,0.768,1187,0.768,1188,0.768,1189,1.403]],["title/interfaces/RequestMetadataResponse.html",[0,0.3,885,0.959]],["body/interfaces/RequestMetadataResponse.html",[0,0.578,2,0.29,3,0.126,4,0.094,6,0.144,7,0.267,10,0.021,11,0.783,12,0.634,13,0.568,14,0.568,15,0.642,16,0.502,17,0.379,18,0.577,19,0.919,20,0.642,21,0.875,22,0.864,23,0.399,26,0.803,30,0.399,31,0.775,34,0.68,35,0.559,36,0.569,38,0.424,49,1.122,50,0.68,53,0.357,55,0.569,56,0.764,58,0.015,63,0.53,65,0.929,68,0.505,69,0.349,72,0.47,73,0.913,75,0.837,76,0.841,77,0.53,78,0.719,79,1.06,80,0.685,84,0.064,87,1.174,88,0.73,89,0.605,90,0.605,93,0.669,95,0.807,97,0.73,99,0.475,104,0.76,109,1.261,112,0.76,117,1.108,118,0.475,119,0.875,126,0.803,129,0.783,130,0.502,131,0.475,134,0.416,136,0.929,139,1.162,141,0.925,143,1.009,144,1.101,146,0.73,147,0.675,148,0.947,149,0.772,150,0.405,151,0.475,157,0.767,158,0.449,174,0.986,176,0.816,179,0.632,181,1.175,186,0.469,187,0.837,191,0.693,197,0.475,199,0.73,200,0.569,203,1.023,206,1.191,209,0.53,212,0.969,213,0.803,215,0.502,218,0.53,221,0.803,228,0.76,229,0.559,231,0.84,234,0.53,235,0.559,236,0.53,238,0.53,242,0.424,243,0.449,244,0.675,245,0.53,261,1.041,263,1.1,267,0.153,284,0.667,287,0.632,290,0.566,291,0.53,293,0.53,294,0.53,299,0.559,305,0.969,315,0.916,319,1.045,323,0.349,327,1.035,330,0.892,339,0.475,355,0.53,369,0.969,370,0.289,371,0.76,375,0.719,382,0.559,388,0.726,413,0.559,415,0.843,423,0.846,425,0.559,430,0.803,436,0.719,437,0.918,438,1.009,449,1.041,450,0.941,451,0.53,454,0.947,455,0.53,458,0.502,460,1.072,461,0.719,464,0.68,469,0.821,471,0.889,472,0.969,478,0.848,481,1.341,487,1.01,489,1.023,495,0.016,496,1.414,498,0.894,499,1.204,500,1.162,511,1.138,515,1.603,517,0.803,519,0.53,526,0.502,532,1.535,541,0.59,546,0.942,557,0.449,559,1.138,560,1.204,562,0.59,578,1.308,582,1.023,583,1.138,584,0.559,585,0.622,586,1.199,587,0.76,590,1.456,591,1.394,592,1.023,594,1.656,595,0.969,596,0.803,597,1.158,605,1.435,607,0.502,609,0.993,611,1.228,612,0.656,616,1.485,617,1.103,618,1.485,619,1.41,620,1.485,621,1.103,622,1.047,623,0.728,624,1.437,627,0.728,629,1.485,632,0.691,634,0.691,639,1.141,642,0.622,643,1.27,646,1.203,647,0.848,658,0.969,686,0.728,687,0.691,688,1.485,689,1.705,690,1.047,691,1.331,692,1.338,693,0.656,694,0.728,695,1.103,696,1.485,697,1.485,698,1.485,699,1.403,700,1.095,701,1.162,702,1.103,703,1.403,704,1.331,705,1.515,706,1.838,707,0.691,708,0.691,709,1.199,710,0.767,711,1.162,712,1.264,713,1.657,714,0.691,715,1.138,716,0.767,717,1.513,718,0.767,719,0.728,720,1.047,721,1.491,722,0.767,723,0.767,724,1.162,725,1.41,726,1.485,727,0.767,728,0.767,729,1.047,730,0.942,731,0.691,732,0.942,733,1.364,734,1.338,735,1.079,736,1.361,737,0.656,738,1.437,739,0.691,740,1.338,741,0.656,742,0.691,743,0.656,744,1.047,745,1.596,746,1.162,747,1.485,748,1.162,749,1.565,750,1.331,751,0.728,752,0.993,753,1.162,754,1.364,755,1.338,756,1.047,757,1.41,758,0.767,759,1.656,760,0.767,761,1.264,762,1.199,763,1.199,764,0.767,765,1.331,766,1.162,767,1.403,768,1.515,769,1.138,770,0.767,771,1.047,772,0.767,773,1.047,774,1.162,775,0.728,776,0.728,777,0.767,778,0.767,779,0.728,780,0.767,781,1.162,782,1.103,783,0.767,784,1.338,785,0.767,786,0.767,787,1.162,788,1.162,789,1.403,790,1.047,791,0.691,792,1.797,793,1.162,794,0.993,795,0.767,796,0.767,797,0.767,798,0.767,799,1.162,800,0.767,801,1.199,802,0.993,803,0.656,804,1.403,805,0.767,806,1.103,807,0.767,808,1.403,809,1.103,810,0.767,811,0.767,812,0.767,813,0.767,814,1.596,815,0.767,816,0.767,817,1.403,818,0.767,819,1.162,820,1.047,821,0.767,822,0.767,823,0.767,824,0.767,825,0.691,826,1.103,827,0.691,828,0.691,829,0.767,830,0.993,831,1.047,832,1.047,833,0.767,834,0.767,835,0.767,836,0.656,837,1.162,838,1.108,839,0.767,840,1.744,841,0.767,842,0.767,843,0.767,844,0.767,845,0.767,846,0.691,847,0.656,848,0.691,849,0.767,850,0.767,851,0.656,852,0.767,853,0.767,854,0.767,855,0.728,856,0.767,857,0.728,858,1.162,859,0.767,860,0.767,861,1.204,862,0.767,863,0.622,864,0.767,865,0.767,866,0.767,867,1.596,868,0.728,869,0.767,870,0.767,871,1.682,872,1.162,873,1.682,874,1.565,875,0.767,876,1.103,877,1.103,878,1.485,879,1.682,880,1.403,881,1.331,882,0.728,883,1.331,884,0.728,885,0.993,886,1.331,887,1.331,888,0.728,889,1.103,890,1.596,891,1.162,892,1.403,893,1.103,894,1.264,895,1.596,896,1.679,897,0.767,898,0.767,899,0.767,900,0.767,901,0.767,902,1.162,903,1.162,904,1.103,905,0.767,906,0.767,907,0.767,908,0.767,909,0.767,910,1.331,911,1.047,912,0.767,913,0.767,914,0.622,915,0.656,916,0.767,917,0.728,918,1.596,919,0.767,920,0.728,921,1.485,922,0.728,923,1.331,924,0.728,925,1.403,926,0.767,927,0.767,928,0.691,929,0.728,930,0.767,931,0.767,932,1.565,933,0.767,934,0.767,935,0.767,936,0.767,937,1.682,938,0.767,939,0.767,940,0.767,941,0.728,942,0.767,943,0.767,944,0.767,945,0.993,946,0.767,947,0.767,948,0.767,949,0.767,950,0.767,951,0.767,952,0.767,953,1.047,954,0.767,955,0.691,956,0.691,957,0.942,958,0.767,959,0.767,960,0.767,961,0.767,962,1.162,963,1.162,964,1.162,965,0.767,966,1.162,967,0.767,968,0.767,969,0.728,970,1.162,971,0.767,972,0.728,973,0.767,974,0.767,975,1.331,976,1.331,977,0.767,978,0.767,979,0.767,980,0.767,981,0.767,982,0.767,983,0.767,984,0.728,985,1.162,986,0.767,987,0.728,988,0.767,989,1.162,990,0.767,991,0.767,992,0.767,993,0.767,994,0.767,995,0.767,996,0.767,997,0.767,998,1.162,999,0.767,1000,0.767,1001,0.767,1002,1.162,1003,1.162,1004,1.162,1005,0.767,1006,0.767,1007,1.403,1008,0.767,1009,1.565,1010,1.893,1011,0.767,1012,0.767,1013,1.162,1014,0.767,1015,0.767,1016,0.767,1017,1.162,1018,0.767,1019,0.767,1020,1.403,1021,0.767,1022,1.162,1023,1.162,1024,1.162,1025,0.767,1026,1.162,1027,0.767,1028,0.767,1029,1.403,1030,1.162,1031,0.767,1032,0.767,1033,0.767,1034,0.767,1035,0.767,1036,0.848,1037,0.622,1038,1.162,1039,0.767,1040,0.767,1041,1.403,1042,0.767,1043,1.515,1044,1.485,1045,0.767,1046,1.103,1047,0.691,1048,0.656,1049,1.162,1050,0.767,1051,0.767,1052,0.767,1053,1.162,1054,1.565,1055,1.162,1056,1.162,1057,0.767,1058,1.264,1059,0.767,1060,1.331,1061,0.767,1062,0.767,1063,1.162,1064,0.767,1065,0.728,1066,1.264,1067,0.767,1068,0.767,1069,0.728,1070,0.767,1071,1.403,1072,0.767,1073,1.485,1074,1.403,1075,0.767,1076,0.767,1077,1.162,1078,1.403,1079,0.767,1080,0.767,1081,0.767,1082,1.162,1083,0.767,1084,0.767,1085,0.767,1086,1.162,1087,0.728,1088,0.767,1089,1.162,1090,0.767,1091,0.767,1092,0.767,1093,0.767,1094,0.691,1095,1.331,1096,0.728,1097,0.691,1098,0.767,1099,0.767,1100,1.162,1101,1.403,1102,0.767,1103,1.162,1104,0.767,1105,0.767,1106,0.767,1107,1.403,1108,0.622,1109,0.767,1110,0.767,1111,0.767,1112,0.622,1113,0.767,1114,0.767,1115,0.767,1116,0.767,1117,0.767,1118,0.728,1119,1.162,1120,1.162,1121,1.162,1122,0.767,1123,1.162,1124,0.993,1125,1.047,1126,0.767,1127,0.767,1128,1.331,1129,0.993,1130,0.767,1131,0.728,1132,0.767,1133,0.767,1134,0.59,1135,0.767,1136,0.767,1137,0.767,1138,1.162,1139,1.162,1140,0.767,1141,0.767,1142,0.767,1143,0.767,1144,0.767,1145,1.103,1146,0.728,1147,1.162,1148,0.767,1149,0.767,1150,0.767,1151,0.767,1152,0.767,1153,0.767,1154,0.767,1155,0.767,1156,0.656,1157,0.767,1158,0.767,1159,1.162,1160,0.767,1161,0.767,1162,0.767,1163,1.162,1164,0.767,1165,0.767,1166,0.728,1167,1.162,1168,0.767,1169,0.656,1170,1.162,1171,1.331,1172,0.767,1173,0.767,1174,1.162,1175,1.162,1176,0.767,1177,0.728,1178,0.993,1179,0.767,1180,1.403,1181,0.767,1182,0.767,1183,0.691,1184,0.767,1185,0.767,1186,0.767,1187,0.767,1188,0.767,1189,1.403]],["title/interfaces/RevokeCredentialsResult.html",[0,0.3,888,1.065]],["body/interfaces/RevokeCredentialsResult.html",[0,0.579,2,0.29,3,0.126,4,0.094,6,0.144,7,0.267,10,0.021,11,0.783,12,0.634,13,0.532,14,0.569,15,0.643,16,0.503,17,0.38,18,0.577,19,0.92,20,0.643,21,0.876,22,0.643,23,0.4,26,0.805,30,0.4,31,0.776,34,0.681,35,0.561,36,0.57,38,0.425,49,1.083,50,0.681,53,0.357,55,0.57,56,0.764,58,0.015,63,0.531,65,0.93,68,0.505,69,0.349,72,0.47,73,0.913,75,0.837,76,0.841,77,0.531,78,0.721,79,1.06,80,0.685,84,0.064,87,1.174,88,0.731,89,0.606,90,0.606,93,0.67,95,0.808,97,0.876,99,0.476,104,0.762,109,1.261,112,0.762,117,1.108,118,0.476,119,0.876,126,0.805,129,0.783,130,0.502,131,0.476,134,0.416,136,0.93,139,1.163,141,0.925,143,1.01,144,1.101,146,0.731,147,0.676,148,0.947,149,0.772,150,0.401,151,0.476,157,0.768,158,0.45,174,0.986,176,0.816,179,0.633,181,1.175,186,0.47,187,0.837,191,0.693,197,0.476,199,0.731,200,0.57,203,1.025,206,1.191,209,0.531,212,0.97,213,0.805,215,0.503,218,0.531,221,0.805,228,0.762,229,0.561,231,0.84,234,0.531,235,0.561,236,0.531,238,0.531,242,0.425,243,0.45,244,0.676,245,0.531,261,1.042,263,1.102,267,0.147,284,0.667,287,0.633,290,0.567,291,0.531,293,0.531,294,0.531,299,0.561,305,0.971,315,0.917,319,1.046,323,0.349,327,1.036,330,0.893,339,0.476,355,0.531,369,0.97,370,0.29,371,0.762,375,0.721,382,0.561,388,0.727,413,0.561,415,0.843,423,0.847,425,0.561,430,0.805,436,0.721,437,0.919,438,1.01,449,1.042,450,0.941,451,0.531,454,0.947,455,0.531,458,0.503,460,1.073,461,0.721,464,0.681,469,0.822,471,0.889,472,0.971,478,0.849,481,1.342,487,0.997,489,1.025,495,0.016,496,1.415,498,0.896,499,1.205,500,1.163,511,1.139,515,1.604,517,0.805,519,0.531,526,0.503,532,1.537,541,0.592,546,0.944,557,0.45,559,1.139,560,1.205,562,0.592,578,1.309,582,1.025,583,1.139,584,0.561,585,0.624,586,1.201,587,0.762,590,1.458,591,1.394,592,1.025,594,1.657,595,0.971,596,0.805,597,1.159,605,1.437,607,0.503,609,0.995,611,1.228,612,0.657,616,1.487,617,1.105,618,1.487,619,1.411,620,1.487,621,1.105,622,1.049,623,0.73,624,1.439,627,0.73,629,1.487,632,0.693,634,0.693,639,1.143,642,0.624,643,1.271,646,1.204,647,0.849,658,0.971,686,0.73,687,0.693,688,1.487,689,1.707,690,1.049,691,1.333,692,1.339,693,0.657,694,0.73,695,1.105,696,1.487,697,1.487,698,1.487,699,1.405,700,1.096,701,1.164,702,1.105,703,1.405,704,1.333,705,1.516,706,1.84,707,0.693,708,0.693,709,1.201,710,0.769,711,1.164,712,1.265,713,1.658,714,0.693,715,1.139,716,0.769,717,1.514,718,0.769,719,0.73,720,1.049,721,1.492,722,0.769,723,0.769,724,1.164,725,1.411,726,1.487,727,0.769,728,0.769,729,1.049,730,0.944,731,0.693,732,0.944,733,1.365,734,1.339,735,1.081,736,1.363,737,0.657,738,1.439,739,0.693,740,1.339,741,0.657,742,0.693,743,0.657,744,1.049,745,1.598,746,1.164,747,1.487,748,1.164,749,1.567,750,1.333,751,0.73,752,0.995,753,1.164,754,1.365,755,1.339,756,1.049,757,1.411,758,0.769,759,1.657,760,0.769,761,1.265,762,1.201,763,1.201,764,0.769,765,1.333,766,1.164,767,1.405,768,1.516,769,1.139,770,0.769,771,1.049,772,0.769,773,1.049,774,1.164,775,0.73,776,0.73,777,0.769,778,0.769,779,0.73,780,0.769,781,1.164,782,1.105,783,0.769,784,1.339,785,0.769,786,0.769,787,1.164,788,1.164,789,1.405,790,1.049,791,0.693,792,1.798,793,1.164,794,0.995,795,0.769,796,0.769,797,0.769,798,0.769,799,1.164,800,0.769,801,1.201,802,0.995,803,0.657,804,1.405,805,0.769,806,1.105,807,0.769,808,1.405,809,1.105,810,0.769,811,0.769,812,0.769,813,0.769,814,1.598,815,0.769,816,0.769,817,1.405,818,0.769,819,1.164,820,1.049,821,0.769,822,0.769,823,0.769,824,0.769,825,0.693,826,1.105,827,0.693,828,0.693,829,0.769,830,0.995,831,1.049,832,1.049,833,0.769,834,0.769,835,0.769,836,0.657,837,1.164,838,1.108,839,0.769,840,1.746,841,0.769,842,0.769,843,0.769,844,0.769,845,0.769,846,0.693,847,0.657,848,0.693,849,0.769,850,0.769,851,0.657,852,0.769,853,0.769,854,0.769,855,0.73,856,0.769,857,0.73,858,1.164,859,0.769,860,0.769,861,1.205,862,0.769,863,0.624,864,0.769,865,0.769,866,0.769,867,1.598,868,0.73,869,0.769,870,0.769,871,1.684,872,1.164,873,1.684,874,1.567,875,0.769,876,1.105,877,1.105,878,1.487,879,1.684,880,1.405,881,1.333,882,0.73,883,1.333,884,0.73,885,0.657,886,1.333,887,1.333,888,1.105,889,1.598,890,1.598,891,1.164,892,1.405,893,1.105,894,1.265,895,1.598,896,1.681,897,0.769,898,0.769,899,0.769,900,0.769,901,0.769,902,1.164,903,1.164,904,1.105,905,0.769,906,0.769,907,0.769,908,0.769,909,0.769,910,1.333,911,1.049,912,0.769,913,0.769,914,0.624,915,0.657,916,0.769,917,0.73,918,1.598,919,0.769,920,0.73,921,1.487,922,0.73,923,1.333,924,0.73,925,1.405,926,0.769,927,0.769,928,0.693,929,0.73,930,0.769,931,0.769,932,1.567,933,0.769,934,0.769,935,0.769,936,0.769,937,1.684,938,0.769,939,0.769,940,0.769,941,0.73,942,0.769,943,0.769,944,0.769,945,0.995,946,0.769,947,0.769,948,0.769,949,0.769,950,0.769,951,0.769,952,0.769,953,1.049,954,0.769,955,0.693,956,0.693,957,0.944,958,0.769,959,0.769,960,0.769,961,0.769,962,1.164,963,1.164,964,1.164,965,0.769,966,1.164,967,0.769,968,0.769,969,0.73,970,1.164,971,0.769,972,0.73,973,0.769,974,0.769,975,1.333,976,1.333,977,0.769,978,0.769,979,0.769,980,0.769,981,0.769,982,0.769,983,0.769,984,0.73,985,1.164,986,0.769,987,0.73,988,0.769,989,1.164,990,0.769,991,0.769,992,0.769,993,0.769,994,0.769,995,0.769,996,0.769,997,0.769,998,1.164,999,0.769,1000,0.769,1001,0.769,1002,1.164,1003,1.164,1004,1.164,1005,0.769,1006,0.769,1007,1.405,1008,0.769,1009,1.567,1010,1.895,1011,0.769,1012,0.769,1013,1.164,1014,0.769,1015,0.769,1016,0.769,1017,1.164,1018,0.769,1019,0.769,1020,1.405,1021,0.769,1022,1.164,1023,1.164,1024,1.164,1025,0.769,1026,1.164,1027,0.769,1028,0.769,1029,1.405,1030,1.164,1031,0.769,1032,0.769,1033,0.769,1034,0.769,1035,0.769,1036,0.849,1037,0.624,1038,1.164,1039,0.769,1040,0.769,1041,1.405,1042,0.769,1043,1.516,1044,1.487,1045,0.769,1046,1.105,1047,0.693,1048,0.657,1049,1.164,1050,0.769,1051,0.769,1052,0.769,1053,1.164,1054,1.567,1055,1.164,1056,1.164,1057,0.769,1058,1.265,1059,0.769,1060,1.333,1061,0.769,1062,0.769,1063,1.164,1064,0.769,1065,0.73,1066,1.265,1067,0.769,1068,0.769,1069,0.73,1070,0.769,1071,1.405,1072,0.769,1073,1.487,1074,1.405,1075,0.769,1076,0.769,1077,1.164,1078,1.405,1079,0.769,1080,0.769,1081,0.769,1082,1.164,1083,0.769,1084,0.769,1085,0.769,1086,1.164,1087,0.73,1088,0.769,1089,1.164,1090,0.769,1091,0.769,1092,0.769,1093,0.769,1094,0.693,1095,1.333,1096,0.73,1097,0.693,1098,0.769,1099,0.769,1100,1.164,1101,1.405,1102,0.769,1103,1.164,1104,0.769,1105,0.769,1106,0.769,1107,1.405,1108,0.624,1109,0.769,1110,0.769,1111,0.769,1112,0.624,1113,0.769,1114,0.769,1115,0.769,1116,0.769,1117,0.769,1118,0.73,1119,1.164,1120,1.164,1121,1.164,1122,0.769,1123,1.164,1124,0.995,1125,1.049,1126,0.769,1127,0.769,1128,1.333,1129,0.995,1130,0.769,1131,0.73,1132,0.769,1133,0.769,1134,0.592,1135,0.769,1136,0.769,1137,0.769,1138,1.164,1139,1.164,1140,0.769,1141,0.769,1142,0.769,1143,0.769,1144,0.769,1145,1.105,1146,0.73,1147,1.164,1148,0.769,1149,0.769,1150,0.769,1151,0.769,1152,0.769,1153,0.769,1154,0.769,1155,0.769,1156,0.657,1157,0.769,1158,0.769,1159,1.164,1160,0.769,1161,0.769,1162,0.769,1163,1.164,1164,0.769,1165,0.769,1166,0.73,1167,1.164,1168,0.769,1169,0.657,1170,1.164,1171,1.333,1172,0.769,1173,0.769,1174,1.164,1175,1.164,1176,0.769,1177,0.73,1178,0.995,1179,0.769,1180,1.405,1181,0.769,1182,0.769,1183,0.693,1184,0.769,1185,0.769,1186,0.769,1187,0.769,1188,0.769,1189,1.405]],["title/interfaces/SignBlobResponse.html",[0,0.3,494,1.996]],["body/interfaces/SignBlobResponse.html",[0,0.52,1,3.035,2,0.17,3,0.15,4,0.278,5,1.63,6,0.094,7,0.416,9,2.114,10,0.021,11,0.873,12,0.809,13,0.634,14,0.638,15,1.075,16,1.432,17,0.366,18,0.59,19,0.911,20,0.718,21,0.69,22,0.506,23,0.811,24,2.532,25,1.75,26,0.916,27,2.532,28,1.63,29,1.431,30,0.983,31,1,32,2.974,33,3.353,34,1.166,35,0.967,36,0.887,37,2.365,38,0.943,39,2.371,40,2.532,41,2.371,42,1.555,43,1.524,44,2.77,45,1.75,46,2.419,47,1.524,48,1.75,49,1.038,50,1.247,51,2.205,52,1.75,53,0.333,54,3.22,55,0.887,56,0.782,57,3.035,58,0.014,59,2.532,60,2.357,61,2.77,62,3.102,63,0.916,64,2.532,65,1.075,66,2.532,67,1.63,68,0.567,69,0.567,70,2.411,71,1.929,72,0.275,73,0.672,74,1.75,75,0.944,76,0.765,77,0.916,78,1.307,79,1.109,80,0.684,81,2.357,82,1.63,83,1.63,84,0.11,85,1.63,86,2.591,87,0.69,88,0.477,89,0.943,90,0.889,91,2.532,92,3.012,93,0.589,94,2.591,95,0.857,96,1.75,97,0.69,98,2.357,99,0.821,100,1.75,101,1.524,102,1.75,103,1.75,104,0.6,105,1.75,106,3.605,107,3.259,108,1.75,109,1.32,110,1.75,111,1.63,112,0.6,113,1.75,114,1.75,115,1.75,116,1.75,117,0.776,118,0.567,119,1.013,120,2.974,121,1.75,122,3.259,123,1.75,124,1.63,125,3.357,126,0.633,127,3.605,128,1.75,129,0.535,130,0.396,131,0.567,132,1.524,133,1.27,134,0.376,135,2.205,136,0.506,137,1.431,138,2.532,139,1.076,140,1.75,141,0.918,142,2.532,143,0.811,144,1.057,145,2.974,146,1.013,147,0.911,148,0.782,149,0.753,150,0.426,151,1.257,152,2.288,153,2.532,154,1.75,155,1.75,156,2.532,157,0.763,158,0.536,159,1.75,160,2.858,161,1.75,162,1.75,163,1.75,164,1.75,165,2.243,166,2.77,167,2.661,168,2.432,169,2.974,170,2.827,171,2.532,172,2.205,173,3.458,174,0.943,175,2.974,176,0.824,177,1.75,178,2.158,179,0.844,180,1.75,181,1.328,182,1.75,183,1.75,184,1.75,185,2.532,186,0.805,187,0.815,188,1.63,189,2.114,190,1.63,191,0.682,192,2.532,193,1.75,194,2.532,195,3.807,196,1.75,197,0.821,198,1.75,199,0.69,200,0.763,201,1.75,202,2.532,203,0.668,204,2.532,205,1.75,206,1.265,207,1.75,208,1.75,209,0.633,210,3.989,211,1.75,212,0.964,213,1.378,214,2.357,215,0.6,216,4.069,217,1.75,218,0.633,219,1.524,220,2.532,221,1.076,222,2.532,223,3.259,224,2.357,225,2.77,226,2.974,227,1.75,228,1.235,229,0.668,230,2.532,231,0.867,232,1.75,233,1.63,234,0.633,235,0.668,236,0.633,237,1.75,238,1.076,239,3.545,240,1.75,241,1.75,242,0.506,243,0.536,244,0.396,245,0.633,246,1.63,247,1.75,248,1.75,249,1.75,250,1.75,251,2.77,252,1.75,253,2.974,254,1.75,255,1.75,256,3.035,257,1.75,258,2.974,259,1.75,260,3.357,261,0.567,262,1.75,263,0.868,264,1.75,265,1.346,266,1.63,267,0.11,268,1.75,269,2.357,270,1.75,271,1.75,272,1.75,273,2.532,274,1.75,275,1.75,276,1.524,277,1.75,278,1.75,279,2.532,280,1.75,281,1.75,282,1.75,283,1.75,284,0.82,285,1.75,286,1.75,287,0.805,288,3.807,289,1.75,290,0.689,291,0.916,292,1.75,293,0.633,294,0.633,295,1.75,296,1.63,297,1.75,298,1.75,299,0.668,300,1.75,301,1.75,302,1.75,303,1.75,304,3.039,305,0.633,306,1.63,307,1.75,308,1.75,309,1.75,310,1.75,311,1.75,312,1.524,313,1.75,314,1.75,315,0.536,316,1.346,317,1.524,318,1.27,319,0.506,320,1.75,321,1.75,322,1.75,323,0.544,324,2.288,325,2.665,326,1.75,327,1.207,328,1.431,329,1.75,330,0.61,331,1.63,332,1.63,333,1.75,334,1.75,335,2.532,336,1.75,337,2.827,338,2.432,339,1.169,340,2.205,341,1.75,342,2.07,343,1.75,344,1.75,345,1.346,346,1.431,347,1.431,348,1.431,349,2.07,350,1.431,351,1.431,352,1.431,353,1.75,354,1.524,355,0.633,356,1.63,357,1.75,358,2.77,359,2.532,360,2.07,361,1.75,362,2.532,363,1.75,364,1.75,365,1.524,366,1.75,367,1.75,368,1.75,369,0.821,370,0.345,371,1.185,372,3.458,373,1.75,374,2.532,375,0.964,376,1.524,377,1.75,378,1.75,379,1.75,380,1.75,381,1.524,382,0.668,383,1.63,384,1.75,385,2.532,386,1.75,387,1.75,388,0.572,389,1.75,390,2.974,391,1.75,392,1.75,393,1.75,394,1.75,395,1.63,396,1.63,397,1.75,398,1.75,399,2.532,400,1.75,401,1.75,402,2.07,403,1.75,404,1.75,405,1.75,406,1.75,407,1.75,408,1.75,409,1.75,410,1.75,411,1.75,412,1.75,413,0.967,414,3.035,415,0.345,416,2.205,417,1.75,418,1.75,419,1.75,420,1.75,421,1.75,422,1.75,423,0.717,424,1.346,425,0.668,426,1.346,427,1.63,428,1.75,429,1.75,430,0.633,431,1.75,432,1.75,433,1.75,434,2.532,435,1.75,436,0.964,437,0.6,438,0.69,439,1.135,440,1.75,441,1.75,442,1.75,443,1.75,444,1.75,445,1.75,446,1.75,447,1.75,448,1.75,449,0.422,450,0.37,451,0.633,452,3.458,453,1.75,454,0.396,455,0.633,456,2.532,457,2.357,458,0.6,459,1.75,460,0.811,461,0.567,462,1.75,463,1.75,464,0.536,465,1.75,466,1.2,467,1.2,468,1.2,469,0.536,470,1.75,471,0.396,472,1.305,473,1.63,474,1.27,475,1.75,476,1.75,477,1.75,478,0.668,479,1.75,480,1.75,481,0.668,482,2.532,483,1.524,484,1.75,485,1.75,486,1.75,487,0.422,488,1.75,489,0.668,490,1.75,491,1.75,492,1.75,493,1.75,494,2.357,495,0.012]],["title/interfaces/TokenInfo.html",[0,0.3,707,1.011]],["body/interfaces/TokenInfo.html",[0,0.576,2,0.285,3,0.121,4,0.091,6,0.141,7,0.26,10,0.021,11,0.775,12,0.624,13,0.524,14,0.564,15,0.625,16,0.484,17,0.381,18,0.576,19,0.914,20,0.636,21,0.862,22,0.625,23,0.385,26,0.782,30,0.385,31,0.758,34,0.662,35,0.54,36,0.554,38,0.409,49,1.075,50,0.662,53,0.355,55,0.554,56,0.753,58,0.015,63,0.512,65,0.964,68,0.497,69,0.34,72,0.461,73,0.935,75,0.845,76,0.842,77,0.512,78,0.85,79,1.085,80,0.684,84,0.062,87,1.183,88,0.8,89,0.715,90,0.589,93,0.693,95,0.803,97,0.715,99,0.458,104,0.74,109,1.254,112,0.74,117,1.095,118,0.458,119,0.862,126,0.782,129,0.775,130,0.488,131,0.458,134,0.417,136,0.914,139,1.144,141,0.922,143,0.999,144,1.094,146,0.715,147,0.714,148,0.964,149,0.768,150,0.411,151,0.458,157,0.811,158,0.433,174,0.999,176,0.812,179,0.62,181,1.165,186,0.457,187,0.828,191,0.684,197,0.458,199,0.715,200,0.554,203,1.001,206,1.181,209,0.512,212,0.951,213,0.782,215,0.74,218,0.512,221,0.782,228,0.74,229,0.54,231,0.834,234,0.512,235,0.54,236,0.512,238,0.512,242,0.409,243,0.433,244,0.753,245,0.512,261,1.025,263,1.142,267,0.168,284,0.684,287,0.62,290,0.554,291,0.512,293,0.512,294,0.782,299,0.54,305,0.949,315,0.968,319,1.034,323,0.412,327,1.021,330,0.901,339,0.458,355,0.512,369,0.951,370,0.279,371,0.74,375,0.7,382,0.54,388,0.753,413,0.54,415,0.852,423,0.883,425,0.54,430,0.782,436,0.7,437,0.898,438,0.999,449,1.046,450,0.943,451,0.512,454,0.952,455,0.512,458,0.484,460,1.064,461,0.7,464,0.662,469,0.803,471,0.892,472,0.949,478,0.825,481,1.324,487,0.992,489,1.001,495,0.016,496,1.397,498,0.87,499,1.182,500,1.206,511,1.113,515,1.588,517,0.782,519,0.512,526,0.484,532,1.519,541,0.57,546,0.917,557,0.662,559,1.113,560,1.182,562,0.57,578,1.326,582,1.121,583,1.415,584,0.54,585,0.6,586,1.314,587,0.74,590,1.44,591,1.41,592,1.001,594,1.635,595,1.206,596,0.949,597,1.142,605,1.519,607,0.484,609,0.967,611,1.23,612,0.633,616,1.458,617,1.073,618,1.458,619,1.384,620,1.458,621,1.073,622,1.019,623,0.703,624,1.415,627,0.703,629,1.458,632,0.667,634,0.667,639,1.121,642,0.6,643,1.326,646,1.256,647,0.825,658,0.949,686,0.703,687,0.667,688,1.458,689,1.686,690,1.019,691,1.303,692,1.314,693,0.633,694,0.703,695,1.073,696,1.458,697,1.458,698,1.458,699,1.373,700,1.08,701,1.131,702,1.073,703,1.373,704,1.303,705,1.491,706,1.816,707,1.019,708,1.019,709,1.492,710,1.131,711,1.537,712,1.572,713,1.747,714,1.019,715,1.246,716,1.131,717,1.674,718,1.131,719,1.073,720,1.236,721,1.615,722,1.131,723,1.131,724,1.656,725,1.491,726,1.571,727,1.131,728,1.131,729,1.384,730,1.246,731,1.019,732,1.246,733,1.588,734,1.415,735,1.182,736,1.44,737,0.967,738,1.492,739,1.019,740,1.492,741,0.967,742,1.019,743,0.967,744,1.491,745,1.723,746,1.373,747,1.656,748,1.373,749,1.656,750,1.656,751,0.703,752,0.967,753,1.131,754,1.343,755,1.314,756,1.019,757,1.384,758,0.74,759,1.635,760,0.74,761,1.236,762,1.173,763,1.173,764,0.74,765,1.303,766,1.131,767,1.373,768,1.491,769,1.113,770,0.74,771,1.019,772,0.74,773,1.019,774,1.131,775,0.703,776,0.703,777,0.74,778,0.74,779,0.703,780,0.74,781,1.131,782,1.073,783,0.74,784,1.314,785,0.74,786,0.74,787,1.131,788,1.131,789,1.373,790,1.019,791,0.667,792,1.777,793,1.131,794,0.967,795,0.74,796,0.74,797,0.74,798,0.74,799,1.131,800,0.74,801,1.173,802,0.967,803,0.633,804,1.373,805,0.74,806,1.073,807,0.74,808,1.373,809,1.073,810,0.74,811,0.74,812,0.74,813,0.74,814,1.571,815,0.74,816,0.74,817,1.373,818,0.74,819,1.131,820,1.019,821,0.74,822,0.74,823,0.74,824,0.74,825,0.667,826,1.073,827,0.667,828,0.667,829,0.74,830,0.967,831,1.019,832,1.019,833,0.74,834,0.74,835,0.74,836,0.633,837,1.131,838,1.095,839,0.74,840,1.723,841,0.74,842,0.74,843,0.74,844,0.74,845,0.74,846,0.667,847,0.633,848,0.667,849,0.74,850,0.74,851,0.633,852,0.74,853,0.74,854,0.74,855,0.703,856,0.74,857,0.703,858,1.131,859,0.74,860,0.74,861,1.182,862,0.74,863,0.6,864,0.74,865,0.74,866,0.74,867,1.571,868,0.703,869,0.74,870,0.74,871,1.656,872,1.131,873,1.656,874,1.537,875,0.74,876,1.073,877,1.073,878,1.458,879,1.656,880,1.373,881,1.303,882,0.703,883,1.303,884,0.703,885,0.633,886,1.303,887,1.303,888,0.703,889,1.073,890,1.571,891,1.131,892,1.373,893,1.073,894,1.236,895,1.571,896,1.656,897,0.74,898,0.74,899,0.74,900,0.74,901,0.74,902,1.131,903,1.131,904,1.073,905,0.74,906,0.74,907,0.74,908,0.74,909,0.74,910,1.303,911,1.019,912,0.74,913,0.74,914,0.6,915,0.633,916,0.74,917,0.703,918,1.571,919,0.74,920,0.703,921,1.458,922,0.703,923,1.303,924,0.703,925,1.373,926,0.74,927,0.74,928,0.667,929,0.703,930,0.74,931,0.74,932,1.537,933,0.74,934,0.74,935,0.74,936,0.74,937,1.656,938,0.74,939,0.74,940,0.74,941,0.703,942,0.74,943,0.74,944,0.74,945,0.967,946,0.74,947,0.74,948,0.74,949,0.74,950,0.74,951,0.74,952,0.74,953,1.019,954,0.74,955,0.667,956,0.667,957,0.917,958,0.74,959,0.74,960,0.74,961,0.74,962,1.131,963,1.131,964,1.131,965,0.74,966,1.131,967,0.74,968,0.74,969,0.703,970,1.131,971,0.74,972,0.703,973,0.74,974,0.74,975,1.303,976,1.303,977,0.74,978,0.74,979,0.74,980,0.74,981,0.74,982,0.74,983,0.74,984,0.703,985,1.131,986,0.74,987,0.703,988,0.74,989,1.131,990,0.74,991,0.74,992,0.74,993,0.74,994,0.74,995,0.74,996,0.74,997,0.74,998,1.131,999,0.74,1000,0.74,1001,0.74,1002,1.131,1003,1.131,1004,1.131,1005,0.74,1006,0.74,1007,1.373,1008,0.74,1009,1.537,1010,1.873,1011,0.74,1012,0.74,1013,1.131,1014,0.74,1015,0.74,1016,0.74,1017,1.131,1018,0.74,1019,0.74,1020,1.373,1021,0.74,1022,1.131,1023,1.131,1024,1.131,1025,0.74,1026,1.131,1027,0.74,1028,0.74,1029,1.373,1030,1.131,1031,0.74,1032,0.74,1033,0.74,1034,0.74,1035,0.74,1036,0.825,1037,0.6,1038,1.131,1039,0.74,1040,0.74,1041,1.373,1042,0.74,1043,1.491,1044,1.458,1045,0.74,1046,1.073,1047,0.667,1048,0.633,1049,1.131,1050,0.74,1051,0.74,1052,0.74,1053,1.131,1054,1.537,1055,1.131,1056,1.131,1057,0.74,1058,1.236,1059,0.74,1060,1.303,1061,0.74,1062,0.74,1063,1.131,1064,0.74,1065,0.703,1066,1.236,1067,0.74,1068,0.74,1069,0.703,1070,0.74,1071,1.373,1072,0.74,1073,1.458,1074,1.373,1075,0.74,1076,0.74,1077,1.131,1078,1.373,1079,0.74,1080,0.74,1081,0.74,1082,1.131,1083,0.74,1084,0.74,1085,0.74,1086,1.131,1087,0.703,1088,0.74,1089,1.131,1090,0.74,1091,0.74,1092,0.74,1093,0.74,1094,0.667,1095,1.303,1096,0.703,1097,0.667,1098,0.74,1099,0.74,1100,1.131,1101,1.373,1102,0.74,1103,1.131,1104,0.74,1105,0.74,1106,0.74,1107,1.373,1108,0.6,1109,0.74,1110,0.74,1111,0.74,1112,0.6,1113,0.74,1114,0.74,1115,0.74,1116,0.74,1117,0.74,1118,0.703,1119,1.131,1120,1.131,1121,1.131,1122,0.74,1123,1.131,1124,0.967,1125,1.019,1126,0.74,1127,0.74,1128,1.303,1129,0.967,1130,0.74,1131,0.703,1132,0.74,1133,0.74,1134,0.57,1135,0.74,1136,0.74,1137,0.74,1138,1.131,1139,1.131,1140,0.74,1141,0.74,1142,0.74,1143,0.74,1144,0.74,1145,1.073,1146,0.703,1147,1.131,1148,0.74,1149,0.74,1150,0.74,1151,0.74,1152,0.74,1153,0.74,1154,0.74,1155,0.74,1156,0.633,1157,0.74,1158,0.74,1159,1.131,1160,0.74,1161,0.74,1162,0.74,1163,1.131,1164,0.74,1165,0.74,1166,0.703,1167,1.131,1168,0.74,1169,0.633,1170,1.131,1171,1.303,1172,0.74,1173,0.74,1174,1.131,1175,1.131,1176,0.74,1177,0.703,1178,0.967,1179,0.74,1180,1.373,1181,0.74,1182,0.74,1183,0.667,1184,0.74,1185,0.74,1186,0.74,1187,0.74,1188,0.74,1189,1.373]],["title/interfaces/TokenInfoRequest.html",[0,0.3,751,1.065]],["body/interfaces/TokenInfoRequest.html",[0,0.578,2,0.289,3,0.125,4,0.093,6,0.143,7,0.265,10,0.021,11,0.781,12,0.631,13,0.529,14,0.567,15,0.637,16,0.498,17,0.381,18,0.577,19,0.918,20,0.641,21,0.872,22,0.637,23,0.396,26,0.798,30,0.396,31,0.771,34,0.675,35,0.555,36,0.566,38,0.42,49,1.081,50,0.675,53,0.356,55,0.566,56,0.761,58,0.015,63,0.526,65,0.925,68,0.503,69,0.347,72,0.468,73,0.929,75,0.835,76,0.84,77,0.526,78,0.715,79,1.058,80,0.685,84,0.063,87,1.173,88,0.726,89,0.601,90,0.601,93,0.668,95,0.806,97,0.726,99,0.471,104,0.755,109,1.259,112,0.755,117,1.105,118,0.471,119,0.872,126,0.798,129,0.781,130,0.498,131,0.471,134,0.416,136,0.925,139,1.158,141,0.924,143,1.007,144,1.099,146,0.726,147,0.672,148,0.946,149,0.771,150,0.414,151,0.471,157,0.763,158,0.445,174,0.983,176,0.815,179,0.629,181,1.172,186,0.466,187,0.835,191,0.69,197,0.471,199,0.726,200,0.566,203,1.018,206,1.189,209,0.526,212,0.964,213,0.798,215,0.498,218,0.526,221,0.798,228,0.755,229,0.555,231,0.839,234,0.526,235,0.555,236,0.526,238,0.526,242,0.42,243,0.445,244,0.672,245,0.526,261,1.037,263,1.096,267,0.171,284,0.664,287,0.629,290,0.563,291,0.526,293,0.526,294,0.526,299,0.555,305,0.964,315,0.911,319,1.043,323,0.347,327,1.032,330,0.89,339,0.471,355,0.526,369,0.964,370,0.286,371,0.755,375,0.715,382,0.555,388,0.723,413,0.555,415,0.842,423,0.844,425,0.555,430,0.798,436,0.715,437,0.913,438,1.007,449,1.041,450,0.941,451,0.526,454,0.946,455,0.526,458,0.498,460,1.07,461,0.715,464,0.675,469,0.816,471,0.887,472,0.964,478,0.842,481,1.337,487,0.996,489,1.018,495,0.016,496,1.41,498,0.888,499,1.199,500,1.158,511,1.132,515,1.599,517,0.798,519,0.526,526,0.498,532,1.531,541,0.585,546,0.936,557,0.445,559,1.132,560,1.199,562,0.585,578,1.305,582,1.018,583,1.132,584,0.555,585,0.617,586,1.193,587,0.755,590,1.453,591,1.392,592,1.018,594,1.651,595,0.964,596,0.798,597,1.154,605,1.43,607,0.498,609,0.987,611,1.226,612,0.65,616,1.479,617,1.096,618,1.479,619,1.403,620,1.479,621,1.096,622,1.04,623,0.722,624,1.432,627,0.722,629,1.479,632,0.685,634,0.685,639,1.136,642,1.264,643,1.385,646,1.199,647,0.842,658,0.964,686,0.722,687,0.685,688,1.479,689,1.701,690,1.04,691,1.324,692,1.332,693,0.65,694,0.722,695,1.096,696,1.479,697,1.479,698,1.479,699,1.396,700,1.092,701,1.154,702,1.096,703,1.396,704,1.324,705,1.509,706,1.833,707,0.685,708,0.685,709,1.507,710,0.76,711,1.154,712,1.257,713,1.653,714,0.685,715,1.132,716,0.76,717,1.507,718,0.76,719,0.722,720,1.04,721,1.486,722,0.76,723,0.76,724,1.675,725,1.403,726,1.479,727,0.76,728,0.76,729,1.04,730,0.936,731,0.685,732,0.936,733,1.531,734,1.332,735,1.073,736,1.357,737,0.65,738,1.432,739,0.685,740,1.332,741,0.65,742,0.685,743,0.65,744,1.509,745,1.59,746,1.154,747,1.479,748,1.154,749,1.558,750,1.674,751,1.096,752,1.432,753,1.154,754,1.359,755,1.332,756,1.04,757,1.403,758,0.76,759,1.651,760,0.76,761,1.257,762,1.193,763,1.193,764,0.76,765,1.324,766,1.154,767,1.396,768,1.509,769,1.132,770,0.76,771,1.04,772,0.76,773,1.04,774,1.154,775,0.722,776,0.722,777,0.76,778,0.76,779,0.722,780,0.76,781,1.154,782,1.096,783,0.76,784,1.332,785,0.76,786,0.76,787,1.154,788,1.154,789,1.396,790,1.04,791,0.685,792,1.792,793,1.154,794,0.987,795,0.76,796,0.76,797,0.76,798,0.76,799,1.154,800,0.76,801,1.193,802,0.987,803,0.65,804,1.396,805,0.76,806,1.096,807,0.76,808,1.396,809,1.096,810,0.76,811,0.76,812,0.76,813,0.76,814,1.59,815,0.76,816,0.76,817,1.396,818,0.76,819,1.154,820,1.04,821,0.76,822,0.76,823,0.76,824,0.76,825,0.685,826,1.096,827,0.685,828,0.685,829,0.76,830,0.987,831,1.04,832,1.04,833,0.76,834,0.76,835,0.76,836,0.65,837,1.154,838,1.105,839,0.76,840,1.739,841,0.76,842,0.76,843,0.76,844,0.76,845,0.76,846,0.685,847,0.65,848,0.685,849,0.76,850,0.76,851,0.65,852,0.76,853,0.76,854,0.76,855,0.722,856,0.76,857,0.722,858,1.154,859,0.76,860,0.76,861,1.199,862,0.76,863,0.617,864,0.76,865,0.76,866,0.76,867,1.59,868,0.722,869,0.76,870,0.76,871,1.675,872,1.154,873,1.675,874,1.558,875,0.76,876,1.096,877,1.096,878,1.479,879,1.675,880,1.396,881,1.324,882,0.722,883,1.324,884,0.722,885,0.65,886,1.324,887,1.324,888,0.722,889,1.096,890,1.59,891,1.154,892,1.396,893,1.096,894,1.257,895,1.59,896,1.674,897,0.76,898,0.76,899,0.76,900,0.76,901,0.76,902,1.154,903,1.154,904,1.096,905,0.76,906,0.76,907,0.76,908,0.76,909,0.76,910,1.324,911,1.04,912,0.76,913,0.76,914,0.617,915,0.65,916,0.76,917,0.722,918,1.59,919,0.76,920,0.722,921,1.479,922,0.722,923,1.324,924,0.722,925,1.396,926,0.76,927,0.76,928,0.685,929,0.722,930,0.76,931,0.76,932,1.558,933,0.76,934,0.76,935,0.76,936,0.76,937,1.675,938,0.76,939,0.76,940,0.76,941,0.722,942,0.76,943,0.76,944,0.76,945,0.987,946,0.76,947,0.76,948,0.76,949,0.76,950,0.76,951,0.76,952,0.76,953,1.04,954,0.76,955,0.685,956,0.685,957,0.936,958,0.76,959,0.76,960,0.76,961,0.76,962,1.154,963,1.154,964,1.154,965,0.76,966,1.154,967,0.76,968,0.76,969,0.722,970,1.154,971,0.76,972,0.722,973,0.76,974,0.76,975,1.324,976,1.324,977,0.76,978,0.76,979,0.76,980,0.76,981,0.76,982,0.76,983,0.76,984,0.722,985,1.154,986,0.76,987,0.722,988,0.76,989,1.154,990,0.76,991,0.76,992,0.76,993,0.76,994,0.76,995,0.76,996,0.76,997,0.76,998,1.154,999,0.76,1000,0.76,1001,0.76,1002,1.154,1003,1.154,1004,1.154,1005,0.76,1006,0.76,1007,1.396,1008,0.76,1009,1.558,1010,1.888,1011,0.76,1012,0.76,1013,1.154,1014,0.76,1015,0.76,1016,0.76,1017,1.154,1018,0.76,1019,0.76,1020,1.396,1021,0.76,1022,1.154,1023,1.154,1024,1.154,1025,0.76,1026,1.154,1027,0.76,1028,0.76,1029,1.396,1030,1.154,1031,0.76,1032,0.76,1033,0.76,1034,0.76,1035,0.76,1036,0.842,1037,0.617,1038,1.154,1039,0.76,1040,0.76,1041,1.396,1042,0.76,1043,1.509,1044,1.479,1045,0.76,1046,1.096,1047,0.685,1048,0.65,1049,1.154,1050,0.76,1051,0.76,1052,0.76,1053,1.154,1054,1.558,1055,1.154,1056,1.154,1057,0.76,1058,1.257,1059,0.76,1060,1.324,1061,0.76,1062,0.76,1063,1.154,1064,0.76,1065,0.722,1066,1.257,1067,0.76,1068,0.76,1069,0.722,1070,0.76,1071,1.396,1072,0.76,1073,1.479,1074,1.396,1075,0.76,1076,0.76,1077,1.154,1078,1.396,1079,0.76,1080,0.76,1081,0.76,1082,1.154,1083,0.76,1084,0.76,1085,0.76,1086,1.154,1087,0.722,1088,0.76,1089,1.154,1090,0.76,1091,0.76,1092,0.76,1093,0.76,1094,0.685,1095,1.324,1096,0.722,1097,0.685,1098,0.76,1099,0.76,1100,1.154,1101,1.396,1102,0.76,1103,1.154,1104,0.76,1105,0.76,1106,0.76,1107,1.396,1108,0.617,1109,0.76,1110,0.76,1111,0.76,1112,0.617,1113,0.76,1114,0.76,1115,0.76,1116,0.76,1117,0.76,1118,0.722,1119,1.154,1120,1.154,1121,1.154,1122,0.76,1123,1.154,1124,0.987,1125,1.04,1126,0.76,1127,0.76,1128,1.324,1129,0.987,1130,0.76,1131,0.722,1132,0.76,1133,0.76,1134,0.585,1135,0.76,1136,0.76,1137,0.76,1138,1.154,1139,1.154,1140,0.76,1141,0.76,1142,0.76,1143,0.76,1144,0.76,1145,1.096,1146,0.722,1147,1.154,1148,0.76,1149,0.76,1150,0.76,1151,0.76,1152,0.76,1153,0.76,1154,0.76,1155,0.76,1156,0.65,1157,0.76,1158,0.76,1159,1.154,1160,0.76,1161,0.76,1162,0.76,1163,1.154,1164,0.76,1165,0.76,1166,0.722,1167,1.154,1168,0.76,1169,0.65,1170,1.154,1171,1.324,1172,0.76,1173,0.76,1174,1.154,1175,1.154,1176,0.76,1177,0.722,1178,0.987,1179,0.76,1180,1.396,1181,0.76,1182,0.76,1183,0.685,1184,0.76,1185,0.76,1186,0.76,1187,0.76,1188,0.76,1189,1.396]],["title/interfaces/TokenPayload.html",[0,0.3,693,0.959]],["body/interfaces/TokenPayload.html",[0,0.44,2,0.233,3,0.206,4,0.154,6,0.129,7,0.378,10,0.021,13,0.377,17,0.386,18,0.576,46,1.932,53,0.27,58,0.015,65,1.078,69,0.377,73,0.961,76,0.854,78,1.02,79,1.212,80,0.377,84,0.153,87,1.016,93,0.699,95,0.621,97,0.957,99,1.36,134,0.42,148,0.898,149,0.577,150,0.426,157,0.807,174,0.858,187,0.711,215,1.078,244,0.542,267,0.188,284,0.621,287,0.665,319,1.078,323,0.495,365,2.74,369,1.02,370,0.621,388,0.971,415,0.867,423,0.899,438,1.18,449,0.99,450,0.949,454,0.711,460,1.016,495,0.015,500,1.139,501,3.141,526,1.078,557,0.964,578,1.139,582,1.602,583,1.336,590,1.267,591,1.437,596,1.139,605,1.781,607,1.278,643,1.438,646,1.278,658,1.139,692,1.073,693,1.733,700,0.777,705,1.484,708,1.484,709,1.669,712,2.064,713,1.973,714,1.758,717,1.839,720,1.131,721,1.583,729,1.874,730,1.825,731,1.484,732,1.583,733,1.745,734,1.408,735,1.77,736,1.267,737,1.408,738,1.669,739,1.484,740,1.779,741,1.408,742,1.484,743,1.408,744,1.758,752,1.669,755,1.669,756,1.758,757,1.758,759,1.131,761,1.484,762,1.408,769,1.336,790,2.026,794,1.779,801,1.408,803,1.408,820,1.484,828,1.874,830,1.408,831,1.484,832,1.484,838,0.964,847,1.669,848,1.758,861,1.601,863,1.583,945,1.669,953,1.758,955,1.484,956,1.484,957,1.336,1048,1.408,1097,1.484,1108,1.336,1112,1.336,1124,1.669,1125,1.484,1156,1.408,1169,1.669,1178,1.779,1260,4.387,1273,3.702,1340,3.499,1341,3.499,1342,3.499,1343,3.499,1344,3.499,1345,3.499,1346,5.125,1348,4.083,1349,4.083,1350,5.441,1352,3.111,1353,3.499,1354,3.499,1358,4.592,1359,4.592,1360,4.592,1361,4.592,1362,3.499,1363,4.592,1364,4.387,1365,4.592,1366,4.083,1367,5.441,1368,4.083,1369,4.083,1370,5.441,1371,4.592,1372,4.592,1373,5.442,1374,6.121,1375,6.121,1376,6.121,1377,5.996,1378,5.441,1379,4.592,1380,5.441,1381,4.838,1382,5.441,1383,5.441,1384,4.592,1385,4.592]],["title/interfaces/Transporter.html",[0,0.3,38,0.62]],["body/interfaces/Transporter.html",[0,0.557,2,0.278,3,0.246,4,0.184,6,0.154,10,0.021,11,0.807,12,0.806,13,0.45,17,0.302,18,0.567,19,0.924,20,0.6,21,1.205,22,1.019,23,1.085,37,2.078,38,1.103,53,0.342,55,0.735,58,0.016,68,0.554,69,0.45,72,0.45,75,0.796,76,0.86,80,0.669,84,0.125,93,0.487,95,0.565,117,0.877,119,1.149,129,0.745,134,0.386,141,0.925,143,0.781,144,0.96,147,0.647,149,0.7,150,0.423,157,0.735,160,2.078,165,2.284,176,0.565,179,0.745,186,0.605,187,0.9,191,0.695,199,0.781,231,0.745,267,0.183,284,0.565,287,0.605,290,0.745,323,0.45,330,0.69,370,0.565,388,0.647,415,0.785,424,2.203,439,2.474,464,1.079,466,2.415,467,2.415,468,2.615,469,1.314,471,0.647,487,0.985,495,0.016,496,1.728,497,3.094,498,1.537,499,1.676,500,1.036,501,2.888,502,3.094,503,2.863,504,3.467,505,4.215,506,3.094,507,3.094,508,3.094,509,3.094,510,3.805,511,1.496,512,4.809,513,3.37,514,3.37,515,1.216,516,4.121,517,1.036,518,4.145,519,1.036,520,2.863,521,3.37,522,3.37,523,3.094,524,3.37,525,3.37,526,1.207,527,3.094,528,3.37,529,3.37,530,3.37,531,3.37,532,1.216,533,3.37,534,3.37,535,2.203,536,3.37,537,4.489,538,4.489,539,4.145,540,3.37,541,1.154,542,3.37,543,3.37,544,3.37,545,3.094,546,1.216,547,3.094,548,3.37,549,4.145,550,3.37,551,3.37,552,3.37,553,3.37,554,3.37,555,3.37,556,3.37,557,0.877,558,3.37,559,1.216,560,1.154,561,4.489,562,1.537,563,3.37,564,4.684,565,4.684,566,3.805,567,3.37,568,3.37,569,3.37,570,4.145,571,3.37,572,3.37,573,3.37,574,3.094,575,3.37,576,3.37,577,3.37,578,1.036,611,1.275,678,3.552,682,5.568,684,4.145,1395,4.883,1396,4.883,1397,4.883]],["title/interfaces/UserRefreshClientOptions.html",[0,0.3,1398,3.128]],["body/interfaces/UserRefreshClientOptions.html",[0,0.503,2,0.287,3,0.254,4,0.19,6,0.159,7,0.432,10,0.021,11,0.819,12,0.845,13,0.466,14,0.582,15,1.12,17,0.381,18,0.555,19,0.91,20,0.659,34,1.264,42,2.208,50,1.186,51,3.372,53,0.309,56,0.669,58,0.017,62,3.266,68,0.667,69,0.649,79,0.807,80,0.565,84,0.129,95,0.709,104,1.015,109,1.186,118,0.96,119,0.807,134,0.349,141,0.912,149,0.786,150,0.418,151,0.96,176,0.827,178,2.609,179,0.626,186,0.626,191,0.709,197,0.96,199,0.807,200,0.76,206,1.101,231,0.872,267,0.175,284,0.709,287,0.76,290,0.626,304,2.939,319,0.856,323,0.565,324,2.766,325,3.292,327,0.907,328,2.421,331,2.758,332,3.348,337,2.939,338,3.165,339,1.305,342,2.421,345,2.278,346,2.421,347,2.421,348,2.421,349,2.939,350,2.421,351,2.421,352,2.421,354,2.579,402,2.421,415,0.764,449,0.714,450,0.872,495,0.017,517,1.401,585,1.258,591,1.414,597,1.015,609,1.951,612,1.326,643,1.072,646,1.015,647,1.131,700,0.96,715,1.644,769,1.258,836,1.802,838,1.186,894,2.002,895,2.156,904,1.924,910,1.472,911,1.397,915,1.326,917,1.787,918,2.05,920,1.472,921,1.472,922,1.472,923,1.472,924,1.472,928,1.397,1043,1.397,1134,1.193,1166,1.472,1278,3.843,1279,3.843,1280,4.322,1306,4.322,1398,5.651,1399,5.05,1400,4.322,1401,5.05,1402,5.05,1403,5.05,1404,4.322,1405,5.05,1406,5.05,1407,6.131,1408,5.05,1409,5.05,1410,6.131,1411,6.131,1412,6.602]],["title/interfaces/VerifyIdTokenOptions.html",[0,0.3,890,1.065]],["body/interfaces/VerifyIdTokenOptions.html",[0,0.578,2,0.29,3,0.126,4,0.094,6,0.144,7,0.266,10,0.021,11,0.782,12,0.633,13,0.531,14,0.568,15,0.641,16,0.501,17,0.381,18,0.577,19,0.919,20,0.642,21,0.875,22,0.641,23,0.399,26,0.802,30,0.399,31,0.774,34,0.679,35,0.559,36,0.569,38,0.423,49,1.083,50,0.679,53,0.357,55,0.569,56,0.763,58,0.015,63,0.529,65,0.928,68,0.505,69,0.348,72,0.469,73,0.913,75,0.836,76,0.841,77,0.529,78,0.719,79,1.059,80,0.685,84,0.064,87,1.174,88,0.73,89,0.604,90,0.604,93,0.669,95,0.807,97,0.73,99,0.474,104,0.76,109,1.26,112,0.76,117,1.107,118,0.474,119,0.875,126,0.802,129,0.782,130,0.501,131,0.474,134,0.416,136,0.928,139,1.161,141,0.925,143,1.009,144,1.101,146,0.73,147,0.675,148,0.946,149,0.771,150,0.405,151,0.474,157,0.766,158,0.448,174,0.985,176,0.816,179,0.631,181,1.174,186,0.469,187,0.836,191,0.692,197,0.474,199,0.73,200,0.569,203,1.022,206,1.19,209,0.529,212,0.968,213,0.802,215,0.501,218,0.529,221,0.802,228,0.76,229,0.559,231,0.84,234,0.529,235,0.559,236,0.529,238,0.529,242,0.423,243,0.448,244,0.675,245,0.529,261,1.04,263,1.1,267,0.157,284,0.666,287,0.631,290,0.566,291,0.529,293,0.529,294,0.529,299,0.559,305,0.969,315,0.915,319,1.045,323,0.348,327,1.035,330,0.892,339,0.474,355,0.529,369,0.968,370,0.289,371,0.76,375,0.719,382,0.559,388,0.725,413,0.559,415,0.843,423,0.846,425,0.559,430,0.802,436,0.719,437,0.917,438,1.009,449,1.041,450,0.941,451,0.529,454,0.946,455,0.529,458,0.501,460,1.072,461,0.719,464,0.679,469,0.82,471,0.889,472,0.969,478,0.847,481,1.34,487,0.997,489,1.022,495,0.016,496,1.413,498,0.893,499,1.203,500,1.161,511,1.137,515,1.602,517,0.802,519,0.529,526,0.501,532,1.535,541,0.589,546,0.942,557,0.448,559,1.137,560,1.203,562,0.589,578,1.308,582,1.022,583,1.137,584,0.559,585,0.621,586,1.198,587,0.76,590,1.456,591,1.393,592,1.022,594,1.655,595,0.969,596,0.802,597,1.157,605,1.434,607,0.501,609,0.992,611,1.227,612,0.655,616,1.484,617,1.102,618,1.484,619,1.409,620,1.484,621,1.102,622,1.046,623,0.727,624,1.437,627,0.727,629,1.484,632,0.69,634,0.69,639,1.141,642,0.621,643,1.339,646,1.202,647,0.847,658,0.969,686,0.727,687,0.69,688,1.484,689,1.705,690,1.046,691,1.33,692,1.337,693,0.655,694,0.727,695,1.102,696,1.484,697,1.484,698,1.484,699,1.402,700,1.095,701,1.161,702,1.102,703,1.402,704,1.33,705,1.514,706,1.837,707,0.69,708,0.69,709,1.198,710,0.766,711,1.161,712,1.263,713,1.656,714,0.69,715,1.137,716,0.766,717,1.512,718,0.766,719,0.727,720,1.046,721,1.49,722,0.766,723,0.766,724,1.161,725,1.409,726,1.484,727,0.766,728,0.766,729,1.046,730,0.942,731,0.69,732,0.942,733,1.363,734,1.337,735,1.078,736,1.361,737,0.655,738,1.618,739,0.69,740,1.337,741,0.655,742,0.69,743,0.655,744,1.046,745,1.595,746,1.161,747,1.484,748,1.161,749,1.564,750,1.33,751,0.727,752,0.992,753,1.161,754,1.363,755,1.337,756,1.046,757,1.409,758,0.766,759,1.655,760,0.766,761,1.263,762,1.198,763,1.198,764,0.766,765,1.33,766,1.161,767,1.402,768,1.514,769,1.137,770,0.766,771,1.046,772,0.766,773,1.046,774,1.161,775,0.727,776,0.727,777,0.766,778,0.766,779,0.727,780,0.766,781,1.161,782,1.102,783,0.766,784,1.337,785,0.766,786,0.766,787,1.161,788,1.161,789,1.402,790,1.046,791,0.69,792,1.796,793,1.161,794,0.992,795,0.766,796,0.766,797,0.766,798,0.766,799,1.161,800,0.766,801,1.198,802,0.992,803,0.655,804,1.402,805,0.766,806,1.102,807,0.766,808,1.402,809,1.102,810,0.766,811,0.766,812,0.766,813,0.766,814,1.595,815,0.766,816,0.766,817,1.402,818,0.766,819,1.161,820,1.046,821,0.766,822,0.766,823,0.766,824,0.766,825,0.69,826,1.102,827,0.69,828,0.69,829,0.766,830,0.992,831,1.046,832,1.046,833,0.766,834,0.766,835,0.766,836,0.655,837,1.161,838,1.107,839,0.766,840,1.744,841,0.766,842,0.766,843,0.766,844,0.766,845,0.766,846,0.69,847,0.655,848,0.69,849,0.766,850,0.766,851,0.655,852,0.766,853,0.766,854,0.766,855,0.727,856,0.766,857,0.727,858,1.161,859,0.766,860,0.766,861,1.203,862,0.766,863,0.621,864,0.766,865,0.766,866,0.766,867,1.595,868,0.727,869,0.766,870,0.766,871,1.681,872,1.161,873,1.681,874,1.564,875,0.766,876,1.102,877,1.102,878,1.484,879,1.681,880,1.402,881,1.33,882,0.727,883,1.33,884,0.727,885,0.655,886,1.33,887,1.33,888,0.727,889,1.102,890,1.679,891,1.681,892,1.769,893,1.102,894,1.263,895,1.595,896,1.679,897,0.766,898,0.766,899,0.766,900,0.766,901,0.766,902,1.161,903,1.161,904,1.102,905,0.766,906,0.766,907,0.766,908,0.766,909,0.766,910,1.33,911,1.046,912,0.766,913,0.766,914,0.621,915,0.655,916,0.766,917,0.727,918,1.595,919,0.766,920,0.727,921,1.484,922,0.727,923,1.33,924,0.727,925,1.402,926,0.766,927,0.766,928,0.69,929,0.727,930,0.766,931,0.766,932,1.564,933,0.766,934,0.766,935,0.766,936,0.766,937,1.681,938,0.766,939,0.766,940,0.766,941,0.727,942,0.766,943,0.766,944,0.766,945,0.992,946,0.766,947,0.766,948,0.766,949,0.766,950,0.766,951,0.766,952,0.766,953,1.046,954,0.766,955,0.69,956,0.69,957,0.942,958,0.766,959,0.766,960,0.766,961,0.766,962,1.161,963,1.161,964,1.161,965,0.766,966,1.161,967,0.766,968,0.766,969,0.727,970,1.161,971,0.766,972,0.727,973,0.766,974,0.766,975,1.33,976,1.33,977,0.766,978,0.766,979,0.766,980,0.766,981,0.766,982,0.766,983,0.766,984,0.727,985,1.161,986,0.766,987,0.727,988,0.766,989,1.161,990,0.766,991,0.766,992,0.766,993,0.766,994,0.766,995,0.766,996,0.766,997,0.766,998,1.161,999,0.766,1000,0.766,1001,0.766,1002,1.161,1003,1.161,1004,1.161,1005,0.766,1006,0.766,1007,1.402,1008,0.766,1009,1.564,1010,1.893,1011,0.766,1012,0.766,1013,1.161,1014,0.766,1015,0.766,1016,0.766,1017,1.161,1018,0.766,1019,0.766,1020,1.402,1021,0.766,1022,1.161,1023,1.161,1024,1.161,1025,0.766,1026,1.161,1027,0.766,1028,0.766,1029,1.402,1030,1.161,1031,0.766,1032,0.766,1033,0.766,1034,0.766,1035,0.766,1036,0.847,1037,0.621,1038,1.161,1039,0.766,1040,0.766,1041,1.402,1042,0.766,1043,1.514,1044,1.484,1045,0.766,1046,1.102,1047,0.69,1048,0.655,1049,1.161,1050,0.766,1051,0.766,1052,0.766,1053,1.161,1054,1.564,1055,1.161,1056,1.161,1057,0.766,1058,1.263,1059,0.766,1060,1.33,1061,0.766,1062,0.766,1063,1.161,1064,0.766,1065,0.727,1066,1.263,1067,0.766,1068,0.766,1069,0.727,1070,0.766,1071,1.402,1072,0.766,1073,1.484,1074,1.402,1075,0.766,1076,0.766,1077,1.161,1078,1.402,1079,0.766,1080,0.766,1081,0.766,1082,1.161,1083,0.766,1084,0.766,1085,0.766,1086,1.161,1087,0.727,1088,0.766,1089,1.161,1090,0.766,1091,0.766,1092,0.766,1093,0.766,1094,0.69,1095,1.33,1096,0.727,1097,0.69,1098,0.766,1099,0.766,1100,1.161,1101,1.402,1102,0.766,1103,1.161,1104,0.766,1105,0.766,1106,0.766,1107,1.402,1108,0.621,1109,0.766,1110,0.766,1111,0.766,1112,0.621,1113,0.766,1114,0.766,1115,0.766,1116,0.766,1117,0.766,1118,0.727,1119,1.161,1120,1.161,1121,1.161,1122,0.766,1123,1.161,1124,0.992,1125,1.046,1126,0.766,1127,0.766,1128,1.33,1129,0.992,1130,0.766,1131,0.727,1132,0.766,1133,0.766,1134,0.589,1135,0.766,1136,0.766,1137,0.766,1138,1.161,1139,1.161,1140,0.766,1141,0.766,1142,0.766,1143,0.766,1144,0.766,1145,1.102,1146,0.727,1147,1.161,1148,0.766,1149,0.766,1150,0.766,1151,0.766,1152,0.766,1153,0.766,1154,0.766,1155,0.766,1156,0.655,1157,0.766,1158,0.766,1159,1.161,1160,0.766,1161,0.766,1162,0.766,1163,1.161,1164,0.766,1165,0.766,1166,0.727,1167,1.161,1168,0.766,1169,0.655,1170,1.161,1171,1.33,1172,0.766,1173,0.766,1174,1.161,1175,1.161,1176,0.766,1177,0.727,1178,0.992,1179,0.766,1180,1.402,1181,0.766,1182,0.766,1183,0.69,1184,0.766,1185,0.766,1186,0.766,1187,0.766,1188,0.766,1189,1.402]],["title/interfaces/Warning.html",[0,0.3,318,1.555]],["body/interfaces/Warning.html",[0,0.499,2,0.284,3,0.251,4,0.188,6,0.157,7,0.429,10,0.021,12,0.577,14,0.516,17,0.359,18,0.387,20,0.498,33,2.391,36,1.128,39,2.005,46,1.796,53,0.376,58,0.017,68,0.46,75,0.661,80,0.681,84,0.184,90,1.211,93,0.757,97,1.05,129,0.93,130,0.979,131,1.404,132,3.749,133,2.983,134,0.415,135,2.547,136,1.209,137,2.391,148,0.87,150,0.346,158,0.896,167,2.745,168,2.917,170,2.391,174,0.797,189,2.314,200,0.75,243,0.896,244,0.661,267,0.193,287,0.618,315,0.896,317,2.547,318,3.158,369,0.948,381,3.772,415,0.704,416,2.547,423,0.86,426,2.745,466,2.005,467,2.005,468,2.005,471,0.994,474,2.589,495,0.017,527,3.159,587,1.002,602,3.492,694,1.453,754,1.242,838,0.896,914,1.242,972,1.453,1036,1.531,1037,1.242,1112,1.515,1129,1.309,1134,1.734,1193,3.85,1217,3.568,1224,4.268,1413,3.441,1414,5.851,1415,5.207,1416,4.268,1417,4.268,1418,4.268,1419,6.084,1420,4.986,1421,4.986,1422,4.986,1423,4.986,1424,4.268,1425,6.084,1426,4.986,1427,6.084,1428,4.268,1429,4.986,1430,4.986,1431,4.268,1432,4.268,1433,4.268,1434,3.795,1435,3.795,1436,4.268,1437,4.268,1438,4.268,1439,4.268,1440,6.283,1441,5.066,1442,4.268,1443,4.268,1444,4.268,1445,5.207,1446,4.268,1447,5.207,1448,4.268,1449,5.207,1450,4.268,1451,4.268,1452,4.268,1453,4.268,1454,4.268]],["title/changelog.html",[242,0.518,375,0.581,1455,2.617]],["body/changelog.html",[0,0.381,4,0.251,7,0.328,10,0.021,11,0.577,13,0.429,14,0.582,18,0.517,29,2.793,30,0.931,31,0.788,34,0.835,39,1.869,46,2.402,49,1.12,53,0.293,58,0.016,68,0.429,69,0.429,72,0.537,73,0.884,76,0.538,80,0.656,84,0.162,90,0.931,92,3.58,93,0.582,104,1.504,129,0.928,130,0.974,131,1.268,133,1.978,134,0.405,136,1.131,137,2.793,143,0.743,147,0.843,148,0.843,158,1.234,167,2.098,168,2.229,170,3.41,172,2.976,176,0.772,178,2.839,179,0.577,181,1.234,186,0.722,191,0.538,212,0.884,219,2.375,225,2.539,231,0.577,244,0.616,260,2.539,265,3.315,267,0.149,269,2.539,284,0.795,290,0.577,315,1.047,318,1.978,323,0.429,330,0.657,360,2.229,376,2.976,402,2.229,415,0.538,436,0.884,439,1.768,449,0.657,450,0.789,451,0.987,454,0.616,460,0.743,461,1.108,471,0.929,474,1.978,487,0.657,495,0.016,504,2.375,506,2.946,523,2.946,557,1.259,574,2.946,583,1.451,591,1.171,602,3.407,607,0.934,611,0.835,624,1.221,634,1.286,644,2.727,657,4.226,658,1.237,689,1.286,691,1.855,700,0.884,730,1.158,732,1.158,736,1.376,755,1.221,763,1.221,771,1.286,802,1.221,809,1.355,851,1.221,857,1.355,911,1.612,914,1.158,957,1.158,1036,1.305,1037,1.451,1094,1.286,1095,1.355,1128,1.355,1134,1.098,1171,1.698,1183,1.286,1193,4.029,1217,2.727,1245,3.979,1267,4.392,1312,3.979,1364,4.392,1373,5.774,1400,5.446,1404,4.987,1428,5.709,1434,3.538,1441,3.209,1455,3.979,1456,4.987,1457,4.649,1458,4.649,1459,6.486,1460,4.649,1461,4.649,1462,4.649,1463,4.649,1464,7.414,1465,4.649,1466,4.649,1467,4.649,1468,5.826,1469,4.649,1470,4.649,1471,6.363,1472,4.649,1473,4.649,1474,4.649,1475,4.649,1476,4.649,1477,5.826,1478,4.649,1479,4.649,1480,6.67,1481,4.649,1482,3.979,1483,4.649,1484,4.649,1485,5.826,1486,4.649,1487,6.363,1488,4.649,1489,4.649,1490,7.384,1491,6.363,1492,4.649,1493,6.363,1494,4.649,1495,5.999,1496,4.649,1497,4.649,1498,4.649,1499,5.826,1500,4.649,1501,5.826,1502,4.649,1503,4.649,1504,5.826,1505,4.649,1506,4.649,1507,4.649,1508,6.363,1509,4.649,1510,5.826,1511,4.649,1512,4.649,1513,4.649,1514,4.649,1515,4.649,1516,4.649,1517,4.649,1518,4.649,1519,4.649,1520,4.987,1521,5.826,1522,4.649,1523,4.649,1524,5.826,1525,4.649,1526,3.979,1527,4.649,1528,4.649,1529,4.649,1530,4.649,1531,4.649,1532,5.446,1533,4.649,1534,4.987,1535,5.709,1536,5.826,1537,5.826,1538,4.649,1539,4.649,1540,4.649,1541,5.446,1542,4.649,1543,4.649,1544,4.649,1545,4.649,1546,3.538,1547,4.649,1548,3.979,1549,4.649,1550,4.649,1551,5.826,1552,4.649,1553,4.987,1554,4.649,1555,3.979,1556,4.649,1557,3.979,1558,4.649,1559,4.649,1560,4.649,1561,4.649,1562,4.649,1563,4.649,1564,4.987,1565,4.649,1566,4.649,1567,4.649,1568,4.649,1569,4.649,1570,4.649,1571,4.649,1572,4.649,1573,4.649,1574,4.649,1575,4.649,1576,4.649,1577,4.649,1578,4.649,1579,4.649,1580,4.649,1581,4.649,1582,4.649,1583,5.826,1584,4.649,1585,3.979,1586,4.649,1587,4.649,1588,6.363,1589,4.649,1590,4.649,1591,4.649,1592,4.649,1593,4.649,1594,4.649,1595,4.649,1596,4.649,1597,4.649,1598,4.649,1599,3.979,1600,4.649,1601,4.649,1602,3.979,1603,4.649,1604,4.649,1605,5.826,1606,4.649,1607,6.363,1608,6.363,1609,4.649,1610,4.649,1611,4.649,1612,4.649,1613,4.649,1614,4.649,1615,4.649,1616,4.649,1617,4.649,1618,4.649,1619,4.649,1620,4.649,1621,4.649,1622,4.649,1623,4.649,1624,5.826,1625,4.649,1626,4.649,1627,4.649,1628,4.649,1629,4.649,1630,4.649,1631,4.649,1632,4.649,1633,4.649,1634,4.649,1635,4.649,1636,5.826,1637,4.649,1638,4.649,1639,4.649]],["title/dependencies.html",[265,1.982,1602,2.617]],["body/dependencies.html",[10,0.021,23,0.945,29,2.835,30,0.945,31,1.003,58,0.018,86,3.021,265,2.668,495,0.018,504,3.021,505,3.468,1237,5.062,1238,5.062,1285,5.062,1415,5.062,1640,5.914,1641,5.914,1642,5.914,1643,5.914,1644,5.914,1645,5.914,1646,5.914]],["title/miscellaneous/enumerations.html",[1647,1.561,1648,3.76]],["body/miscellaneous/enumerations.html",[6,0.184,10,0.021,43,3.415,58,0.018,87,1.202,130,0.775,318,2.845,495,0.018,687,1.618,695,1.948,696,1.948,697,1.948,868,1.948,1413,4.036,1414,5.722,1416,5.006,1647,2.987,1648,5.006,1649,5.006,1650,4.451,1651,4.451,1652,4.451,1653,6.685,1654,6.685,1655,6.685,1656,6.685]],["title/miscellaneous/functions.html",[200,0.661,1647,1.561]],["body/miscellaneous/functions.html",[4,0.216,6,0.181,10,0.019,44,3.802,58,0.018,72,0.528,93,0.572,134,0.326,146,0.916,148,0.759,150,0.396,152,2.585,200,0.862,267,0.146,316,2.585,318,2.962,495,0.018,500,1.402,501,2.811,545,3.629,587,1.151,611,1.187,633,3.629,649,3.953,651,4.359,652,3.629,653,4.359,654,4.377,655,4.41,656,3.629,657,3.629,658,1.216,659,3.953,660,3.953,661,3.359,662,3.953,663,4.359,664,3.953,665,3.953,666,3.953,667,3.953,668,4.185,669,3.953,670,3.953,671,3.953,672,3.953,673,3.953,674,3.953,675,3.629,676,3.953,677,3.953,1087,2.029,1413,3.953,1417,4.903,1647,2.926,1650,5.599,1651,4.359,1652,4.359,1657,6.961,1658,6.961,1659,6.961,1660,6.961,1661,5.728,1662,5.728,1663,5.728]],["title/index.html",[6,0.096,242,0.518,375,0.581]],["body/index.html",[2,0.216,3,0.291,4,0.26,7,0.268,10,0.021,13,0.35,14,0.632,15,1.184,16,1.027,17,0.191,18,0.535,21,0.607,31,0.979,33,1.821,39,2.726,46,2.515,51,1.941,53,0.257,58,0.014,62,2.907,63,0.806,65,1.169,68,0.35,69,0.35,70,1.445,71,1.445,73,0.899,75,0.97,76,0.785,78,1.174,79,0.987,80,0.702,84,0.097,90,1.17,92,3.39,93,0.738,94,1.941,95,0.591,99,0.971,111,2.075,112,0.763,129,0.799,133,2.457,134,0.429,136,0.867,141,0.634,144,0.607,146,0.817,147,0.926,148,0.966,150,0.328,157,0.769,158,0.683,160,2.972,165,2.524,166,2.075,167,2.994,170,1.821,174,1.116,176,0.817,178,1.617,179,0.471,181,1.303,186,0.471,187,0.504,189,2.656,190,2.075,191,0.591,200,0.998,206,1.158,212,0.722,214,2.075,218,1.463,219,1.941,224,2.79,231,0.634,236,0.806,239,3.372,242,0.979,243,0.683,244,0.765,245,1.311,246,2.075,261,1.098,263,1.295,265,2.605,266,2.79,267,0.173,276,2.61,284,0.867,290,0.799,291,1.311,293,0.806,294,0.806,305,1.368,306,2.79,312,1.941,315,1.109,323,0.644,330,1.006,345,1.714,360,1.821,371,0.763,376,3.463,388,0.677,395,2.075,415,0.768,423,0.959,426,1.714,427,2.075,430,1.085,436,1.174,437,0.763,438,1.084,439,2.196,449,0.959,450,0.93,454,0.926,458,0.763,460,1.154,471,0.914,473,3.519,483,2.61,487,0.959,495,0.014,503,2.228,504,3.154,519,0.806,520,2.997,526,0.763,535,1.714,547,3.912,557,0.918,581,3.252,582,1.145,586,1.341,587,1.16,590,1.207,591,1.385,592,1.544,595,0.806,596,0.806,597,1.334,605,1.438,607,0.763,611,0.683,624,0.997,632,1.413,639,1.519,644,2.228,645,2.407,646,1.027,647,1.293,652,2.407,654,3.621,655,3.237,656,2.407,658,1.085,661,2.228,668,2.407,675,3.658,688,1.107,700,0.722,702,1.107,704,1.489,707,1.051,713,1.341,721,1.273,725,1.051,730,0.946,736,1.602,738,0.997,740,1.341,741,1.516,745,1.107,747,1.8,750,1.8,754,0.946,762,0.997,763,1.78,765,1.107,768,1.413,773,1.051,776,1.107,779,1.107,782,1.976,784,0.997,791,1.051,792,2.009,801,1.621,802,0.997,803,1.341,825,1.051,827,1.051,838,1.255,846,1.413,861,0.898,867,1.683,889,1.107,894,1.051,896,1.107,914,1.823,915,0.997,941,1.107,969,1.107,976,1.878,987,1.107,1037,0.946,1046,1.107,1065,1.878,1094,1.413,1096,1.489,1108,1.273,1112,0.946,1118,1.107,1129,0.997,1131,1.107,1134,1.207,1145,1.107,1146,1.489,1156,1.516,1199,4.904,1267,3.527,1286,4.374,1348,4.394,1418,3.252,1441,5.031,1456,4.374,1459,3.252,1495,3.252,1526,5.285,1532,4.374,1534,3.252,1535,4.374,1541,4.942,1546,2.891,1548,4.374,1553,4.942,1555,4.374,1557,3.252,1664,5.11,1665,3.799,1666,3.799,1667,5.11,1668,5.11,1669,3.799,1670,6.175,1671,3.799,1672,3.252,1673,3.799,1674,4.374,1675,3.799,1676,3.799,1677,3.799,1678,5.11,1679,5.774,1680,6.443,1681,3.799,1682,3.799,1683,6.893,1684,5.11,1685,4.942,1686,3.799,1687,4.942,1688,3.799,1689,3.252,1690,3.799,1691,6.443,1692,5.11,1693,3.799,1694,5.11,1695,5.11,1696,6.443,1697,3.799,1698,3.799,1699,3.799,1700,3.799,1701,5.11,1702,3.799,1703,3.799,1704,3.799,1705,4.374,1706,3.799,1707,3.799,1708,3.799,1709,3.799,1710,3.799,1711,3.799,1712,3.799,1713,5.11,1714,5.11,1715,3.799,1716,3.799,1717,3.799,1718,3.799,1719,3.799,1720,3.799,1721,3.799,1722,3.252,1723,5.11,1724,3.799,1725,3.799,1726,3.799,1727,3.799,1728,3.799,1729,5.11,1730,5.11,1731,5.11,1732,5.11,1733,3.799,1734,3.799,1735,3.799,1736,3.799,1737,3.799,1738,3.799,1739,3.799,1740,3.799,1741,3.799,1742,3.799,1743,3.799,1744,3.799,1745,3.799,1746,3.799,1747,3.799,1748,3.799,1749,3.799,1750,3.799,1751,4.942,1752,5.11,1753,3.799,1754,3.799,1755,3.799,1756,3.799,1757,3.799,1758,3.799,1759,3.799,1760,3.799,1761,3.799,1762,3.799,1763,3.799,1764,5.774,1765,3.799,1766,3.799,1767,3.799,1768,3.799,1769,3.799,1770,3.252,1771,3.799,1772,3.799,1773,3.799,1774,3.799,1775,3.799,1776,3.799,1777,3.799,1778,5.11,1779,3.799,1780,3.799,1781,3.799,1782,3.799,1783,5.11,1784,5.774,1785,3.799,1786,3.799,1787,3.799,1788,3.799,1789,3.799,1790,3.799,1791,3.799,1792,3.799,1793,3.799,1794,3.799,1795,3.799,1796,3.799,1797,5.11,1798,3.799,1799,3.799,1800,3.799,1801,3.799,1802,3.799,1803,3.799,1804,3.799,1805,3.799,1806,3.799,1807,3.799,1808,3.799,1809,3.799,1810,3.799,1811,3.799,1812,3.799,1813,3.799,1814,3.799,1815,4.374,1816,3.252]],["title/license.html",[242,0.518,375,0.581,654,1.793]],["body/license.html",[0,0.348,3,0.367,4,0.275,10,0.017,20,0.424,39,1.708,58,0.018,68,0.631,69,0.392,72,0.595,84,0.108,88,0.679,89,1.031,112,1.105,134,0.412,146,0.679,148,0.809,152,3.015,158,0.763,172,2.17,189,1.616,228,0.854,233,2.32,238,0.902,243,0.763,244,0.729,267,0.108,290,0.682,296,2.32,312,2.17,316,3.144,360,2.637,383,3.523,388,0.979,396,2.32,426,1.917,437,0.854,438,1.129,439,1.616,454,0.729,457,3.004,458,1.105,471,0.809,495,0.015,501,2.844,519,0.902,520,3.226,541,1.004,557,0.763,578,1.167,587,0.854,593,4.708,596,0.902,606,4.708,633,4.088,648,2.491,649,5.058,652,2.691,654,4.471,655,4.522,656,4.088,657,3.865,658,1.295,659,4.21,660,2.932,661,3.784,662,2.932,664,4.21,665,4.453,666,4.453,667,3.796,668,4.644,669,3.796,670,4.809,671,5.058,672,3.796,673,3.796,674,3.796,675,2.691,676,2.932,677,2.932,678,2.32,715,1.058,717,1.115,719,1.603,721,1.058,726,2.058,732,1.058,734,1.854,735,1.441,737,1.444,743,1.115,754,1.058,763,1.115,768,1.521,769,1.058,771,1.175,773,1.849,775,1.88,784,1.115,791,1.849,794,1.444,802,1.694,806,1.238,814,1.88,825,1.928,826,2.173,827,1.785,830,1.115,846,1.687,847,1.444,851,1.797,855,1.603,861,1.732,876,1.238,877,1.238,957,1.058,975,1.238,984,1.238,1047,1.687,1108,1.519,1129,1.694,1177,1.238,1267,3.796,1282,4.708,1303,3.636,1352,4.91,1364,2.932,1366,3.233,1368,3.233,1369,5.21,1381,4.186,1424,3.636,1435,3.233,1482,3.636,1520,3.636,1546,3.233,1564,3.636,1585,3.636,1599,3.636,1672,3.636,1674,5.221,1685,3.636,1687,3.636,1689,5.221,1705,6.573,1722,3.636,1751,3.636,1770,3.636,1815,6.045,1816,5.522,1817,4.248,1818,4.248,1819,4.248,1820,7.137,1821,6.452,1822,6.1,1823,7.389,1824,7.292,1825,7.199,1826,6.846,1827,7.249,1828,6.683,1829,4.248,1830,6.1,1831,4.248,1832,4.248,1833,5.5,1834,5.5,1835,5.5,1836,4.248,1837,5.5,1838,4.248,1839,4.248,1840,4.248,1841,4.248,1842,4.248,1843,4.248,1844,6.1,1845,5.5,1846,6.846,1847,4.248,1848,4.248,1849,4.248,1850,4.248,1851,4.248,1852,6.1,1853,7.435,1854,5.5,1855,7.472,1856,4.248,1857,4.248,1858,4.248,1859,4.248,1860,5.5,1861,4.248,1862,5.5,1863,4.248,1864,4.248,1865,6.452,1866,5.5,1867,6.683,1868,5.5,1869,4.248,1870,4.248,1871,4.248,1872,4.248,1873,4.248,1874,6.1,1875,4.248,1876,5.5,1877,4.248,1878,7.199,1879,4.248,1880,5.5,1881,6.452,1882,5.5,1883,5.5,1884,5.5,1885,5.5,1886,6.1,1887,5.5,1888,5.5,1889,5.5,1890,6.1,1891,4.248,1892,5.5,1893,4.248,1894,6.968,1895,5.5,1896,5.5,1897,4.248,1898,6.1,1899,4.248,1900,6.1,1901,6.1,1902,4.248,1903,4.248,1904,4.248,1905,5.5,1906,4.248,1907,4.248,1908,4.248,1909,4.248,1910,4.248,1911,4.248,1912,6.1,1913,4.248,1914,4.248,1915,4.248,1916,4.248,1917,4.248,1918,4.248,1919,4.248,1920,4.248,1921,6.1,1922,5.5,1923,4.248,1924,4.248,1925,4.248,1926,4.248,1927,5.5,1928,4.248,1929,4.248,1930,4.248,1931,4.248,1932,4.248,1933,4.248,1934,4.248,1935,4.248,1936,4.248,1937,6.452,1938,4.248,1939,4.248,1940,4.248,1941,4.248,1942,4.248,1943,4.248,1944,4.248,1945,4.248,1946,4.248,1947,4.248,1948,4.248,1949,4.248,1950,4.248,1951,4.248,1952,5.5,1953,4.248,1954,6.683,1955,4.248,1956,4.248,1957,5.5,1958,4.248,1959,4.248,1960,4.248,1961,6.683,1962,4.248,1963,4.248,1964,4.248,1965,4.248,1966,4.248,1967,5.5,1968,4.248,1969,4.248,1970,4.248,1971,4.248,1972,4.248,1973,4.248,1974,4.248,1975,4.248,1976,4.248,1977,5.5,1978,4.248,1979,4.248,1980,4.248,1981,4.248,1982,4.248,1983,4.248,1984,4.248,1985,5.5,1986,5.5,1987,4.248,1988,4.248,1989,4.248,1990,4.248,1991,4.248]],["title/modules.html",[1992,4.26]],["body/modules.html",[10,0.018,58,0.018,495,0.018,1992,5.12]],["title/overview.html",[1993,4.26]],["body/overview.html",[0,0.49,10,0.018,58,0.018,84,0.152,495,0.018,1993,5.11,1994,5.971,1995,5.971]],["title/miscellaneous/typealiases.html",[1647,1.561,1996,4.393]],["body/miscellaneous/typealiases.html",[6,0.187,10,0.018,49,1.128,58,0.018,267,0.184,495,0.018,687,1.637,689,1.951,735,1.666,1218,4.505,1283,6.037,1647,3.024,1649,5.761,1997,5.919,1998,5.067]],["title/miscellaneous/variables.html",[165,1.671,1647,1.561]],["body/miscellaneous/variables.html",[5,2.682,6,0.155,10,0.021,12,0.568,14,0.511,17,0.342,36,1.109,39,1.975,43,3.079,46,2.171,58,0.016,68,0.699,75,0.799,81,3.562,82,2.682,83,2.682,84,0.184,85,2.682,87,1.203,90,1.215,93,0.757,98,3.292,129,0.928,130,0.971,131,1.392,132,3.74,133,2.97,134,0.413,135,2.509,136,1.205,137,2.355,147,0.997,148,0.865,165,1.868,167,2.72,168,2.89,174,0.785,176,0.568,189,2.293,243,0.883,244,0.651,267,0.194,284,0.568,315,0.883,317,2.509,381,3.763,415,0.698,423,0.852,426,2.72,471,0.977,474,2.565,495,0.016,497,3.112,502,4.132,503,2.881,504,2.509,505,2.881,507,4.132,508,3.112,509,4.132,510,3.112,587,0.987,602,3.474,754,1.223,838,0.883,914,1.223,1036,1.523,1037,1.223,1134,1.73,1193,3.825,1217,3.535,1218,3.738,1239,5.582,1240,5.16,1241,4.204,1242,4.204,1243,4.204,1349,4.964,1413,3.39,1431,5.582,1432,4.204,1433,4.204,1434,3.738,1435,3.738,1436,4.204,1437,4.204,1438,5.582,1439,4.204,1440,6.267,1441,5.054,1442,5.582,1443,4.204,1444,5.582,1445,5.16,1446,5.582,1447,5.16,1448,5.582,1449,5.16,1450,5.582,1451,4.204,1452,5.582,1453,5.582,1454,5.582,1647,2.509,1650,3.738,1651,5.607,1652,3.738,1998,4.204,1999,4.912,2000,4.912,2001,6.522,2002,4.912]]],"invertedIndex":[["",{"_index":10,"title":{},"body":{"interfaces/ADCCallback.html":{},"interfaces/ADCResponse.html":{},"interfaces/BodyResponseCallback.html":{},"interfaces/ComputeOptions.html":{},"interfaces/CredentialBody.html":{},"interfaces/CredentialCallback.html":{},"interfaces/CredentialRequest.html":{},"interfaces/Credentials.html":{},"classes/DefaultTransporter.html":{},"interfaces/FederatedSignonCertsResponse.html":{},"interfaces/GetAccessTokenCallback.html":{},"interfaces/GetAccessTokenResponse.html":{},"interfaces/GetFederatedSignonCertsCallback.html":{},"interfaces/GetTokenCallback.html":{},"interfaces/GetTokenOptions.html":{},"interfaces/GetTokenResponse.html":{},"interfaces/GoogleAuthOptions.html":{},"classes/IAMAuth.html":{},"classes/JWTAccess.html":{},"interfaces/JWTInput.html":{},"interfaces/JWTOptions.html":{},"classes/LoginTicket.html":{},"interfaces/OAuth2ClientOptions.html":{},"classes/PemVerifier.html":{},"interfaces/ProjectIdCallback.html":{},"interfaces/RefreshAccessTokenCallback.html":{},"interfaces/RefreshAccessTokenResponse.html":{},"interfaces/RefreshOptions.html":{},"interfaces/RequestError.html":{},"interfaces/RequestMetadata.html":{},"interfaces/RequestMetadataCallback.html":{},"interfaces/RequestMetadataResponse.html":{},"interfaces/RevokeCredentialsResult.html":{},"interfaces/SignBlobResponse.html":{},"interfaces/TokenInfo.html":{},"interfaces/TokenInfoRequest.html":{},"interfaces/TokenPayload.html":{},"interfaces/Transporter.html":{},"interfaces/UserRefreshClientOptions.html":{},"interfaces/VerifyIdTokenOptions.html":{},"interfaces/Warning.html":{},"changelog.html":{},"dependencies.html":{},"miscellaneous/enumerations.html":{},"miscellaneous/functions.html":{},"index.html":{},"license.html":{},"modules.html":{},"overview.html":{},"miscellaneous/typealiases.html":{},"miscellaneous/variables.html":{}}}],["0",{"_index":256,"title":{},"body":{"interfaces/ADCCallback.html":{},"interfaces/ADCResponse.html":{},"interfaces/CredentialCallback.html":{},"interfaces/GoogleAuthOptions.html":{},"interfaces/JWTOptions.html":{},"interfaces/ProjectIdCallback.html":{},"interfaces/SignBlobResponse.html":{}}}],["0.12.0",{"_index":1590,"title":{},"body":{"changelog.html":{}}}],["0.13.0",{"_index":1478,"title":{},"body":{"changelog.html":{}}}],["0.18.0",{"_index":1640,"title":{},"body":{"dependencies.html":{}}}],["0.7.0",{"_index":1641,"title":{},"body":{"dependencies.html":{}}}],["1",{"_index":596,"title":{},"body":{"interfaces/ComputeOptions.html":{},"interfaces/FederatedSignonCertsResponse.html":{},"interfaces/GetAccessTokenCallback.html":{},"interfaces/GetAccessTokenResponse.html":{},"interfaces/GetFederatedSignonCertsCallback.html":{},"interfaces/GetTokenCallback.html":{},"interfaces/GetTokenOptions.html":{},"interfaces/GetTokenResponse.html":{},"classes/JWTAccess.html":{},"interfaces/JWTOptions.html":{},"classes/LoginTicket.html":{},"interfaces/OAuth2ClientOptions.html":{},"interfaces/RefreshAccessTokenCallback.html":{},"interfaces/RefreshAccessTokenResponse.html":{},"interfaces/RefreshOptions.html":{},"interfaces/RequestMetadataCallback.html":{},"interfaces/RequestMetadataResponse.html":{},"interfaces/RevokeCredentialsResult.html":{},"interfaces/TokenInfo.html":{},"interfaces/TokenInfoRequest.html":{},"interfaces/TokenPayload.html":{},"interfaces/VerifyIdTokenOptions.html":{},"index.html":{},"license.html":{}}}],["1.x",{"_index":1667,"title":{},"body":{"index.html":{}}}],["10",{"_index":1994,"title":{},"body":{"overview.html":{}}}],["1000",{"_index":619,"title":{},"body":{"interfaces/ComputeOptions.html":{},"interfaces/FederatedSignonCertsResponse.html":{},"interfaces/GetAccessTokenCallback.html":{},"interfaces/GetAccessTokenResponse.html":{},"interfaces/GetFederatedSignonCertsCallback.html":{},"interfaces/GetTokenCallback.html":{},"interfaces/GetTokenOptions.html":{},"interfaces/GetTokenResponse.html":{},"classes/JWTAccess.html":{},"interfaces/OAuth2ClientOptions.html":{},"interfaces/RefreshAccessTokenCallback.html":{},"interfaces/RefreshAccessTokenResponse.html":{},"interfaces/RefreshOptions.html":{},"interfaces/RequestMetadataCallback.html":{},"interfaces/RequestMetadataResponse.html":{},"interfaces/RevokeCredentialsResult.html":{},"interfaces/TokenInfo.html":{},"interfaces/TokenInfoRequest.html":{},"interfaces/VerifyIdTokenOptions.html":{}}}],["2",{"_index":1671,"title":{},"body":{"index.html":{}}}],["2.0",{"_index":658,"title":{},"body":{"interfaces/Credentials.html":{},"interfaces/FederatedSignonCertsResponse.html":{},"interfaces/GetAccessTokenCallback.html":{},"interfaces/GetAccessTokenResponse.html":{},"interfaces/GetFederatedSignonCertsCallback.html":{},"interfaces/GetTokenCallback.html":{},"interfaces/GetTokenOptions.html":{},"interfaces/GetTokenResponse.html":{},"classes/LoginTicket.html":{},"interfaces/OAuth2ClientOptions.html":{},"interfaces/RefreshAccessTokenCallback.html":{},"interfaces/RefreshAccessTokenResponse.html":{},"interfaces/RefreshOptions.html":{},"interfaces/RequestMetadataCallback.html":{},"interfaces/RequestMetadataResponse.html":{},"interfaces/RevokeCredentialsResult.html":{},"interfaces/TokenInfo.html":{},"interfaces/TokenInfoRequest.html":{},"interfaces/TokenPayload.html":{},"interfaces/VerifyIdTokenOptions.html":{},"changelog.html":{},"miscellaneous/functions.html":{},"index.html":{},"license.html":{}}}],["2.0unless",{"_index":663,"title":{},"body":{"interfaces/Credentials.html":{},"classes/LoginTicket.html":{},"miscellaneous/functions.html":{}}}],["2.2.1",{"_index":1643,"title":{},"body":{"dependencies.html":{}}}],["2.3.0",{"_index":1642,"title":{},"body":{"dependencies.html":{}}}],["200",{"_index":563,"title":{},"body":{"interfaces/BodyResponseCallback.html":{},"classes/DefaultTransporter.html":{},"interfaces/RequestError.html":{},"interfaces/Transporter.html":{}}}],["2004",{"_index":1818,"title":{},"body":{"license.html":{}}}],["2014",{"_index":650,"title":{},"body":{"interfaces/Credentials.html":{},"classes/LoginTicket.html":{}}}],["2017",{"_index":1663,"title":{},"body":{"miscellaneous/functions.html":{}}}],["3",{"_index":365,"title":{},"body":{"interfaces/ADCCallback.html":{},"interfaces/ADCResponse.html":{},"interfaces/CredentialCallback.html":{},"interfaces/GoogleAuthOptions.html":{},"classes/LoginTicket.html":{},"interfaces/ProjectIdCallback.html":{},"interfaces/SignBlobResponse.html":{},"interfaces/TokenPayload.html":{}}}],["3).tolowercas",{"_index":367,"title":{},"body":{"interfaces/ADCCallback.html":{},"interfaces/ADCResponse.html":{},"interfaces/CredentialCallback.html":{},"interfaces/GoogleAuthOptions.html":{},"interfaces/ProjectIdCallback.html":{},"interfaces/SignBlobResponse.html":{}}}],["3.0",{"_index":132,"title":{},"body":{"interfaces/ADCCallback.html":{},"interfaces/ADCResponse.html":{},"interfaces/CredentialCallback.html":{},"interfaces/GoogleAuthOptions.html":{},"interfaces/ProjectIdCallback.html":{},"interfaces/SignBlobResponse.html":{},"interfaces/Warning.html":{},"miscellaneous/variables.html":{}}}],["3.1.5",{"_index":1644,"title":{},"body":{"dependencies.html":{}}}],["300",{"_index":947,"title":{},"body":{"interfaces/FederatedSignonCertsResponse.html":{},"interfaces/GetAccessTokenCallback.html":{},"interfaces/GetAccessTokenResponse.html":{},"interfaces/GetFederatedSignonCertsCallback.html":{},"interfaces/GetTokenCallback.html":{},"interfaces/GetTokenOptions.html":{},"interfaces/GetTokenResponse.html":{},"interfaces/OAuth2ClientOptions.html":{},"interfaces/RefreshAccessTokenCallback.html":{},"interfaces/RefreshAccessTokenResponse.html":{},"interfaces/RefreshOptions.html":{},"interfaces/RequestMetadataCallback.html":{},"interfaces/RequestMetadataResponse.html":{},"interfaces/RevokeCredentialsResult.html":{},"interfaces/TokenInfo.html":{},"interfaces/TokenInfoRequest.html":{},"interfaces/VerifyIdTokenOptions.html":{}}}],["300000",{"_index":901,"title":{},"body":{"interfaces/FederatedSignonCertsResponse.html":{},"interfaces/GetAccessTokenCallback.html":{},"interfaces/GetAccessTokenResponse.html":{},"interfaces/GetFederatedSignonCertsCallback.html":{},"interfaces/GetTokenCallback.html":{},"interfaces/GetTokenOptions.html":{},"interfaces/GetTokenResponse.html":{},"interfaces/OAuth2ClientOptions.html":{},"interfaces/RefreshAccessTokenCallback.html":{},"interfaces/RefreshAccessTokenResponse.html":{},"interfaces/RefreshOptions.html":{},"interfaces/RequestMetadataCallback.html":{},"interfaces/RequestMetadataResponse.html":{},"interfaces/RevokeCredentialsResult.html":{},"interfaces/TokenInfo.html":{},"interfaces/TokenInfoRequest.html":{},"interfaces/VerifyIdTokenOptions.html":{}}}],["3600",{"_index":1258,"title":{},"body":{"classes/JWTAccess.html":{}}}],["37",{"_index":1995,"title":{},"body":{"overview.html":{}}}],["385",{"_index":1576,"title":{},"body":{"changelog.html":{}}}],["386",{"_index":1639,"title":{},"body":{"changelog.html":{}}}],["387",{"_index":1637,"title":{},"body":{"changelog.html":{}}}],["388",{"_index":1635,"title":{},"body":{"changelog.html":{}}}],["394",{"_index":1634,"title":{},"body":{"changelog.html":{}}}],["397",{"_index":1631,"title":{},"body":{"changelog.html":{}}}],["399",{"_index":1573,"title":{},"body":{"changelog.html":{}}}],["4",{"_index":1582,"title":{},"body":{"changelog.html":{}}}],["4.x",{"_index":1536,"title":{},"body":{"changelog.html":{}}}],["400",{"_index":574,"title":{},"body":{"interfaces/BodyResponseCallback.html":{},"classes/DefaultTransporter.html":{},"interfaces/RequestError.html":{},"interfaces/Transporter.html":{},"changelog.html":{}}}],["401",{"_index":1095,"title":{},"body":{"interfaces/FederatedSignonCertsResponse.html":{},"interfaces/GetAccessTokenCallback.html":{},"interfaces/GetAccessTokenResponse.html":{},"interfaces/GetFederatedSignonCertsCallback.html":{},"interfaces/GetTokenCallback.html":{},"interfaces/GetTokenOptions.html":{},"interfaces/GetTokenResponse.html":{},"interfaces/OAuth2ClientOptions.html":{},"interfaces/RefreshAccessTokenCallback.html":{},"interfaces/RefreshAccessTokenResponse.html":{},"interfaces/RefreshOptions.html":{},"interfaces/RequestMetadataCallback.html":{},"interfaces/RequestMetadataResponse.html":{},"interfaces/RevokeCredentialsResult.html":{},"interfaces/TokenInfo.html":{},"interfaces/TokenInfoRequest.html":{},"interfaces/VerifyIdTokenOptions.html":{},"changelog.html":{}}}],["402",{"_index":1581,"title":{},"body":{"changelog.html":{}}}],["403",{"_index":629,"title":{},"body":{"interfaces/ComputeOptions.html":{},"interfaces/FederatedSignonCertsResponse.html":{},"interfaces/GetAccessTokenCallback.html":{},"interfaces/GetAccessTokenResponse.html":{},"interfaces/GetFederatedSignonCertsCallback.html":{},"interfaces/GetTokenCallback.html":{},"interfaces/GetTokenOptions.html":{},"interfaces/GetTokenResponse.html":{},"interfaces/OAuth2ClientOptions.html":{},"interfaces/RefreshAccessTokenCallback.html":{},"interfaces/RefreshAccessTokenResponse.html":{},"interfaces/RefreshOptions.html":{},"interfaces/RequestMetadataCallback.html":{},"interfaces/RequestMetadataResponse.html":{},"interfaces/RevokeCredentialsResult.html":{},"interfaces/TokenInfo.html":{},"interfaces/TokenInfoRequest.html":{},"interfaces/VerifyIdTokenOptions.html":{}}}],["404",{"_index":634,"title":{},"body":{"interfaces/ComputeOptions.html":{},"interfaces/FederatedSignonCertsResponse.html":{},"interfaces/GetAccessTokenCallback.html":{},"interfaces/GetAccessTokenResponse.html":{},"interfaces/GetFederatedSignonCertsCallback.html":{},"interfaces/GetTokenCallback.html":{},"interfaces/GetTokenOptions.html":{},"interfaces/GetTokenResponse.html":{},"interfaces/OAuth2ClientOptions.html":{},"interfaces/RefreshAccessTokenCallback.html":{},"interfaces/RefreshAccessTokenResponse.html":{},"interfaces/RefreshOptions.html":{},"interfaces/RequestMetadataCallback.html":{},"interfaces/RequestMetadataResponse.html":{},"interfaces/RevokeCredentialsResult.html":{},"interfaces/TokenInfo.html":{},"interfaces/TokenInfoRequest.html":{},"interfaces/VerifyIdTokenOptions.html":{},"changelog.html":{}}}],["405",{"_index":1559,"title":{},"body":{"changelog.html":{}}}],["409",{"_index":1571,"title":{},"body":{"changelog.html":{}}}],["410",{"_index":1578,"title":{},"body":{"changelog.html":{}}}],["411",{"_index":1580,"title":{},"body":{"changelog.html":{}}}],["412",{"_index":1630,"title":{},"body":{"changelog.html":{}}}],["413",{"_index":1567,"title":{},"body":{"changelog.html":{}}}],["414",{"_index":1577,"title":{},"body":{"changelog.html":{}}}],["415",{"_index":1629,"title":{},"body":{"changelog.html":{}}}],["417",{"_index":1579,"title":{},"body":{"changelog.html":{}}}],["420",{"_index":1627,"title":{},"body":{"changelog.html":{}}}],["422",{"_index":1625,"title":{},"body":{"changelog.html":{}}}],["423",{"_index":1565,"title":{},"body":{"changelog.html":{}}}],["424",{"_index":1623,"title":{},"body":{"changelog.html":{}}}],["425",{"_index":1621,"title":{},"body":{"changelog.html":{}}}],["428",{"_index":1622,"title":{},"body":{"changelog.html":{}}}],["430",{"_index":1616,"title":{},"body":{"changelog.html":{}}}],["431",{"_index":1619,"title":{},"body":{"changelog.html":{}}}],["432",{"_index":1618,"title":{},"body":{"changelog.html":{}}}],["434",{"_index":1562,"title":{},"body":{"changelog.html":{}}}],["437",{"_index":1561,"title":{},"body":{"changelog.html":{}}}],["440",{"_index":1612,"title":{},"body":{"changelog.html":{}}}],["442",{"_index":1606,"title":{},"body":{"changelog.html":{}}}],["443",{"_index":1609,"title":{},"body":{"changelog.html":{}}}],["445",{"_index":1604,"title":{},"body":{"changelog.html":{}}}],["446",{"_index":1601,"title":{},"body":{"changelog.html":{}}}],["447",{"_index":1598,"title":{},"body":{"changelog.html":{}}}],["448",{"_index":1592,"title":{},"body":{"changelog.html":{}}}],["450",{"_index":1558,"title":{},"body":{"changelog.html":{}}}],["452",{"_index":1595,"title":{},"body":{"changelog.html":{}}}],["453",{"_index":1591,"title":{},"body":{"changelog.html":{}}}],["454",{"_index":1589,"title":{},"body":{"changelog.html":{}}}],["455",{"_index":1586,"title":{},"body":{"changelog.html":{}}}],["459",{"_index":1488,"title":{},"body":{"changelog.html":{}}}],["462",{"_index":1528,"title":{},"body":{"changelog.html":{}}}],["465",{"_index":1527,"title":{},"body":{"changelog.html":{}}}],["467",{"_index":1463,"title":{},"body":{"changelog.html":{}}}],["468",{"_index":1525,"title":{},"body":{"changelog.html":{}}}],["469",{"_index":1486,"title":{},"body":{"changelog.html":{}}}],["470",{"_index":1461,"title":{},"body":{"changelog.html":{}}}],["471",{"_index":1523,"title":{},"body":{"changelog.html":{}}}],["472",{"_index":1483,"title":{},"body":{"changelog.html":{}}}],["473",{"_index":1522,"title":{},"body":{"changelog.html":{}}}],["477",{"_index":1519,"title":{},"body":{"changelog.html":{}}}],["478",{"_index":1517,"title":{},"body":{"changelog.html":{}}}],["479",{"_index":1514,"title":{},"body":{"changelog.html":{}}}],["482",{"_index":1513,"title":{},"body":{"changelog.html":{}}}],["483",{"_index":1481,"title":{},"body":{"changelog.html":{}}}],["488",{"_index":1460,"title":{},"body":{"changelog.html":{}}}],["489",{"_index":1512,"title":{},"body":{"changelog.html":{}}}],["490",{"_index":1509,"title":{},"body":{"changelog.html":{}}}],["494",{"_index":1506,"title":{},"body":{"changelog.html":{}}}],["495",{"_index":1505,"title":{},"body":{"changelog.html":{}}}],["497",{"_index":1479,"title":{},"body":{"changelog.html":{}}}],["499",{"_index":1476,"title":{},"body":{"changelog.html":{}}}],["4xx",{"_index":576,"title":{},"body":{"interfaces/BodyResponseCallback.html":{},"classes/DefaultTransporter.html":{},"interfaces/RequestError.html":{},"interfaces/Transporter.html":{}}}],["5",{"_index":902,"title":{},"body":{"interfaces/FederatedSignonCertsResponse.html":{},"interfaces/GetAccessTokenCallback.html":{},"interfaces/GetAccessTokenResponse.html":{},"interfaces/GetFederatedSignonCertsCallback.html":{},"interfaces/GetTokenCallback.html":{},"interfaces/GetTokenOptions.html":{},"interfaces/GetTokenResponse.html":{},"interfaces/OAuth2ClientOptions.html":{},"interfaces/RefreshAccessTokenCallback.html":{},"interfaces/RefreshAccessTokenResponse.html":{},"interfaces/RefreshOptions.html":{},"interfaces/RequestMetadataCallback.html":{},"interfaces/RequestMetadataResponse.html":{},"interfaces/RevokeCredentialsResult.html":{},"interfaces/TokenInfo.html":{},"interfaces/TokenInfoRequest.html":{},"interfaces/VerifyIdTokenOptions.html":{}}}],["5.0.0",{"_index":1645,"title":{},"body":{"dependencies.html":{}}}],["5.5.0",{"_index":1646,"title":{},"body":{"dependencies.html":{}}}],["50",{"_index":1840,"title":{},"body":{"license.html":{}}}],["500",{"_index":1245,"title":{},"body":{"classes/JWTAccess.html":{},"changelog.html":{}}}],["501",{"_index":1467,"title":{},"body":{"changelog.html":{}}}],["502",{"_index":1470,"title":{},"body":{"changelog.html":{}}}],["503",{"_index":1473,"title":{},"body":{"changelog.html":{}}}],["504",{"_index":1500,"title":{},"body":{"changelog.html":{}}}],["506",{"_index":1497,"title":{},"body":{"changelog.html":{}}}],["507",{"_index":1494,"title":{},"body":{"changelog.html":{}}}],["509",{"_index":1492,"title":{},"body":{"changelog.html":{}}}],["5xx",{"_index":577,"title":{},"body":{"interfaces/BodyResponseCallback.html":{},"classes/DefaultTransporter.html":{},"interfaces/RequestError.html":{},"interfaces/Transporter.html":{}}}],["6",{"_index":972,"title":{},"body":{"interfaces/FederatedSignonCertsResponse.html":{},"interfaces/GetAccessTokenCallback.html":{},"interfaces/GetAccessTokenResponse.html":{},"interfaces/GetFederatedSignonCertsCallback.html":{},"interfaces/GetTokenCallback.html":{},"interfaces/GetTokenOptions.html":{},"interfaces/GetTokenResponse.html":{},"interfaces/OAuth2ClientOptions.html":{},"interfaces/RefreshAccessTokenCallback.html":{},"interfaces/RefreshAccessTokenResponse.html":{},"interfaces/RefreshOptions.html":{},"interfaces/RequestMetadataCallback.html":{},"interfaces/RequestMetadataResponse.html":{},"interfaces/RevokeCredentialsResult.html":{},"interfaces/TokenInfo.html":{},"interfaces/TokenInfoRequest.html":{},"interfaces/VerifyIdTokenOptions.html":{},"interfaces/Warning.html":{}}}],["6*128/8",{"_index":978,"title":{},"body":{"interfaces/FederatedSignonCertsResponse.html":{},"interfaces/GetAccessTokenCallback.html":{},"interfaces/GetAccessTokenResponse.html":{},"interfaces/GetFederatedSignonCertsCallback.html":{},"interfaces/GetTokenCallback.html":{},"interfaces/GetTokenOptions.html":{},"interfaces/GetTokenResponse.html":{},"interfaces/OAuth2ClientOptions.html":{},"interfaces/RefreshAccessTokenCallback.html":{},"interfaces/RefreshAccessTokenResponse.html":{},"interfaces/RefreshOptions.html":{},"interfaces/RequestMetadataCallback.html":{},"interfaces/RequestMetadataResponse.html":{},"interfaces/RevokeCredentialsResult.html":{},"interfaces/TokenInfo.html":{},"interfaces/TokenInfoRequest.html":{},"interfaces/VerifyIdTokenOptions.html":{}}}],["6.0.0",{"_index":1638,"title":{},"body":{"changelog.html":{}}}],["60",{"_index":929,"title":{},"body":{"interfaces/FederatedSignonCertsResponse.html":{},"interfaces/GetAccessTokenCallback.html":{},"interfaces/GetAccessTokenResponse.html":{},"interfaces/GetFederatedSignonCertsCallback.html":{},"interfaces/GetTokenCallback.html":{},"interfaces/GetTokenOptions.html":{},"interfaces/GetTokenResponse.html":{},"classes/JWTAccess.html":{},"interfaces/OAuth2ClientOptions.html":{},"interfaces/RefreshAccessTokenCallback.html":{},"interfaces/RefreshAccessTokenResponse.html":{},"interfaces/RefreshOptions.html":{},"interfaces/RequestMetadataCallback.html":{},"interfaces/RequestMetadataResponse.html":{},"interfaces/RevokeCredentialsResult.html":{},"interfaces/TokenInfo.html":{},"interfaces/TokenInfoRequest.html":{},"interfaces/VerifyIdTokenOptions.html":{}}}],["6qr4p6gpi6hn506pt8ejuq83di341hur.apps.googleusercontent.com",{"_index":83,"title":{},"body":{"interfaces/ADCCallback.html":{},"interfaces/ADCResponse.html":{},"interfaces/CredentialCallback.html":{},"interfaces/GoogleAuthOptions.html":{},"interfaces/ProjectIdCallback.html":{},"interfaces/SignBlobResponse.html":{},"miscellaneous/variables.html":{}}}],["764086051850",{"_index":82,"title":{},"body":{"interfaces/ADCCallback.html":{},"interfaces/ADCResponse.html":{},"interfaces/CredentialCallback.html":{},"interfaces/GoogleAuthOptions.html":{},"interfaces/ProjectIdCallback.html":{},"interfaces/SignBlobResponse.html":{},"miscellaneous/variables.html":{}}}],["8",{"_index":1421,"title":{},"body":{"interfaces/Warning.html":{}}}],["86400",{"_index":952,"title":{},"body":{"interfaces/FederatedSignonCertsResponse.html":{},"interfaces/GetAccessTokenCallback.html":{},"interfaces/GetAccessTokenResponse.html":{},"interfaces/GetFederatedSignonCertsCallback.html":{},"interfaces/GetTokenCallback.html":{},"interfaces/GetTokenOptions.html":{},"interfaces/GetTokenResponse.html":{},"interfaces/OAuth2ClientOptions.html":{},"interfaces/RefreshAccessTokenCallback.html":{},"interfaces/RefreshAccessTokenResponse.html":{},"interfaces/RefreshOptions.html":{},"interfaces/RequestMetadataCallback.html":{},"interfaces/RequestMetadataResponse.html":{},"interfaces/RevokeCredentialsResult.html":{},"interfaces/TokenInfo.html":{},"interfaces/TokenInfoRequest.html":{},"interfaces/VerifyIdTokenOptions.html":{}}}],["9",{"_index":984,"title":{},"body":{"interfaces/FederatedSignonCertsResponse.html":{},"interfaces/GetAccessTokenCallback.html":{},"interfaces/GetAccessTokenResponse.html":{},"interfaces/GetFederatedSignonCertsCallback.html":{},"interfaces/GetTokenCallback.html":{},"interfaces/GetTokenOptions.html":{},"interfaces/GetTokenResponse.html":{},"interfaces/OAuth2ClientOptions.html":{},"interfaces/RefreshAccessTokenCallback.html":{},"interfaces/RefreshAccessTokenResponse.html":{},"interfaces/RefreshOptions.html":{},"interfaces/RequestMetadataCallback.html":{},"interfaces/RequestMetadataResponse.html":{},"interfaces/RevokeCredentialsResult.html":{},"interfaces/TokenInfo.html":{},"interfaces/TokenInfoRequest.html":{},"interfaces/VerifyIdTokenOptions.html":{},"license.html":{}}}],["9.x",{"_index":1537,"title":{},"body":{"changelog.html":{}}}],["96",{"_index":979,"title":{},"body":{"interfaces/FederatedSignonCertsResponse.html":{},"interfaces/GetAccessTokenCallback.html":{},"interfaces/GetAccessTokenResponse.html":{},"interfaces/GetFederatedSignonCertsCallback.html":{},"interfaces/GetTokenCallback.html":{},"interfaces/GetTokenOptions.html":{},"interfaces/GetTokenResponse.html":{},"interfaces/OAuth2ClientOptions.html":{},"interfaces/RefreshAccessTokenCallback.html":{},"interfaces/RefreshAccessTokenResponse.html":{},"interfaces/RefreshOptions.html":{},"interfaces/RequestMetadataCallback.html":{},"interfaces/RequestMetadataResponse.html":{},"interfaces/RevokeCredentialsResult.html":{},"interfaces/TokenInfo.html":{},"interfaces/TokenInfoRequest.html":{},"interfaces/VerifyIdTokenOptions.html":{}}}],["_",{"_index":985,"title":{},"body":{"interfaces/FederatedSignonCertsResponse.html":{},"interfaces/GetAccessTokenCallback.html":{},"interfaces/GetAccessTokenResponse.html":{},"interfaces/GetFederatedSignonCertsCallback.html":{},"interfaces/GetTokenCallback.html":{},"interfaces/GetTokenOptions.html":{},"interfaces/GetTokenResponse.html":{},"interfaces/OAuth2ClientOptions.html":{},"interfaces/RefreshAccessTokenCallback.html":{},"interfaces/RefreshAccessTokenResponse.html":{},"interfaces/RefreshOptions.html":{},"interfaces/RequestMetadataCallback.html":{},"interfaces/RequestMetadataResponse.html":{},"interfaces/RevokeCredentialsResult.html":{},"interfaces/TokenInfo.html":{},"interfaces/TokenInfoRequest.html":{},"interfaces/VerifyIdTokenOptions.html":{}}}],["_').replace(/\\//g",{"_index":993,"title":{},"body":{"interfaces/FederatedSignonCertsResponse.html":{},"interfaces/GetAccessTokenCallback.html":{},"interfaces/GetAccessTokenResponse.html":{},"interfaces/GetFederatedSignonCertsCallback.html":{},"interfaces/GetTokenCallback.html":{},"interfaces/GetTokenOptions.html":{},"interfaces/GetTokenResponse.html":{},"interfaces/OAuth2ClientOptions.html":{},"interfaces/RefreshAccessTokenCallback.html":{},"interfaces/RefreshAccessTokenResponse.html":{},"interfaces/RefreshOptions.html":{},"interfaces/RequestMetadataCallback.html":{},"interfaces/RequestMetadataResponse.html":{},"interfaces/RevokeCredentialsResult.html":{},"interfaces/TokenInfo.html":{},"interfaces/TokenInfoRequest.html":{},"interfaces/VerifyIdTokenOptions.html":{}}}],["_cachedprojectid",{"_index":110,"title":{},"body":{"interfaces/ADCCallback.html":{},"interfaces/ADCResponse.html":{},"interfaces/CredentialCallback.html":{},"interfaces/GoogleAuthOptions.html":{},"interfaces/ProjectIdCallback.html":{},"interfaces/SignBlobResponse.html":{}}}],["_checkisgc",{"_index":249,"title":{},"body":{"interfaces/ADCCallback.html":{},"interfaces/ADCResponse.html":{},"interfaces/CredentialCallback.html":{},"interfaces/GoogleAuthOptions.html":{},"interfaces/ProjectIdCallback.html":{},"interfaces/SignBlobResponse.html":{}}}],["_clientid",{"_index":912,"title":{},"body":{"interfaces/FederatedSignonCertsResponse.html":{},"interfaces/GetAccessTokenCallback.html":{},"interfaces/GetAccessTokenResponse.html":{},"interfaces/GetFederatedSignonCertsCallback.html":{},"interfaces/GetTokenCallback.html":{},"interfaces/GetTokenOptions.html":{},"interfaces/GetTokenResponse.html":{},"interfaces/OAuth2ClientOptions.html":{},"interfaces/RefreshAccessTokenCallback.html":{},"interfaces/RefreshAccessTokenResponse.html":{},"interfaces/RefreshOptions.html":{},"interfaces/RequestMetadataCallback.html":{},"interfaces/RequestMetadataResponse.html":{},"interfaces/RevokeCredentialsResult.html":{},"interfaces/TokenInfo.html":{},"interfaces/TokenInfoRequest.html":{},"interfaces/VerifyIdTokenOptions.html":{}}}],["_clientsecret",{"_index":913,"title":{},"body":{"interfaces/FederatedSignonCertsResponse.html":{},"interfaces/GetAccessTokenCallback.html":{},"interfaces/GetAccessTokenResponse.html":{},"interfaces/GetFederatedSignonCertsCallback.html":{},"interfaces/GetTokenCallback.html":{},"interfaces/GetTokenOptions.html":{},"interfaces/GetTokenResponse.html":{},"interfaces/OAuth2ClientOptions.html":{},"interfaces/RefreshAccessTokenCallback.html":{},"interfaces/RefreshAccessTokenResponse.html":{},"interfaces/RefreshOptions.html":{},"interfaces/RequestMetadataCallback.html":{},"interfaces/RequestMetadataResponse.html":{},"interfaces/RevokeCredentialsResult.html":{},"interfaces/TokenInfo.html":{},"interfaces/TokenInfoRequest.html":{},"interfaces/VerifyIdTokenOptions.html":{}}}],["_createreadstream(filepath",{"_index":373,"title":{},"body":{"interfaces/ADCCallback.html":{},"interfaces/ADCResponse.html":{},"interfaces/CredentialCallback.html":{},"interfaces/GoogleAuthOptions.html":{},"interfaces/ProjectIdCallback.html":{},"interfaces/SignBlobResponse.html":{}}}],["_fileexists(filepath",{"_index":379,"title":{},"body":{"interfaces/ADCCallback.html":{},"interfaces/ADCResponse.html":{},"interfaces/CredentialCallback.html":{},"interfaces/GoogleAuthOptions.html":{},"interfaces/ProjectIdCallback.html":{},"interfaces/SignBlobResponse.html":{}}}],["_getapplicationcredentialsfromfilepath",{"_index":289,"title":{},"body":{"interfaces/ADCCallback.html":{},"interfaces/ADCResponse.html":{},"interfaces/CredentialCallback.html":{},"interfaces/GoogleAuthOptions.html":{},"interfaces/ProjectIdCallback.html":{},"interfaces/SignBlobResponse.html":{}}}],["_getdefaultprojectidpromis",{"_index":108,"title":{},"body":{"interfaces/ADCCallback.html":{},"interfaces/ADCResponse.html":{},"interfaces/CredentialCallback.html":{},"interfaces/GoogleAuthOptions.html":{},"interfaces/ProjectIdCallback.html":{},"interfaces/SignBlobResponse.html":{}}}],["_iswindow",{"_index":361,"title":{},"body":{"interfaces/ADCCallback.html":{},"interfaces/ADCResponse.html":{},"interfaces/CredentialCallback.html":{},"interfaces/GoogleAuthOptions.html":{},"interfaces/ProjectIdCallback.html":{},"interfaces/SignBlobResponse.html":{}}}],["_mockwellknownfilepath(filepath",{"_index":387,"title":{},"body":{"interfaces/ADCCallback.html":{},"interfaces/ADCResponse.html":{},"interfaces/CredentialCallback.html":{},"interfaces/GoogleAuthOptions.html":{},"interfaces/ProjectIdCallback.html":{},"interfaces/SignBlobResponse.html":{}}}],["_osplatform",{"_index":377,"title":{},"body":{"interfaces/ADCCallback.html":{},"interfaces/ADCResponse.html":{},"interfaces/CredentialCallback.html":{},"interfaces/GoogleAuthOptions.html":{},"interfaces/ProjectIdCallback.html":{},"interfaces/SignBlobResponse.html":{}}}],["_pathjoin(item1",{"_index":384,"title":{},"body":{"interfaces/ADCCallback.html":{},"interfaces/ADCResponse.html":{},"interfaces/CredentialCallback.html":{},"interfaces/GoogleAuthOptions.html":{},"interfaces/ProjectIdCallback.html":{},"interfaces/SignBlobResponse.html":{}}}],["_propertynam",{"_index":1401,"title":{},"body":{"interfaces/UserRefreshClientOptions.html":{}}}],["_refreshtoken",{"_index":1405,"title":{},"body":{"interfaces/UserRefreshClientOptions.html":{}}}],["_trygetapplicationcredentialsfromenvironmentvari",{"_index":252,"title":{},"body":{"interfaces/ADCCallback.html":{},"interfaces/ADCResponse.html":{},"interfaces/CredentialCallback.html":{},"interfaces/GoogleAuthOptions.html":{},"interfaces/ProjectIdCallback.html":{},"interfaces/SignBlobResponse.html":{}}}],["_trygetapplicationcredentialsfromwellknownfil",{"_index":262,"title":{},"body":{"interfaces/ADCCallback.html":{},"interfaces/ADCResponse.html":{},"interfaces/CredentialCallback.html":{},"interfaces/GoogleAuthOptions.html":{},"interfaces/ProjectIdCallback.html":{},"interfaces/SignBlobResponse.html":{}}}],["abov",{"_index":877,"title":{},"body":{"interfaces/FederatedSignonCertsResponse.html":{},"interfaces/GetAccessTokenCallback.html":{},"interfaces/GetAccessTokenResponse.html":{},"interfaces/GetFederatedSignonCertsCallback.html":{},"interfaces/GetTokenCallback.html":{},"interfaces/GetTokenOptions.html":{},"interfaces/GetTokenResponse.html":{},"interfaces/OAuth2ClientOptions.html":{},"interfaces/RefreshAccessTokenCallback.html":{},"interfaces/RefreshAccessTokenResponse.html":{},"interfaces/RefreshOptions.html":{},"interfaces/RequestMetadataCallback.html":{},"interfaces/RequestMetadataResponse.html":{},"interfaces/RevokeCredentialsResult.html":{},"interfaces/TokenInfo.html":{},"interfaces/TokenInfoRequest.html":{},"interfaces/VerifyIdTokenOptions.html":{},"license.html":{}}}],["accept",{"_index":1129,"title":{},"body":{"interfaces/FederatedSignonCertsResponse.html":{},"interfaces/GetAccessTokenCallback.html":{},"interfaces/GetAccessTokenResponse.html":{},"interfaces/GetFederatedSignonCertsCallback.html":{},"interfaces/GetTokenCallback.html":{},"interfaces/GetTokenOptions.html":{},"interfaces/GetTokenResponse.html":{},"interfaces/OAuth2ClientOptions.html":{},"interfaces/RefreshAccessTokenCallback.html":{},"interfaces/RefreshAccessTokenResponse.html":{},"interfaces/RefreshOptions.html":{},"interfaces/RequestMetadataCallback.html":{},"interfaces/RequestMetadataResponse.html":{},"interfaces/RevokeCredentialsResult.html":{},"interfaces/TokenInfo.html":{},"interfaces/TokenInfoRequest.html":{},"interfaces/VerifyIdTokenOptions.html":{},"interfaces/Warning.html":{},"index.html":{},"license.html":{}}}],["access",{"_index":449,"title":{},"body":{"interfaces/ADCCallback.html":{},"interfaces/ADCResponse.html":{},"interfaces/ComputeOptions.html":{},"interfaces/CredentialCallback.html":{},"interfaces/FederatedSignonCertsResponse.html":{},"interfaces/GetAccessTokenCallback.html":{},"interfaces/GetAccessTokenResponse.html":{},"interfaces/GetFederatedSignonCertsCallback.html":{},"interfaces/GetTokenCallback.html":{},"interfaces/GetTokenOptions.html":{},"interfaces/GetTokenResponse.html":{},"interfaces/GoogleAuthOptions.html":{},"classes/JWTAccess.html":{},"interfaces/JWTOptions.html":{},"classes/LoginTicket.html":{},"interfaces/OAuth2ClientOptions.html":{},"interfaces/ProjectIdCallback.html":{},"interfaces/RefreshAccessTokenCallback.html":{},"interfaces/RefreshAccessTokenResponse.html":{},"interfaces/RefreshOptions.html":{},"interfaces/RequestMetadataCallback.html":{},"interfaces/RequestMetadataResponse.html":{},"interfaces/RevokeCredentialsResult.html":{},"interfaces/SignBlobResponse.html":{},"interfaces/TokenInfo.html":{},"interfaces/TokenInfoRequest.html":{},"interfaces/TokenPayload.html":{},"interfaces/UserRefreshClientOptions.html":{},"interfaces/VerifyIdTokenOptions.html":{},"changelog.html":{},"index.html":{}}}],["access_token",{"_index":639,"title":{},"body":{"interfaces/CredentialBody.html":{},"interfaces/CredentialRequest.html":{},"interfaces/Credentials.html":{},"interfaces/FederatedSignonCertsResponse.html":{},"interfaces/GetAccessTokenCallback.html":{},"interfaces/GetAccessTokenResponse.html":{},"interfaces/GetFederatedSignonCertsCallback.html":{},"interfaces/GetTokenCallback.html":{},"interfaces/GetTokenOptions.html":{},"interfaces/GetTokenResponse.html":{},"interfaces/JWTInput.html":{},"interfaces/JWTOptions.html":{},"interfaces/OAuth2ClientOptions.html":{},"interfaces/RefreshAccessTokenCallback.html":{},"interfaces/RefreshAccessTokenResponse.html":{},"interfaces/RefreshOptions.html":{},"interfaces/RequestMetadataCallback.html":{},"interfaces/RequestMetadataResponse.html":{},"interfaces/RevokeCredentialsResult.html":{},"interfaces/TokenInfo.html":{},"interfaces/TokenInfoRequest.html":{},"interfaces/VerifyIdTokenOptions.html":{},"index.html":{}}}],["access_typ",{"_index":750,"title":{},"body":{"interfaces/FederatedSignonCertsResponse.html":{},"interfaces/GetAccessTokenCallback.html":{},"interfaces/GetAccessTokenResponse.html":{},"interfaces/GetFederatedSignonCertsCallback.html":{},"interfaces/GetTokenCallback.html":{},"interfaces/GetTokenOptions.html":{},"interfaces/GetTokenResponse.html":{},"interfaces/OAuth2ClientOptions.html":{},"interfaces/RefreshAccessTokenCallback.html":{},"interfaces/RefreshAccessTokenResponse.html":{},"interfaces/RefreshOptions.html":{},"interfaces/RequestMetadataCallback.html":{},"interfaces/RequestMetadataResponse.html":{},"interfaces/RevokeCredentialsResult.html":{},"interfaces/TokenInfo.html":{},"interfaces/TokenInfoRequest.html":{},"interfaces/VerifyIdTokenOptions.html":{},"index.html":{}}}],["accesstoken",{"_index":1147,"title":{},"body":{"interfaces/FederatedSignonCertsResponse.html":{},"interfaces/GetAccessTokenCallback.html":{},"interfaces/GetAccessTokenResponse.html":{},"interfaces/GetFederatedSignonCertsCallback.html":{},"interfaces/GetTokenCallback.html":{},"interfaces/GetTokenOptions.html":{},"interfaces/GetTokenResponse.html":{},"interfaces/OAuth2ClientOptions.html":{},"interfaces/RefreshAccessTokenCallback.html":{},"interfaces/RefreshAccessTokenResponse.html":{},"interfaces/RefreshOptions.html":{},"interfaces/RequestMetadataCallback.html":{},"interfaces/RequestMetadataResponse.html":{},"interfaces/RevokeCredentialsResult.html":{},"interfaces/TokenInfo.html":{},"interfaces/TokenInfoRequest.html":{},"interfaces/VerifyIdTokenOptions.html":{}}}],["account",{"_index":423,"title":{},"body":{"interfaces/ADCCallback.html":{},"interfaces/ADCResponse.html":{},"interfaces/ComputeOptions.html":{},"interfaces/CredentialCallback.html":{},"interfaces/FederatedSignonCertsResponse.html":{},"interfaces/GetAccessTokenCallback.html":{},"interfaces/GetAccessTokenResponse.html":{},"interfaces/GetFederatedSignonCertsCallback.html":{},"interfaces/GetTokenCallback.html":{},"interfaces/GetTokenOptions.html":{},"interfaces/GetTokenResponse.html":{},"interfaces/GoogleAuthOptions.html":{},"classes/JWTAccess.html":{},"interfaces/JWTOptions.html":{},"classes/LoginTicket.html":{},"interfaces/OAuth2ClientOptions.html":{},"interfaces/ProjectIdCallback.html":{},"interfaces/RefreshAccessTokenCallback.html":{},"interfaces/RefreshAccessTokenResponse.html":{},"interfaces/RefreshOptions.html":{},"interfaces/RequestMetadataCallback.html":{},"interfaces/RequestMetadataResponse.html":{},"interfaces/RevokeCredentialsResult.html":{},"interfaces/SignBlobResponse.html":{},"interfaces/TokenInfo.html":{},"interfaces/TokenInfoRequest.html":{},"interfaces/TokenPayload.html":{},"interfaces/VerifyIdTokenOptions.html":{},"interfaces/Warning.html":{},"index.html":{},"miscellaneous/variables.html":{}}}],["account'",{"_index":1288,"title":{},"body":{"interfaces/JWTOptions.html":{}}}],["account@example.com",{"_index":1805,"title":{},"body":{"index.html":{}}}],["accounts.google.com",{"_index":955,"title":{},"body":{"interfaces/FederatedSignonCertsResponse.html":{},"interfaces/GetAccessTokenCallback.html":{},"interfaces/GetAccessTokenResponse.html":{},"interfaces/GetFederatedSignonCertsCallback.html":{},"interfaces/GetTokenCallback.html":{},"interfaces/GetTokenOptions.html":{},"interfaces/GetTokenResponse.html":{},"classes/LoginTicket.html":{},"interfaces/OAuth2ClientOptions.html":{},"interfaces/RefreshAccessTokenCallback.html":{},"interfaces/RefreshAccessTokenResponse.html":{},"interfaces/RefreshOptions.html":{},"interfaces/RequestMetadataCallback.html":{},"interfaces/RequestMetadataResponse.html":{},"interfaces/RevokeCredentialsResult.html":{},"interfaces/TokenInfo.html":{},"interfaces/TokenInfoRequest.html":{},"interfaces/TokenPayload.html":{},"interfaces/VerifyIdTokenOptions.html":{}}}],["accounts/${this.serviceaccountemail}/token",{"_index":614,"title":{},"body":{"interfaces/ComputeOptions.html":{}}}],["acquir",{"_index":1199,"title":{},"body":{"classes/IAMAuth.html":{},"interfaces/RequestMetadata.html":{},"index.html":{}}}],["act",{"_index":1830,"title":{},"body":{"license.html":{}}}],["action",{"_index":1673,"title":{},"body":{"index.html":{}}}],["actual",{"_index":297,"title":{},"body":{"interfaces/ADCCallback.html":{},"interfaces/ADCResponse.html":{},"interfaces/CredentialCallback.html":{},"interfaces/GoogleAuthOptions.html":{},"interfaces/ProjectIdCallback.html":{},"interfaces/SignBlobResponse.html":{}}}],["adapt",{"_index":525,"title":{},"body":{"interfaces/BodyResponseCallback.html":{},"classes/DefaultTransporter.html":{},"interfaces/RequestError.html":{},"interfaces/Transporter.html":{}}}],["adccallback",{"_index":1,"title":{"interfaces/ADCCallback.html":{}},"body":{"interfaces/ADCCallback.html":{},"interfaces/ADCResponse.html":{},"interfaces/CredentialCallback.html":{},"interfaces/GoogleAuthOptions.html":{},"interfaces/ProjectIdCallback.html":{},"interfaces/SignBlobResponse.html":{}}}],["adccallback|refreshopt",{"_index":196,"title":{},"body":{"interfaces/ADCCallback.html":{},"interfaces/ADCResponse.html":{},"interfaces/CredentialCallback.html":{},"interfaces/GoogleAuthOptions.html":{},"interfaces/ProjectIdCallback.html":{},"interfaces/SignBlobResponse.html":{}}}],["adcrespons",{"_index":60,"title":{"interfaces/ADCResponse.html":{}},"body":{"interfaces/ADCCallback.html":{},"interfaces/ADCResponse.html":{},"interfaces/CredentialCallback.html":{},"interfaces/GoogleAuthOptions.html":{},"interfaces/ProjectIdCallback.html":{},"interfaces/SignBlobResponse.html":{}}}],["add",{"_index":1267,"title":{},"body":{"classes/JWTAccess.html":{},"changelog.html":{},"index.html":{},"license.html":{}}}],["addendum",{"_index":1931,"title":{},"body":{"license.html":{}}}],["addit",{"_index":851,"title":{},"body":{"interfaces/FederatedSignonCertsResponse.html":{},"interfaces/GetAccessTokenCallback.html":{},"interfaces/GetAccessTokenResponse.html":{},"interfaces/GetFederatedSignonCertsCallback.html":{},"interfaces/GetTokenCallback.html":{},"interfaces/GetTokenOptions.html":{},"interfaces/GetTokenResponse.html":{},"classes/JWTAccess.html":{},"interfaces/OAuth2ClientOptions.html":{},"interfaces/RefreshAccessTokenCallback.html":{},"interfaces/RefreshAccessTokenResponse.html":{},"interfaces/RefreshOptions.html":{},"interfaces/RequestMetadataCallback.html":{},"interfaces/RequestMetadataResponse.html":{},"interfaces/RevokeCredentialsResult.html":{},"interfaces/TokenInfo.html":{},"interfaces/TokenInfoRequest.html":{},"interfaces/VerifyIdTokenOptions.html":{},"changelog.html":{},"license.html":{}}}],["addition",{"_index":845,"title":{},"body":{"interfaces/FederatedSignonCertsResponse.html":{},"interfaces/GetAccessTokenCallback.html":{},"interfaces/GetAccessTokenResponse.html":{},"interfaces/GetFederatedSignonCertsCallback.html":{},"interfaces/GetTokenCallback.html":{},"interfaces/GetTokenOptions.html":{},"interfaces/GetTokenResponse.html":{},"interfaces/OAuth2ClientOptions.html":{},"interfaces/RefreshAccessTokenCallback.html":{},"interfaces/RefreshAccessTokenResponse.html":{},"interfaces/RefreshOptions.html":{},"interfaces/RequestMetadataCallback.html":{},"interfaces/RequestMetadataResponse.html":{},"interfaces/RevokeCredentialsResult.html":{},"interfaces/TokenInfo.html":{},"interfaces/TokenInfoRequest.html":{},"interfaces/VerifyIdTokenOptions.html":{}}}],["additionalclaim",{"_index":1234,"title":{},"body":{"classes/JWTAccess.html":{},"interfaces/JWTOptions.html":{}}}],["additionalclaims[claim",{"_index":1263,"title":{},"body":{"classes/JWTAccess.html":{}}}],["address",{"_index":863,"title":{},"body":{"interfaces/FederatedSignonCertsResponse.html":{},"interfaces/GetAccessTokenCallback.html":{},"interfaces/GetAccessTokenResponse.html":{},"interfaces/GetFederatedSignonCertsCallback.html":{},"interfaces/GetTokenCallback.html":{},"interfaces/GetTokenOptions.html":{},"interfaces/GetTokenResponse.html":{},"classes/JWTAccess.html":{},"interfaces/JWTOptions.html":{},"classes/LoginTicket.html":{},"interfaces/OAuth2ClientOptions.html":{},"interfaces/RefreshAccessTokenCallback.html":{},"interfaces/RefreshAccessTokenResponse.html":{},"interfaces/RefreshOptions.html":{},"interfaces/RequestMetadataCallback.html":{},"interfaces/RequestMetadataResponse.html":{},"interfaces/RevokeCredentialsResult.html":{},"interfaces/TokenInfo.html":{},"interfaces/TokenInfoRequest.html":{},"interfaces/TokenPayload.html":{},"interfaces/VerifyIdTokenOptions.html":{}}}],["advis",{"_index":1974,"title":{},"body":{"license.html":{}}}],["again",{"_index":1766,"title":{},"body":{"index.html":{}}}],["against",{"_index":847,"title":{},"body":{"interfaces/FederatedSignonCertsResponse.html":{},"interfaces/GetAccessTokenCallback.html":{},"interfaces/GetAccessTokenResponse.html":{},"interfaces/GetFederatedSignonCertsCallback.html":{},"interfaces/GetTokenCallback.html":{},"interfaces/GetTokenOptions.html":{},"interfaces/GetTokenResponse.html":{},"classes/LoginTicket.html":{},"interfaces/OAuth2ClientOptions.html":{},"interfaces/RefreshAccessTokenCallback.html":{},"interfaces/RefreshAccessTokenResponse.html":{},"interfaces/RefreshOptions.html":{},"interfaces/RequestMetadataCallback.html":{},"interfaces/RequestMetadataResponse.html":{},"interfaces/RevokeCredentialsResult.html":{},"interfaces/TokenInfo.html":{},"interfaces/TokenInfoRequest.html":{},"interfaces/TokenPayload.html":{},"interfaces/VerifyIdTokenOptions.html":{},"license.html":{}}}],["agent",{"_index":505,"title":{},"body":{"interfaces/BodyResponseCallback.html":{},"classes/DefaultTransporter.html":{},"interfaces/RequestError.html":{},"interfaces/Transporter.html":{},"dependencies.html":{},"miscellaneous/variables.html":{}}}],["agre",{"_index":665,"title":{},"body":{"interfaces/Credentials.html":{},"classes/LoginTicket.html":{},"miscellaneous/functions.html":{},"license.html":{}}}],["agreement",{"_index":1942,"title":{},"body":{"license.html":{}}}],["alg",{"_index":1241,"title":{},"body":{"classes/JWTAccess.html":{},"miscellaneous/variables.html":{}}}],["alias",{"_index":1997,"title":{},"body":{"miscellaneous/typealiases.html":{}}}],["alleg",{"_index":1908,"title":{},"body":{"license.html":{}}}],["allow",{"_index":371,"title":{},"body":{"interfaces/ADCCallback.html":{},"interfaces/ADCResponse.html":{},"interfaces/CredentialCallback.html":{},"interfaces/FederatedSignonCertsResponse.html":{},"interfaces/GetAccessTokenCallback.html":{},"interfaces/GetAccessTokenResponse.html":{},"interfaces/GetFederatedSignonCertsCallback.html":{},"interfaces/GetTokenCallback.html":{},"interfaces/GetTokenOptions.html":{},"interfaces/GetTokenResponse.html":{},"interfaces/GoogleAuthOptions.html":{},"classes/JWTAccess.html":{},"interfaces/OAuth2ClientOptions.html":{},"interfaces/ProjectIdCallback.html":{},"interfaces/RefreshAccessTokenCallback.html":{},"interfaces/RefreshAccessTokenResponse.html":{},"interfaces/RefreshOptions.html":{},"interfaces/RequestMetadataCallback.html":{},"interfaces/RequestMetadataResponse.html":{},"interfaces/RevokeCredentialsResult.html":{},"interfaces/SignBlobResponse.html":{},"interfaces/TokenInfo.html":{},"interfaces/TokenInfoRequest.html":{},"interfaces/VerifyIdTokenOptions.html":{},"index.html":{}}}],["alon",{"_index":1902,"title":{},"body":{"license.html":{}}}],["along",{"_index":1925,"title":{},"body":{"license.html":{}}}],["alongsid",{"_index":1930,"title":{},"body":{"license.html":{}}}],["alreadi",{"_index":209,"title":{},"body":{"interfaces/ADCCallback.html":{},"interfaces/ADCResponse.html":{},"interfaces/CredentialCallback.html":{},"interfaces/FederatedSignonCertsResponse.html":{},"interfaces/GetAccessTokenCallback.html":{},"interfaces/GetAccessTokenResponse.html":{},"interfaces/GetFederatedSignonCertsCallback.html":{},"interfaces/GetTokenCallback.html":{},"interfaces/GetTokenOptions.html":{},"interfaces/GetTokenResponse.html":{},"interfaces/GoogleAuthOptions.html":{},"interfaces/JWTOptions.html":{},"interfaces/OAuth2ClientOptions.html":{},"interfaces/ProjectIdCallback.html":{},"interfaces/RefreshAccessTokenCallback.html":{},"interfaces/RefreshAccessTokenResponse.html":{},"interfaces/RefreshOptions.html":{},"interfaces/RequestMetadataCallback.html":{},"interfaces/RequestMetadataResponse.html":{},"interfaces/RevokeCredentialsResult.html":{},"interfaces/SignBlobResponse.html":{},"interfaces/TokenInfo.html":{},"interfaces/TokenInfoRequest.html":{},"interfaces/VerifyIdTokenOptions.html":{}}}],["altern",{"_index":1365,"title":{},"body":{"classes/LoginTicket.html":{},"interfaces/TokenPayload.html":{}}}],["alway",{"_index":607,"title":{},"body":{"interfaces/ComputeOptions.html":{},"interfaces/FederatedSignonCertsResponse.html":{},"interfaces/GetAccessTokenCallback.html":{},"interfaces/GetAccessTokenResponse.html":{},"interfaces/GetFederatedSignonCertsCallback.html":{},"interfaces/GetTokenCallback.html":{},"interfaces/GetTokenOptions.html":{},"interfaces/GetTokenResponse.html":{},"classes/IAMAuth.html":{},"classes/JWTAccess.html":{},"classes/LoginTicket.html":{},"interfaces/OAuth2ClientOptions.html":{},"interfaces/RefreshAccessTokenCallback.html":{},"interfaces/RefreshAccessTokenResponse.html":{},"interfaces/RefreshOptions.html":{},"interfaces/RequestMetadata.html":{},"interfaces/RequestMetadataCallback.html":{},"interfaces/RequestMetadataResponse.html":{},"interfaces/RevokeCredentialsResult.html":{},"interfaces/TokenInfo.html":{},"interfaces/TokenInfoRequest.html":{},"interfaces/TokenPayload.html":{},"interfaces/VerifyIdTokenOptions.html":{},"changelog.html":{},"index.html":{}}}],["amount",{"_index":795,"title":{},"body":{"interfaces/FederatedSignonCertsResponse.html":{},"interfaces/GetAccessTokenCallback.html":{},"interfaces/GetAccessTokenResponse.html":{},"interfaces/GetFederatedSignonCertsCallback.html":{},"interfaces/GetTokenCallback.html":{},"interfaces/GetTokenOptions.html":{},"interfaces/GetTokenResponse.html":{},"interfaces/OAuth2ClientOptions.html":{},"interfaces/RefreshAccessTokenCallback.html":{},"interfaces/RefreshAccessTokenResponse.html":{},"interfaces/RefreshOptions.html":{},"interfaces/RequestMetadataCallback.html":{},"interfaces/RequestMetadataResponse.html":{},"interfaces/RevokeCredentialsResult.html":{},"interfaces/TokenInfo.html":{},"interfaces/TokenInfoRequest.html":{},"interfaces/VerifyIdTokenOptions.html":{}}}],["and(b",{"_index":1916,"title":{},"body":{"license.html":{}}}],["and(c",{"_index":1919,"title":{},"body":{"license.html":{}}}],["and(d",{"_index":1923,"title":{},"body":{"license.html":{}}}],["and/or",{"_index":1978,"title":{},"body":{"license.html":{}}}],["android",{"_index":742,"title":{},"body":{"interfaces/FederatedSignonCertsResponse.html":{},"interfaces/GetAccessTokenCallback.html":{},"interfaces/GetAccessTokenResponse.html":{},"interfaces/GetFederatedSignonCertsCallback.html":{},"interfaces/GetTokenCallback.html":{},"interfaces/GetTokenOptions.html":{},"interfaces/GetTokenResponse.html":{},"classes/LoginTicket.html":{},"interfaces/OAuth2ClientOptions.html":{},"interfaces/RefreshAccessTokenCallback.html":{},"interfaces/RefreshAccessTokenResponse.html":{},"interfaces/RefreshOptions.html":{},"interfaces/RequestMetadataCallback.html":{},"interfaces/RequestMetadataResponse.html":{},"interfaces/RevokeCredentialsResult.html":{},"interfaces/TokenInfo.html":{},"interfaces/TokenInfoRequest.html":{},"interfaces/TokenPayload.html":{},"interfaces/VerifyIdTokenOptions.html":{}}}],["annot",{"_index":1858,"title":{},"body":{"license.html":{}}}],["anoth",{"_index":842,"title":{},"body":{"interfaces/FederatedSignonCertsResponse.html":{},"interfaces/GetAccessTokenCallback.html":{},"interfaces/GetAccessTokenResponse.html":{},"interfaces/GetFederatedSignonCertsCallback.html":{},"interfaces/GetTokenCallback.html":{},"interfaces/GetTokenOptions.html":{},"interfaces/GetTokenResponse.html":{},"interfaces/OAuth2ClientOptions.html":{},"interfaces/RefreshAccessTokenCallback.html":{},"interfaces/RefreshAccessTokenResponse.html":{},"interfaces/RefreshOptions.html":{},"interfaces/RequestMetadataCallback.html":{},"interfaces/RequestMetadataResponse.html":{},"interfaces/RevokeCredentialsResult.html":{},"interfaces/TokenInfo.html":{},"interfaces/TokenInfoRequest.html":{},"interfaces/VerifyIdTokenOptions.html":{}}}],["any).id_token",{"_index":1332,"title":{},"body":{"interfaces/JWTOptions.html":{}}}],["apach",{"_index":656,"title":{},"body":{"interfaces/Credentials.html":{},"classes/LoginTicket.html":{},"miscellaneous/functions.html":{},"index.html":{},"license.html":{}}}],["api",{"_index":75,"title":{},"body":{"interfaces/ADCCallback.html":{},"interfaces/ADCResponse.html":{},"interfaces/BodyResponseCallback.html":{},"interfaces/ComputeOptions.html":{},"interfaces/CredentialCallback.html":{},"classes/DefaultTransporter.html":{},"interfaces/FederatedSignonCertsResponse.html":{},"interfaces/GetAccessTokenCallback.html":{},"interfaces/GetAccessTokenResponse.html":{},"interfaces/GetFederatedSignonCertsCallback.html":{},"interfaces/GetTokenCallback.html":{},"interfaces/GetTokenOptions.html":{},"interfaces/GetTokenResponse.html":{},"interfaces/GoogleAuthOptions.html":{},"interfaces/JWTOptions.html":{},"interfaces/OAuth2ClientOptions.html":{},"interfaces/ProjectIdCallback.html":{},"interfaces/RefreshAccessTokenCallback.html":{},"interfaces/RefreshAccessTokenResponse.html":{},"interfaces/RefreshOptions.html":{},"interfaces/RequestError.html":{},"interfaces/RequestMetadataCallback.html":{},"interfaces/RequestMetadataResponse.html":{},"interfaces/RevokeCredentialsResult.html":{},"interfaces/SignBlobResponse.html":{},"interfaces/TokenInfo.html":{},"interfaces/TokenInfoRequest.html":{},"interfaces/Transporter.html":{},"interfaces/VerifyIdTokenOptions.html":{},"interfaces/Warning.html":{},"index.html":{},"miscellaneous/variables.html":{}}}],["apikey",{"_index":355,"title":{},"body":{"interfaces/ADCCallback.html":{},"interfaces/ADCResponse.html":{},"interfaces/CredentialCallback.html":{},"interfaces/FederatedSignonCertsResponse.html":{},"interfaces/GetAccessTokenCallback.html":{},"interfaces/GetAccessTokenResponse.html":{},"interfaces/GetFederatedSignonCertsCallback.html":{},"interfaces/GetTokenCallback.html":{},"interfaces/GetTokenOptions.html":{},"interfaces/GetTokenResponse.html":{},"interfaces/GoogleAuthOptions.html":{},"interfaces/JWTOptions.html":{},"interfaces/OAuth2ClientOptions.html":{},"interfaces/ProjectIdCallback.html":{},"interfaces/RefreshAccessTokenCallback.html":{},"interfaces/RefreshAccessTokenResponse.html":{},"interfaces/RefreshOptions.html":{},"interfaces/RequestMetadataCallback.html":{},"interfaces/RequestMetadataResponse.html":{},"interfaces/RevokeCredentialsResult.html":{},"interfaces/SignBlobResponse.html":{},"interfaces/TokenInfo.html":{},"interfaces/TokenInfoRequest.html":{},"interfaces/VerifyIdTokenOptions.html":{}}}],["app",{"_index":740,"title":{},"body":{"interfaces/FederatedSignonCertsResponse.html":{},"interfaces/GetAccessTokenCallback.html":{},"interfaces/GetAccessTokenResponse.html":{},"interfaces/GetFederatedSignonCertsCallback.html":{},"interfaces/GetTokenCallback.html":{},"interfaces/GetTokenOptions.html":{},"interfaces/GetTokenResponse.html":{},"classes/LoginTicket.html":{},"interfaces/OAuth2ClientOptions.html":{},"interfaces/RefreshAccessTokenCallback.html":{},"interfaces/RefreshAccessTokenResponse.html":{},"interfaces/RefreshOptions.html":{},"interfaces/RequestMetadataCallback.html":{},"interfaces/RequestMetadataResponse.html":{},"interfaces/RevokeCredentialsResult.html":{},"interfaces/TokenInfo.html":{},"interfaces/TokenInfoRequest.html":{},"interfaces/TokenPayload.html":{},"interfaces/VerifyIdTokenOptions.html":{},"index.html":{}}}],["app'",{"_index":1374,"title":{},"body":{"classes/LoginTicket.html":{},"interfaces/TokenPayload.html":{}}}],["app_engin",{"_index":1653,"title":{},"body":{"miscellaneous/enumerations.html":{}}}],["appear",{"_index":1929,"title":{},"body":{"license.html":{}}}],["appendix",{"_index":1854,"title":{},"body":{"license.html":{}}}],["appli",{"_index":1898,"title":{},"body":{"license.html":{}}}],["applic",{"_index":148,"title":{},"body":{"interfaces/ADCCallback.html":{},"interfaces/ADCResponse.html":{},"interfaces/CredentialCallback.html":{},"interfaces/Credentials.html":{},"interfaces/FederatedSignonCertsResponse.html":{},"interfaces/GetAccessTokenCallback.html":{},"interfaces/GetAccessTokenResponse.html":{},"interfaces/GetFederatedSignonCertsCallback.html":{},"interfaces/GetTokenCallback.html":{},"interfaces/GetTokenOptions.html":{},"interfaces/GetTokenResponse.html":{},"interfaces/GoogleAuthOptions.html":{},"classes/LoginTicket.html":{},"interfaces/OAuth2ClientOptions.html":{},"interfaces/ProjectIdCallback.html":{},"interfaces/RefreshAccessTokenCallback.html":{},"interfaces/RefreshAccessTokenResponse.html":{},"interfaces/RefreshOptions.html":{},"interfaces/RequestMetadataCallback.html":{},"interfaces/RequestMetadataResponse.html":{},"interfaces/RevokeCredentialsResult.html":{},"interfaces/SignBlobResponse.html":{},"interfaces/TokenInfo.html":{},"interfaces/TokenInfoRequest.html":{},"interfaces/TokenPayload.html":{},"interfaces/VerifyIdTokenOptions.html":{},"interfaces/Warning.html":{},"changelog.html":{},"miscellaneous/functions.html":{},"index.html":{},"license.html":{},"miscellaneous/variables.html":{}}}],["application'",{"_index":823,"title":{},"body":{"interfaces/FederatedSignonCertsResponse.html":{},"interfaces/GetAccessTokenCallback.html":{},"interfaces/GetAccessTokenResponse.html":{},"interfaces/GetFederatedSignonCertsCallback.html":{},"interfaces/GetTokenCallback.html":{},"interfaces/GetTokenOptions.html":{},"interfaces/GetTokenResponse.html":{},"interfaces/OAuth2ClientOptions.html":{},"interfaces/RefreshAccessTokenCallback.html":{},"interfaces/RefreshAccessTokenResponse.html":{},"interfaces/RefreshOptions.html":{},"interfaces/RequestMetadataCallback.html":{},"interfaces/RequestMetadataResponse.html":{},"interfaces/RevokeCredentialsResult.html":{},"interfaces/TokenInfo.html":{},"interfaces/TokenInfoRequest.html":{},"interfaces/VerifyIdTokenOptions.html":{}}}],["application/x",{"_index":1022,"title":{},"body":{"interfaces/FederatedSignonCertsResponse.html":{},"interfaces/GetAccessTokenCallback.html":{},"interfaces/GetAccessTokenResponse.html":{},"interfaces/GetFederatedSignonCertsCallback.html":{},"interfaces/GetTokenCallback.html":{},"interfaces/GetTokenOptions.html":{},"interfaces/GetTokenResponse.html":{},"interfaces/OAuth2ClientOptions.html":{},"interfaces/RefreshAccessTokenCallback.html":{},"interfaces/RefreshAccessTokenResponse.html":{},"interfaces/RefreshOptions.html":{},"interfaces/RequestMetadataCallback.html":{},"interfaces/RequestMetadataResponse.html":{},"interfaces/RevokeCredentialsResult.html":{},"interfaces/TokenInfo.html":{},"interfaces/TokenInfoRequest.html":{},"interfaces/VerifyIdTokenOptions.html":{}}}],["application_default_credentials.json",{"_index":280,"title":{},"body":{"interfaces/ADCCallback.html":{},"interfaces/ADCResponse.html":{},"interfaces/CredentialCallback.html":{},"interfaces/GoogleAuthOptions.html":{},"interfaces/ProjectIdCallback.html":{},"interfaces/SignBlobResponse.html":{}}}],["approach",{"_index":1677,"title":{},"body":{"index.html":{}}}],["appropri",{"_index":458,"title":{},"body":{"interfaces/ADCCallback.html":{},"interfaces/ADCResponse.html":{},"interfaces/CredentialCallback.html":{},"interfaces/FederatedSignonCertsResponse.html":{},"interfaces/GetAccessTokenCallback.html":{},"interfaces/GetAccessTokenResponse.html":{},"interfaces/GetFederatedSignonCertsCallback.html":{},"interfaces/GetTokenCallback.html":{},"interfaces/GetTokenOptions.html":{},"interfaces/GetTokenResponse.html":{},"interfaces/GoogleAuthOptions.html":{},"interfaces/OAuth2ClientOptions.html":{},"interfaces/ProjectIdCallback.html":{},"interfaces/RefreshAccessTokenCallback.html":{},"interfaces/RefreshAccessTokenResponse.html":{},"interfaces/RefreshOptions.html":{},"interfaces/RequestMetadataCallback.html":{},"interfaces/RequestMetadataResponse.html":{},"interfaces/RevokeCredentialsResult.html":{},"interfaces/SignBlobResponse.html":{},"interfaces/TokenInfo.html":{},"interfaces/TokenInfoRequest.html":{},"interfaces/VerifyIdTokenOptions.html":{},"index.html":{},"license.html":{}}}],["appveyor",{"_index":1518,"title":{},"body":{"changelog.html":{}}}],["archiv",{"_index":1990,"title":{},"body":{"license.html":{}}}],["argument",{"_index":1130,"title":{},"body":{"interfaces/FederatedSignonCertsResponse.html":{},"interfaces/GetAccessTokenCallback.html":{},"interfaces/GetAccessTokenResponse.html":{},"interfaces/GetFederatedSignonCertsCallback.html":{},"interfaces/GetTokenCallback.html":{},"interfaces/GetTokenOptions.html":{},"interfaces/GetTokenResponse.html":{},"interfaces/OAuth2ClientOptions.html":{},"interfaces/RefreshAccessTokenCallback.html":{},"interfaces/RefreshAccessTokenResponse.html":{},"interfaces/RefreshOptions.html":{},"interfaces/RequestMetadataCallback.html":{},"interfaces/RequestMetadataResponse.html":{},"interfaces/RevokeCredentialsResult.html":{},"interfaces/TokenInfo.html":{},"interfaces/TokenInfoRequest.html":{},"interfaces/VerifyIdTokenOptions.html":{}}}],["aris",{"_index":1965,"title":{},"body":{"license.html":{}}}],["around",{"_index":1776,"title":{},"body":{"index.html":{}}}],["array",{"_index":725,"title":{},"body":{"interfaces/FederatedSignonCertsResponse.html":{},"interfaces/GetAccessTokenCallback.html":{},"interfaces/GetAccessTokenResponse.html":{},"interfaces/GetFederatedSignonCertsCallback.html":{},"interfaces/GetTokenCallback.html":{},"interfaces/GetTokenOptions.html":{},"interfaces/GetTokenResponse.html":{},"interfaces/JWTOptions.html":{},"interfaces/OAuth2ClientOptions.html":{},"interfaces/RefreshAccessTokenCallback.html":{},"interfaces/RefreshAccessTokenResponse.html":{},"interfaces/RefreshOptions.html":{},"interfaces/RequestMetadataCallback.html":{},"interfaces/RequestMetadataResponse.html":{},"interfaces/RevokeCredentialsResult.html":{},"interfaces/TokenInfo.html":{},"interfaces/TokenInfoRequest.html":{},"interfaces/VerifyIdTokenOptions.html":{},"index.html":{}}}],["array.isarray(body.error.error",{"_index":567,"title":{},"body":{"interfaces/BodyResponseCallback.html":{},"classes/DefaultTransporter.html":{},"interfaces/RequestError.html":{},"interfaces/Transporter.html":{}}}],["ask",{"_index":1096,"title":{},"body":{"interfaces/FederatedSignonCertsResponse.html":{},"interfaces/GetAccessTokenCallback.html":{},"interfaces/GetAccessTokenResponse.html":{},"interfaces/GetFederatedSignonCertsCallback.html":{},"interfaces/GetTokenCallback.html":{},"interfaces/GetTokenOptions.html":{},"interfaces/GetTokenResponse.html":{},"interfaces/OAuth2ClientOptions.html":{},"interfaces/RefreshAccessTokenCallback.html":{},"interfaces/RefreshAccessTokenResponse.html":{},"interfaces/RefreshOptions.html":{},"interfaces/RequestMetadataCallback.html":{},"interfaces/RequestMetadataResponse.html":{},"interfaces/RevokeCredentialsResult.html":{},"interfaces/TokenInfo.html":{},"interfaces/TokenInfoRequest.html":{},"interfaces/VerifyIdTokenOptions.html":{},"index.html":{}}}],["assert",{"_index":1599,"title":{},"body":{"changelog.html":{},"license.html":{}}}],["assert.reject",{"_index":1628,"title":{},"body":{"changelog.html":{}}}],["associ",{"_index":312,"title":{},"body":{"interfaces/ADCCallback.html":{},"interfaces/ADCResponse.html":{},"interfaces/CredentialCallback.html":{},"interfaces/GoogleAuthOptions.html":{},"interfaces/ProjectIdCallback.html":{},"interfaces/SignBlobResponse.html":{},"index.html":{},"license.html":{}}}],["assum",{"_index":541,"title":{},"body":{"interfaces/BodyResponseCallback.html":{},"classes/DefaultTransporter.html":{},"interfaces/FederatedSignonCertsResponse.html":{},"interfaces/GetAccessTokenCallback.html":{},"interfaces/GetAccessTokenResponse.html":{},"interfaces/GetFederatedSignonCertsCallback.html":{},"interfaces/GetTokenCallback.html":{},"interfaces/GetTokenOptions.html":{},"interfaces/GetTokenResponse.html":{},"interfaces/OAuth2ClientOptions.html":{},"interfaces/RefreshAccessTokenCallback.html":{},"interfaces/RefreshAccessTokenResponse.html":{},"interfaces/RefreshOptions.html":{},"interfaces/RequestError.html":{},"interfaces/RequestMetadataCallback.html":{},"interfaces/RequestMetadataResponse.html":{},"interfaces/RevokeCredentialsResult.html":{},"interfaces/TokenInfo.html":{},"interfaces/TokenInfoRequest.html":{},"interfaces/Transporter.html":{},"interfaces/VerifyIdTokenOptions.html":{},"license.html":{}}}],["assur",{"_index":835,"title":{},"body":{"interfaces/FederatedSignonCertsResponse.html":{},"interfaces/GetAccessTokenCallback.html":{},"interfaces/GetAccessTokenResponse.html":{},"interfaces/GetFederatedSignonCertsCallback.html":{},"interfaces/GetTokenCallback.html":{},"interfaces/GetTokenOptions.html":{},"interfaces/GetTokenResponse.html":{},"interfaces/OAuth2ClientOptions.html":{},"interfaces/RefreshAccessTokenCallback.html":{},"interfaces/RefreshAccessTokenResponse.html":{},"interfaces/RefreshOptions.html":{},"interfaces/RequestMetadataCallback.html":{},"interfaces/RequestMetadataResponse.html":{},"interfaces/RevokeCredentialsResult.html":{},"interfaces/TokenInfo.html":{},"interfaces/TokenInfoRequest.html":{},"interfaces/VerifyIdTokenOptions.html":{}}}],["asterisk",{"_index":770,"title":{},"body":{"interfaces/FederatedSignonCertsResponse.html":{},"interfaces/GetAccessTokenCallback.html":{},"interfaces/GetAccessTokenResponse.html":{},"interfaces/GetFederatedSignonCertsCallback.html":{},"interfaces/GetTokenCallback.html":{},"interfaces/GetTokenOptions.html":{},"interfaces/GetTokenResponse.html":{},"interfaces/OAuth2ClientOptions.html":{},"interfaces/RefreshAccessTokenCallback.html":{},"interfaces/RefreshAccessTokenResponse.html":{},"interfaces/RefreshOptions.html":{},"interfaces/RequestMetadataCallback.html":{},"interfaces/RequestMetadataResponse.html":{},"interfaces/RevokeCredentialsResult.html":{},"interfaces/TokenInfo.html":{},"interfaces/TokenInfoRequest.html":{},"interfaces/VerifyIdTokenOptions.html":{}}}],["async",{"_index":206,"title":{},"body":{"interfaces/ADCCallback.html":{},"interfaces/ADCResponse.html":{},"interfaces/ComputeOptions.html":{},"interfaces/CredentialCallback.html":{},"interfaces/FederatedSignonCertsResponse.html":{},"interfaces/GetAccessTokenCallback.html":{},"interfaces/GetAccessTokenResponse.html":{},"interfaces/GetFederatedSignonCertsCallback.html":{},"interfaces/GetTokenCallback.html":{},"interfaces/GetTokenOptions.html":{},"interfaces/GetTokenResponse.html":{},"interfaces/GoogleAuthOptions.html":{},"interfaces/JWTOptions.html":{},"interfaces/OAuth2ClientOptions.html":{},"interfaces/ProjectIdCallback.html":{},"interfaces/RefreshAccessTokenCallback.html":{},"interfaces/RefreshAccessTokenResponse.html":{},"interfaces/RefreshOptions.html":{},"interfaces/RequestMetadataCallback.html":{},"interfaces/RequestMetadataResponse.html":{},"interfaces/RevokeCredentialsResult.html":{},"interfaces/SignBlobResponse.html":{},"interfaces/TokenInfo.html":{},"interfaces/TokenInfoRequest.html":{},"interfaces/UserRefreshClientOptions.html":{},"interfaces/VerifyIdTokenOptions.html":{},"index.html":{}}}],["at_hash",{"_index":1367,"title":{},"body":{"classes/LoginTicket.html":{},"interfaces/TokenPayload.html":{}}}],["attach",{"_index":457,"title":{},"body":{"interfaces/ADCCallback.html":{},"interfaces/ADCResponse.html":{},"interfaces/CredentialCallback.html":{},"interfaces/GoogleAuthOptions.html":{},"interfaces/ProjectIdCallback.html":{},"interfaces/SignBlobResponse.html":{},"license.html":{}}}],["attack",{"_index":848,"title":{},"body":{"interfaces/FederatedSignonCertsResponse.html":{},"interfaces/GetAccessTokenCallback.html":{},"interfaces/GetAccessTokenResponse.html":{},"interfaces/GetFederatedSignonCertsCallback.html":{},"interfaces/GetTokenCallback.html":{},"interfaces/GetTokenOptions.html":{},"interfaces/GetTokenResponse.html":{},"classes/LoginTicket.html":{},"interfaces/OAuth2ClientOptions.html":{},"interfaces/RefreshAccessTokenCallback.html":{},"interfaces/RefreshAccessTokenResponse.html":{},"interfaces/RefreshOptions.html":{},"interfaces/RequestMetadataCallback.html":{},"interfaces/RequestMetadataResponse.html":{},"interfaces/RevokeCredentialsResult.html":{},"interfaces/TokenInfo.html":{},"interfaces/TokenInfoRequest.html":{},"interfaces/TokenPayload.html":{},"interfaces/VerifyIdTokenOptions.html":{}}}],["attempt",{"_index":251,"title":{},"body":{"interfaces/ADCCallback.html":{},"interfaces/ADCResponse.html":{},"interfaces/ComputeOptions.html":{},"interfaces/CredentialCallback.html":{},"interfaces/GoogleAuthOptions.html":{},"interfaces/ProjectIdCallback.html":{},"interfaces/SignBlobResponse.html":{}}}],["attribut",{"_index":1352,"title":{},"body":{"classes/LoginTicket.html":{},"interfaces/TokenPayload.html":{},"license.html":{}}}],["aud",{"_index":709,"title":{},"body":{"interfaces/FederatedSignonCertsResponse.html":{},"interfaces/GetAccessTokenCallback.html":{},"interfaces/GetAccessTokenResponse.html":{},"interfaces/GetFederatedSignonCertsCallback.html":{},"interfaces/GetTokenCallback.html":{},"interfaces/GetTokenOptions.html":{},"interfaces/GetTokenResponse.html":{},"classes/JWTAccess.html":{},"classes/LoginTicket.html":{},"interfaces/OAuth2ClientOptions.html":{},"interfaces/RefreshAccessTokenCallback.html":{},"interfaces/RefreshAccessTokenResponse.html":{},"interfaces/RefreshOptions.html":{},"interfaces/RequestMetadataCallback.html":{},"interfaces/RequestMetadataResponse.html":{},"interfaces/RevokeCredentialsResult.html":{},"interfaces/TokenInfo.html":{},"interfaces/TokenInfoRequest.html":{},"interfaces/TokenPayload.html":{},"interfaces/VerifyIdTokenOptions.html":{}}}],["audienc",{"_index":738,"title":{},"body":{"interfaces/FederatedSignonCertsResponse.html":{},"interfaces/GetAccessTokenCallback.html":{},"interfaces/GetAccessTokenResponse.html":{},"interfaces/GetFederatedSignonCertsCallback.html":{},"interfaces/GetTokenCallback.html":{},"interfaces/GetTokenOptions.html":{},"interfaces/GetTokenResponse.html":{},"classes/LoginTicket.html":{},"interfaces/OAuth2ClientOptions.html":{},"interfaces/RefreshAccessTokenCallback.html":{},"interfaces/RefreshAccessTokenResponse.html":{},"interfaces/RefreshOptions.html":{},"interfaces/RequestMetadataCallback.html":{},"interfaces/RequestMetadataResponse.html":{},"interfaces/RevokeCredentialsResult.html":{},"interfaces/TokenInfo.html":{},"interfaces/TokenInfoRequest.html":{},"interfaces/TokenPayload.html":{},"interfaces/VerifyIdTokenOptions.html":{},"index.html":{}}}],["audverifi",{"_index":1174,"title":{},"body":{"interfaces/FederatedSignonCertsResponse.html":{},"interfaces/GetAccessTokenCallback.html":{},"interfaces/GetAccessTokenResponse.html":{},"interfaces/GetFederatedSignonCertsCallback.html":{},"interfaces/GetTokenCallback.html":{},"interfaces/GetTokenOptions.html":{},"interfaces/GetTokenResponse.html":{},"interfaces/OAuth2ClientOptions.html":{},"interfaces/RefreshAccessTokenCallback.html":{},"interfaces/RefreshAccessTokenResponse.html":{},"interfaces/RefreshOptions.html":{},"interfaces/RequestMetadataCallback.html":{},"interfaces/RequestMetadataResponse.html":{},"interfaces/RevokeCredentialsResult.html":{},"interfaces/TokenInfo.html":{},"interfaces/TokenInfoRequest.html":{},"interfaces/VerifyIdTokenOptions.html":{}}}],["auth",{"_index":90,"title":{},"body":{"interfaces/ADCCallback.html":{},"interfaces/ADCResponse.html":{},"interfaces/CredentialCallback.html":{},"interfaces/FederatedSignonCertsResponse.html":{},"interfaces/GetAccessTokenCallback.html":{},"interfaces/GetAccessTokenResponse.html":{},"interfaces/GetFederatedSignonCertsCallback.html":{},"interfaces/GetTokenCallback.html":{},"interfaces/GetTokenOptions.html":{},"interfaces/GetTokenResponse.html":{},"interfaces/GoogleAuthOptions.html":{},"classes/JWTAccess.html":{},"interfaces/JWTOptions.html":{},"interfaces/OAuth2ClientOptions.html":{},"interfaces/ProjectIdCallback.html":{},"interfaces/RefreshAccessTokenCallback.html":{},"interfaces/RefreshAccessTokenResponse.html":{},"interfaces/RefreshOptions.html":{},"interfaces/RequestMetadataCallback.html":{},"interfaces/RequestMetadataResponse.html":{},"interfaces/RevokeCredentialsResult.html":{},"interfaces/SignBlobResponse.html":{},"interfaces/TokenInfo.html":{},"interfaces/TokenInfoRequest.html":{},"interfaces/VerifyIdTokenOptions.html":{},"interfaces/Warning.html":{},"changelog.html":{},"index.html":{},"miscellaneous/variables.html":{}}}],["auth.fromjson(key",{"_index":1800,"title":{},"body":{"index.html":{}}}],["auth.getapplicationdefault(function(err",{"_index":1549,"title":{},"body":{"changelog.html":{}}}],["auth.getcli",{"_index":1541,"title":{},"body":{"changelog.html":{},"index.html":{}}}],["auth.getprojectid",{"_index":1693,"title":{},"body":{"index.html":{}}}],["auth_provider_x509_cert_url",{"_index":1795,"title":{},"body":{"index.html":{}}}],["auth_uri",{"_index":1791,"title":{},"body":{"index.html":{}}}],["authclient",{"_index":691,"title":{},"body":{"interfaces/FederatedSignonCertsResponse.html":{},"interfaces/GetAccessTokenCallback.html":{},"interfaces/GetAccessTokenResponse.html":{},"interfaces/GetFederatedSignonCertsCallback.html":{},"interfaces/GetTokenCallback.html":{},"interfaces/GetTokenOptions.html":{},"interfaces/GetTokenResponse.html":{},"interfaces/OAuth2ClientOptions.html":{},"interfaces/RefreshAccessTokenCallback.html":{},"interfaces/RefreshAccessTokenResponse.html":{},"interfaces/RefreshOptions.html":{},"interfaces/RequestMetadataCallback.html":{},"interfaces/RequestMetadataResponse.html":{},"interfaces/RevokeCredentialsResult.html":{},"interfaces/TokenInfo.html":{},"interfaces/TokenInfoRequest.html":{},"interfaces/VerifyIdTokenOptions.html":{},"changelog.html":{}}}],["authclient.createscop",{"_index":1552,"title":{},"body":{"changelog.html":{}}}],["authclient.createscopedrequir",{"_index":1551,"title":{},"body":{"changelog.html":{}}}],["authent",{"_index":838,"title":{},"body":{"interfaces/FederatedSignonCertsResponse.html":{},"interfaces/GetAccessTokenCallback.html":{},"interfaces/GetAccessTokenResponse.html":{},"interfaces/GetFederatedSignonCertsCallback.html":{},"interfaces/GetTokenCallback.html":{},"interfaces/GetTokenOptions.html":{},"interfaces/GetTokenResponse.html":{},"classes/IAMAuth.html":{},"classes/JWTAccess.html":{},"interfaces/JWTOptions.html":{},"classes/LoginTicket.html":{},"interfaces/OAuth2ClientOptions.html":{},"interfaces/RefreshAccessTokenCallback.html":{},"interfaces/RefreshAccessTokenResponse.html":{},"interfaces/RefreshOptions.html":{},"interfaces/RequestMetadata.html":{},"interfaces/RequestMetadataCallback.html":{},"interfaces/RequestMetadataResponse.html":{},"interfaces/RevokeCredentialsResult.html":{},"interfaces/TokenInfo.html":{},"interfaces/TokenInfoRequest.html":{},"interfaces/TokenPayload.html":{},"interfaces/UserRefreshClientOptions.html":{},"interfaces/VerifyIdTokenOptions.html":{},"interfaces/Warning.html":{},"index.html":{},"miscellaneous/variables.html":{}}}],["author",{"_index":454,"title":{},"body":{"interfaces/ADCCallback.html":{},"interfaces/ADCResponse.html":{},"interfaces/CredentialCallback.html":{},"interfaces/FederatedSignonCertsResponse.html":{},"interfaces/GetAccessTokenCallback.html":{},"interfaces/GetAccessTokenResponse.html":{},"interfaces/GetFederatedSignonCertsCallback.html":{},"interfaces/GetTokenCallback.html":{},"interfaces/GetTokenOptions.html":{},"interfaces/GetTokenResponse.html":{},"interfaces/GoogleAuthOptions.html":{},"classes/IAMAuth.html":{},"classes/JWTAccess.html":{},"interfaces/JWTOptions.html":{},"classes/LoginTicket.html":{},"interfaces/OAuth2ClientOptions.html":{},"interfaces/ProjectIdCallback.html":{},"interfaces/RefreshAccessTokenCallback.html":{},"interfaces/RefreshAccessTokenResponse.html":{},"interfaces/RefreshOptions.html":{},"interfaces/RequestMetadata.html":{},"interfaces/RequestMetadataCallback.html":{},"interfaces/RequestMetadataResponse.html":{},"interfaces/RevokeCredentialsResult.html":{},"interfaces/SignBlobResponse.html":{},"interfaces/TokenInfo.html":{},"interfaces/TokenInfoRequest.html":{},"interfaces/TokenPayload.html":{},"interfaces/VerifyIdTokenOptions.html":{},"changelog.html":{},"index.html":{},"license.html":{}}}],["authorization_cod",{"_index":1018,"title":{},"body":{"interfaces/FederatedSignonCertsResponse.html":{},"interfaces/GetAccessTokenCallback.html":{},"interfaces/GetAccessTokenResponse.html":{},"interfaces/GetFederatedSignonCertsCallback.html":{},"interfaces/GetTokenCallback.html":{},"interfaces/GetTokenOptions.html":{},"interfaces/GetTokenResponse.html":{},"interfaces/OAuth2ClientOptions.html":{},"interfaces/RefreshAccessTokenCallback.html":{},"interfaces/RefreshAccessTokenResponse.html":{},"interfaces/RefreshOptions.html":{},"interfaces/RequestMetadataCallback.html":{},"interfaces/RequestMetadataResponse.html":{},"interfaces/RevokeCredentialsResult.html":{},"interfaces/TokenInfo.html":{},"interfaces/TokenInfoRequest.html":{},"interfaces/VerifyIdTokenOptions.html":{}}}],["authorize(callback",{"_index":1321,"title":{},"body":{"interfaces/JWTOptions.html":{}}}],["authorizeasync",{"_index":1324,"title":{},"body":{"interfaces/JWTOptions.html":{}}}],["authorized_us",{"_index":332,"title":{},"body":{"interfaces/ADCCallback.html":{},"interfaces/ADCResponse.html":{},"interfaces/CredentialCallback.html":{},"interfaces/GoogleAuthOptions.html":{},"interfaces/ProjectIdCallback.html":{},"interfaces/SignBlobResponse.html":{},"interfaces/UserRefreshClientOptions.html":{}}}],["authorizerequest(opt",{"_index":459,"title":{},"body":{"interfaces/ADCCallback.html":{},"interfaces/ADCResponse.html":{},"interfaces/CredentialCallback.html":{},"interfaces/GoogleAuthOptions.html":{},"interfaces/ProjectIdCallback.html":{},"interfaces/SignBlobResponse.html":{}}}],["authorizeurl",{"_index":1730,"title":{},"body":{"index.html":{}}}],["authorship",{"_index":1852,"title":{},"body":{"license.html":{}}}],["authuri",{"_index":1251,"title":{},"body":{"classes/JWTAccess.html":{}}}],["automat",{"_index":436,"title":{},"body":{"interfaces/ADCCallback.html":{},"interfaces/ADCResponse.html":{},"interfaces/ComputeOptions.html":{},"interfaces/CredentialCallback.html":{},"interfaces/FederatedSignonCertsResponse.html":{},"interfaces/GetAccessTokenCallback.html":{},"interfaces/GetAccessTokenResponse.html":{},"interfaces/GetFederatedSignonCertsCallback.html":{},"interfaces/GetTokenCallback.html":{},"interfaces/GetTokenOptions.html":{},"interfaces/GetTokenResponse.html":{},"interfaces/GoogleAuthOptions.html":{},"interfaces/OAuth2ClientOptions.html":{},"interfaces/ProjectIdCallback.html":{},"interfaces/RefreshAccessTokenCallback.html":{},"interfaces/RefreshAccessTokenResponse.html":{},"interfaces/RefreshOptions.html":{},"interfaces/RequestMetadataCallback.html":{},"interfaces/RequestMetadataResponse.html":{},"interfaces/RevokeCredentialsResult.html":{},"interfaces/SignBlobResponse.html":{},"interfaces/TokenInfo.html":{},"interfaces/TokenInfoRequest.html":{},"interfaces/VerifyIdTokenOptions.html":{},"changelog.html":{},"index.html":{}}}],["avail",{"_index":519,"title":{},"body":{"interfaces/BodyResponseCallback.html":{},"classes/DefaultTransporter.html":{},"interfaces/FederatedSignonCertsResponse.html":{},"interfaces/GetAccessTokenCallback.html":{},"interfaces/GetAccessTokenResponse.html":{},"interfaces/GetFederatedSignonCertsCallback.html":{},"interfaces/GetTokenCallback.html":{},"interfaces/GetTokenOptions.html":{},"interfaces/GetTokenResponse.html":{},"interfaces/JWTOptions.html":{},"interfaces/OAuth2ClientOptions.html":{},"interfaces/RefreshAccessTokenCallback.html":{},"interfaces/RefreshAccessTokenResponse.html":{},"interfaces/RefreshOptions.html":{},"interfaces/RequestError.html":{},"interfaces/RequestMetadataCallback.html":{},"interfaces/RequestMetadataResponse.html":{},"interfaces/RevokeCredentialsResult.html":{},"interfaces/TokenInfo.html":{},"interfaces/TokenInfoRequest.html":{},"interfaces/Transporter.html":{},"interfaces/VerifyIdTokenOptions.html":{},"index.html":{},"license.html":{}}}],["availab",{"_index":1115,"title":{},"body":{"interfaces/FederatedSignonCertsResponse.html":{},"interfaces/GetAccessTokenCallback.html":{},"interfaces/GetAccessTokenResponse.html":{},"interfaces/GetFederatedSignonCertsCallback.html":{},"interfaces/GetTokenCallback.html":{},"interfaces/GetTokenOptions.html":{},"interfaces/GetTokenResponse.html":{},"interfaces/OAuth2ClientOptions.html":{},"interfaces/RefreshAccessTokenCallback.html":{},"interfaces/RefreshAccessTokenResponse.html":{},"interfaces/RefreshOptions.html":{},"interfaces/RequestMetadataCallback.html":{},"interfaces/RequestMetadataResponse.html":{},"interfaces/RevokeCredentialsResult.html":{},"interfaces/TokenInfo.html":{},"interfaces/TokenInfoRequest.html":{},"interfaces/VerifyIdTokenOptions.html":{}}}],["avoid",{"_index":1570,"title":{},"body":{"changelog.html":{}}}],["await",{"_index":181,"title":{},"body":{"interfaces/ADCCallback.html":{},"interfaces/ADCResponse.html":{},"interfaces/ComputeOptions.html":{},"interfaces/CredentialCallback.html":{},"interfaces/FederatedSignonCertsResponse.html":{},"interfaces/GetAccessTokenCallback.html":{},"interfaces/GetAccessTokenResponse.html":{},"interfaces/GetFederatedSignonCertsCallback.html":{},"interfaces/GetTokenCallback.html":{},"interfaces/GetTokenOptions.html":{},"interfaces/GetTokenResponse.html":{},"interfaces/GoogleAuthOptions.html":{},"interfaces/JWTOptions.html":{},"interfaces/OAuth2ClientOptions.html":{},"interfaces/ProjectIdCallback.html":{},"interfaces/RefreshAccessTokenCallback.html":{},"interfaces/RefreshAccessTokenResponse.html":{},"interfaces/RefreshOptions.html":{},"interfaces/RequestMetadataCallback.html":{},"interfaces/RequestMetadataResponse.html":{},"interfaces/RevokeCredentialsResult.html":{},"interfaces/SignBlobResponse.html":{},"interfaces/TokenInfo.html":{},"interfaces/TokenInfoRequest.html":{},"interfaces/VerifyIdTokenOptions.html":{},"changelog.html":{},"index.html":{}}}],["axio",{"_index":23,"title":{},"body":{"interfaces/ADCCallback.html":{},"interfaces/ADCResponse.html":{},"interfaces/BodyResponseCallback.html":{},"interfaces/ComputeOptions.html":{},"interfaces/CredentialCallback.html":{},"classes/DefaultTransporter.html":{},"interfaces/FederatedSignonCertsResponse.html":{},"interfaces/GetAccessTokenCallback.html":{},"interfaces/GetAccessTokenResponse.html":{},"interfaces/GetFederatedSignonCertsCallback.html":{},"interfaces/GetTokenCallback.html":{},"interfaces/GetTokenOptions.html":{},"interfaces/GetTokenResponse.html":{},"interfaces/GoogleAuthOptions.html":{},"interfaces/OAuth2ClientOptions.html":{},"interfaces/ProjectIdCallback.html":{},"interfaces/RefreshAccessTokenCallback.html":{},"interfaces/RefreshAccessTokenResponse.html":{},"interfaces/RefreshOptions.html":{},"interfaces/RequestError.html":{},"interfaces/RequestMetadataCallback.html":{},"interfaces/RequestMetadataResponse.html":{},"interfaces/RevokeCredentialsResult.html":{},"interfaces/SignBlobResponse.html":{},"interfaces/TokenInfo.html":{},"interfaces/TokenInfoRequest.html":{},"interfaces/Transporter.html":{},"interfaces/VerifyIdTokenOptions.html":{},"dependencies.html":{}}}],["axios(opts).catch(",{"_index":555,"title":{},"body":{"interfaces/BodyResponseCallback.html":{},"classes/DefaultTransporter.html":{},"interfaces/RequestError.html":{},"interfaces/Transporter.html":{}}}],["axios(opts).then",{"_index":553,"title":{},"body":{"interfaces/BodyResponseCallback.html":{},"classes/DefaultTransporter.html":{},"interfaces/RequestError.html":{},"interfaces/Transporter.html":{}}}],["axios.defaults.adapt",{"_index":530,"title":{},"body":{"interfaces/BodyResponseCallback.html":{},"classes/DefaultTransporter.html":{},"interfaces/RequestError.html":{},"interfaces/Transporter.html":{}}}],["axioserror",{"_index":498,"title":{},"body":{"interfaces/BodyResponseCallback.html":{},"interfaces/ComputeOptions.html":{},"classes/DefaultTransporter.html":{},"interfaces/FederatedSignonCertsResponse.html":{},"interfaces/GetAccessTokenCallback.html":{},"interfaces/GetAccessTokenResponse.html":{},"interfaces/GetFederatedSignonCertsCallback.html":{},"interfaces/GetTokenCallback.html":{},"interfaces/GetTokenOptions.html":{},"interfaces/GetTokenResponse.html":{},"interfaces/OAuth2ClientOptions.html":{},"interfaces/RefreshAccessTokenCallback.html":{},"interfaces/RefreshAccessTokenResponse.html":{},"interfaces/RefreshOptions.html":{},"interfaces/RequestError.html":{},"interfaces/RequestMetadataCallback.html":{},"interfaces/RequestMetadataResponse.html":{},"interfaces/RevokeCredentialsResult.html":{},"interfaces/TokenInfo.html":{},"interfaces/TokenInfoRequest.html":{},"interfaces/Transporter.html":{},"interfaces/VerifyIdTokenOptions.html":{}}}],["axioserror).respons",{"_index":627,"title":{},"body":{"interfaces/ComputeOptions.html":{},"interfaces/FederatedSignonCertsResponse.html":{},"interfaces/GetAccessTokenCallback.html":{},"interfaces/GetAccessTokenResponse.html":{},"interfaces/GetFederatedSignonCertsCallback.html":{},"interfaces/GetTokenCallback.html":{},"interfaces/GetTokenOptions.html":{},"interfaces/GetTokenResponse.html":{},"interfaces/OAuth2ClientOptions.html":{},"interfaces/RefreshAccessTokenCallback.html":{},"interfaces/RefreshAccessTokenResponse.html":{},"interfaces/RefreshOptions.html":{},"interfaces/RequestMetadataCallback.html":{},"interfaces/RequestMetadataResponse.html":{},"interfaces/RevokeCredentialsResult.html":{},"interfaces/TokenInfo.html":{},"interfaces/TokenInfoRequest.html":{},"interfaces/VerifyIdTokenOptions.html":{}}}],["axioserror|nul",{"_index":879,"title":{},"body":{"interfaces/FederatedSignonCertsResponse.html":{},"interfaces/GetAccessTokenCallback.html":{},"interfaces/GetAccessTokenResponse.html":{},"interfaces/GetFederatedSignonCertsCallback.html":{},"interfaces/GetTokenCallback.html":{},"interfaces/GetTokenOptions.html":{},"interfaces/GetTokenResponse.html":{},"interfaces/OAuth2ClientOptions.html":{},"interfaces/RefreshAccessTokenCallback.html":{},"interfaces/RefreshAccessTokenResponse.html":{},"interfaces/RefreshOptions.html":{},"interfaces/RequestMetadataCallback.html":{},"interfaces/RequestMetadataResponse.html":{},"interfaces/RevokeCredentialsResult.html":{},"interfaces/TokenInfo.html":{},"interfaces/TokenInfoRequest.html":{},"interfaces/VerifyIdTokenOptions.html":{}}}],["axiospromis",{"_index":499,"title":{},"body":{"interfaces/BodyResponseCallback.html":{},"interfaces/ComputeOptions.html":{},"classes/DefaultTransporter.html":{},"interfaces/FederatedSignonCertsResponse.html":{},"interfaces/GetAccessTokenCallback.html":{},"interfaces/GetAccessTokenResponse.html":{},"interfaces/GetFederatedSignonCertsCallback.html":{},"interfaces/GetTokenCallback.html":{},"interfaces/GetTokenOptions.html":{},"interfaces/GetTokenResponse.html":{},"interfaces/OAuth2ClientOptions.html":{},"interfaces/RefreshAccessTokenCallback.html":{},"interfaces/RefreshAccessTokenResponse.html":{},"interfaces/RefreshOptions.html":{},"interfaces/RequestError.html":{},"interfaces/RequestMetadataCallback.html":{},"interfaces/RequestMetadataResponse.html":{},"interfaces/RevokeCredentialsResult.html":{},"interfaces/TokenInfo.html":{},"interfaces/TokenInfoRequest.html":{},"interfaces/Transporter.html":{},"interfaces/VerifyIdTokenOptions.html":{}}}],["axiospromise|void",{"_index":511,"title":{},"body":{"interfaces/BodyResponseCallback.html":{},"classes/DefaultTransporter.html":{},"interfaces/FederatedSignonCertsResponse.html":{},"interfaces/GetAccessTokenCallback.html":{},"interfaces/GetAccessTokenResponse.html":{},"interfaces/GetFederatedSignonCertsCallback.html":{},"interfaces/GetTokenCallback.html":{},"interfaces/GetTokenOptions.html":{},"interfaces/GetTokenResponse.html":{},"interfaces/OAuth2ClientOptions.html":{},"interfaces/RefreshAccessTokenCallback.html":{},"interfaces/RefreshAccessTokenResponse.html":{},"interfaces/RefreshOptions.html":{},"interfaces/RequestError.html":{},"interfaces/RequestMetadataCallback.html":{},"interfaces/RequestMetadataResponse.html":{},"interfaces/RevokeCredentialsResult.html":{},"interfaces/TokenInfo.html":{},"interfaces/TokenInfoRequest.html":{},"interfaces/Transporter.html":{},"interfaces/VerifyIdTokenOptions.html":{}}}],["axiosrequestconfig",{"_index":21,"title":{},"body":{"interfaces/ADCCallback.html":{},"interfaces/ADCResponse.html":{},"interfaces/BodyResponseCallback.html":{},"interfaces/ComputeOptions.html":{},"interfaces/CredentialCallback.html":{},"classes/DefaultTransporter.html":{},"interfaces/FederatedSignonCertsResponse.html":{},"interfaces/GetAccessTokenCallback.html":{},"interfaces/GetAccessTokenResponse.html":{},"interfaces/GetFederatedSignonCertsCallback.html":{},"interfaces/GetTokenCallback.html":{},"interfaces/GetTokenOptions.html":{},"interfaces/GetTokenResponse.html":{},"interfaces/GoogleAuthOptions.html":{},"interfaces/OAuth2ClientOptions.html":{},"interfaces/ProjectIdCallback.html":{},"interfaces/RefreshAccessTokenCallback.html":{},"interfaces/RefreshAccessTokenResponse.html":{},"interfaces/RefreshOptions.html":{},"interfaces/RequestError.html":{},"interfaces/RequestMetadataCallback.html":{},"interfaces/RequestMetadataResponse.html":{},"interfaces/RevokeCredentialsResult.html":{},"interfaces/SignBlobResponse.html":{},"interfaces/TokenInfo.html":{},"interfaces/TokenInfoRequest.html":{},"interfaces/Transporter.html":{},"interfaces/VerifyIdTokenOptions.html":{},"index.html":{}}}],["axiosrespons",{"_index":22,"title":{},"body":{"interfaces/ADCCallback.html":{},"interfaces/ADCResponse.html":{},"interfaces/BodyResponseCallback.html":{},"interfaces/ComputeOptions.html":{},"interfaces/CredentialCallback.html":{},"classes/DefaultTransporter.html":{},"interfaces/FederatedSignonCertsResponse.html":{},"interfaces/GetAccessTokenCallback.html":{},"interfaces/GetAccessTokenResponse.html":{},"interfaces/GetFederatedSignonCertsCallback.html":{},"interfaces/GetTokenCallback.html":{},"interfaces/GetTokenOptions.html":{},"interfaces/GetTokenResponse.html":{},"interfaces/GoogleAuthOptions.html":{},"interfaces/OAuth2ClientOptions.html":{},"interfaces/ProjectIdCallback.html":{},"interfaces/RefreshAccessTokenCallback.html":{},"interfaces/RefreshAccessTokenResponse.html":{},"interfaces/RefreshOptions.html":{},"interfaces/RequestError.html":{},"interfaces/RequestMetadataCallback.html":{},"interfaces/RequestMetadataResponse.html":{},"interfaces/RevokeCredentialsResult.html":{},"interfaces/SignBlobResponse.html":{},"interfaces/TokenInfo.html":{},"interfaces/TokenInfoRequest.html":{},"interfaces/Transporter.html":{},"interfaces/VerifyIdTokenOptions.html":{}}}],["axiosresponse|nul",{"_index":515,"title":{},"body":{"interfaces/BodyResponseCallback.html":{},"classes/DefaultTransporter.html":{},"interfaces/FederatedSignonCertsResponse.html":{},"interfaces/GetAccessTokenCallback.html":{},"interfaces/GetAccessTokenResponse.html":{},"interfaces/GetFederatedSignonCertsCallback.html":{},"interfaces/GetTokenCallback.html":{},"interfaces/GetTokenOptions.html":{},"interfaces/GetTokenResponse.html":{},"interfaces/OAuth2ClientOptions.html":{},"interfaces/RefreshAccessTokenCallback.html":{},"interfaces/RefreshAccessTokenResponse.html":{},"interfaces/RefreshOptions.html":{},"interfaces/RequestError.html":{},"interfaces/RequestMetadataCallback.html":{},"interfaces/RequestMetadataResponse.html":{},"interfaces/RevokeCredentialsResult.html":{},"interfaces/TokenInfo.html":{},"interfaces/TokenInfoRequest.html":{},"interfaces/Transporter.html":{},"interfaces/VerifyIdTokenOptions.html":{}}}],["azp",{"_index":744,"title":{},"body":{"interfaces/FederatedSignonCertsResponse.html":{},"interfaces/GetAccessTokenCallback.html":{},"interfaces/GetAccessTokenResponse.html":{},"interfaces/GetFederatedSignonCertsCallback.html":{},"interfaces/GetTokenCallback.html":{},"interfaces/GetTokenOptions.html":{},"interfaces/GetTokenResponse.html":{},"classes/LoginTicket.html":{},"interfaces/OAuth2ClientOptions.html":{},"interfaces/RefreshAccessTokenCallback.html":{},"interfaces/RefreshAccessTokenResponse.html":{},"interfaces/RefreshOptions.html":{},"interfaces/RequestMetadataCallback.html":{},"interfaces/RequestMetadataResponse.html":{},"interfaces/RevokeCredentialsResult.html":{},"interfaces/TokenInfo.html":{},"interfaces/TokenInfoRequest.html":{},"interfaces/TokenPayload.html":{},"interfaces/VerifyIdTokenOptions.html":{}}}],["b64string",{"_index":1181,"title":{},"body":{"interfaces/FederatedSignonCertsResponse.html":{},"interfaces/GetAccessTokenCallback.html":{},"interfaces/GetAccessTokenResponse.html":{},"interfaces/GetFederatedSignonCertsCallback.html":{},"interfaces/GetTokenCallback.html":{},"interfaces/GetTokenOptions.html":{},"interfaces/GetTokenResponse.html":{},"interfaces/OAuth2ClientOptions.html":{},"interfaces/RefreshAccessTokenCallback.html":{},"interfaces/RefreshAccessTokenResponse.html":{},"interfaces/RefreshOptions.html":{},"interfaces/RequestMetadataCallback.html":{},"interfaces/RequestMetadataResponse.html":{},"interfaces/RevokeCredentialsResult.html":{},"interfaces/TokenInfo.html":{},"interfaces/TokenInfoRequest.html":{},"interfaces/VerifyIdTokenOptions.html":{}}}],["badg",{"_index":1611,"title":{},"body":{"changelog.html":{}}}],["bail",{"_index":237,"title":{},"body":{"interfaces/ADCCallback.html":{},"interfaces/ADCResponse.html":{},"interfaces/CredentialCallback.html":{},"interfaces/GoogleAuthOptions.html":{},"interfaces/ProjectIdCallback.html":{},"interfaces/SignBlobResponse.html":{}}}],["base",{"_index":437,"title":{},"body":{"interfaces/ADCCallback.html":{},"interfaces/ADCResponse.html":{},"interfaces/CredentialCallback.html":{},"interfaces/FederatedSignonCertsResponse.html":{},"interfaces/GetAccessTokenCallback.html":{},"interfaces/GetAccessTokenResponse.html":{},"interfaces/GetFederatedSignonCertsCallback.html":{},"interfaces/GetTokenCallback.html":{},"interfaces/GetTokenOptions.html":{},"interfaces/GetTokenResponse.html":{},"interfaces/GoogleAuthOptions.html":{},"interfaces/OAuth2ClientOptions.html":{},"interfaces/ProjectIdCallback.html":{},"interfaces/RefreshAccessTokenCallback.html":{},"interfaces/RefreshAccessTokenResponse.html":{},"interfaces/RefreshOptions.html":{},"interfaces/RequestMetadataCallback.html":{},"interfaces/RequestMetadataResponse.html":{},"interfaces/RevokeCredentialsResult.html":{},"interfaces/SignBlobResponse.html":{},"interfaces/TokenInfo.html":{},"interfaces/TokenInfoRequest.html":{},"interfaces/VerifyIdTokenOptions.html":{},"index.html":{},"license.html":{}}}],["base64",{"_index":481,"title":{},"body":{"interfaces/ADCCallback.html":{},"interfaces/ADCResponse.html":{},"interfaces/CredentialCallback.html":{},"interfaces/FederatedSignonCertsResponse.html":{},"interfaces/GetAccessTokenCallback.html":{},"interfaces/GetAccessTokenResponse.html":{},"interfaces/GetFederatedSignonCertsCallback.html":{},"interfaces/GetTokenCallback.html":{},"interfaces/GetTokenOptions.html":{},"interfaces/GetTokenResponse.html":{},"interfaces/GoogleAuthOptions.html":{},"interfaces/OAuth2ClientOptions.html":{},"interfaces/ProjectIdCallback.html":{},"interfaces/RefreshAccessTokenCallback.html":{},"interfaces/RefreshAccessTokenResponse.html":{},"interfaces/RefreshOptions.html":{},"interfaces/RequestMetadataCallback.html":{},"interfaces/RequestMetadataResponse.html":{},"interfaces/RevokeCredentialsResult.html":{},"interfaces/SignBlobResponse.html":{},"interfaces/TokenInfo.html":{},"interfaces/TokenInfoRequest.html":{},"interfaces/VerifyIdTokenOptions.html":{}}}],["base64urlencod",{"_index":996,"title":{},"body":{"interfaces/FederatedSignonCertsResponse.html":{},"interfaces/GetAccessTokenCallback.html":{},"interfaces/GetAccessTokenResponse.html":{},"interfaces/GetFederatedSignonCertsCallback.html":{},"interfaces/GetTokenCallback.html":{},"interfaces/GetTokenOptions.html":{},"interfaces/GetTokenResponse.html":{},"interfaces/OAuth2ClientOptions.html":{},"interfaces/RefreshAccessTokenCallback.html":{},"interfaces/RefreshAccessTokenResponse.html":{},"interfaces/RefreshOptions.html":{},"interfaces/RequestMetadataCallback.html":{},"interfaces/RequestMetadataResponse.html":{},"interfaces/RevokeCredentialsResult.html":{},"interfaces/TokenInfo.html":{},"interfaces/TokenInfoRequest.html":{},"interfaces/VerifyIdTokenOptions.html":{}}}],["basi",{"_index":669,"title":{},"body":{"interfaces/Credentials.html":{},"classes/LoginTicket.html":{},"miscellaneous/functions.html":{},"license.html":{}}}],["basic",{"_index":1700,"title":{},"body":{"index.html":{}}}],["be",{"_index":1058,"title":{},"body":{"interfaces/FederatedSignonCertsResponse.html":{},"interfaces/GetAccessTokenCallback.html":{},"interfaces/GetAccessTokenResponse.html":{},"interfaces/GetFederatedSignonCertsCallback.html":{},"interfaces/GetTokenCallback.html":{},"interfaces/GetTokenOptions.html":{},"interfaces/GetTokenResponse.html":{},"classes/JWTAccess.html":{},"interfaces/JWTOptions.html":{},"interfaces/OAuth2ClientOptions.html":{},"interfaces/RefreshAccessTokenCallback.html":{},"interfaces/RefreshAccessTokenResponse.html":{},"interfaces/RefreshOptions.html":{},"interfaces/RequestMetadataCallback.html":{},"interfaces/RequestMetadataResponse.html":{},"interfaces/RevokeCredentialsResult.html":{},"interfaces/TokenInfo.html":{},"interfaces/TokenInfoRequest.html":{},"interfaces/VerifyIdTokenOptions.html":{}}}],["bearer",{"_index":1066,"title":{},"body":{"interfaces/FederatedSignonCertsResponse.html":{},"interfaces/GetAccessTokenCallback.html":{},"interfaces/GetAccessTokenResponse.html":{},"interfaces/GetFederatedSignonCertsCallback.html":{},"interfaces/GetTokenCallback.html":{},"interfaces/GetTokenOptions.html":{},"interfaces/GetTokenResponse.html":{},"classes/JWTAccess.html":{},"interfaces/JWTOptions.html":{},"interfaces/OAuth2ClientOptions.html":{},"interfaces/RefreshAccessTokenCallback.html":{},"interfaces/RefreshAccessTokenResponse.html":{},"interfaces/RefreshOptions.html":{},"interfaces/RequestMetadataCallback.html":{},"interfaces/RequestMetadataResponse.html":{},"interfaces/RevokeCredentialsResult.html":{},"interfaces/TokenInfo.html":{},"interfaces/TokenInfoRequest.html":{},"interfaces/VerifyIdTokenOptions.html":{}}}],["becom",{"_index":728,"title":{},"body":{"interfaces/FederatedSignonCertsResponse.html":{},"interfaces/GetAccessTokenCallback.html":{},"interfaces/GetAccessTokenResponse.html":{},"interfaces/GetFederatedSignonCertsCallback.html":{},"interfaces/GetTokenCallback.html":{},"interfaces/GetTokenOptions.html":{},"interfaces/GetTokenResponse.html":{},"interfaces/OAuth2ClientOptions.html":{},"interfaces/RefreshAccessTokenCallback.html":{},"interfaces/RefreshAccessTokenResponse.html":{},"interfaces/RefreshOptions.html":{},"interfaces/RequestMetadataCallback.html":{},"interfaces/RequestMetadataResponse.html":{},"interfaces/RevokeCredentialsResult.html":{},"interfaces/TokenInfo.html":{},"interfaces/TokenInfoRequest.html":{},"interfaces/VerifyIdTokenOptions.html":{}}}],["befor",{"_index":535,"title":{},"body":{"interfaces/BodyResponseCallback.html":{},"interfaces/ComputeOptions.html":{},"classes/DefaultTransporter.html":{},"classes/IAMAuth.html":{},"classes/JWTAccess.html":{},"interfaces/JWTOptions.html":{},"interfaces/RequestError.html":{},"interfaces/RequestMetadata.html":{},"interfaces/Transporter.html":{},"index.html":{}}}],["behalf",{"_index":791,"title":{},"body":{"interfaces/FederatedSignonCertsResponse.html":{},"interfaces/GetAccessTokenCallback.html":{},"interfaces/GetAccessTokenResponse.html":{},"interfaces/GetFederatedSignonCertsCallback.html":{},"interfaces/GetTokenCallback.html":{},"interfaces/GetTokenOptions.html":{},"interfaces/GetTokenResponse.html":{},"interfaces/OAuth2ClientOptions.html":{},"interfaces/RefreshAccessTokenCallback.html":{},"interfaces/RefreshAccessTokenResponse.html":{},"interfaces/RefreshOptions.html":{},"interfaces/RequestMetadataCallback.html":{},"interfaces/RequestMetadataResponse.html":{},"interfaces/RevokeCredentialsResult.html":{},"interfaces/TokenInfo.html":{},"interfaces/TokenInfoRequest.html":{},"interfaces/VerifyIdTokenOptions.html":{},"index.html":{},"license.html":{}}}],["belong",{"_index":1385,"title":{},"body":{"classes/LoginTicket.html":{},"interfaces/TokenPayload.html":{}}}],["below",{"_index":1685,"title":{},"body":{"index.html":{},"license.html":{}}}],["benefici",{"_index":1843,"title":{},"body":{"license.html":{}}}],["best",{"_index":1675,"title":{},"body":{"index.html":{}}}],["between",{"_index":799,"title":{},"body":{"interfaces/FederatedSignonCertsResponse.html":{},"interfaces/GetAccessTokenCallback.html":{},"interfaces/GetAccessTokenResponse.html":{},"interfaces/GetFederatedSignonCertsCallback.html":{},"interfaces/GetTokenCallback.html":{},"interfaces/GetTokenOptions.html":{},"interfaces/GetTokenResponse.html":{},"interfaces/OAuth2ClientOptions.html":{},"interfaces/RefreshAccessTokenCallback.html":{},"interfaces/RefreshAccessTokenResponse.html":{},"interfaces/RefreshOptions.html":{},"interfaces/RequestMetadataCallback.html":{},"interfaces/RequestMetadataResponse.html":{},"interfaces/RevokeCredentialsResult.html":{},"interfaces/TokenInfo.html":{},"interfaces/TokenInfoRequest.html":{},"interfaces/VerifyIdTokenOptions.html":{}}}],["bind",{"_index":1864,"title":{},"body":{"license.html":{}}}],["bit",{"_index":973,"title":{},"body":{"interfaces/FederatedSignonCertsResponse.html":{},"interfaces/GetAccessTokenCallback.html":{},"interfaces/GetAccessTokenResponse.html":{},"interfaces/GetFederatedSignonCertsCallback.html":{},"interfaces/GetTokenCallback.html":{},"interfaces/GetTokenOptions.html":{},"interfaces/GetTokenResponse.html":{},"interfaces/OAuth2ClientOptions.html":{},"interfaces/RefreshAccessTokenCallback.html":{},"interfaces/RefreshAccessTokenResponse.html":{},"interfaces/RefreshOptions.html":{},"interfaces/RequestMetadataCallback.html":{},"interfaces/RequestMetadataResponse.html":{},"interfaces/RevokeCredentialsResult.html":{},"interfaces/TokenInfo.html":{},"interfaces/TokenInfoRequest.html":{},"interfaces/VerifyIdTokenOptions.html":{}}}],["bodi",{"_index":512,"title":{},"body":{"interfaces/BodyResponseCallback.html":{},"classes/DefaultTransporter.html":{},"interfaces/RequestError.html":{},"interfaces/Transporter.html":{}}}],["body.error",{"_index":561,"title":{},"body":{"interfaces/BodyResponseCallback.html":{},"classes/DefaultTransporter.html":{},"interfaces/RequestError.html":{},"interfaces/Transporter.html":{}}}],["body.error.cod",{"_index":570,"title":{},"body":{"interfaces/BodyResponseCallback.html":{},"classes/DefaultTransporter.html":{},"interfaces/RequestError.html":{},"interfaces/Transporter.html":{}}}],["body.error.error",{"_index":572,"title":{},"body":{"interfaces/BodyResponseCallback.html":{},"classes/DefaultTransporter.html":{},"interfaces/RequestError.html":{},"interfaces/Transporter.html":{}}}],["body.error.errors.map((err2",{"_index":568,"title":{},"body":{"interfaces/BodyResponseCallback.html":{},"classes/DefaultTransporter.html":{},"interfaces/RequestError.html":{},"interfaces/Transporter.html":{}}}],["body.error.messag",{"_index":573,"title":{},"body":{"interfaces/BodyResponseCallback.html":{},"classes/DefaultTransporter.html":{},"interfaces/RequestError.html":{},"interfaces/Transporter.html":{}}}],["bodyresponsecallback",{"_index":496,"title":{"interfaces/BodyResponseCallback.html":{}},"body":{"interfaces/BodyResponseCallback.html":{},"classes/DefaultTransporter.html":{},"interfaces/FederatedSignonCertsResponse.html":{},"interfaces/GetAccessTokenCallback.html":{},"interfaces/GetAccessTokenResponse.html":{},"interfaces/GetFederatedSignonCertsCallback.html":{},"interfaces/GetTokenCallback.html":{},"interfaces/GetTokenOptions.html":{},"interfaces/GetTokenResponse.html":{},"interfaces/OAuth2ClientOptions.html":{},"interfaces/RefreshAccessTokenCallback.html":{},"interfaces/RefreshAccessTokenResponse.html":{},"interfaces/RefreshOptions.html":{},"interfaces/RequestError.html":{},"interfaces/RequestMetadataCallback.html":{},"interfaces/RequestMetadataResponse.html":{},"interfaces/RevokeCredentialsResult.html":{},"interfaces/TokenInfo.html":{},"interfaces/TokenInfoRequest.html":{},"interfaces/Transporter.html":{},"interfaces/VerifyIdTokenOptions.html":{}}}],["boilerpl",{"_index":1984,"title":{},"body":{"license.html":{}}}],["boolean",{"_index":97,"title":{},"body":{"interfaces/ADCCallback.html":{},"interfaces/ADCResponse.html":{},"interfaces/ComputeOptions.html":{},"interfaces/CredentialCallback.html":{},"interfaces/FederatedSignonCertsResponse.html":{},"interfaces/GetAccessTokenCallback.html":{},"interfaces/GetAccessTokenResponse.html":{},"interfaces/GetFederatedSignonCertsCallback.html":{},"interfaces/GetTokenCallback.html":{},"interfaces/GetTokenOptions.html":{},"interfaces/GetTokenResponse.html":{},"interfaces/GoogleAuthOptions.html":{},"classes/IAMAuth.html":{},"classes/JWTAccess.html":{},"classes/LoginTicket.html":{},"interfaces/OAuth2ClientOptions.html":{},"interfaces/ProjectIdCallback.html":{},"interfaces/RefreshAccessTokenCallback.html":{},"interfaces/RefreshAccessTokenResponse.html":{},"interfaces/RefreshOptions.html":{},"interfaces/RequestMetadataCallback.html":{},"interfaces/RequestMetadataResponse.html":{},"interfaces/RevokeCredentialsResult.html":{},"interfaces/SignBlobResponse.html":{},"interfaces/TokenInfo.html":{},"interfaces/TokenInfoRequest.html":{},"interfaces/TokenPayload.html":{},"interfaces/VerifyIdTokenOptions.html":{},"interfaces/Warning.html":{}}}],["bracket",{"_index":1986,"title":{},"body":{"license.html":{}}}],["break",{"_index":1532,"title":{},"body":{"changelog.html":{},"index.html":{}}}],["broken",{"_index":1563,"title":{},"body":{"changelog.html":{}}}],["brows",{"_index":240,"title":{},"body":{"interfaces/ADCCallback.html":{},"interfaces/ADCResponse.html":{},"interfaces/CredentialCallback.html":{},"interfaces/GoogleAuthOptions.html":{},"interfaces/ProjectIdCallback.html":{},"interfaces/SignBlobResponse.html":{}}}],["browser",{"_index":745,"title":{},"body":{"interfaces/FederatedSignonCertsResponse.html":{},"interfaces/GetAccessTokenCallback.html":{},"interfaces/GetAccessTokenResponse.html":{},"interfaces/GetFederatedSignonCertsCallback.html":{},"interfaces/GetTokenCallback.html":{},"interfaces/GetTokenOptions.html":{},"interfaces/GetTokenResponse.html":{},"interfaces/OAuth2ClientOptions.html":{},"interfaces/RefreshAccessTokenCallback.html":{},"interfaces/RefreshAccessTokenResponse.html":{},"interfaces/RefreshOptions.html":{},"interfaces/RequestMetadataCallback.html":{},"interfaces/RequestMetadataResponse.html":{},"interfaces/RevokeCredentialsResult.html":{},"interfaces/TokenInfo.html":{},"interfaces/TokenInfoRequest.html":{},"interfaces/VerifyIdTokenOptions.html":{},"index.html":{}}}],["buffer",{"_index":1183,"title":{},"body":{"interfaces/FederatedSignonCertsResponse.html":{},"interfaces/GetAccessTokenCallback.html":{},"interfaces/GetAccessTokenResponse.html":{},"interfaces/GetFederatedSignonCertsCallback.html":{},"interfaces/GetTokenCallback.html":{},"interfaces/GetTokenOptions.html":{},"interfaces/GetTokenResponse.html":{},"interfaces/OAuth2ClientOptions.html":{},"classes/PemVerifier.html":{},"interfaces/RefreshAccessTokenCallback.html":{},"interfaces/RefreshAccessTokenResponse.html":{},"interfaces/RefreshOptions.html":{},"interfaces/RequestMetadataCallback.html":{},"interfaces/RequestMetadataResponse.html":{},"interfaces/RevokeCredentialsResult.html":{},"interfaces/TokenInfo.html":{},"interfaces/TokenInfoRequest.html":{},"interfaces/VerifyIdTokenOptions.html":{},"changelog.html":{}}}],["buffer.from",{"_index":1574,"title":{},"body":{"changelog.html":{}}}],["buffer.from(b64str",{"_index":1184,"title":{},"body":{"interfaces/FederatedSignonCertsResponse.html":{},"interfaces/GetAccessTokenCallback.html":{},"interfaces/GetAccessTokenResponse.html":{},"interfaces/GetFederatedSignonCertsCallback.html":{},"interfaces/GetTokenCallback.html":{},"interfaces/GetTokenOptions.html":{},"interfaces/GetTokenResponse.html":{},"interfaces/OAuth2ClientOptions.html":{},"interfaces/RefreshAccessTokenCallback.html":{},"interfaces/RefreshAccessTokenResponse.html":{},"interfaces/RefreshOptions.html":{},"interfaces/RequestMetadataCallback.html":{},"interfaces/RequestMetadataResponse.html":{},"interfaces/RevokeCredentialsResult.html":{},"interfaces/TokenInfo.html":{},"interfaces/TokenInfoRequest.html":{},"interfaces/VerifyIdTokenOptions.html":{}}}],["buffer.from(data).tostring('base64",{"_index":492,"title":{},"body":{"interfaces/ADCCallback.html":{},"interfaces/ADCResponse.html":{},"interfaces/CredentialCallback.html":{},"interfaces/GoogleAuthOptions.html":{},"interfaces/ProjectIdCallback.html":{},"interfaces/SignBlobResponse.html":{}}}],["buffer.tostring('utf8",{"_index":1185,"title":{},"body":{"interfaces/FederatedSignonCertsResponse.html":{},"interfaces/GetAccessTokenCallback.html":{},"interfaces/GetAccessTokenResponse.html":{},"interfaces/GetFederatedSignonCertsCallback.html":{},"interfaces/GetTokenCallback.html":{},"interfaces/GetTokenOptions.html":{},"interfaces/GetTokenResponse.html":{},"interfaces/OAuth2ClientOptions.html":{},"interfaces/RefreshAccessTokenCallback.html":{},"interfaces/RefreshAccessTokenResponse.html":{},"interfaces/RefreshOptions.html":{},"interfaces/RequestMetadataCallback.html":{},"interfaces/RequestMetadataResponse.html":{},"interfaces/RevokeCredentialsResult.html":{},"interfaces/TokenInfo.html":{},"interfaces/TokenInfoRequest.html":{},"interfaces/VerifyIdTokenOptions.html":{}}}],["bug",{"_index":1534,"title":{},"body":{"changelog.html":{},"index.html":{}}}],["bug/issu",{"_index":1813,"title":{},"body":{"index.html":{}}}],["build",{"_index":1495,"title":{},"body":{"changelog.html":{},"index.html":{}}}],["built",{"_index":631,"title":{},"body":{"interfaces/ComputeOptions.html":{}}}],["bytestosign",{"_index":491,"title":{},"body":{"interfaces/ADCCallback.html":{},"interfaces/ADCResponse.html":{},"interfaces/CredentialCallback.html":{},"interfaces/GoogleAuthOptions.html":{},"interfaces/ProjectIdCallback.html":{},"interfaces/SignBlobResponse.html":{}}}],["cach",{"_index":86,"title":{},"body":{"interfaces/ADCCallback.html":{},"interfaces/ADCResponse.html":{},"interfaces/CredentialCallback.html":{},"interfaces/GoogleAuthOptions.html":{},"classes/JWTAccess.html":{},"interfaces/ProjectIdCallback.html":{},"interfaces/SignBlobResponse.html":{},"dependencies.html":{}}}],["cachedcredenti",{"_index":115,"title":{},"body":{"interfaces/ADCCallback.html":{},"interfaces/ADCResponse.html":{},"interfaces/CredentialCallback.html":{},"interfaces/GoogleAuthOptions.html":{},"interfaces/ProjectIdCallback.html":{},"interfaces/SignBlobResponse.html":{}}}],["cachedtoken",{"_index":1254,"title":{},"body":{"classes/JWTAccess.html":{}}}],["call",{"_index":592,"title":{},"body":{"interfaces/ComputeOptions.html":{},"interfaces/FederatedSignonCertsResponse.html":{},"interfaces/GetAccessTokenCallback.html":{},"interfaces/GetAccessTokenResponse.html":{},"interfaces/GetFederatedSignonCertsCallback.html":{},"interfaces/GetTokenCallback.html":{},"interfaces/GetTokenOptions.html":{},"interfaces/GetTokenResponse.html":{},"classes/IAMAuth.html":{},"classes/JWTAccess.html":{},"interfaces/JWTOptions.html":{},"interfaces/OAuth2ClientOptions.html":{},"interfaces/RefreshAccessTokenCallback.html":{},"interfaces/RefreshAccessTokenResponse.html":{},"interfaces/RefreshOptions.html":{},"interfaces/RequestMetadata.html":{},"interfaces/RequestMetadataCallback.html":{},"interfaces/RequestMetadataResponse.html":{},"interfaces/RevokeCredentialsResult.html":{},"interfaces/TokenInfo.html":{},"interfaces/TokenInfoRequest.html":{},"interfaces/VerifyIdTokenOptions.html":{},"index.html":{}}}],["callback",{"_index":141,"title":{},"body":{"interfaces/ADCCallback.html":{},"interfaces/ADCResponse.html":{},"interfaces/BodyResponseCallback.html":{},"interfaces/CredentialCallback.html":{},"classes/DefaultTransporter.html":{},"interfaces/FederatedSignonCertsResponse.html":{},"interfaces/GetAccessTokenCallback.html":{},"interfaces/GetAccessTokenResponse.html":{},"interfaces/GetFederatedSignonCertsCallback.html":{},"interfaces/GetTokenCallback.html":{},"interfaces/GetTokenOptions.html":{},"interfaces/GetTokenResponse.html":{},"interfaces/GoogleAuthOptions.html":{},"classes/IAMAuth.html":{},"classes/JWTAccess.html":{},"interfaces/JWTOptions.html":{},"interfaces/OAuth2ClientOptions.html":{},"interfaces/ProjectIdCallback.html":{},"interfaces/RefreshAccessTokenCallback.html":{},"interfaces/RefreshAccessTokenResponse.html":{},"interfaces/RefreshOptions.html":{},"interfaces/RequestError.html":{},"interfaces/RequestMetadata.html":{},"interfaces/RequestMetadataCallback.html":{},"interfaces/RequestMetadataResponse.html":{},"interfaces/RevokeCredentialsResult.html":{},"interfaces/SignBlobResponse.html":{},"interfaces/TokenInfo.html":{},"interfaces/TokenInfoRequest.html":{},"interfaces/Transporter.html":{},"interfaces/UserRefreshClientOptions.html":{},"interfaces/VerifyIdTokenOptions.html":{},"index.html":{}}}],["callback!(nul",{"_index":202,"title":{},"body":{"interfaces/ADCCallback.html":{},"interfaces/ADCResponse.html":{},"interfaces/CredentialCallback.html":{},"interfaces/GoogleAuthOptions.html":{},"interfaces/ProjectIdCallback.html":{},"interfaces/SignBlobResponse.html":{}}}],["callback(",{"_index":546,"title":{},"body":{"interfaces/BodyResponseCallback.html":{},"classes/DefaultTransporter.html":{},"interfaces/FederatedSignonCertsResponse.html":{},"interfaces/GetAccessTokenCallback.html":{},"interfaces/GetAccessTokenResponse.html":{},"interfaces/GetFederatedSignonCertsCallback.html":{},"interfaces/GetTokenCallback.html":{},"interfaces/GetTokenOptions.html":{},"interfaces/GetTokenResponse.html":{},"interfaces/OAuth2ClientOptions.html":{},"interfaces/RefreshAccessTokenCallback.html":{},"interfaces/RefreshAccessTokenResponse.html":{},"interfaces/RefreshOptions.html":{},"interfaces/RequestError.html":{},"interfaces/RequestMetadataCallback.html":{},"interfaces/RequestMetadataResponse.html":{},"interfaces/RevokeCredentialsResult.html":{},"interfaces/TokenInfo.html":{},"interfaces/TokenInfoRequest.html":{},"interfaces/Transporter.html":{},"interfaces/VerifyIdTokenOptions.html":{}}}],["callback(err",{"_index":1550,"title":{},"body":{"changelog.html":{}}}],["callback(nul",{"_index":143,"title":{},"body":{"interfaces/ADCCallback.html":{},"interfaces/ADCResponse.html":{},"interfaces/BodyResponseCallback.html":{},"interfaces/CredentialCallback.html":{},"classes/DefaultTransporter.html":{},"interfaces/FederatedSignonCertsResponse.html":{},"interfaces/GetAccessTokenCallback.html":{},"interfaces/GetAccessTokenResponse.html":{},"interfaces/GetFederatedSignonCertsCallback.html":{},"interfaces/GetTokenCallback.html":{},"interfaces/GetTokenOptions.html":{},"interfaces/GetTokenResponse.html":{},"interfaces/GoogleAuthOptions.html":{},"interfaces/JWTOptions.html":{},"interfaces/OAuth2ClientOptions.html":{},"interfaces/ProjectIdCallback.html":{},"interfaces/RefreshAccessTokenCallback.html":{},"interfaces/RefreshAccessTokenResponse.html":{},"interfaces/RefreshOptions.html":{},"interfaces/RequestError.html":{},"interfaces/RequestMetadataCallback.html":{},"interfaces/RequestMetadataResponse.html":{},"interfaces/RevokeCredentialsResult.html":{},"interfaces/SignBlobResponse.html":{},"interfaces/TokenInfo.html":{},"interfaces/TokenInfoRequest.html":{},"interfaces/Transporter.html":{},"interfaces/VerifyIdTokenOptions.html":{},"changelog.html":{}}}],["callback(this.processerror(",{"_index":554,"title":{},"body":{"interfaces/BodyResponseCallback.html":{},"classes/DefaultTransporter.html":{},"interfaces/RequestError.html":{},"interfaces/Transporter.html":{}}}],["captur",{"_index":843,"title":{},"body":{"interfaces/FederatedSignonCertsResponse.html":{},"interfaces/GetAccessTokenCallback.html":{},"interfaces/GetAccessTokenResponse.html":{},"interfaces/GetFederatedSignonCertsCallback.html":{},"interfaces/GetTokenCallback.html":{},"interfaces/GetTokenOptions.html":{},"interfaces/GetTokenResponse.html":{},"interfaces/OAuth2ClientOptions.html":{},"interfaces/RefreshAccessTokenCallback.html":{},"interfaces/RefreshAccessTokenResponse.html":{},"interfaces/RefreshOptions.html":{},"interfaces/RequestMetadataCallback.html":{},"interfaces/RequestMetadataResponse.html":{},"interfaces/RevokeCredentialsResult.html":{},"interfaces/TokenInfo.html":{},"interfaces/TokenInfoRequest.html":{},"interfaces/VerifyIdTokenOptions.html":{}}}],["care",{"_index":246,"title":{},"body":{"interfaces/ADCCallback.html":{},"interfaces/ADCResponse.html":{},"interfaces/CredentialCallback.html":{},"interfaces/GoogleAuthOptions.html":{},"interfaces/ProjectIdCallback.html":{},"interfaces/SignBlobResponse.html":{},"index.html":{}}}],["carri",{"_index":1917,"title":{},"body":{"license.html":{}}}],["case",{"_index":157,"title":{},"body":{"interfaces/ADCCallback.html":{},"interfaces/ADCResponse.html":{},"interfaces/BodyResponseCallback.html":{},"interfaces/CredentialCallback.html":{},"classes/DefaultTransporter.html":{},"interfaces/FederatedSignonCertsResponse.html":{},"interfaces/GetAccessTokenCallback.html":{},"interfaces/GetAccessTokenResponse.html":{},"interfaces/GetFederatedSignonCertsCallback.html":{},"interfaces/GetTokenCallback.html":{},"interfaces/GetTokenOptions.html":{},"interfaces/GetTokenResponse.html":{},"interfaces/GoogleAuthOptions.html":{},"classes/LoginTicket.html":{},"interfaces/OAuth2ClientOptions.html":{},"interfaces/ProjectIdCallback.html":{},"interfaces/RefreshAccessTokenCallback.html":{},"interfaces/RefreshAccessTokenResponse.html":{},"interfaces/RefreshOptions.html":{},"interfaces/RequestError.html":{},"interfaces/RequestMetadataCallback.html":{},"interfaces/RequestMetadataResponse.html":{},"interfaces/RevokeCredentialsResult.html":{},"interfaces/SignBlobResponse.html":{},"interfaces/TokenInfo.html":{},"interfaces/TokenInfoRequest.html":{},"interfaces/TokenPayload.html":{},"interfaces/Transporter.html":{},"interfaces/VerifyIdTokenOptions.html":{},"index.html":{}}}],["catch",{"_index":186,"title":{},"body":{"interfaces/ADCCallback.html":{},"interfaces/ADCResponse.html":{},"interfaces/BodyResponseCallback.html":{},"interfaces/ComputeOptions.html":{},"interfaces/CredentialCallback.html":{},"classes/DefaultTransporter.html":{},"interfaces/FederatedSignonCertsResponse.html":{},"interfaces/GetAccessTokenCallback.html":{},"interfaces/GetAccessTokenResponse.html":{},"interfaces/GetFederatedSignonCertsCallback.html":{},"interfaces/GetTokenCallback.html":{},"interfaces/GetTokenOptions.html":{},"interfaces/GetTokenResponse.html":{},"interfaces/GoogleAuthOptions.html":{},"classes/JWTAccess.html":{},"interfaces/JWTOptions.html":{},"interfaces/OAuth2ClientOptions.html":{},"interfaces/ProjectIdCallback.html":{},"interfaces/RefreshAccessTokenCallback.html":{},"interfaces/RefreshAccessTokenResponse.html":{},"interfaces/RefreshOptions.html":{},"interfaces/RequestError.html":{},"interfaces/RequestMetadataCallback.html":{},"interfaces/RequestMetadataResponse.html":{},"interfaces/RevokeCredentialsResult.html":{},"interfaces/SignBlobResponse.html":{},"interfaces/TokenInfo.html":{},"interfaces/TokenInfoRequest.html":{},"interfaces/Transporter.html":{},"interfaces/UserRefreshClientOptions.html":{},"interfaces/VerifyIdTokenOptions.html":{},"changelog.html":{},"index.html":{}}}],["caus",{"_index":1834,"title":{},"body":{"license.html":{}}}],["cert",{"_index":688,"title":{},"body":{"interfaces/FederatedSignonCertsResponse.html":{},"interfaces/GetAccessTokenCallback.html":{},"interfaces/GetAccessTokenResponse.html":{},"interfaces/GetFederatedSignonCertsCallback.html":{},"interfaces/GetTokenCallback.html":{},"interfaces/GetTokenOptions.html":{},"interfaces/GetTokenResponse.html":{},"interfaces/OAuth2ClientOptions.html":{},"interfaces/RefreshAccessTokenCallback.html":{},"interfaces/RefreshAccessTokenResponse.html":{},"interfaces/RefreshOptions.html":{},"interfaces/RequestMetadataCallback.html":{},"interfaces/RequestMetadataResponse.html":{},"interfaces/RevokeCredentialsResult.html":{},"interfaces/TokenInfo.html":{},"interfaces/TokenInfoRequest.html":{},"interfaces/VerifyIdTokenOptions.html":{},"index.html":{}}}],["certif",{"_index":689,"title":{},"body":{"interfaces/FederatedSignonCertsResponse.html":{},"interfaces/GetAccessTokenCallback.html":{},"interfaces/GetAccessTokenResponse.html":{},"interfaces/GetFederatedSignonCertsCallback.html":{},"interfaces/GetTokenCallback.html":{},"interfaces/GetTokenOptions.html":{},"interfaces/GetTokenResponse.html":{},"interfaces/OAuth2ClientOptions.html":{},"interfaces/RefreshAccessTokenCallback.html":{},"interfaces/RefreshAccessTokenResponse.html":{},"interfaces/RefreshOptions.html":{},"interfaces/RequestMetadataCallback.html":{},"interfaces/RequestMetadataResponse.html":{},"interfaces/RevokeCredentialsResult.html":{},"interfaces/TokenInfo.html":{},"interfaces/TokenInfoRequest.html":{},"interfaces/VerifyIdTokenOptions.html":{},"changelog.html":{},"miscellaneous/typealiases.html":{}}}],["certificatecach",{"_index":905,"title":{},"body":{"interfaces/FederatedSignonCertsResponse.html":{},"interfaces/GetAccessTokenCallback.html":{},"interfaces/GetAccessTokenResponse.html":{},"interfaces/GetFederatedSignonCertsCallback.html":{},"interfaces/GetTokenCallback.html":{},"interfaces/GetTokenOptions.html":{},"interfaces/GetTokenResponse.html":{},"interfaces/OAuth2ClientOptions.html":{},"interfaces/RefreshAccessTokenCallback.html":{},"interfaces/RefreshAccessTokenResponse.html":{},"interfaces/RefreshOptions.html":{},"interfaces/RequestMetadataCallback.html":{},"interfaces/RequestMetadataResponse.html":{},"interfaces/RevokeCredentialsResult.html":{},"interfaces/TokenInfo.html":{},"interfaces/TokenInfoRequest.html":{},"interfaces/VerifyIdTokenOptions.html":{}}}],["certificateexpiri",{"_index":906,"title":{},"body":{"interfaces/FederatedSignonCertsResponse.html":{},"interfaces/GetAccessTokenCallback.html":{},"interfaces/GetAccessTokenResponse.html":{},"interfaces/GetFederatedSignonCertsCallback.html":{},"interfaces/GetTokenCallback.html":{},"interfaces/GetTokenOptions.html":{},"interfaces/GetTokenResponse.html":{},"interfaces/OAuth2ClientOptions.html":{},"interfaces/RefreshAccessTokenCallback.html":{},"interfaces/RefreshAccessTokenResponse.html":{},"interfaces/RefreshOptions.html":{},"interfaces/RequestMetadataCallback.html":{},"interfaces/RequestMetadataResponse.html":{},"interfaces/RevokeCredentialsResult.html":{},"interfaces/TokenInfo.html":{},"interfaces/TokenInfoRequest.html":{},"interfaces/VerifyIdTokenOptions.html":{}}}],["challeng",{"_index":875,"title":{},"body":{"interfaces/FederatedSignonCertsResponse.html":{},"interfaces/GetAccessTokenCallback.html":{},"interfaces/GetAccessTokenResponse.html":{},"interfaces/GetFederatedSignonCertsCallback.html":{},"interfaces/GetTokenCallback.html":{},"interfaces/GetTokenOptions.html":{},"interfaces/GetTokenResponse.html":{},"interfaces/OAuth2ClientOptions.html":{},"interfaces/RefreshAccessTokenCallback.html":{},"interfaces/RefreshAccessTokenResponse.html":{},"interfaces/RefreshOptions.html":{},"interfaces/RequestMetadataCallback.html":{},"interfaces/RequestMetadataResponse.html":{},"interfaces/RevokeCredentialsResult.html":{},"interfaces/TokenInfo.html":{},"interfaces/TokenInfoRequest.html":{},"interfaces/VerifyIdTokenOptions.html":{}}}],["chang",{"_index":557,"title":{},"body":{"interfaces/BodyResponseCallback.html":{},"interfaces/ComputeOptions.html":{},"classes/DefaultTransporter.html":{},"interfaces/FederatedSignonCertsResponse.html":{},"interfaces/GetAccessTokenCallback.html":{},"interfaces/GetAccessTokenResponse.html":{},"interfaces/GetFederatedSignonCertsCallback.html":{},"interfaces/GetTokenCallback.html":{},"interfaces/GetTokenOptions.html":{},"interfaces/GetTokenResponse.html":{},"classes/LoginTicket.html":{},"interfaces/OAuth2ClientOptions.html":{},"interfaces/RefreshAccessTokenCallback.html":{},"interfaces/RefreshAccessTokenResponse.html":{},"interfaces/RefreshOptions.html":{},"interfaces/RequestError.html":{},"interfaces/RequestMetadataCallback.html":{},"interfaces/RequestMetadataResponse.html":{},"interfaces/RevokeCredentialsResult.html":{},"interfaces/TokenInfo.html":{},"interfaces/TokenInfoRequest.html":{},"interfaces/TokenPayload.html":{},"interfaces/Transporter.html":{},"interfaces/VerifyIdTokenOptions.html":{},"changelog.html":{},"index.html":{},"license.html":{}}}],["changelog",{"_index":1455,"title":{"changelog.html":{}},"body":{"changelog.html":{}}}],["char",{"_index":990,"title":{},"body":{"interfaces/FederatedSignonCertsResponse.html":{},"interfaces/GetAccessTokenCallback.html":{},"interfaces/GetAccessTokenResponse.html":{},"interfaces/GetFederatedSignonCertsCallback.html":{},"interfaces/GetTokenCallback.html":{},"interfaces/GetTokenOptions.html":{},"interfaces/GetTokenResponse.html":{},"interfaces/OAuth2ClientOptions.html":{},"interfaces/RefreshAccessTokenCallback.html":{},"interfaces/RefreshAccessTokenResponse.html":{},"interfaces/RefreshOptions.html":{},"interfaces/RequestMetadataCallback.html":{},"interfaces/RequestMetadataResponse.html":{},"interfaces/RevokeCredentialsResult.html":{},"interfaces/TokenInfo.html":{},"interfaces/TokenInfoRequest.html":{},"interfaces/VerifyIdTokenOptions.html":{}}}],["charact",{"_index":975,"title":{},"body":{"interfaces/FederatedSignonCertsResponse.html":{},"interfaces/GetAccessTokenCallback.html":{},"interfaces/GetAccessTokenResponse.html":{},"interfaces/GetFederatedSignonCertsCallback.html":{},"interfaces/GetTokenCallback.html":{},"interfaces/GetTokenOptions.html":{},"interfaces/GetTokenResponse.html":{},"interfaces/OAuth2ClientOptions.html":{},"interfaces/RefreshAccessTokenCallback.html":{},"interfaces/RefreshAccessTokenResponse.html":{},"interfaces/RefreshOptions.html":{},"interfaces/RequestMetadataCallback.html":{},"interfaces/RequestMetadataResponse.html":{},"interfaces/RevokeCredentialsResult.html":{},"interfaces/TokenInfo.html":{},"interfaces/TokenInfoRequest.html":{},"interfaces/VerifyIdTokenOptions.html":{},"license.html":{}}}],["charg",{"_index":1886,"title":{},"body":{"license.html":{}}}],["check",{"_index":212,"title":{},"body":{"interfaces/ADCCallback.html":{},"interfaces/ADCResponse.html":{},"interfaces/CredentialCallback.html":{},"interfaces/FederatedSignonCertsResponse.html":{},"interfaces/GetAccessTokenCallback.html":{},"interfaces/GetAccessTokenResponse.html":{},"interfaces/GetFederatedSignonCertsCallback.html":{},"interfaces/GetTokenCallback.html":{},"interfaces/GetTokenOptions.html":{},"interfaces/GetTokenResponse.html":{},"interfaces/GoogleAuthOptions.html":{},"interfaces/JWTOptions.html":{},"interfaces/OAuth2ClientOptions.html":{},"interfaces/ProjectIdCallback.html":{},"interfaces/RefreshAccessTokenCallback.html":{},"interfaces/RefreshAccessTokenResponse.html":{},"interfaces/RefreshOptions.html":{},"interfaces/RequestMetadataCallback.html":{},"interfaces/RequestMetadataResponse.html":{},"interfaces/RevokeCredentialsResult.html":{},"interfaces/SignBlobResponse.html":{},"interfaces/TokenInfo.html":{},"interfaces/TokenInfoRequest.html":{},"interfaces/VerifyIdTokenOptions.html":{},"changelog.html":{},"index.html":{}}}],["checkisgc",{"_index":96,"title":{},"body":{"interfaces/ADCCallback.html":{},"interfaces/ADCResponse.html":{},"interfaces/CredentialCallback.html":{},"interfaces/GoogleAuthOptions.html":{},"interfaces/ProjectIdCallback.html":{},"interfaces/SignBlobResponse.html":{}}}],["child_process",{"_index":25,"title":{},"body":{"interfaces/ADCCallback.html":{},"interfaces/ADCResponse.html":{},"interfaces/CredentialCallback.html":{},"interfaces/GoogleAuthOptions.html":{},"interfaces/ProjectIdCallback.html":{},"interfaces/SignBlobResponse.html":{}}}],["choos",{"_index":1687,"title":{},"body":{"index.html":{},"license.html":{}}}],["chore",{"_index":1490,"title":{},"body":{"changelog.html":{}}}],["chore(build",{"_index":1498,"title":{},"body":{"changelog.html":{}}}],["chore(dep",{"_index":1464,"title":{},"body":{"changelog.html":{}}}],["chore(packag",{"_index":1636,"title":{},"body":{"changelog.html":{}}}],["chores(build",{"_index":1501,"title":{},"body":{"changelog.html":{}}}],["chunk",{"_index":349,"title":{},"body":{"interfaces/ADCCallback.html":{},"interfaces/ADCResponse.html":{},"interfaces/CredentialCallback.html":{},"interfaces/GoogleAuthOptions.html":{},"classes/JWTAccess.html":{},"interfaces/JWTOptions.html":{},"interfaces/ProjectIdCallback.html":{},"interfaces/SignBlobResponse.html":{},"interfaces/UserRefreshClientOptions.html":{}}}],["ci",{"_index":1524,"title":{},"body":{"changelog.html":{}}}],["claim",{"_index":735,"title":{},"body":{"interfaces/FederatedSignonCertsResponse.html":{},"interfaces/GetAccessTokenCallback.html":{},"interfaces/GetAccessTokenResponse.html":{},"interfaces/GetFederatedSignonCertsCallback.html":{},"interfaces/GetTokenCallback.html":{},"interfaces/GetTokenOptions.html":{},"interfaces/GetTokenResponse.html":{},"classes/JWTAccess.html":{},"classes/LoginTicket.html":{},"interfaces/OAuth2ClientOptions.html":{},"interfaces/RefreshAccessTokenCallback.html":{},"interfaces/RefreshAccessTokenResponse.html":{},"interfaces/RefreshOptions.html":{},"interfaces/RequestMetadataCallback.html":{},"interfaces/RequestMetadataResponse.html":{},"interfaces/RevokeCredentialsResult.html":{},"interfaces/TokenInfo.html":{},"interfaces/TokenInfoRequest.html":{},"interfaces/TokenPayload.html":{},"interfaces/VerifyIdTokenOptions.html":{},"license.html":{},"miscellaneous/typealiases.html":{}}}],["class",{"_index":84,"title":{"classes/DefaultTransporter.html":{},"classes/IAMAuth.html":{},"classes/JWTAccess.html":{},"classes/LoginTicket.html":{},"classes/PemVerifier.html":{}},"body":{"interfaces/ADCCallback.html":{},"interfaces/ADCResponse.html":{},"interfaces/BodyResponseCallback.html":{},"interfaces/ComputeOptions.html":{},"interfaces/CredentialCallback.html":{},"classes/DefaultTransporter.html":{},"interfaces/FederatedSignonCertsResponse.html":{},"interfaces/GetAccessTokenCallback.html":{},"interfaces/GetAccessTokenResponse.html":{},"interfaces/GetFederatedSignonCertsCallback.html":{},"interfaces/GetTokenCallback.html":{},"interfaces/GetTokenOptions.html":{},"interfaces/GetTokenResponse.html":{},"interfaces/GoogleAuthOptions.html":{},"classes/IAMAuth.html":{},"classes/JWTAccess.html":{},"interfaces/JWTOptions.html":{},"classes/LoginTicket.html":{},"interfaces/OAuth2ClientOptions.html":{},"classes/PemVerifier.html":{},"interfaces/ProjectIdCallback.html":{},"interfaces/RefreshAccessTokenCallback.html":{},"interfaces/RefreshAccessTokenResponse.html":{},"interfaces/RefreshOptions.html":{},"interfaces/RequestError.html":{},"interfaces/RequestMetadata.html":{},"interfaces/RequestMetadataCallback.html":{},"interfaces/RequestMetadataResponse.html":{},"interfaces/RevokeCredentialsResult.html":{},"interfaces/SignBlobResponse.html":{},"interfaces/TokenInfo.html":{},"interfaces/TokenInfoRequest.html":{},"interfaces/TokenPayload.html":{},"interfaces/Transporter.html":{},"interfaces/UserRefreshClientOptions.html":{},"interfaces/VerifyIdTokenOptions.html":{},"interfaces/Warning.html":{},"changelog.html":{},"index.html":{},"license.html":{},"overview.html":{},"miscellaneous/variables.html":{}}}],["cleanup",{"_index":1588,"title":{},"body":{"changelog.html":{}}}],["clear",{"_index":1087,"title":{},"body":{"interfaces/FederatedSignonCertsResponse.html":{},"interfaces/GetAccessTokenCallback.html":{},"interfaces/GetAccessTokenResponse.html":{},"interfaces/GetFederatedSignonCertsCallback.html":{},"interfaces/GetTokenCallback.html":{},"interfaces/GetTokenOptions.html":{},"interfaces/GetTokenResponse.html":{},"interfaces/OAuth2ClientOptions.html":{},"interfaces/RefreshAccessTokenCallback.html":{},"interfaces/RefreshAccessTokenResponse.html":{},"interfaces/RefreshOptions.html":{},"interfaces/RequestMetadataCallback.html":{},"interfaces/RequestMetadataResponse.html":{},"interfaces/RevokeCredentialsResult.html":{},"interfaces/TokenInfo.html":{},"interfaces/TokenInfoRequest.html":{},"interfaces/VerifyIdTokenOptions.html":{},"miscellaneous/functions.html":{}}}],["click",{"_index":1704,"title":{},"body":{"index.html":{}}}],["client",{"_index":284,"title":{},"body":{"interfaces/ADCCallback.html":{},"interfaces/ADCResponse.html":{},"interfaces/BodyResponseCallback.html":{},"interfaces/CredentialCallback.html":{},"classes/DefaultTransporter.html":{},"interfaces/FederatedSignonCertsResponse.html":{},"interfaces/GetAccessTokenCallback.html":{},"interfaces/GetAccessTokenResponse.html":{},"interfaces/GetFederatedSignonCertsCallback.html":{},"interfaces/GetTokenCallback.html":{},"interfaces/GetTokenOptions.html":{},"interfaces/GetTokenResponse.html":{},"interfaces/GoogleAuthOptions.html":{},"interfaces/JWTOptions.html":{},"classes/LoginTicket.html":{},"interfaces/OAuth2ClientOptions.html":{},"interfaces/ProjectIdCallback.html":{},"interfaces/RefreshAccessTokenCallback.html":{},"interfaces/RefreshAccessTokenResponse.html":{},"interfaces/RefreshOptions.html":{},"interfaces/RequestError.html":{},"interfaces/RequestMetadataCallback.html":{},"interfaces/RequestMetadataResponse.html":{},"interfaces/RevokeCredentialsResult.html":{},"interfaces/SignBlobResponse.html":{},"interfaces/TokenInfo.html":{},"interfaces/TokenInfoRequest.html":{},"interfaces/TokenPayload.html":{},"interfaces/Transporter.html":{},"interfaces/UserRefreshClientOptions.html":{},"interfaces/VerifyIdTokenOptions.html":{},"changelog.html":{},"index.html":{},"miscellaneous/variables.html":{}}}],["client'",{"_index":844,"title":{},"body":{"interfaces/FederatedSignonCertsResponse.html":{},"interfaces/GetAccessTokenCallback.html":{},"interfaces/GetAccessTokenResponse.html":{},"interfaces/GetFederatedSignonCertsCallback.html":{},"interfaces/GetTokenCallback.html":{},"interfaces/GetTokenOptions.html":{},"interfaces/GetTokenResponse.html":{},"interfaces/OAuth2ClientOptions.html":{},"interfaces/RefreshAccessTokenCallback.html":{},"interfaces/RefreshAccessTokenResponse.html":{},"interfaces/RefreshOptions.html":{},"interfaces/RequestMetadataCallback.html":{},"interfaces/RequestMetadataResponse.html":{},"interfaces/RevokeCredentialsResult.html":{},"interfaces/TokenInfo.html":{},"interfaces/TokenInfoRequest.html":{},"interfaces/VerifyIdTokenOptions.html":{}}}],["client.email",{"_index":321,"title":{},"body":{"interfaces/ADCCallback.html":{},"interfaces/ADCResponse.html":{},"interfaces/CredentialCallback.html":{},"interfaces/GoogleAuthOptions.html":{},"interfaces/ProjectIdCallback.html":{},"interfaces/SignBlobResponse.html":{}}}],["client.fromapikey(apikey",{"_index":357,"title":{},"body":{"interfaces/ADCCallback.html":{},"interfaces/ADCResponse.html":{},"interfaces/CredentialCallback.html":{},"interfaces/GoogleAuthOptions.html":{},"interfaces/ProjectIdCallback.html":{},"interfaces/SignBlobResponse.html":{}}}],["client.fromjson(json",{"_index":336,"title":{},"body":{"interfaces/ADCCallback.html":{},"interfaces/ADCResponse.html":{},"interfaces/CredentialCallback.html":{},"interfaces/GoogleAuthOptions.html":{},"interfaces/ProjectIdCallback.html":{},"interfaces/SignBlobResponse.html":{}}}],["client.getaccesstoken()).token",{"_index":453,"title":{},"body":{"interfaces/ADCCallback.html":{},"interfaces/ADCResponse.html":{},"interfaces/CredentialCallback.html":{},"interfaces/GoogleAuthOptions.html":{},"interfaces/ProjectIdCallback.html":{},"interfaces/SignBlobResponse.html":{}}}],["client.getrequestheaders();th",{"_index":1544,"title":{},"body":{"changelog.html":{}}}],["client.getrequestheaders(url",{"_index":456,"title":{},"body":{"interfaces/ADCCallback.html":{},"interfaces/ADCResponse.html":{},"interfaces/CredentialCallback.html":{},"interfaces/GoogleAuthOptions.html":{},"interfaces/ProjectIdCallback.html":{},"interfaces/SignBlobResponse.html":{}}}],["client.getrequestmetadata",{"_index":1542,"title":{},"body":{"changelog.html":{}}}],["client.key",{"_index":476,"title":{},"body":{"interfaces/ADCCallback.html":{},"interfaces/ADCResponse.html":{},"interfaces/CredentialCallback.html":{},"interfaces/GoogleAuthOptions.html":{},"interfaces/ProjectIdCallback.html":{},"interfaces/SignBlobResponse.html":{}}}],["client.on('token",{"_index":1755,"title":{},"body":{"index.html":{}}}],["client.request",{"_index":1695,"title":{},"body":{"index.html":{}}}],["client.request(opt",{"_index":470,"title":{},"body":{"interfaces/ADCCallback.html":{},"interfaces/ADCResponse.html":{},"interfaces/CredentialCallback.html":{},"interfaces/GoogleAuthOptions.html":{},"interfaces/ProjectIdCallback.html":{},"interfaces/SignBlobResponse.html":{}}}],["client.request({url",{"_index":1784,"title":{},"body":{"index.html":{}}}],["client.scop",{"_index":1801,"title":{},"body":{"index.html":{}}}],["client/issues/1083",{"_index":529,"title":{},"body":{"interfaces/BodyResponseCallback.html":{},"classes/DefaultTransporter.html":{},"interfaces/RequestError.html":{},"interfaces/Transporter.html":{}}}],["client_email",{"_index":70,"title":{},"body":{"interfaces/ADCCallback.html":{},"interfaces/ADCResponse.html":{},"interfaces/CredentialBody.html":{},"interfaces/CredentialCallback.html":{},"interfaces/CredentialRequest.html":{},"interfaces/Credentials.html":{},"interfaces/GoogleAuthOptions.html":{},"classes/JWTAccess.html":{},"interfaces/JWTInput.html":{},"interfaces/JWTOptions.html":{},"interfaces/ProjectIdCallback.html":{},"interfaces/SignBlobResponse.html":{},"index.html":{}}}],["client_id",{"_index":646,"title":{},"body":{"interfaces/CredentialBody.html":{},"interfaces/CredentialRequest.html":{},"interfaces/Credentials.html":{},"interfaces/FederatedSignonCertsResponse.html":{},"interfaces/GetAccessTokenCallback.html":{},"interfaces/GetAccessTokenResponse.html":{},"interfaces/GetFederatedSignonCertsCallback.html":{},"interfaces/GetTokenCallback.html":{},"interfaces/GetTokenOptions.html":{},"interfaces/GetTokenResponse.html":{},"interfaces/JWTInput.html":{},"classes/LoginTicket.html":{},"interfaces/OAuth2ClientOptions.html":{},"interfaces/RefreshAccessTokenCallback.html":{},"interfaces/RefreshAccessTokenResponse.html":{},"interfaces/RefreshOptions.html":{},"interfaces/RequestMetadataCallback.html":{},"interfaces/RequestMetadataResponse.html":{},"interfaces/RevokeCredentialsResult.html":{},"interfaces/TokenInfo.html":{},"interfaces/TokenInfoRequest.html":{},"interfaces/TokenPayload.html":{},"interfaces/UserRefreshClientOptions.html":{},"interfaces/VerifyIdTokenOptions.html":{},"index.html":{}}}],["client_secret",{"_index":647,"title":{},"body":{"interfaces/CredentialBody.html":{},"interfaces/CredentialRequest.html":{},"interfaces/Credentials.html":{},"interfaces/FederatedSignonCertsResponse.html":{},"interfaces/GetAccessTokenCallback.html":{},"interfaces/GetAccessTokenResponse.html":{},"interfaces/GetFederatedSignonCertsCallback.html":{},"interfaces/GetTokenCallback.html":{},"interfaces/GetTokenOptions.html":{},"interfaces/GetTokenResponse.html":{},"interfaces/JWTInput.html":{},"interfaces/OAuth2ClientOptions.html":{},"interfaces/RefreshAccessTokenCallback.html":{},"interfaces/RefreshAccessTokenResponse.html":{},"interfaces/RefreshOptions.html":{},"interfaces/RequestMetadataCallback.html":{},"interfaces/RequestMetadataResponse.html":{},"interfaces/RevokeCredentialsResult.html":{},"interfaces/TokenInfo.html":{},"interfaces/TokenInfoRequest.html":{},"interfaces/UserRefreshClientOptions.html":{},"interfaces/VerifyIdTokenOptions.html":{},"index.html":{}}}],["client_x509_cert_url",{"_index":1796,"title":{},"body":{"index.html":{}}}],["clientid",{"_index":894,"title":{},"body":{"interfaces/FederatedSignonCertsResponse.html":{},"interfaces/GetAccessTokenCallback.html":{},"interfaces/GetAccessTokenResponse.html":{},"interfaces/GetFederatedSignonCertsCallback.html":{},"interfaces/GetTokenCallback.html":{},"interfaces/GetTokenOptions.html":{},"interfaces/GetTokenResponse.html":{},"interfaces/OAuth2ClientOptions.html":{},"interfaces/RefreshAccessTokenCallback.html":{},"interfaces/RefreshAccessTokenResponse.html":{},"interfaces/RefreshOptions.html":{},"interfaces/RequestMetadataCallback.html":{},"interfaces/RequestMetadataResponse.html":{},"interfaces/RevokeCredentialsResult.html":{},"interfaces/TokenInfo.html":{},"interfaces/TokenInfoRequest.html":{},"interfaces/UserRefreshClientOptions.html":{},"interfaces/VerifyIdTokenOptions.html":{},"index.html":{}}}],["clientsecret",{"_index":895,"title":{},"body":{"interfaces/FederatedSignonCertsResponse.html":{},"interfaces/GetAccessTokenCallback.html":{},"interfaces/GetAccessTokenResponse.html":{},"interfaces/GetFederatedSignonCertsCallback.html":{},"interfaces/GetTokenCallback.html":{},"interfaces/GetTokenOptions.html":{},"interfaces/GetTokenResponse.html":{},"interfaces/OAuth2ClientOptions.html":{},"interfaces/RefreshAccessTokenCallback.html":{},"interfaces/RefreshAccessTokenResponse.html":{},"interfaces/RefreshOptions.html":{},"interfaces/RequestMetadataCallback.html":{},"interfaces/RequestMetadataResponse.html":{},"interfaces/RevokeCredentialsResult.html":{},"interfaces/TokenInfo.html":{},"interfaces/TokenInfoRequest.html":{},"interfaces/UserRefreshClientOptions.html":{},"interfaces/VerifyIdTokenOptions.html":{}}}],["clock",{"_index":942,"title":{},"body":{"interfaces/FederatedSignonCertsResponse.html":{},"interfaces/GetAccessTokenCallback.html":{},"interfaces/GetAccessTokenResponse.html":{},"interfaces/GetFederatedSignonCertsCallback.html":{},"interfaces/GetTokenCallback.html":{},"interfaces/GetTokenOptions.html":{},"interfaces/GetTokenResponse.html":{},"interfaces/OAuth2ClientOptions.html":{},"interfaces/RefreshAccessTokenCallback.html":{},"interfaces/RefreshAccessTokenResponse.html":{},"interfaces/RefreshOptions.html":{},"interfaces/RequestMetadataCallback.html":{},"interfaces/RequestMetadataResponse.html":{},"interfaces/RevokeCredentialsResult.html":{},"interfaces/TokenInfo.html":{},"interfaces/TokenInfoRequest.html":{},"interfaces/VerifyIdTokenOptions.html":{}}}],["clock_skew_secs_",{"_index":946,"title":{},"body":{"interfaces/FederatedSignonCertsResponse.html":{},"interfaces/GetAccessTokenCallback.html":{},"interfaces/GetAccessTokenResponse.html":{},"interfaces/GetFederatedSignonCertsCallback.html":{},"interfaces/GetTokenCallback.html":{},"interfaces/GetTokenOptions.html":{},"interfaces/GetTokenResponse.html":{},"interfaces/OAuth2ClientOptions.html":{},"interfaces/RefreshAccessTokenCallback.html":{},"interfaces/RefreshAccessTokenResponse.html":{},"interfaces/RefreshOptions.html":{},"interfaces/RequestMetadataCallback.html":{},"interfaces/RequestMetadataResponse.html":{},"interfaces/RevokeCredentialsResult.html":{},"interfaces/TokenInfo.html":{},"interfaces/TokenInfoRequest.html":{},"interfaces/VerifyIdTokenOptions.html":{}}}],["clone",{"_index":1301,"title":{},"body":{"interfaces/JWTOptions.html":{}}}],["close",{"_index":987,"title":{},"body":{"interfaces/FederatedSignonCertsResponse.html":{},"interfaces/GetAccessTokenCallback.html":{},"interfaces/GetAccessTokenResponse.html":{},"interfaces/GetFederatedSignonCertsCallback.html":{},"interfaces/GetTokenCallback.html":{},"interfaces/GetTokenOptions.html":{},"interfaces/GetTokenResponse.html":{},"interfaces/OAuth2ClientOptions.html":{},"interfaces/RefreshAccessTokenCallback.html":{},"interfaces/RefreshAccessTokenResponse.html":{},"interfaces/RefreshOptions.html":{},"interfaces/RequestMetadataCallback.html":{},"interfaces/RequestMetadataResponse.html":{},"interfaces/RevokeCredentialsResult.html":{},"interfaces/TokenInfo.html":{},"interfaces/TokenInfoRequest.html":{},"interfaces/VerifyIdTokenOptions.html":{},"index.html":{}}}],["cloud",{"_index":167,"title":{},"body":{"interfaces/ADCCallback.html":{},"interfaces/ADCResponse.html":{},"interfaces/CredentialCallback.html":{},"interfaces/GoogleAuthOptions.html":{},"interfaces/ProjectIdCallback.html":{},"interfaces/SignBlobResponse.html":{},"interfaces/Warning.html":{},"changelog.html":{},"index.html":{},"miscellaneous/variables.html":{}}}],["cloud_funct",{"_index":1655,"title":{},"body":{"miscellaneous/enumerations.html":{}}}],["cloud_sdk_client_id",{"_index":81,"title":{},"body":{"interfaces/ADCCallback.html":{},"interfaces/ADCResponse.html":{},"interfaces/CredentialCallback.html":{},"interfaces/GoogleAuthOptions.html":{},"interfaces/ProjectIdCallback.html":{},"interfaces/SignBlobResponse.html":{},"miscellaneous/variables.html":{}}}],["code",{"_index":471,"title":{},"body":{"interfaces/ADCCallback.html":{},"interfaces/ADCResponse.html":{},"interfaces/BodyResponseCallback.html":{},"interfaces/CredentialCallback.html":{},"classes/DefaultTransporter.html":{},"interfaces/FederatedSignonCertsResponse.html":{},"interfaces/GetAccessTokenCallback.html":{},"interfaces/GetAccessTokenResponse.html":{},"interfaces/GetFederatedSignonCertsCallback.html":{},"interfaces/GetTokenCallback.html":{},"interfaces/GetTokenOptions.html":{},"interfaces/GetTokenResponse.html":{},"interfaces/GoogleAuthOptions.html":{},"interfaces/OAuth2ClientOptions.html":{},"interfaces/ProjectIdCallback.html":{},"interfaces/RefreshAccessTokenCallback.html":{},"interfaces/RefreshAccessTokenResponse.html":{},"interfaces/RefreshOptions.html":{},"interfaces/RequestError.html":{},"interfaces/RequestMetadataCallback.html":{},"interfaces/RequestMetadataResponse.html":{},"interfaces/RevokeCredentialsResult.html":{},"interfaces/SignBlobResponse.html":{},"interfaces/TokenInfo.html":{},"interfaces/TokenInfoRequest.html":{},"interfaces/Transporter.html":{},"interfaces/VerifyIdTokenOptions.html":{},"interfaces/Warning.html":{},"changelog.html":{},"index.html":{},"license.html":{},"miscellaneous/variables.html":{}}}],["code_challeng",{"_index":873,"title":{},"body":{"interfaces/FederatedSignonCertsResponse.html":{},"interfaces/GetAccessTokenCallback.html":{},"interfaces/GetAccessTokenResponse.html":{},"interfaces/GetFederatedSignonCertsCallback.html":{},"interfaces/GetTokenCallback.html":{},"interfaces/GetTokenOptions.html":{},"interfaces/GetTokenResponse.html":{},"interfaces/OAuth2ClientOptions.html":{},"interfaces/RefreshAccessTokenCallback.html":{},"interfaces/RefreshAccessTokenResponse.html":{},"interfaces/RefreshOptions.html":{},"interfaces/RequestMetadataCallback.html":{},"interfaces/RequestMetadataResponse.html":{},"interfaces/RevokeCredentialsResult.html":{},"interfaces/TokenInfo.html":{},"interfaces/TokenInfoRequest.html":{},"interfaces/VerifyIdTokenOptions.html":{}}}],["code_challenge_method",{"_index":874,"title":{},"body":{"interfaces/FederatedSignonCertsResponse.html":{},"interfaces/GetAccessTokenCallback.html":{},"interfaces/GetAccessTokenResponse.html":{},"interfaces/GetFederatedSignonCertsCallback.html":{},"interfaces/GetTokenCallback.html":{},"interfaces/GetTokenOptions.html":{},"interfaces/GetTokenResponse.html":{},"interfaces/OAuth2ClientOptions.html":{},"interfaces/RefreshAccessTokenCallback.html":{},"interfaces/RefreshAccessTokenResponse.html":{},"interfaces/RefreshOptions.html":{},"interfaces/RequestMetadataCallback.html":{},"interfaces/RequestMetadataResponse.html":{},"interfaces/RevokeCredentialsResult.html":{},"interfaces/TokenInfo.html":{},"interfaces/TokenInfoRequest.html":{},"interfaces/VerifyIdTokenOptions.html":{}}}],["code_verifi",{"_index":871,"title":{},"body":{"interfaces/FederatedSignonCertsResponse.html":{},"interfaces/GetAccessTokenCallback.html":{},"interfaces/GetAccessTokenResponse.html":{},"interfaces/GetFederatedSignonCertsCallback.html":{},"interfaces/GetTokenCallback.html":{},"interfaces/GetTokenOptions.html":{},"interfaces/GetTokenResponse.html":{},"interfaces/OAuth2ClientOptions.html":{},"interfaces/RefreshAccessTokenCallback.html":{},"interfaces/RefreshAccessTokenResponse.html":{},"interfaces/RefreshOptions.html":{},"interfaces/RequestMetadataCallback.html":{},"interfaces/RequestMetadataResponse.html":{},"interfaces/RevokeCredentialsResult.html":{},"interfaces/TokenInfo.html":{},"interfaces/TokenInfoRequest.html":{},"interfaces/VerifyIdTokenOptions.html":{}}}],["codechalleng",{"_index":998,"title":{},"body":{"interfaces/FederatedSignonCertsResponse.html":{},"interfaces/GetAccessTokenCallback.html":{},"interfaces/GetAccessTokenResponse.html":{},"interfaces/GetFederatedSignonCertsCallback.html":{},"interfaces/GetTokenCallback.html":{},"interfaces/GetTokenOptions.html":{},"interfaces/GetTokenResponse.html":{},"interfaces/OAuth2ClientOptions.html":{},"interfaces/RefreshAccessTokenCallback.html":{},"interfaces/RefreshAccessTokenResponse.html":{},"interfaces/RefreshOptions.html":{},"interfaces/RequestMetadataCallback.html":{},"interfaces/RequestMetadataResponse.html":{},"interfaces/RevokeCredentialsResult.html":{},"interfaces/TokenInfo.html":{},"interfaces/TokenInfoRequest.html":{},"interfaces/VerifyIdTokenOptions.html":{}}}],["codechallengemethod",{"_index":695,"title":{},"body":{"interfaces/FederatedSignonCertsResponse.html":{},"interfaces/GetAccessTokenCallback.html":{},"interfaces/GetAccessTokenResponse.html":{},"interfaces/GetFederatedSignonCertsCallback.html":{},"interfaces/GetTokenCallback.html":{},"interfaces/GetTokenOptions.html":{},"interfaces/GetTokenResponse.html":{},"interfaces/OAuth2ClientOptions.html":{},"interfaces/RefreshAccessTokenCallback.html":{},"interfaces/RefreshAccessTokenResponse.html":{},"interfaces/RefreshOptions.html":{},"interfaces/RequestMetadataCallback.html":{},"interfaces/RequestMetadataResponse.html":{},"interfaces/RevokeCredentialsResult.html":{},"interfaces/TokenInfo.html":{},"interfaces/TokenInfoRequest.html":{},"interfaces/VerifyIdTokenOptions.html":{},"miscellaneous/enumerations.html":{}}}],["codecov",{"_index":1504,"title":{},"body":{"changelog.html":{}}}],["codeoropt",{"_index":1007,"title":{},"body":{"interfaces/FederatedSignonCertsResponse.html":{},"interfaces/GetAccessTokenCallback.html":{},"interfaces/GetAccessTokenResponse.html":{},"interfaces/GetFederatedSignonCertsCallback.html":{},"interfaces/GetTokenCallback.html":{},"interfaces/GetTokenOptions.html":{},"interfaces/GetTokenResponse.html":{},"interfaces/OAuth2ClientOptions.html":{},"interfaces/RefreshAccessTokenCallback.html":{},"interfaces/RefreshAccessTokenResponse.html":{},"interfaces/RefreshOptions.html":{},"interfaces/RequestMetadataCallback.html":{},"interfaces/RequestMetadataResponse.html":{},"interfaces/RevokeCredentialsResult.html":{},"interfaces/TokenInfo.html":{},"interfaces/TokenInfoRequest.html":{},"interfaces/VerifyIdTokenOptions.html":{}}}],["codeverifi",{"_index":699,"title":{},"body":{"interfaces/FederatedSignonCertsResponse.html":{},"interfaces/GetAccessTokenCallback.html":{},"interfaces/GetAccessTokenResponse.html":{},"interfaces/GetFederatedSignonCertsCallback.html":{},"interfaces/GetTokenCallback.html":{},"interfaces/GetTokenOptions.html":{},"interfaces/GetTokenResponse.html":{},"interfaces/OAuth2ClientOptions.html":{},"interfaces/RefreshAccessTokenCallback.html":{},"interfaces/RefreshAccessTokenResponse.html":{},"interfaces/RefreshOptions.html":{},"interfaces/RequestMetadataCallback.html":{},"interfaces/RequestMetadataResponse.html":{},"interfaces/RevokeCredentialsResult.html":{},"interfaces/TokenInfo.html":{},"interfaces/TokenInfoRequest.html":{},"interfaces/VerifyIdTokenOptions.html":{}}}],["collect",{"_index":1502,"title":{},"body":{"changelog.html":{}}}],["collid",{"_index":1262,"title":{},"body":{"classes/JWTAccess.html":{}}}],["combin",{"_index":1903,"title":{},"body":{"license.html":{}}}],["come",{"_index":1698,"title":{},"body":{"index.html":{}}}],["command",{"_index":395,"title":{},"body":{"interfaces/ADCCallback.html":{},"interfaces/ADCResponse.html":{},"interfaces/CredentialCallback.html":{},"interfaces/GoogleAuthOptions.html":{},"interfaces/ProjectIdCallback.html":{},"interfaces/SignBlobResponse.html":{},"index.html":{}}}],["comment",{"_index":1987,"title":{},"body":{"license.html":{}}}],["commerci",{"_index":1972,"title":{},"body":{"license.html":{}}}],["commit",{"_index":1682,"title":{},"body":{"index.html":{}}}],["common",{"_index":1831,"title":{},"body":{"license.html":{}}}],["commun",{"_index":1674,"title":{},"body":{"index.html":{},"license.html":{}}}],["compil",{"_index":1849,"title":{},"body":{"license.html":{}}}],["complet",{"_index":704,"title":{},"body":{"interfaces/FederatedSignonCertsResponse.html":{},"interfaces/GetAccessTokenCallback.html":{},"interfaces/GetAccessTokenResponse.html":{},"interfaces/GetFederatedSignonCertsCallback.html":{},"interfaces/GetTokenCallback.html":{},"interfaces/GetTokenOptions.html":{},"interfaces/GetTokenResponse.html":{},"interfaces/OAuth2ClientOptions.html":{},"interfaces/RefreshAccessTokenCallback.html":{},"interfaces/RefreshAccessTokenResponse.html":{},"interfaces/RefreshOptions.html":{},"interfaces/RequestMetadataCallback.html":{},"interfaces/RequestMetadataResponse.html":{},"interfaces/RevokeCredentialsResult.html":{},"interfaces/TokenInfo.html":{},"interfaces/TokenInfoRequest.html":{},"interfaces/VerifyIdTokenOptions.html":{},"index.html":{}}}],["compli",{"_index":1935,"title":{},"body":{"license.html":{}}}],["complianc",{"_index":660,"title":{},"body":{"interfaces/Credentials.html":{},"classes/LoginTicket.html":{},"miscellaneous/functions.html":{},"license.html":{}}}],["comput",{"_index":39,"title":{},"body":{"interfaces/ADCCallback.html":{},"interfaces/ADCResponse.html":{},"interfaces/ComputeOptions.html":{},"interfaces/CredentialCallback.html":{},"interfaces/GoogleAuthOptions.html":{},"interfaces/ProjectIdCallback.html":{},"interfaces/SignBlobResponse.html":{},"interfaces/Warning.html":{},"changelog.html":{},"index.html":{},"license.html":{},"miscellaneous/variables.html":{}}}],["compute(opt",{"_index":248,"title":{},"body":{"interfaces/ADCCallback.html":{},"interfaces/ADCResponse.html":{},"interfaces/CredentialCallback.html":{},"interfaces/GoogleAuthOptions.html":{},"interfaces/ProjectIdCallback.html":{},"interfaces/SignBlobResponse.html":{}}}],["compute_create_scoped_deprec",{"_index":1442,"title":{},"body":{"interfaces/Warning.html":{},"miscellaneous/variables.html":{}}}],["compute_engin",{"_index":1656,"title":{},"body":{"miscellaneous/enumerations.html":{}}}],["computecli",{"_index":40,"title":{},"body":{"interfaces/ADCCallback.html":{},"interfaces/ADCResponse.html":{},"interfaces/CredentialCallback.html":{},"interfaces/GoogleAuthOptions.html":{},"interfaces/ProjectIdCallback.html":{},"interfaces/SignBlobResponse.html":{}}}],["computeopt",{"_index":579,"title":{"interfaces/ComputeOptions.html":{}},"body":{"interfaces/ComputeOptions.html":{}}}],["condit",{"_index":671,"title":{},"body":{"interfaces/Credentials.html":{},"classes/LoginTicket.html":{},"miscellaneous/functions.html":{},"license.html":{}}}],["conduct",{"_index":1572,"title":{},"body":{"changelog.html":{}}}],["config",{"_index":170,"title":{},"body":{"interfaces/ADCCallback.html":{},"interfaces/ADCResponse.html":{},"interfaces/CredentialCallback.html":{},"interfaces/GoogleAuthOptions.html":{},"interfaces/ProjectIdCallback.html":{},"interfaces/SignBlobResponse.html":{},"interfaces/Warning.html":{},"changelog.html":{},"index.html":{}}}],["configur",{"_index":439,"title":{},"body":{"interfaces/ADCCallback.html":{},"interfaces/ADCResponse.html":{},"interfaces/BodyResponseCallback.html":{},"interfaces/CredentialCallback.html":{},"classes/DefaultTransporter.html":{},"interfaces/GoogleAuthOptions.html":{},"interfaces/ProjectIdCallback.html":{},"interfaces/RequestError.html":{},"interfaces/SignBlobResponse.html":{},"interfaces/Transporter.html":{},"changelog.html":{},"index.html":{},"license.html":{}}}],["configure(opt",{"_index":536,"title":{},"body":{"interfaces/BodyResponseCallback.html":{},"classes/DefaultTransporter.html":{},"interfaces/RequestError.html":{},"interfaces/Transporter.html":{}}}],["confirm",{"_index":850,"title":{},"body":{"interfaces/FederatedSignonCertsResponse.html":{},"interfaces/GetAccessTokenCallback.html":{},"interfaces/GetAccessTokenResponse.html":{},"interfaces/GetFederatedSignonCertsCallback.html":{},"interfaces/GetTokenCallback.html":{},"interfaces/GetTokenOptions.html":{},"interfaces/GetTokenResponse.html":{},"interfaces/OAuth2ClientOptions.html":{},"interfaces/RefreshAccessTokenCallback.html":{},"interfaces/RefreshAccessTokenResponse.html":{},"interfaces/RefreshOptions.html":{},"interfaces/RequestMetadataCallback.html":{},"interfaces/RequestMetadataResponse.html":{},"interfaces/RevokeCredentialsResult.html":{},"interfaces/TokenInfo.html":{},"interfaces/TokenInfoRequest.html":{},"interfaces/VerifyIdTokenOptions.html":{}}}],["connect",{"_index":837,"title":{},"body":{"interfaces/FederatedSignonCertsResponse.html":{},"interfaces/GetAccessTokenCallback.html":{},"interfaces/GetAccessTokenResponse.html":{},"interfaces/GetFederatedSignonCertsCallback.html":{},"interfaces/GetTokenCallback.html":{},"interfaces/GetTokenOptions.html":{},"interfaces/GetTokenResponse.html":{},"interfaces/OAuth2ClientOptions.html":{},"interfaces/RefreshAccessTokenCallback.html":{},"interfaces/RefreshAccessTokenResponse.html":{},"interfaces/RefreshOptions.html":{},"interfaces/RequestMetadataCallback.html":{},"interfaces/RequestMetadataResponse.html":{},"interfaces/RevokeCredentialsResult.html":{},"interfaces/TokenInfo.html":{},"interfaces/TokenInfoRequest.html":{},"interfaces/VerifyIdTokenOptions.html":{}}}],["consent",{"_index":792,"title":{},"body":{"interfaces/FederatedSignonCertsResponse.html":{},"interfaces/GetAccessTokenCallback.html":{},"interfaces/GetAccessTokenResponse.html":{},"interfaces/GetFederatedSignonCertsCallback.html":{},"interfaces/GetTokenCallback.html":{},"interfaces/GetTokenOptions.html":{},"interfaces/GetTokenResponse.html":{},"interfaces/OAuth2ClientOptions.html":{},"interfaces/RefreshAccessTokenCallback.html":{},"interfaces/RefreshAccessTokenResponse.html":{},"interfaces/RefreshOptions.html":{},"interfaces/RequestMetadataCallback.html":{},"interfaces/RequestMetadataResponse.html":{},"interfaces/RevokeCredentialsResult.html":{},"interfaces/TokenInfo.html":{},"interfaces/TokenInfoRequest.html":{},"interfaces/VerifyIdTokenOptions.html":{},"index.html":{}}}],["consequenti",{"_index":1964,"title":{},"body":{"license.html":{}}}],["consid",{"_index":575,"title":{},"body":{"interfaces/BodyResponseCallback.html":{},"classes/DefaultTransporter.html":{},"interfaces/RequestError.html":{},"interfaces/Transporter.html":{}}}],["consist",{"_index":1585,"title":{},"body":{"changelog.html":{},"license.html":{}}}],["consol",{"_index":782,"title":{},"body":{"interfaces/FederatedSignonCertsResponse.html":{},"interfaces/GetAccessTokenCallback.html":{},"interfaces/GetAccessTokenResponse.html":{},"interfaces/GetFederatedSignonCertsCallback.html":{},"interfaces/GetTokenCallback.html":{},"interfaces/GetTokenOptions.html":{},"interfaces/GetTokenResponse.html":{},"interfaces/OAuth2ClientOptions.html":{},"interfaces/RefreshAccessTokenCallback.html":{},"interfaces/RefreshAccessTokenResponse.html":{},"interfaces/RefreshOptions.html":{},"interfaces/RequestMetadataCallback.html":{},"interfaces/RequestMetadataResponse.html":{},"interfaces/RevokeCredentialsResult.html":{},"interfaces/TokenInfo.html":{},"interfaces/TokenInfoRequest.html":{},"interfaces/VerifyIdTokenOptions.html":{},"index.html":{}}}],["console.error(",{"_index":1720,"title":{},"body":{"index.html":{}}}],["console.info('token",{"_index":1746,"title":{},"body":{"index.html":{}}}],["console.log(`cod",{"_index":1740,"title":{},"body":{"index.html":{}}}],["console.log(res.data",{"_index":1696,"title":{},"body":{"index.html":{}}}],["console.log(tokeninfo.scopes);thi",{"_index":1773,"title":{},"body":{"index.html":{}}}],["console.log(tokens.access_token",{"_index":1758,"title":{},"body":{"index.html":{}}}],["console.log(tokens.refresh_token",{"_index":1757,"title":{},"body":{"index.html":{}}}],["conspicu",{"_index":1875,"title":{},"body":{"license.html":{}}}],["const",{"_index":80,"title":{},"body":{"interfaces/ADCCallback.html":{},"interfaces/ADCResponse.html":{},"interfaces/BodyResponseCallback.html":{},"interfaces/ComputeOptions.html":{},"interfaces/CredentialCallback.html":{},"classes/DefaultTransporter.html":{},"interfaces/FederatedSignonCertsResponse.html":{},"interfaces/GetAccessTokenCallback.html":{},"interfaces/GetAccessTokenResponse.html":{},"interfaces/GetFederatedSignonCertsCallback.html":{},"interfaces/GetTokenCallback.html":{},"interfaces/GetTokenOptions.html":{},"interfaces/GetTokenResponse.html":{},"interfaces/GoogleAuthOptions.html":{},"classes/JWTAccess.html":{},"interfaces/JWTOptions.html":{},"classes/LoginTicket.html":{},"interfaces/OAuth2ClientOptions.html":{},"classes/PemVerifier.html":{},"interfaces/ProjectIdCallback.html":{},"interfaces/RefreshAccessTokenCallback.html":{},"interfaces/RefreshAccessTokenResponse.html":{},"interfaces/RefreshOptions.html":{},"interfaces/RequestError.html":{},"interfaces/RequestMetadataCallback.html":{},"interfaces/RequestMetadataResponse.html":{},"interfaces/RevokeCredentialsResult.html":{},"interfaces/SignBlobResponse.html":{},"interfaces/TokenInfo.html":{},"interfaces/TokenInfoRequest.html":{},"interfaces/TokenPayload.html":{},"interfaces/Transporter.html":{},"interfaces/UserRefreshClientOptions.html":{},"interfaces/VerifyIdTokenOptions.html":{},"interfaces/Warning.html":{},"changelog.html":{},"index.html":{}}}],["constitut",{"_index":1909,"title":{},"body":{"license.html":{}}}],["constru",{"_index":1932,"title":{},"body":{"license.html":{}}}],["constructor",{"_index":700,"title":{},"body":{"interfaces/FederatedSignonCertsResponse.html":{},"interfaces/GetAccessTokenCallback.html":{},"interfaces/GetAccessTokenResponse.html":{},"interfaces/GetFederatedSignonCertsCallback.html":{},"interfaces/GetTokenCallback.html":{},"interfaces/GetTokenOptions.html":{},"interfaces/GetTokenResponse.html":{},"classes/IAMAuth.html":{},"classes/JWTAccess.html":{},"interfaces/JWTOptions.html":{},"classes/LoginTicket.html":{},"interfaces/OAuth2ClientOptions.html":{},"interfaces/RefreshAccessTokenCallback.html":{},"interfaces/RefreshAccessTokenResponse.html":{},"interfaces/RefreshOptions.html":{},"interfaces/RequestMetadata.html":{},"interfaces/RequestMetadataCallback.html":{},"interfaces/RequestMetadataResponse.html":{},"interfaces/RevokeCredentialsResult.html":{},"interfaces/TokenInfo.html":{},"interfaces/TokenInfoRequest.html":{},"interfaces/TokenPayload.html":{},"interfaces/UserRefreshClientOptions.html":{},"interfaces/VerifyIdTokenOptions.html":{},"changelog.html":{},"index.html":{}}}],["constructor(clientid",{"_index":917,"title":{},"body":{"interfaces/FederatedSignonCertsResponse.html":{},"interfaces/GetAccessTokenCallback.html":{},"interfaces/GetAccessTokenResponse.html":{},"interfaces/GetFederatedSignonCertsCallback.html":{},"interfaces/GetTokenCallback.html":{},"interfaces/GetTokenOptions.html":{},"interfaces/GetTokenResponse.html":{},"interfaces/OAuth2ClientOptions.html":{},"interfaces/RefreshAccessTokenCallback.html":{},"interfaces/RefreshAccessTokenResponse.html":{},"interfaces/RefreshOptions.html":{},"interfaces/RequestMetadataCallback.html":{},"interfaces/RequestMetadataResponse.html":{},"interfaces/RevokeCredentialsResult.html":{},"interfaces/TokenInfo.html":{},"interfaces/TokenInfoRequest.html":{},"interfaces/UserRefreshClientOptions.html":{},"interfaces/VerifyIdTokenOptions.html":{}}}],["constructor(email",{"_index":1221,"title":{},"body":{"classes/JWTAccess.html":{}}}],["constructor(env",{"_index":1345,"title":{},"body":{"classes/LoginTicket.html":{},"interfaces/TokenPayload.html":{}}}],["constructor(opt",{"_index":118,"title":{},"body":{"interfaces/ADCCallback.html":{},"interfaces/ADCResponse.html":{},"interfaces/ComputeOptions.html":{},"interfaces/CredentialCallback.html":{},"interfaces/FederatedSignonCertsResponse.html":{},"interfaces/GetAccessTokenCallback.html":{},"interfaces/GetAccessTokenResponse.html":{},"interfaces/GetFederatedSignonCertsCallback.html":{},"interfaces/GetTokenCallback.html":{},"interfaces/GetTokenOptions.html":{},"interfaces/GetTokenResponse.html":{},"interfaces/GoogleAuthOptions.html":{},"interfaces/JWTOptions.html":{},"interfaces/OAuth2ClientOptions.html":{},"interfaces/ProjectIdCallback.html":{},"interfaces/RefreshAccessTokenCallback.html":{},"interfaces/RefreshAccessTokenResponse.html":{},"interfaces/RefreshOptions.html":{},"interfaces/RequestMetadataCallback.html":{},"interfaces/RequestMetadataResponse.html":{},"interfaces/RevokeCredentialsResult.html":{},"interfaces/SignBlobResponse.html":{},"interfaces/TokenInfo.html":{},"interfaces/TokenInfoRequest.html":{},"interfaces/UserRefreshClientOptions.html":{},"interfaces/VerifyIdTokenOptions.html":{}}}],["constructor(publ",{"_index":1209,"title":{},"body":{"classes/IAMAuth.html":{},"interfaces/RequestMetadata.html":{}}}],["constructor(selector",{"_index":1194,"title":{},"body":{"classes/IAMAuth.html":{}}}],["contain",{"_index":69,"title":{},"body":{"interfaces/ADCCallback.html":{},"interfaces/ADCResponse.html":{},"interfaces/BodyResponseCallback.html":{},"interfaces/CredentialCallback.html":{},"classes/DefaultTransporter.html":{},"interfaces/FederatedSignonCertsResponse.html":{},"interfaces/GetAccessTokenCallback.html":{},"interfaces/GetAccessTokenResponse.html":{},"interfaces/GetFederatedSignonCertsCallback.html":{},"interfaces/GetTokenCallback.html":{},"interfaces/GetTokenOptions.html":{},"interfaces/GetTokenResponse.html":{},"interfaces/GoogleAuthOptions.html":{},"classes/IAMAuth.html":{},"classes/JWTAccess.html":{},"interfaces/JWTOptions.html":{},"classes/LoginTicket.html":{},"interfaces/OAuth2ClientOptions.html":{},"interfaces/ProjectIdCallback.html":{},"interfaces/RefreshAccessTokenCallback.html":{},"interfaces/RefreshAccessTokenResponse.html":{},"interfaces/RefreshOptions.html":{},"interfaces/RequestError.html":{},"interfaces/RequestMetadata.html":{},"interfaces/RequestMetadataCallback.html":{},"interfaces/RequestMetadataResponse.html":{},"interfaces/RevokeCredentialsResult.html":{},"interfaces/SignBlobResponse.html":{},"interfaces/TokenInfo.html":{},"interfaces/TokenInfoRequest.html":{},"interfaces/TokenPayload.html":{},"interfaces/Transporter.html":{},"interfaces/UserRefreshClientOptions.html":{},"interfaces/VerifyIdTokenOptions.html":{},"changelog.html":{},"index.html":{},"license.html":{}}}],["content",{"_index":112,"title":{},"body":{"interfaces/ADCCallback.html":{},"interfaces/ADCResponse.html":{},"interfaces/CredentialCallback.html":{},"interfaces/FederatedSignonCertsResponse.html":{},"interfaces/GetAccessTokenCallback.html":{},"interfaces/GetAccessTokenResponse.html":{},"interfaces/GetFederatedSignonCertsCallback.html":{},"interfaces/GetTokenCallback.html":{},"interfaces/GetTokenOptions.html":{},"interfaces/GetTokenResponse.html":{},"interfaces/GoogleAuthOptions.html":{},"interfaces/OAuth2ClientOptions.html":{},"interfaces/ProjectIdCallback.html":{},"interfaces/RefreshAccessTokenCallback.html":{},"interfaces/RefreshAccessTokenResponse.html":{},"interfaces/RefreshOptions.html":{},"interfaces/RequestMetadataCallback.html":{},"interfaces/RequestMetadataResponse.html":{},"interfaces/RevokeCredentialsResult.html":{},"interfaces/SignBlobResponse.html":{},"interfaces/TokenInfo.html":{},"interfaces/TokenInfoRequest.html":{},"interfaces/VerifyIdTokenOptions.html":{},"index.html":{},"license.html":{}}}],["context",{"_index":804,"title":{},"body":{"interfaces/FederatedSignonCertsResponse.html":{},"interfaces/GetAccessTokenCallback.html":{},"interfaces/GetAccessTokenResponse.html":{},"interfaces/GetFederatedSignonCertsCallback.html":{},"interfaces/GetTokenCallback.html":{},"interfaces/GetTokenOptions.html":{},"interfaces/GetTokenResponse.html":{},"interfaces/OAuth2ClientOptions.html":{},"interfaces/RefreshAccessTokenCallback.html":{},"interfaces/RefreshAccessTokenResponse.html":{},"interfaces/RefreshOptions.html":{},"interfaces/RequestMetadataCallback.html":{},"interfaces/RequestMetadataResponse.html":{},"interfaces/RevokeCredentialsResult.html":{},"interfaces/TokenInfo.html":{},"interfaces/TokenInfoRequest.html":{},"interfaces/VerifyIdTokenOptions.html":{}}}],["continu",{"_index":1434,"title":{},"body":{"interfaces/Warning.html":{},"changelog.html":{},"miscellaneous/variables.html":{}}}],["contract",{"_index":1835,"title":{},"body":{"license.html":{}}}],["contribut",{"_index":1815,"title":{},"body":{"index.html":{},"license.html":{}}}],["contribution(",{"_index":1901,"title":{},"body":{"license.html":{}}}],["contributor",{"_index":1878,"title":{},"body":{"license.html":{}}}],["contributori",{"_index":1910,"title":{},"body":{"license.html":{}}}],["control",{"_index":773,"title":{},"body":{"interfaces/FederatedSignonCertsResponse.html":{},"interfaces/GetAccessTokenCallback.html":{},"interfaces/GetAccessTokenResponse.html":{},"interfaces/GetFederatedSignonCertsCallback.html":{},"interfaces/GetTokenCallback.html":{},"interfaces/GetTokenOptions.html":{},"interfaces/GetTokenResponse.html":{},"interfaces/OAuth2ClientOptions.html":{},"interfaces/RefreshAccessTokenCallback.html":{},"interfaces/RefreshAccessTokenResponse.html":{},"interfaces/RefreshOptions.html":{},"interfaces/RequestMetadataCallback.html":{},"interfaces/RequestMetadataResponse.html":{},"interfaces/RevokeCredentialsResult.html":{},"interfaces/TokenInfo.html":{},"interfaces/TokenInfoRequest.html":{},"interfaces/VerifyIdTokenOptions.html":{},"index.html":{},"license.html":{}}}],["conveni",{"_index":969,"title":{},"body":{"interfaces/FederatedSignonCertsResponse.html":{},"interfaces/GetAccessTokenCallback.html":{},"interfaces/GetAccessTokenResponse.html":{},"interfaces/GetFederatedSignonCertsCallback.html":{},"interfaces/GetTokenCallback.html":{},"interfaces/GetTokenOptions.html":{},"interfaces/GetTokenResponse.html":{},"interfaces/OAuth2ClientOptions.html":{},"interfaces/RefreshAccessTokenCallback.html":{},"interfaces/RefreshAccessTokenResponse.html":{},"interfaces/RefreshOptions.html":{},"interfaces/RequestMetadataCallback.html":{},"interfaces/RequestMetadataResponse.html":{},"interfaces/RevokeCredentialsResult.html":{},"interfaces/TokenInfo.html":{},"interfaces/TokenInfoRequest.html":{},"interfaces/VerifyIdTokenOptions.html":{},"index.html":{}}}],["convers",{"_index":1850,"title":{},"body":{"license.html":{}}}],["convert",{"_index":1318,"title":{},"body":{"interfaces/JWTOptions.html":{}}}],["cooki",{"_index":841,"title":{},"body":{"interfaces/FederatedSignonCertsResponse.html":{},"interfaces/GetAccessTokenCallback.html":{},"interfaces/GetAccessTokenResponse.html":{},"interfaces/GetFederatedSignonCertsCallback.html":{},"interfaces/GetTokenCallback.html":{},"interfaces/GetTokenOptions.html":{},"interfaces/GetTokenResponse.html":{},"interfaces/OAuth2ClientOptions.html":{},"interfaces/RefreshAccessTokenCallback.html":{},"interfaces/RefreshAccessTokenResponse.html":{},"interfaces/RefreshOptions.html":{},"interfaces/RequestMetadataCallback.html":{},"interfaces/RequestMetadataResponse.html":{},"interfaces/RevokeCredentialsResult.html":{},"interfaces/TokenInfo.html":{},"interfaces/TokenInfoRequest.html":{},"interfaces/VerifyIdTokenOptions.html":{}}}],["copi",{"_index":661,"title":{},"body":{"interfaces/Credentials.html":{},"interfaces/JWTOptions.html":{},"classes/LoginTicket.html":{},"miscellaneous/functions.html":{},"index.html":{},"license.html":{}}}],["copyright",{"_index":649,"title":{},"body":{"interfaces/Credentials.html":{},"classes/LoginTicket.html":{},"miscellaneous/functions.html":{},"license.html":{}}}],["correct",{"_index":632,"title":{},"body":{"interfaces/ComputeOptions.html":{},"interfaces/FederatedSignonCertsResponse.html":{},"interfaces/GetAccessTokenCallback.html":{},"interfaces/GetAccessTokenResponse.html":{},"interfaces/GetFederatedSignonCertsCallback.html":{},"interfaces/GetTokenCallback.html":{},"interfaces/GetTokenOptions.html":{},"interfaces/GetTokenResponse.html":{},"interfaces/OAuth2ClientOptions.html":{},"interfaces/RefreshAccessTokenCallback.html":{},"interfaces/RefreshAccessTokenResponse.html":{},"interfaces/RefreshOptions.html":{},"interfaces/RequestMetadataCallback.html":{},"interfaces/RequestMetadataResponse.html":{},"interfaces/RevokeCredentialsResult.html":{},"interfaces/TokenInfo.html":{},"interfaces/TokenInfoRequest.html":{},"interfaces/VerifyIdTokenOptions.html":{},"index.html":{}}}],["correl",{"_index":711,"title":{},"body":{"interfaces/FederatedSignonCertsResponse.html":{},"interfaces/GetAccessTokenCallback.html":{},"interfaces/GetAccessTokenResponse.html":{},"interfaces/GetFederatedSignonCertsCallback.html":{},"interfaces/GetTokenCallback.html":{},"interfaces/GetTokenOptions.html":{},"interfaces/GetTokenResponse.html":{},"interfaces/OAuth2ClientOptions.html":{},"interfaces/RefreshAccessTokenCallback.html":{},"interfaces/RefreshAccessTokenResponse.html":{},"interfaces/RefreshOptions.html":{},"interfaces/RequestMetadataCallback.html":{},"interfaces/RequestMetadataResponse.html":{},"interfaces/RevokeCredentialsResult.html":{},"interfaces/TokenInfo.html":{},"interfaces/TokenInfoRequest.html":{},"interfaces/VerifyIdTokenOptions.html":{}}}],["correspond",{"_index":701,"title":{},"body":{"interfaces/FederatedSignonCertsResponse.html":{},"interfaces/GetAccessTokenCallback.html":{},"interfaces/GetAccessTokenResponse.html":{},"interfaces/GetFederatedSignonCertsCallback.html":{},"interfaces/GetTokenCallback.html":{},"interfaces/GetTokenOptions.html":{},"interfaces/GetTokenResponse.html":{},"interfaces/OAuth2ClientOptions.html":{},"interfaces/RefreshAccessTokenCallback.html":{},"interfaces/RefreshAccessTokenResponse.html":{},"interfaces/RefreshOptions.html":{},"interfaces/RequestMetadataCallback.html":{},"interfaces/RequestMetadataResponse.html":{},"interfaces/RevokeCredentialsResult.html":{},"interfaces/TokenInfo.html":{},"interfaces/TokenInfoRequest.html":{},"interfaces/VerifyIdTokenOptions.html":{}}}],["counterclaim",{"_index":1906,"title":{},"body":{"license.html":{}}}],["cover",{"_index":853,"title":{},"body":{"interfaces/FederatedSignonCertsResponse.html":{},"interfaces/GetAccessTokenCallback.html":{},"interfaces/GetAccessTokenResponse.html":{},"interfaces/GetFederatedSignonCertsCallback.html":{},"interfaces/GetTokenCallback.html":{},"interfaces/GetTokenOptions.html":{},"interfaces/GetTokenResponse.html":{},"interfaces/OAuth2ClientOptions.html":{},"interfaces/RefreshAccessTokenCallback.html":{},"interfaces/RefreshAccessTokenResponse.html":{},"interfaces/RefreshOptions.html":{},"interfaces/RequestMetadataCallback.html":{},"interfaces/RequestMetadataResponse.html":{},"interfaces/RevokeCredentialsResult.html":{},"interfaces/TokenInfo.html":{},"interfaces/TokenInfoRequest.html":{},"interfaces/VerifyIdTokenOptions.html":{}}}],["creat",{"_index":323,"title":{},"body":{"interfaces/ADCCallback.html":{},"interfaces/ADCResponse.html":{},"interfaces/BodyResponseCallback.html":{},"interfaces/ComputeOptions.html":{},"interfaces/CredentialCallback.html":{},"classes/DefaultTransporter.html":{},"interfaces/FederatedSignonCertsResponse.html":{},"interfaces/GetAccessTokenCallback.html":{},"interfaces/GetAccessTokenResponse.html":{},"interfaces/GetFederatedSignonCertsCallback.html":{},"interfaces/GetTokenCallback.html":{},"interfaces/GetTokenOptions.html":{},"interfaces/GetTokenResponse.html":{},"interfaces/GoogleAuthOptions.html":{},"classes/IAMAuth.html":{},"classes/JWTAccess.html":{},"interfaces/JWTOptions.html":{},"classes/LoginTicket.html":{},"interfaces/OAuth2ClientOptions.html":{},"interfaces/ProjectIdCallback.html":{},"interfaces/RefreshAccessTokenCallback.html":{},"interfaces/RefreshAccessTokenResponse.html":{},"interfaces/RefreshOptions.html":{},"interfaces/RequestError.html":{},"interfaces/RequestMetadata.html":{},"interfaces/RequestMetadataCallback.html":{},"interfaces/RequestMetadataResponse.html":{},"interfaces/RevokeCredentialsResult.html":{},"interfaces/SignBlobResponse.html":{},"interfaces/TokenInfo.html":{},"interfaces/TokenInfoRequest.html":{},"interfaces/TokenPayload.html":{},"interfaces/Transporter.html":{},"interfaces/UserRefreshClientOptions.html":{},"interfaces/VerifyIdTokenOptions.html":{},"changelog.html":{},"index.html":{}}}],["createdscop",{"_index":601,"title":{},"body":{"interfaces/ComputeOptions.html":{},"classes/IAMAuth.html":{},"classes/JWTAccess.html":{},"interfaces/RequestMetadata.html":{}}}],["createerror(messag",{"_index":389,"title":{},"body":{"interfaces/ADCCallback.html":{},"interfaces/ADCResponse.html":{},"interfaces/CredentialCallback.html":{},"interfaces/GoogleAuthOptions.html":{},"interfaces/ProjectIdCallback.html":{},"interfaces/SignBlobResponse.html":{}}}],["creategtoken",{"_index":1333,"title":{},"body":{"interfaces/JWTOptions.html":{}}}],["createscop",{"_index":1312,"title":{},"body":{"interfaces/JWTOptions.html":{},"changelog.html":{}}}],["createscoped(scop",{"_index":1302,"title":{},"body":{"interfaces/JWTOptions.html":{}}}],["createscopedrequir",{"_index":602,"title":{},"body":{"interfaces/ComputeOptions.html":{},"classes/IAMAuth.html":{},"classes/JWTAccess.html":{},"interfaces/JWTOptions.html":{},"interfaces/RequestMetadata.html":{},"interfaces/Warning.html":{},"changelog.html":{},"miscellaneous/variables.html":{}}}],["creation",{"_index":604,"title":{},"body":{"interfaces/ComputeOptions.html":{}}}],["cred",{"_index":483,"title":{},"body":{"interfaces/ADCCallback.html":{},"interfaces/ADCResponse.html":{},"interfaces/CredentialCallback.html":{},"interfaces/GoogleAuthOptions.html":{},"interfaces/JWTOptions.html":{},"interfaces/ProjectIdCallback.html":{},"interfaces/SignBlobResponse.html":{},"index.html":{}}}],["credenti",{"_index":14,"title":{"interfaces/Credentials.html":{}},"body":{"interfaces/ADCCallback.html":{},"interfaces/ADCResponse.html":{},"interfaces/ComputeOptions.html":{},"interfaces/CredentialBody.html":{},"interfaces/CredentialCallback.html":{},"interfaces/CredentialRequest.html":{},"interfaces/Credentials.html":{},"interfaces/FederatedSignonCertsResponse.html":{},"interfaces/GetAccessTokenCallback.html":{},"interfaces/GetAccessTokenResponse.html":{},"interfaces/GetFederatedSignonCertsCallback.html":{},"interfaces/GetTokenCallback.html":{},"interfaces/GetTokenOptions.html":{},"interfaces/GetTokenResponse.html":{},"interfaces/GoogleAuthOptions.html":{},"classes/IAMAuth.html":{},"classes/JWTAccess.html":{},"interfaces/JWTInput.html":{},"interfaces/JWTOptions.html":{},"interfaces/OAuth2ClientOptions.html":{},"interfaces/ProjectIdCallback.html":{},"interfaces/RefreshAccessTokenCallback.html":{},"interfaces/RefreshAccessTokenResponse.html":{},"interfaces/RefreshOptions.html":{},"interfaces/RequestMetadata.html":{},"interfaces/RequestMetadataCallback.html":{},"interfaces/RequestMetadataResponse.html":{},"interfaces/RevokeCredentialsResult.html":{},"interfaces/SignBlobResponse.html":{},"interfaces/TokenInfo.html":{},"interfaces/TokenInfoRequest.html":{},"interfaces/UserRefreshClientOptions.html":{},"interfaces/VerifyIdTokenOptions.html":{},"interfaces/Warning.html":{},"changelog.html":{},"index.html":{},"miscellaneous/variables.html":{}}}],["credential.scop",{"_index":222,"title":{},"body":{"interfaces/ADCCallback.html":{},"interfaces/ADCResponse.html":{},"interfaces/CredentialCallback.html":{},"interfaces/GoogleAuthOptions.html":{},"interfaces/ProjectIdCallback.html":{},"interfaces/SignBlobResponse.html":{}}}],["credentialbodi",{"_index":41,"title":{"interfaces/CredentialBody.html":{}},"body":{"interfaces/ADCCallback.html":{},"interfaces/ADCResponse.html":{},"interfaces/CredentialBody.html":{},"interfaces/CredentialCallback.html":{},"interfaces/CredentialRequest.html":{},"interfaces/Credentials.html":{},"interfaces/GoogleAuthOptions.html":{},"interfaces/JWTInput.html":{},"interfaces/JWTOptions.html":{},"interfaces/ProjectIdCallback.html":{},"interfaces/SignBlobResponse.html":{}}}],["credentialcallback",{"_index":57,"title":{"interfaces/CredentialCallback.html":{}},"body":{"interfaces/ADCCallback.html":{},"interfaces/ADCResponse.html":{},"interfaces/CredentialCallback.html":{},"interfaces/GoogleAuthOptions.html":{},"interfaces/ProjectIdCallback.html":{},"interfaces/SignBlobResponse.html":{}}}],["credentialrequest",{"_index":584,"title":{"interfaces/CredentialRequest.html":{}},"body":{"interfaces/ComputeOptions.html":{},"interfaces/CredentialBody.html":{},"interfaces/CredentialRequest.html":{},"interfaces/Credentials.html":{},"interfaces/FederatedSignonCertsResponse.html":{},"interfaces/GetAccessTokenCallback.html":{},"interfaces/GetAccessTokenResponse.html":{},"interfaces/GetFederatedSignonCertsCallback.html":{},"interfaces/GetTokenCallback.html":{},"interfaces/GetTokenOptions.html":{},"interfaces/GetTokenResponse.html":{},"interfaces/JWTInput.html":{},"interfaces/OAuth2ClientOptions.html":{},"interfaces/RefreshAccessTokenCallback.html":{},"interfaces/RefreshAccessTokenResponse.html":{},"interfaces/RefreshOptions.html":{},"interfaces/RequestMetadataCallback.html":{},"interfaces/RequestMetadataResponse.html":{},"interfaces/RevokeCredentialsResult.html":{},"interfaces/TokenInfo.html":{},"interfaces/TokenInfoRequest.html":{},"interfaces/VerifyIdTokenOptions.html":{}}}],["credentialrequest).expires_in",{"_index":621,"title":{},"body":{"interfaces/ComputeOptions.html":{},"interfaces/FederatedSignonCertsResponse.html":{},"interfaces/GetAccessTokenCallback.html":{},"interfaces/GetAccessTokenResponse.html":{},"interfaces/GetFederatedSignonCertsCallback.html":{},"interfaces/GetTokenCallback.html":{},"interfaces/GetTokenOptions.html":{},"interfaces/GetTokenResponse.html":{},"interfaces/OAuth2ClientOptions.html":{},"interfaces/RefreshAccessTokenCallback.html":{},"interfaces/RefreshAccessTokenResponse.html":{},"interfaces/RefreshOptions.html":{},"interfaces/RequestMetadataCallback.html":{},"interfaces/RequestMetadataResponse.html":{},"interfaces/RevokeCredentialsResult.html":{},"interfaces/TokenInfo.html":{},"interfaces/TokenInfoRequest.html":{},"interfaces/VerifyIdTokenOptions.html":{}}}],["credentials.refresh_token",{"_index":1079,"title":{},"body":{"interfaces/FederatedSignonCertsResponse.html":{},"interfaces/GetAccessTokenCallback.html":{},"interfaces/GetAccessTokenResponse.html":{},"interfaces/GetFederatedSignonCertsCallback.html":{},"interfaces/GetTokenCallback.html":{},"interfaces/GetTokenOptions.html":{},"interfaces/GetTokenResponse.html":{},"interfaces/OAuth2ClientOptions.html":{},"interfaces/RefreshAccessTokenCallback.html":{},"interfaces/RefreshAccessTokenResponse.html":{},"interfaces/RefreshOptions.html":{},"interfaces/RequestMetadataCallback.html":{},"interfaces/RequestMetadataResponse.html":{},"interfaces/RevokeCredentialsResult.html":{},"interfaces/TokenInfo.html":{},"interfaces/TokenInfoRequest.html":{},"interfaces/VerifyIdTokenOptions.html":{}}}],["credentials.token_typ",{"_index":1078,"title":{},"body":{"interfaces/FederatedSignonCertsResponse.html":{},"interfaces/GetAccessTokenCallback.html":{},"interfaces/GetAccessTokenResponse.html":{},"interfaces/GetFederatedSignonCertsCallback.html":{},"interfaces/GetTokenCallback.html":{},"interfaces/GetTokenOptions.html":{},"interfaces/GetTokenResponse.html":{},"interfaces/OAuth2ClientOptions.html":{},"interfaces/RefreshAccessTokenCallback.html":{},"interfaces/RefreshAccessTokenResponse.html":{},"interfaces/RefreshOptions.html":{},"interfaces/RequestMetadataCallback.html":{},"interfaces/RequestMetadataResponse.html":{},"interfaces/RevokeCredentialsResult.html":{},"interfaces/TokenInfo.html":{},"interfaces/TokenInfoRequest.html":{},"interfaces/VerifyIdTokenOptions.html":{}}}],["credentialspath",{"_index":253,"title":{},"body":{"interfaces/ADCCallback.html":{},"interfaces/ADCResponse.html":{},"interfaces/CredentialCallback.html":{},"interfaces/GoogleAuthOptions.html":{},"interfaces/ProjectIdCallback.html":{},"interfaces/SignBlobResponse.html":{}}}],["credentialspath.length",{"_index":255,"title":{},"body":{"interfaces/ADCCallback.html":{},"interfaces/ADCResponse.html":{},"interfaces/CredentialCallback.html":{},"interfaces/GoogleAuthOptions.html":{},"interfaces/ProjectIdCallback.html":{},"interfaces/SignBlobResponse.html":{}}}],["credentials|nul",{"_index":880,"title":{},"body":{"interfaces/FederatedSignonCertsResponse.html":{},"interfaces/GetAccessTokenCallback.html":{},"interfaces/GetAccessTokenResponse.html":{},"interfaces/GetFederatedSignonCertsCallback.html":{},"interfaces/GetTokenCallback.html":{},"interfaces/GetTokenOptions.html":{},"interfaces/GetTokenResponse.html":{},"interfaces/OAuth2ClientOptions.html":{},"interfaces/RefreshAccessTokenCallback.html":{},"interfaces/RefreshAccessTokenResponse.html":{},"interfaces/RefreshOptions.html":{},"interfaces/RequestMetadataCallback.html":{},"interfaces/RequestMetadataResponse.html":{},"interfaces/RevokeCredentialsResult.html":{},"interfaces/TokenInfo.html":{},"interfaces/TokenInfoRequest.html":{},"interfaces/VerifyIdTokenOptions.html":{}}}],["creds.client_email",{"_index":485,"title":{},"body":{"interfaces/ADCCallback.html":{},"interfaces/ADCResponse.html":{},"interfaces/CredentialCallback.html":{},"interfaces/GoogleAuthOptions.html":{},"interfaces/ProjectIdCallback.html":{},"interfaces/SignBlobResponse.html":{}}}],["creds.clientemail",{"_index":1338,"title":{},"body":{"interfaces/JWTOptions.html":{}}}],["creds.privatekey",{"_index":1337,"title":{},"body":{"interfaces/JWTOptions.html":{}}}],["criteria",{"_index":1109,"title":{},"body":{"interfaces/FederatedSignonCertsResponse.html":{},"interfaces/GetAccessTokenCallback.html":{},"interfaces/GetAccessTokenResponse.html":{},"interfaces/GetFederatedSignonCertsCallback.html":{},"interfaces/GetTokenCallback.html":{},"interfaces/GetTokenOptions.html":{},"interfaces/GetTokenResponse.html":{},"interfaces/OAuth2ClientOptions.html":{},"interfaces/RefreshAccessTokenCallback.html":{},"interfaces/RefreshAccessTokenResponse.html":{},"interfaces/RefreshOptions.html":{},"interfaces/RequestMetadataCallback.html":{},"interfaces/RequestMetadataResponse.html":{},"interfaces/RevokeCredentialsResult.html":{},"interfaces/TokenInfo.html":{},"interfaces/TokenInfoRequest.html":{},"interfaces/VerifyIdTokenOptions.html":{}}}],["cross",{"_index":830,"title":{},"body":{"interfaces/FederatedSignonCertsResponse.html":{},"interfaces/GetAccessTokenCallback.html":{},"interfaces/GetAccessTokenResponse.html":{},"interfaces/GetFederatedSignonCertsCallback.html":{},"interfaces/GetTokenCallback.html":{},"interfaces/GetTokenOptions.html":{},"interfaces/GetTokenResponse.html":{},"classes/LoginTicket.html":{},"interfaces/OAuth2ClientOptions.html":{},"interfaces/RefreshAccessTokenCallback.html":{},"interfaces/RefreshAccessTokenResponse.html":{},"interfaces/RefreshOptions.html":{},"interfaces/RequestMetadataCallback.html":{},"interfaces/RequestMetadataResponse.html":{},"interfaces/RevokeCredentialsResult.html":{},"interfaces/TokenInfo.html":{},"interfaces/TokenInfoRequest.html":{},"interfaces/TokenPayload.html":{},"interfaces/VerifyIdTokenOptions.html":{},"license.html":{}}}],["crypto",{"_index":26,"title":{},"body":{"interfaces/ADCCallback.html":{},"interfaces/ADCResponse.html":{},"interfaces/CredentialCallback.html":{},"interfaces/FederatedSignonCertsResponse.html":{},"interfaces/GetAccessTokenCallback.html":{},"interfaces/GetAccessTokenResponse.html":{},"interfaces/GetFederatedSignonCertsCallback.html":{},"interfaces/GetTokenCallback.html":{},"interfaces/GetTokenOptions.html":{},"interfaces/GetTokenResponse.html":{},"interfaces/GoogleAuthOptions.html":{},"interfaces/OAuth2ClientOptions.html":{},"classes/PemVerifier.html":{},"interfaces/ProjectIdCallback.html":{},"interfaces/RefreshAccessTokenCallback.html":{},"interfaces/RefreshAccessTokenResponse.html":{},"interfaces/RefreshOptions.html":{},"interfaces/RequestMetadataCallback.html":{},"interfaces/RequestMetadataResponse.html":{},"interfaces/RevokeCredentialsResult.html":{},"interfaces/SignBlobResponse.html":{},"interfaces/TokenInfo.html":{},"interfaces/TokenInfoRequest.html":{},"interfaces/VerifyIdTokenOptions.html":{}}}],["crypto.createhash('sha256').update(codeverifier).digest('base64",{"_index":995,"title":{},"body":{"interfaces/FederatedSignonCertsResponse.html":{},"interfaces/GetAccessTokenCallback.html":{},"interfaces/GetAccessTokenResponse.html":{},"interfaces/GetFederatedSignonCertsCallback.html":{},"interfaces/GetTokenCallback.html":{},"interfaces/GetTokenOptions.html":{},"interfaces/GetTokenResponse.html":{},"interfaces/OAuth2ClientOptions.html":{},"interfaces/RefreshAccessTokenCallback.html":{},"interfaces/RefreshAccessTokenResponse.html":{},"interfaces/RefreshOptions.html":{},"interfaces/RequestMetadataCallback.html":{},"interfaces/RequestMetadataResponse.html":{},"interfaces/RevokeCredentialsResult.html":{},"interfaces/TokenInfo.html":{},"interfaces/TokenInfoRequest.html":{},"interfaces/VerifyIdTokenOptions.html":{}}}],["crypto.createsign('rsa",{"_index":477,"title":{},"body":{"interfaces/ADCCallback.html":{},"interfaces/ADCResponse.html":{},"interfaces/CredentialCallback.html":{},"interfaces/GoogleAuthOptions.html":{},"interfaces/ProjectIdCallback.html":{},"interfaces/SignBlobResponse.html":{}}}],["crypto.createverify('sha256",{"_index":1392,"title":{},"body":{"classes/PemVerifier.html":{}}}],["crypto.hexbase64latin1encod",{"_index":1388,"title":{},"body":{"classes/PemVerifier.html":{}}}],["crypto.randombytes(96).tostring('base64",{"_index":981,"title":{},"body":{"interfaces/FederatedSignonCertsResponse.html":{},"interfaces/GetAccessTokenCallback.html":{},"interfaces/GetAccessTokenResponse.html":{},"interfaces/GetFederatedSignonCertsCallback.html":{},"interfaces/GetTokenCallback.html":{},"interfaces/GetTokenOptions.html":{},"interfaces/GetTokenResponse.html":{},"interfaces/OAuth2ClientOptions.html":{},"interfaces/RefreshAccessTokenCallback.html":{},"interfaces/RefreshAccessTokenResponse.html":{},"interfaces/RefreshOptions.html":{},"interfaces/RequestMetadataCallback.html":{},"interfaces/RequestMetadataResponse.html":{},"interfaces/RevokeCredentialsResult.html":{},"interfaces/TokenInfo.html":{},"interfaces/TokenInfoRequest.html":{},"interfaces/VerifyIdTokenOptions.html":{}}}],["current",{"_index":358,"title":{},"body":{"interfaces/ADCCallback.html":{},"interfaces/ADCResponse.html":{},"interfaces/CredentialCallback.html":{},"interfaces/GoogleAuthOptions.html":{},"interfaces/JWTOptions.html":{},"interfaces/ProjectIdCallback.html":{},"interfaces/SignBlobResponse.html":{}}}],["custom",{"_index":548,"title":{},"body":{"interfaces/BodyResponseCallback.html":{},"classes/DefaultTransporter.html":{},"interfaces/RequestError.html":{},"interfaces/Transporter.html":{}}}],["customari",{"_index":1946,"title":{},"body":{"license.html":{}}}],["damag",{"_index":1961,"title":{},"body":{"license.html":{}}}],["data",{"_index":327,"title":{},"body":{"interfaces/ADCCallback.html":{},"interfaces/ADCResponse.html":{},"interfaces/CredentialCallback.html":{},"interfaces/FederatedSignonCertsResponse.html":{},"interfaces/GetAccessTokenCallback.html":{},"interfaces/GetAccessTokenResponse.html":{},"interfaces/GetFederatedSignonCertsCallback.html":{},"interfaces/GetTokenCallback.html":{},"interfaces/GetTokenOptions.html":{},"interfaces/GetTokenResponse.html":{},"interfaces/GoogleAuthOptions.html":{},"classes/JWTAccess.html":{},"interfaces/JWTOptions.html":{},"interfaces/OAuth2ClientOptions.html":{},"classes/PemVerifier.html":{},"interfaces/ProjectIdCallback.html":{},"interfaces/RefreshAccessTokenCallback.html":{},"interfaces/RefreshAccessTokenResponse.html":{},"interfaces/RefreshOptions.html":{},"interfaces/RequestMetadataCallback.html":{},"interfaces/RequestMetadataResponse.html":{},"interfaces/RevokeCredentialsResult.html":{},"interfaces/SignBlobResponse.html":{},"interfaces/TokenInfo.html":{},"interfaces/TokenInfoRequest.html":{},"interfaces/UserRefreshClientOptions.html":{},"interfaces/VerifyIdTokenOptions.html":{}}}],["data.default",{"_index":433,"title":{},"body":{"interfaces/ADCCallback.html":{},"interfaces/ADCResponse.html":{},"interfaces/CredentialCallback.html":{},"interfaces/GoogleAuthOptions.html":{},"interfaces/ProjectIdCallback.html":{},"interfaces/SignBlobResponse.html":{}}}],["data.default.email",{"_index":434,"title":{},"body":{"interfaces/ADCCallback.html":{},"interfaces/ADCResponse.html":{},"interfaces/CredentialCallback.html":{},"interfaces/GoogleAuthOptions.html":{},"interfaces/ProjectIdCallback.html":{},"interfaces/SignBlobResponse.html":{}}}],["data.expires_in",{"_index":1151,"title":{},"body":{"interfaces/FederatedSignonCertsResponse.html":{},"interfaces/GetAccessTokenCallback.html":{},"interfaces/GetAccessTokenResponse.html":{},"interfaces/GetFederatedSignonCertsCallback.html":{},"interfaces/GetTokenCallback.html":{},"interfaces/GetTokenOptions.html":{},"interfaces/GetTokenResponse.html":{},"interfaces/OAuth2ClientOptions.html":{},"interfaces/RefreshAccessTokenCallback.html":{},"interfaces/RefreshAccessTokenResponse.html":{},"interfaces/RefreshOptions.html":{},"interfaces/RequestMetadataCallback.html":{},"interfaces/RequestMetadataResponse.html":{},"interfaces/RevokeCredentialsResult.html":{},"interfaces/TokenInfo.html":{},"interfaces/TokenInfoRequest.html":{},"interfaces/VerifyIdTokenOptions.html":{}}}],["data.scope.split",{"_index":1152,"title":{},"body":{"interfaces/FederatedSignonCertsResponse.html":{},"interfaces/GetAccessTokenCallback.html":{},"interfaces/GetAccessTokenResponse.html":{},"interfaces/GetFederatedSignonCertsCallback.html":{},"interfaces/GetTokenCallback.html":{},"interfaces/GetTokenOptions.html":{},"interfaces/GetTokenResponse.html":{},"interfaces/OAuth2ClientOptions.html":{},"interfaces/RefreshAccessTokenCallback.html":{},"interfaces/RefreshAccessTokenResponse.html":{},"interfaces/RefreshOptions.html":{},"interfaces/RequestMetadataCallback.html":{},"interfaces/RequestMetadataResponse.html":{},"interfaces/RevokeCredentialsResult.html":{},"interfaces/TokenInfo.html":{},"interfaces/TokenInfoRequest.html":{},"interfaces/VerifyIdTokenOptions.html":{}}}],["databas",{"_index":1756,"title":{},"body":{"index.html":{}}}],["database)check",{"_index":1769,"title":{},"body":{"index.html":{}}}],["date",{"_index":1770,"title":{},"body":{"index.html":{},"license.html":{}}}],["date()).gettim",{"_index":618,"title":{},"body":{"interfaces/ComputeOptions.html":{},"interfaces/FederatedSignonCertsResponse.html":{},"interfaces/GetAccessTokenCallback.html":{},"interfaces/GetAccessTokenResponse.html":{},"interfaces/GetFederatedSignonCertsCallback.html":{},"interfaces/GetTokenCallback.html":{},"interfaces/GetTokenOptions.html":{},"interfaces/GetTokenResponse.html":{},"interfaces/OAuth2ClientOptions.html":{},"interfaces/RefreshAccessTokenCallback.html":{},"interfaces/RefreshAccessTokenResponse.html":{},"interfaces/RefreshOptions.html":{},"interfaces/RequestMetadataCallback.html":{},"interfaces/RequestMetadataResponse.html":{},"interfaces/RevokeCredentialsResult.html":{},"interfaces/TokenInfo.html":{},"interfaces/TokenInfoRequest.html":{},"interfaces/VerifyIdTokenOptions.html":{}}}],["date().gettim",{"_index":1257,"title":{},"body":{"classes/JWTAccess.html":{}}}],["datetim",{"_index":727,"title":{},"body":{"interfaces/FederatedSignonCertsResponse.html":{},"interfaces/GetAccessTokenCallback.html":{},"interfaces/GetAccessTokenResponse.html":{},"interfaces/GetFederatedSignonCertsCallback.html":{},"interfaces/GetTokenCallback.html":{},"interfaces/GetTokenOptions.html":{},"interfaces/GetTokenResponse.html":{},"interfaces/OAuth2ClientOptions.html":{},"interfaces/RefreshAccessTokenCallback.html":{},"interfaces/RefreshAccessTokenResponse.html":{},"interfaces/RefreshOptions.html":{},"interfaces/RequestMetadataCallback.html":{},"interfaces/RequestMetadataResponse.html":{},"interfaces/RevokeCredentialsResult.html":{},"interfaces/TokenInfo.html":{},"interfaces/TokenInfoRequest.html":{},"interfaces/VerifyIdTokenOptions.html":{}}}],["date|nul",{"_index":907,"title":{},"body":{"interfaces/FederatedSignonCertsResponse.html":{},"interfaces/GetAccessTokenCallback.html":{},"interfaces/GetAccessTokenResponse.html":{},"interfaces/GetFederatedSignonCertsCallback.html":{},"interfaces/GetTokenCallback.html":{},"interfaces/GetTokenOptions.html":{},"interfaces/GetTokenResponse.html":{},"interfaces/OAuth2ClientOptions.html":{},"interfaces/RefreshAccessTokenCallback.html":{},"interfaces/RefreshAccessTokenResponse.html":{},"interfaces/RefreshOptions.html":{},"interfaces/RequestMetadataCallback.html":{},"interfaces/RequestMetadataResponse.html":{},"interfaces/RevokeCredentialsResult.html":{},"interfaces/TokenInfo.html":{},"interfaces/TokenInfoRequest.html":{},"interfaces/VerifyIdTokenOptions.html":{}}}],["day",{"_index":950,"title":{},"body":{"interfaces/FederatedSignonCertsResponse.html":{},"interfaces/GetAccessTokenCallback.html":{},"interfaces/GetAccessTokenResponse.html":{},"interfaces/GetFederatedSignonCertsCallback.html":{},"interfaces/GetTokenCallback.html":{},"interfaces/GetTokenOptions.html":{},"interfaces/GetTokenResponse.html":{},"interfaces/OAuth2ClientOptions.html":{},"interfaces/RefreshAccessTokenCallback.html":{},"interfaces/RefreshAccessTokenResponse.html":{},"interfaces/RefreshOptions.html":{},"interfaces/RequestMetadataCallback.html":{},"interfaces/RequestMetadataResponse.html":{},"interfaces/RevokeCredentialsResult.html":{},"interfaces/TokenInfo.html":{},"interfaces/TokenInfoRequest.html":{},"interfaces/VerifyIdTokenOptions.html":{}}}],["de",{"_index":1033,"title":{},"body":{"interfaces/FederatedSignonCertsResponse.html":{},"interfaces/GetAccessTokenCallback.html":{},"interfaces/GetAccessTokenResponse.html":{},"interfaces/GetFederatedSignonCertsCallback.html":{},"interfaces/GetTokenCallback.html":{},"interfaces/GetTokenOptions.html":{},"interfaces/GetTokenResponse.html":{},"interfaces/OAuth2ClientOptions.html":{},"interfaces/RefreshAccessTokenCallback.html":{},"interfaces/RefreshAccessTokenResponse.html":{},"interfaces/RefreshOptions.html":{},"interfaces/RequestMetadataCallback.html":{},"interfaces/RequestMetadataResponse.html":{},"interfaces/RevokeCredentialsResult.html":{},"interfaces/TokenInfo.html":{},"interfaces/TokenInfoRequest.html":{},"interfaces/VerifyIdTokenOptions.html":{}}}],["decod",{"_index":1180,"title":{},"body":{"interfaces/FederatedSignonCertsResponse.html":{},"interfaces/GetAccessTokenCallback.html":{},"interfaces/GetAccessTokenResponse.html":{},"interfaces/GetFederatedSignonCertsCallback.html":{},"interfaces/GetTokenCallback.html":{},"interfaces/GetTokenOptions.html":{},"interfaces/GetTokenResponse.html":{},"interfaces/OAuth2ClientOptions.html":{},"interfaces/RefreshAccessTokenCallback.html":{},"interfaces/RefreshAccessTokenResponse.html":{},"interfaces/RefreshOptions.html":{},"interfaces/RequestMetadataCallback.html":{},"interfaces/RequestMetadataResponse.html":{},"interfaces/RevokeCredentialsResult.html":{},"interfaces/TokenInfo.html":{},"interfaces/TokenInfoRequest.html":{},"interfaces/VerifyIdTokenOptions.html":{}}}],["decodebase64(b64str",{"_index":1182,"title":{},"body":{"interfaces/FederatedSignonCertsResponse.html":{},"interfaces/GetAccessTokenCallback.html":{},"interfaces/GetAccessTokenResponse.html":{},"interfaces/GetFederatedSignonCertsCallback.html":{},"interfaces/GetTokenCallback.html":{},"interfaces/GetTokenOptions.html":{},"interfaces/GetTokenResponse.html":{},"interfaces/OAuth2ClientOptions.html":{},"interfaces/RefreshAccessTokenCallback.html":{},"interfaces/RefreshAccessTokenResponse.html":{},"interfaces/RefreshOptions.html":{},"interfaces/RequestMetadataCallback.html":{},"interfaces/RequestMetadataResponse.html":{},"interfaces/RevokeCredentialsResult.html":{},"interfaces/TokenInfo.html":{},"interfaces/TokenInfoRequest.html":{},"interfaces/VerifyIdTokenOptions.html":{}}}],["default",{"_index":147,"title":{},"body":{"interfaces/ADCCallback.html":{},"interfaces/ADCResponse.html":{},"interfaces/BodyResponseCallback.html":{},"interfaces/ComputeOptions.html":{},"interfaces/CredentialCallback.html":{},"classes/DefaultTransporter.html":{},"interfaces/FederatedSignonCertsResponse.html":{},"interfaces/GetAccessTokenCallback.html":{},"interfaces/GetAccessTokenResponse.html":{},"interfaces/GetFederatedSignonCertsCallback.html":{},"interfaces/GetTokenCallback.html":{},"interfaces/GetTokenOptions.html":{},"interfaces/GetTokenResponse.html":{},"interfaces/GoogleAuthOptions.html":{},"classes/JWTAccess.html":{},"interfaces/OAuth2ClientOptions.html":{},"interfaces/ProjectIdCallback.html":{},"interfaces/RefreshAccessTokenCallback.html":{},"interfaces/RefreshAccessTokenResponse.html":{},"interfaces/RefreshOptions.html":{},"interfaces/RequestError.html":{},"interfaces/RequestMetadataCallback.html":{},"interfaces/RequestMetadataResponse.html":{},"interfaces/RevokeCredentialsResult.html":{},"interfaces/SignBlobResponse.html":{},"interfaces/TokenInfo.html":{},"interfaces/TokenInfoRequest.html":{},"interfaces/Transporter.html":{},"interfaces/VerifyIdTokenOptions.html":{},"changelog.html":{},"index.html":{},"miscellaneous/variables.html":{}}}],["default_head",{"_index":1239,"title":{},"body":{"classes/JWTAccess.html":{},"miscellaneous/variables.html":{}}}],["default_project_id_deprec",{"_index":1438,"title":{},"body":{"interfaces/Warning.html":{},"miscellaneous/variables.html":{}}}],["defaultclaim",{"_index":1261,"title":{},"body":{"classes/JWTAccess.html":{}}}],["defaulttransport",{"_index":37,"title":{"classes/DefaultTransporter.html":{}},"body":{"interfaces/ADCCallback.html":{},"interfaces/ADCResponse.html":{},"interfaces/BodyResponseCallback.html":{},"interfaces/CredentialCallback.html":{},"classes/DefaultTransporter.html":{},"interfaces/GoogleAuthOptions.html":{},"interfaces/ProjectIdCallback.html":{},"interfaces/RequestError.html":{},"interfaces/SignBlobResponse.html":{},"interfaces/Transporter.html":{}}}],["defaulttransporter.user_ag",{"_index":539,"title":{},"body":{"interfaces/BodyResponseCallback.html":{},"classes/DefaultTransporter.html":{},"interfaces/RequestError.html":{},"interfaces/Transporter.html":{}}}],["defend",{"_index":1980,"title":{},"body":{"license.html":{}}}],["defin",{"_index":678,"title":{},"body":{"classes/DefaultTransporter.html":{},"classes/IAMAuth.html":{},"classes/JWTAccess.html":{},"classes/LoginTicket.html":{},"classes/PemVerifier.html":{},"interfaces/Transporter.html":{},"license.html":{}}}],["definit",{"_index":1822,"title":{},"body":{"license.html":{}}}],["delet",{"_index":620,"title":{},"body":{"interfaces/ComputeOptions.html":{},"interfaces/FederatedSignonCertsResponse.html":{},"interfaces/GetAccessTokenCallback.html":{},"interfaces/GetAccessTokenResponse.html":{},"interfaces/GetFederatedSignonCertsCallback.html":{},"interfaces/GetTokenCallback.html":{},"interfaces/GetTokenOptions.html":{},"interfaces/GetTokenResponse.html":{},"interfaces/OAuth2ClientOptions.html":{},"interfaces/RefreshAccessTokenCallback.html":{},"interfaces/RefreshAccessTokenResponse.html":{},"interfaces/RefreshOptions.html":{},"interfaces/RequestMetadataCallback.html":{},"interfaces/RequestMetadataResponse.html":{},"interfaces/RevokeCredentialsResult.html":{},"interfaces/TokenInfo.html":{},"interfaces/TokenInfoRequest.html":{},"interfaces/VerifyIdTokenOptions.html":{}}}],["deliber",{"_index":1958,"title":{},"body":{"license.html":{}}}],["delimit",{"_index":788,"title":{},"body":{"interfaces/FederatedSignonCertsResponse.html":{},"interfaces/GetAccessTokenCallback.html":{},"interfaces/GetAccessTokenResponse.html":{},"interfaces/GetFederatedSignonCertsCallback.html":{},"interfaces/GetTokenCallback.html":{},"interfaces/GetTokenOptions.html":{},"interfaces/GetTokenResponse.html":{},"interfaces/OAuth2ClientOptions.html":{},"interfaces/RefreshAccessTokenCallback.html":{},"interfaces/RefreshAccessTokenResponse.html":{},"interfaces/RefreshOptions.html":{},"interfaces/RequestMetadataCallback.html":{},"interfaces/RequestMetadataResponse.html":{},"interfaces/RevokeCredentialsResult.html":{},"interfaces/TokenInfo.html":{},"interfaces/TokenInfoRequest.html":{},"interfaces/VerifyIdTokenOptions.html":{}}}],["deni",{"_index":822,"title":{},"body":{"interfaces/FederatedSignonCertsResponse.html":{},"interfaces/GetAccessTokenCallback.html":{},"interfaces/GetAccessTokenResponse.html":{},"interfaces/GetFederatedSignonCertsCallback.html":{},"interfaces/GetTokenCallback.html":{},"interfaces/GetTokenOptions.html":{},"interfaces/GetTokenResponse.html":{},"interfaces/OAuth2ClientOptions.html":{},"interfaces/RefreshAccessTokenCallback.html":{},"interfaces/RefreshAccessTokenResponse.html":{},"interfaces/RefreshOptions.html":{},"interfaces/RequestMetadataCallback.html":{},"interfaces/RequestMetadataResponse.html":{},"interfaces/RevokeCredentialsResult.html":{},"interfaces/TokenInfo.html":{},"interfaces/TokenInfoRequest.html":{},"interfaces/VerifyIdTokenOptions.html":{}}}],["depend",{"_index":265,"title":{"dependencies.html":{}},"body":{"interfaces/ADCCallback.html":{},"interfaces/ADCResponse.html":{},"interfaces/CredentialCallback.html":{},"interfaces/GoogleAuthOptions.html":{},"interfaces/ProjectIdCallback.html":{},"interfaces/SignBlobResponse.html":{},"changelog.html":{},"dependencies.html":{},"index.html":{}}}],["deploy",{"_index":1788,"title":{},"body":{"index.html":{}}}],["deprec",{"_index":130,"title":{},"body":{"interfaces/ADCCallback.html":{},"interfaces/ADCResponse.html":{},"interfaces/ComputeOptions.html":{},"interfaces/CredentialCallback.html":{},"interfaces/FederatedSignonCertsResponse.html":{},"interfaces/GetAccessTokenCallback.html":{},"interfaces/GetAccessTokenResponse.html":{},"interfaces/GetFederatedSignonCertsCallback.html":{},"interfaces/GetTokenCallback.html":{},"interfaces/GetTokenOptions.html":{},"interfaces/GetTokenResponse.html":{},"interfaces/GoogleAuthOptions.html":{},"classes/IAMAuth.html":{},"classes/JWTAccess.html":{},"interfaces/JWTOptions.html":{},"interfaces/OAuth2ClientOptions.html":{},"interfaces/ProjectIdCallback.html":{},"interfaces/RefreshAccessTokenCallback.html":{},"interfaces/RefreshAccessTokenResponse.html":{},"interfaces/RefreshOptions.html":{},"interfaces/RequestMetadata.html":{},"interfaces/RequestMetadataCallback.html":{},"interfaces/RequestMetadataResponse.html":{},"interfaces/RevokeCredentialsResult.html":{},"interfaces/SignBlobResponse.html":{},"interfaces/TokenInfo.html":{},"interfaces/TokenInfoRequest.html":{},"interfaces/VerifyIdTokenOptions.html":{},"interfaces/Warning.html":{},"changelog.html":{},"miscellaneous/enumerations.html":{},"miscellaneous/variables.html":{}}}],["deprecationwarn",{"_index":1416,"title":{},"body":{"interfaces/Warning.html":{},"miscellaneous/enumerations.html":{}}}],["deriv",{"_index":1855,"title":{},"body":{"license.html":{}}}],["describ",{"_index":876,"title":{},"body":{"interfaces/FederatedSignonCertsResponse.html":{},"interfaces/GetAccessTokenCallback.html":{},"interfaces/GetAccessTokenResponse.html":{},"interfaces/GetFederatedSignonCertsCallback.html":{},"interfaces/GetTokenCallback.html":{},"interfaces/GetTokenOptions.html":{},"interfaces/GetTokenResponse.html":{},"interfaces/OAuth2ClientOptions.html":{},"interfaces/RefreshAccessTokenCallback.html":{},"interfaces/RefreshAccessTokenResponse.html":{},"interfaces/RefreshOptions.html":{},"interfaces/RequestMetadataCallback.html":{},"interfaces/RequestMetadataResponse.html":{},"interfaces/RevokeCredentialsResult.html":{},"interfaces/TokenInfo.html":{},"interfaces/TokenInfoRequest.html":{},"interfaces/VerifyIdTokenOptions.html":{},"license.html":{}}}],["descript",{"_index":648,"title":{},"body":{"interfaces/Credentials.html":{},"classes/DefaultTransporter.html":{},"classes/IAMAuth.html":{},"classes/JWTAccess.html":{},"classes/LoginTicket.html":{},"license.html":{}}}],["design",{"_index":1877,"title":{},"body":{"license.html":{}}}],["desir",{"_index":74,"title":{},"body":{"interfaces/ADCCallback.html":{},"interfaces/ADCResponse.html":{},"interfaces/CredentialCallback.html":{},"interfaces/GoogleAuthOptions.html":{},"interfaces/ProjectIdCallback.html":{},"interfaces/SignBlobResponse.html":{}}}],["detail",{"_index":424,"title":{},"body":{"interfaces/ADCCallback.html":{},"interfaces/ADCResponse.html":{},"interfaces/BodyResponseCallback.html":{},"interfaces/CredentialCallback.html":{},"classes/DefaultTransporter.html":{},"interfaces/GoogleAuthOptions.html":{},"interfaces/ProjectIdCallback.html":{},"interfaces/RequestError.html":{},"interfaces/SignBlobResponse.html":{},"interfaces/Transporter.html":{}}}],["determin",{"_index":228,"title":{},"body":{"interfaces/ADCCallback.html":{},"interfaces/ADCResponse.html":{},"interfaces/CredentialCallback.html":{},"interfaces/FederatedSignonCertsResponse.html":{},"interfaces/GetAccessTokenCallback.html":{},"interfaces/GetAccessTokenResponse.html":{},"interfaces/GetFederatedSignonCertsCallback.html":{},"interfaces/GetTokenCallback.html":{},"interfaces/GetTokenOptions.html":{},"interfaces/GetTokenResponse.html":{},"interfaces/GoogleAuthOptions.html":{},"interfaces/JWTOptions.html":{},"interfaces/OAuth2ClientOptions.html":{},"interfaces/ProjectIdCallback.html":{},"interfaces/RefreshAccessTokenCallback.html":{},"interfaces/RefreshAccessTokenResponse.html":{},"interfaces/RefreshOptions.html":{},"interfaces/RequestMetadataCallback.html":{},"interfaces/RequestMetadataResponse.html":{},"interfaces/RevokeCredentialsResult.html":{},"interfaces/SignBlobResponse.html":{},"interfaces/TokenInfo.html":{},"interfaces/TokenInfoRequest.html":{},"interfaces/VerifyIdTokenOptions.html":{},"license.html":{}}}],["develop",{"_index":218,"title":{},"body":{"interfaces/ADCCallback.html":{},"interfaces/ADCResponse.html":{},"interfaces/CredentialCallback.html":{},"interfaces/FederatedSignonCertsResponse.html":{},"interfaces/GetAccessTokenCallback.html":{},"interfaces/GetAccessTokenResponse.html":{},"interfaces/GetFederatedSignonCertsCallback.html":{},"interfaces/GetTokenCallback.html":{},"interfaces/GetTokenOptions.html":{},"interfaces/GetTokenResponse.html":{},"interfaces/GoogleAuthOptions.html":{},"interfaces/OAuth2ClientOptions.html":{},"interfaces/ProjectIdCallback.html":{},"interfaces/RefreshAccessTokenCallback.html":{},"interfaces/RefreshAccessTokenResponse.html":{},"interfaces/RefreshOptions.html":{},"interfaces/RequestMetadataCallback.html":{},"interfaces/RequestMetadataResponse.html":{},"interfaces/RevokeCredentialsResult.html":{},"interfaces/SignBlobResponse.html":{},"interfaces/TokenInfo.html":{},"interfaces/TokenInfoRequest.html":{},"interfaces/VerifyIdTokenOptions.html":{},"index.html":{}}}],["dialog",{"_index":1729,"title":{},"body":{"index.html":{}}}],["didn't",{"_index":1113,"title":{},"body":{"interfaces/FederatedSignonCertsResponse.html":{},"interfaces/GetAccessTokenCallback.html":{},"interfaces/GetAccessTokenResponse.html":{},"interfaces/GetFederatedSignonCertsCallback.html":{},"interfaces/GetTokenCallback.html":{},"interfaces/GetTokenOptions.html":{},"interfaces/GetTokenResponse.html":{},"interfaces/OAuth2ClientOptions.html":{},"interfaces/RefreshAccessTokenCallback.html":{},"interfaces/RefreshAccessTokenResponse.html":{},"interfaces/RefreshOptions.html":{},"interfaces/RequestMetadataCallback.html":{},"interfaces/RequestMetadataResponse.html":{},"interfaces/RevokeCredentialsResult.html":{},"interfaces/TokenInfo.html":{},"interfaces/TokenInfoRequest.html":{},"interfaces/VerifyIdTokenOptions.html":{}}}],["differ",{"_index":732,"title":{},"body":{"interfaces/FederatedSignonCertsResponse.html":{},"interfaces/GetAccessTokenCallback.html":{},"interfaces/GetAccessTokenResponse.html":{},"interfaces/GetFederatedSignonCertsCallback.html":{},"interfaces/GetTokenCallback.html":{},"interfaces/GetTokenOptions.html":{},"interfaces/GetTokenResponse.html":{},"classes/LoginTicket.html":{},"interfaces/OAuth2ClientOptions.html":{},"interfaces/RefreshAccessTokenCallback.html":{},"interfaces/RefreshAccessTokenResponse.html":{},"interfaces/RefreshOptions.html":{},"interfaces/RequestMetadataCallback.html":{},"interfaces/RequestMetadataResponse.html":{},"interfaces/RevokeCredentialsResult.html":{},"interfaces/TokenInfo.html":{},"interfaces/TokenInfoRequest.html":{},"interfaces/TokenPayload.html":{},"interfaces/VerifyIdTokenOptions.html":{},"changelog.html":{},"license.html":{}}}],["direct",{"_index":827,"title":{},"body":{"interfaces/FederatedSignonCertsResponse.html":{},"interfaces/GetAccessTokenCallback.html":{},"interfaces/GetAccessTokenResponse.html":{},"interfaces/GetFederatedSignonCertsCallback.html":{},"interfaces/GetTokenCallback.html":{},"interfaces/GetTokenOptions.html":{},"interfaces/GetTokenResponse.html":{},"interfaces/OAuth2ClientOptions.html":{},"interfaces/RefreshAccessTokenCallback.html":{},"interfaces/RefreshAccessTokenResponse.html":{},"interfaces/RefreshOptions.html":{},"interfaces/RequestMetadataCallback.html":{},"interfaces/RequestMetadataResponse.html":{},"interfaces/RevokeCredentialsResult.html":{},"interfaces/TokenInfo.html":{},"interfaces/TokenInfoRequest.html":{},"interfaces/VerifyIdTokenOptions.html":{},"index.html":{},"license.html":{}}}],["directli",{"_index":1548,"title":{},"body":{"changelog.html":{},"index.html":{}}}],["disclaim",{"_index":1947,"title":{},"body":{"license.html":{}}}],["discuss",{"_index":1872,"title":{},"body":{"license.html":{}}}],["display",{"_index":794,"title":{},"body":{"interfaces/FederatedSignonCertsResponse.html":{},"interfaces/GetAccessTokenCallback.html":{},"interfaces/GetAccessTokenResponse.html":{},"interfaces/GetFederatedSignonCertsCallback.html":{},"interfaces/GetTokenCallback.html":{},"interfaces/GetTokenOptions.html":{},"interfaces/GetTokenResponse.html":{},"classes/LoginTicket.html":{},"interfaces/OAuth2ClientOptions.html":{},"interfaces/RefreshAccessTokenCallback.html":{},"interfaces/RefreshAccessTokenResponse.html":{},"interfaces/RefreshOptions.html":{},"interfaces/RequestMetadataCallback.html":{},"interfaces/RequestMetadataResponse.html":{},"interfaces/RevokeCredentialsResult.html":{},"interfaces/TokenInfo.html":{},"interfaces/TokenInfoRequest.html":{},"interfaces/TokenPayload.html":{},"interfaces/VerifyIdTokenOptions.html":{},"license.html":{}}}],["distribut",{"_index":668,"title":{},"body":{"interfaces/Credentials.html":{},"classes/LoginTicket.html":{},"miscellaneous/functions.html":{},"index.html":{},"license.html":{}}}],["dn",{"_index":1686,"title":{},"body":{"index.html":{}}}],["doc",{"_index":1480,"title":{},"body":{"changelog.html":{}}}],["document",{"_index":802,"title":{},"body":{"interfaces/FederatedSignonCertsResponse.html":{},"interfaces/GetAccessTokenCallback.html":{},"interfaces/GetAccessTokenResponse.html":{},"interfaces/GetFederatedSignonCertsCallback.html":{},"interfaces/GetTokenCallback.html":{},"interfaces/GetTokenOptions.html":{},"interfaces/GetTokenResponse.html":{},"interfaces/OAuth2ClientOptions.html":{},"interfaces/RefreshAccessTokenCallback.html":{},"interfaces/RefreshAccessTokenResponse.html":{},"interfaces/RefreshOptions.html":{},"interfaces/RequestMetadataCallback.html":{},"interfaces/RequestMetadataResponse.html":{},"interfaces/RevokeCredentialsResult.html":{},"interfaces/TokenInfo.html":{},"interfaces/TokenInfoRequest.html":{},"interfaces/VerifyIdTokenOptions.html":{},"changelog.html":{},"index.html":{},"license.html":{}}}],["doesn't",{"_index":416,"title":{},"body":{"interfaces/ADCCallback.html":{},"interfaces/ADCResponse.html":{},"interfaces/CredentialCallback.html":{},"interfaces/GoogleAuthOptions.html":{},"interfaces/JWTOptions.html":{},"interfaces/ProjectIdCallback.html":{},"interfaces/SignBlobResponse.html":{},"interfaces/Warning.html":{}}}],["domain",{"_index":757,"title":{},"body":{"interfaces/FederatedSignonCertsResponse.html":{},"interfaces/GetAccessTokenCallback.html":{},"interfaces/GetAccessTokenResponse.html":{},"interfaces/GetFederatedSignonCertsCallback.html":{},"interfaces/GetTokenCallback.html":{},"interfaces/GetTokenOptions.html":{},"interfaces/GetTokenResponse.html":{},"classes/LoginTicket.html":{},"interfaces/OAuth2ClientOptions.html":{},"interfaces/RefreshAccessTokenCallback.html":{},"interfaces/RefreshAccessTokenResponse.html":{},"interfaces/RefreshOptions.html":{},"interfaces/RequestMetadataCallback.html":{},"interfaces/RequestMetadataResponse.html":{},"interfaces/RevokeCredentialsResult.html":{},"interfaces/TokenInfo.html":{},"interfaces/TokenInfoRequest.html":{},"interfaces/TokenPayload.html":{},"interfaces/VerifyIdTokenOptions.html":{}}}],["don't",{"_index":771,"title":{},"body":{"interfaces/FederatedSignonCertsResponse.html":{},"interfaces/GetAccessTokenCallback.html":{},"interfaces/GetAccessTokenResponse.html":{},"interfaces/GetFederatedSignonCertsCallback.html":{},"interfaces/GetTokenCallback.html":{},"interfaces/GetTokenOptions.html":{},"interfaces/GetTokenResponse.html":{},"interfaces/OAuth2ClientOptions.html":{},"interfaces/RefreshAccessTokenCallback.html":{},"interfaces/RefreshAccessTokenResponse.html":{},"interfaces/RefreshOptions.html":{},"interfaces/RequestMetadataCallback.html":{},"interfaces/RequestMetadataResponse.html":{},"interfaces/RevokeCredentialsResult.html":{},"interfaces/TokenInfo.html":{},"interfaces/TokenInfoRequest.html":{},"interfaces/VerifyIdTokenOptions.html":{},"changelog.html":{},"license.html":{}}}],["donot",{"_index":869,"title":{},"body":{"interfaces/FederatedSignonCertsResponse.html":{},"interfaces/GetAccessTokenCallback.html":{},"interfaces/GetAccessTokenResponse.html":{},"interfaces/GetFederatedSignonCertsCallback.html":{},"interfaces/GetTokenCallback.html":{},"interfaces/GetTokenOptions.html":{},"interfaces/GetTokenResponse.html":{},"interfaces/OAuth2ClientOptions.html":{},"interfaces/RefreshAccessTokenCallback.html":{},"interfaces/RefreshAccessTokenResponse.html":{},"interfaces/RefreshOptions.html":{},"interfaces/RequestMetadataCallback.html":{},"interfaces/RequestMetadataResponse.html":{},"interfaces/RevokeCredentialsResult.html":{},"interfaces/TokenInfo.html":{},"interfaces/TokenInfoRequest.html":{},"interfaces/VerifyIdTokenOptions.html":{}}}],["download",{"_index":1680,"title":{},"body":{"index.html":{}}}],["drop",{"_index":1428,"title":{},"body":{"interfaces/Warning.html":{},"changelog.html":{}}}],["dropdown",{"_index":1681,"title":{},"body":{"index.html":{}}}],["duplic",{"_index":1034,"title":{},"body":{"interfaces/FederatedSignonCertsResponse.html":{},"interfaces/GetAccessTokenCallback.html":{},"interfaces/GetAccessTokenResponse.html":{},"interfaces/GetFederatedSignonCertsCallback.html":{},"interfaces/GetTokenCallback.html":{},"interfaces/GetTokenOptions.html":{},"interfaces/GetTokenResponse.html":{},"interfaces/OAuth2ClientOptions.html":{},"interfaces/RefreshAccessTokenCallback.html":{},"interfaces/RefreshAccessTokenResponse.html":{},"interfaces/RefreshOptions.html":{},"interfaces/RequestMetadataCallback.html":{},"interfaces/RequestMetadataResponse.html":{},"interfaces/RevokeCredentialsResult.html":{},"interfaces/TokenInfo.html":{},"interfaces/TokenInfoRequest.html":{},"interfaces/VerifyIdTokenOptions.html":{}}}],["dure",{"_index":872,"title":{},"body":{"interfaces/FederatedSignonCertsResponse.html":{},"interfaces/GetAccessTokenCallback.html":{},"interfaces/GetAccessTokenResponse.html":{},"interfaces/GetFederatedSignonCertsCallback.html":{},"interfaces/GetTokenCallback.html":{},"interfaces/GetTokenOptions.html":{},"interfaces/GetTokenResponse.html":{},"interfaces/OAuth2ClientOptions.html":{},"interfaces/RefreshAccessTokenCallback.html":{},"interfaces/RefreshAccessTokenResponse.html":{},"interfaces/RefreshOptions.html":{},"interfaces/RequestMetadataCallback.html":{},"interfaces/RequestMetadataResponse.html":{},"interfaces/RevokeCredentialsResult.html":{},"interfaces/TokenInfo.html":{},"interfaces/TokenInfoRequest.html":{},"interfaces/VerifyIdTokenOptions.html":{}}}],["dynam",{"_index":514,"title":{},"body":{"interfaces/BodyResponseCallback.html":{},"classes/DefaultTransporter.html":{},"interfaces/RequestError.html":{},"interfaces/Transporter.html":{}}}],["e",{"_index":187,"title":{},"body":{"interfaces/ADCCallback.html":{},"interfaces/ADCResponse.html":{},"interfaces/BodyResponseCallback.html":{},"interfaces/ComputeOptions.html":{},"interfaces/CredentialCallback.html":{},"classes/DefaultTransporter.html":{},"interfaces/FederatedSignonCertsResponse.html":{},"interfaces/GetAccessTokenCallback.html":{},"interfaces/GetAccessTokenResponse.html":{},"interfaces/GetFederatedSignonCertsCallback.html":{},"interfaces/GetTokenCallback.html":{},"interfaces/GetTokenOptions.html":{},"interfaces/GetTokenResponse.html":{},"interfaces/GoogleAuthOptions.html":{},"interfaces/JWTOptions.html":{},"classes/LoginTicket.html":{},"interfaces/OAuth2ClientOptions.html":{},"interfaces/ProjectIdCallback.html":{},"interfaces/RefreshAccessTokenCallback.html":{},"interfaces/RefreshAccessTokenResponse.html":{},"interfaces/RefreshOptions.html":{},"interfaces/RequestError.html":{},"interfaces/RequestMetadataCallback.html":{},"interfaces/RequestMetadataResponse.html":{},"interfaces/RevokeCredentialsResult.html":{},"interfaces/SignBlobResponse.html":{},"interfaces/TokenInfo.html":{},"interfaces/TokenInfoRequest.html":{},"interfaces/TokenPayload.html":{},"interfaces/Transporter.html":{},"interfaces/VerifyIdTokenOptions.html":{},"index.html":{}}}],["e.g",{"_index":776,"title":{},"body":{"interfaces/FederatedSignonCertsResponse.html":{},"interfaces/GetAccessTokenCallback.html":{},"interfaces/GetAccessTokenResponse.html":{},"interfaces/GetFederatedSignonCertsCallback.html":{},"interfaces/GetTokenCallback.html":{},"interfaces/GetTokenOptions.html":{},"interfaces/GetTokenResponse.html":{},"interfaces/OAuth2ClientOptions.html":{},"interfaces/RefreshAccessTokenCallback.html":{},"interfaces/RefreshAccessTokenResponse.html":{},"interfaces/RefreshOptions.html":{},"interfaces/RequestMetadataCallback.html":{},"interfaces/RequestMetadataResponse.html":{},"interfaces/RevokeCredentialsResult.html":{},"interfaces/TokenInfo.html":{},"interfaces/TokenInfoRequest.html":{},"interfaces/VerifyIdTokenOptions.html":{},"index.html":{}}}],["e.messag",{"_index":234,"title":{},"body":{"interfaces/ADCCallback.html":{},"interfaces/ADCResponse.html":{},"interfaces/ComputeOptions.html":{},"interfaces/CredentialCallback.html":{},"interfaces/FederatedSignonCertsResponse.html":{},"interfaces/GetAccessTokenCallback.html":{},"interfaces/GetAccessTokenResponse.html":{},"interfaces/GetFederatedSignonCertsCallback.html":{},"interfaces/GetTokenCallback.html":{},"interfaces/GetTokenOptions.html":{},"interfaces/GetTokenResponse.html":{},"interfaces/GoogleAuthOptions.html":{},"interfaces/OAuth2ClientOptions.html":{},"interfaces/ProjectIdCallback.html":{},"interfaces/RefreshAccessTokenCallback.html":{},"interfaces/RefreshAccessTokenResponse.html":{},"interfaces/RefreshOptions.html":{},"interfaces/RequestMetadataCallback.html":{},"interfaces/RequestMetadataResponse.html":{},"interfaces/RevokeCredentialsResult.html":{},"interfaces/SignBlobResponse.html":{},"interfaces/TokenInfo.html":{},"interfaces/TokenInfoRequest.html":{},"interfaces/VerifyIdTokenOptions.html":{}}}],["e.respons",{"_index":559,"title":{},"body":{"interfaces/BodyResponseCallback.html":{},"classes/DefaultTransporter.html":{},"interfaces/FederatedSignonCertsResponse.html":{},"interfaces/GetAccessTokenCallback.html":{},"interfaces/GetAccessTokenResponse.html":{},"interfaces/GetFederatedSignonCertsCallback.html":{},"interfaces/GetTokenCallback.html":{},"interfaces/GetTokenOptions.html":{},"interfaces/GetTokenResponse.html":{},"interfaces/OAuth2ClientOptions.html":{},"interfaces/RefreshAccessTokenCallback.html":{},"interfaces/RefreshAccessTokenResponse.html":{},"interfaces/RefreshOptions.html":{},"interfaces/RequestError.html":{},"interfaces/RequestMetadataCallback.html":{},"interfaces/RequestMetadataResponse.html":{},"interfaces/RevokeCredentialsResult.html":{},"interfaces/TokenInfo.html":{},"interfaces/TokenInfoRequest.html":{},"interfaces/Transporter.html":{},"interfaces/VerifyIdTokenOptions.html":{}}}],["e.response.statu",{"_index":1077,"title":{},"body":{"interfaces/FederatedSignonCertsResponse.html":{},"interfaces/GetAccessTokenCallback.html":{},"interfaces/GetAccessTokenResponse.html":{},"interfaces/GetFederatedSignonCertsCallback.html":{},"interfaces/GetTokenCallback.html":{},"interfaces/GetTokenOptions.html":{},"interfaces/GetTokenResponse.html":{},"interfaces/OAuth2ClientOptions.html":{},"interfaces/RefreshAccessTokenCallback.html":{},"interfaces/RefreshAccessTokenResponse.html":{},"interfaces/RefreshOptions.html":{},"interfaces/RequestMetadataCallback.html":{},"interfaces/RequestMetadataResponse.html":{},"interfaces/RevokeCredentialsResult.html":{},"interfaces/TokenInfo.html":{},"interfaces/TokenInfoRequest.html":{},"interfaces/VerifyIdTokenOptions.html":{}}}],["each",{"_index":1881,"title":{},"body":{"license.html":{}}}],["eagerli",{"_index":897,"title":{},"body":{"interfaces/FederatedSignonCertsResponse.html":{},"interfaces/GetAccessTokenCallback.html":{},"interfaces/GetAccessTokenResponse.html":{},"interfaces/GetFederatedSignonCertsCallback.html":{},"interfaces/GetTokenCallback.html":{},"interfaces/GetTokenOptions.html":{},"interfaces/GetTokenResponse.html":{},"interfaces/OAuth2ClientOptions.html":{},"interfaces/RefreshAccessTokenCallback.html":{},"interfaces/RefreshAccessTokenResponse.html":{},"interfaces/RefreshOptions.html":{},"interfaces/RequestMetadataCallback.html":{},"interfaces/RequestMetadataResponse.html":{},"interfaces/RevokeCredentialsResult.html":{},"interfaces/TokenInfo.html":{},"interfaces/TokenInfoRequest.html":{},"interfaces/VerifyIdTokenOptions.html":{}}}],["eagerrefreshthresholdmilli",{"_index":904,"title":{},"body":{"interfaces/FederatedSignonCertsResponse.html":{},"interfaces/GetAccessTokenCallback.html":{},"interfaces/GetAccessTokenResponse.html":{},"interfaces/GetFederatedSignonCertsCallback.html":{},"interfaces/GetTokenCallback.html":{},"interfaces/GetTokenOptions.html":{},"interfaces/GetTokenResponse.html":{},"interfaces/OAuth2ClientOptions.html":{},"interfaces/RefreshAccessTokenCallback.html":{},"interfaces/RefreshAccessTokenResponse.html":{},"interfaces/RefreshOptions.html":{},"interfaces/RequestMetadataCallback.html":{},"interfaces/RequestMetadataResponse.html":{},"interfaces/RevokeCredentialsResult.html":{},"interfaces/TokenInfo.html":{},"interfaces/TokenInfoRequest.html":{},"interfaces/UserRefreshClientOptions.html":{},"interfaces/VerifyIdTokenOptions.html":{}}}],["eagerrefreshthresholdmillismillisecond",{"_index":1186,"title":{},"body":{"interfaces/FederatedSignonCertsResponse.html":{},"interfaces/GetAccessTokenCallback.html":{},"interfaces/GetAccessTokenResponse.html":{},"interfaces/GetFederatedSignonCertsCallback.html":{},"interfaces/GetTokenCallback.html":{},"interfaces/GetTokenOptions.html":{},"interfaces/GetTokenResponse.html":{},"interfaces/OAuth2ClientOptions.html":{},"interfaces/RefreshAccessTokenCallback.html":{},"interfaces/RefreshAccessTokenResponse.html":{},"interfaces/RefreshOptions.html":{},"interfaces/RequestMetadataCallback.html":{},"interfaces/RequestMetadataResponse.html":{},"interfaces/RevokeCredentialsResult.html":{},"interfaces/TokenInfo.html":{},"interfaces/TokenInfoRequest.html":{},"interfaces/VerifyIdTokenOptions.html":{}}}],["earliest",{"_index":1168,"title":{},"body":{"interfaces/FederatedSignonCertsResponse.html":{},"interfaces/GetAccessTokenCallback.html":{},"interfaces/GetAccessTokenResponse.html":{},"interfaces/GetFederatedSignonCertsCallback.html":{},"interfaces/GetTokenCallback.html":{},"interfaces/GetTokenOptions.html":{},"interfaces/GetTokenResponse.html":{},"interfaces/OAuth2ClientOptions.html":{},"interfaces/RefreshAccessTokenCallback.html":{},"interfaces/RefreshAccessTokenResponse.html":{},"interfaces/RefreshOptions.html":{},"interfaces/RequestMetadataCallback.html":{},"interfaces/RequestMetadataResponse.html":{},"interfaces/RevokeCredentialsResult.html":{},"interfaces/TokenInfo.html":{},"interfaces/TokenInfoRequest.html":{},"interfaces/VerifyIdTokenOptions.html":{}}}],["easi",{"_index":1753,"title":{},"body":{"index.html":{}}}],["easier",{"_index":1988,"title":{},"body":{"license.html":{}}}],["easili",{"_index":810,"title":{},"body":{"interfaces/FederatedSignonCertsResponse.html":{},"interfaces/GetAccessTokenCallback.html":{},"interfaces/GetAccessTokenResponse.html":{},"interfaces/GetFederatedSignonCertsCallback.html":{},"interfaces/GetTokenCallback.html":{},"interfaces/GetTokenOptions.html":{},"interfaces/GetTokenResponse.html":{},"interfaces/OAuth2ClientOptions.html":{},"interfaces/RefreshAccessTokenCallback.html":{},"interfaces/RefreshAccessTokenResponse.html":{},"interfaces/RefreshOptions.html":{},"interfaces/RequestMetadataCallback.html":{},"interfaces/RequestMetadataResponse.html":{},"interfaces/RevokeCredentialsResult.html":{},"interfaces/TokenInfo.html":{},"interfaces/TokenInfoRequest.html":{},"interfaces/VerifyIdTokenOptions.html":{}}}],["editori",{"_index":1856,"title":{},"body":{"license.html":{}}}],["elabor",{"_index":1859,"title":{},"body":{"license.html":{}}}],["electron",{"_index":520,"title":{},"body":{"interfaces/BodyResponseCallback.html":{},"classes/DefaultTransporter.html":{},"interfaces/RequestError.html":{},"interfaces/Transporter.html":{},"index.html":{},"license.html":{}}}],["email",{"_index":582,"title":{},"body":{"interfaces/ComputeOptions.html":{},"interfaces/FederatedSignonCertsResponse.html":{},"interfaces/GetAccessTokenCallback.html":{},"interfaces/GetAccessTokenResponse.html":{},"interfaces/GetFederatedSignonCertsCallback.html":{},"interfaces/GetTokenCallback.html":{},"interfaces/GetTokenOptions.html":{},"interfaces/GetTokenResponse.html":{},"classes/JWTAccess.html":{},"interfaces/JWTOptions.html":{},"classes/LoginTicket.html":{},"interfaces/OAuth2ClientOptions.html":{},"interfaces/RefreshAccessTokenCallback.html":{},"interfaces/RefreshAccessTokenResponse.html":{},"interfaces/RefreshOptions.html":{},"interfaces/RequestMetadataCallback.html":{},"interfaces/RequestMetadataResponse.html":{},"interfaces/RevokeCredentialsResult.html":{},"interfaces/TokenInfo.html":{},"interfaces/TokenInfoRequest.html":{},"interfaces/TokenPayload.html":{},"interfaces/VerifyIdTokenOptions.html":{},"index.html":{}}}],["email_verifi",{"_index":1370,"title":{},"body":{"classes/LoginTicket.html":{},"interfaces/TokenPayload.html":{}}}],["emb",{"_index":1774,"title":{},"body":{"index.html":{}}}],["emitwarn",{"_index":1423,"title":{},"body":{"interfaces/Warning.html":{}}}],["enabl",{"_index":315,"title":{},"body":{"interfaces/ADCCallback.html":{},"interfaces/ADCResponse.html":{},"interfaces/CredentialCallback.html":{},"interfaces/FederatedSignonCertsResponse.html":{},"interfaces/GetAccessTokenCallback.html":{},"interfaces/GetAccessTokenResponse.html":{},"interfaces/GetFederatedSignonCertsCallback.html":{},"interfaces/GetTokenCallback.html":{},"interfaces/GetTokenOptions.html":{},"interfaces/GetTokenResponse.html":{},"interfaces/GoogleAuthOptions.html":{},"interfaces/OAuth2ClientOptions.html":{},"interfaces/ProjectIdCallback.html":{},"interfaces/RefreshAccessTokenCallback.html":{},"interfaces/RefreshAccessTokenResponse.html":{},"interfaces/RefreshOptions.html":{},"interfaces/RequestMetadataCallback.html":{},"interfaces/RequestMetadataResponse.html":{},"interfaces/RevokeCredentialsResult.html":{},"interfaces/SignBlobResponse.html":{},"interfaces/TokenInfo.html":{},"interfaces/TokenInfoRequest.html":{},"interfaces/VerifyIdTokenOptions.html":{},"interfaces/Warning.html":{},"changelog.html":{},"index.html":{},"miscellaneous/variables.html":{}}}],["enclos",{"_index":1985,"title":{},"body":{"license.html":{}}}],["encod",{"_index":840,"title":{},"body":{"interfaces/FederatedSignonCertsResponse.html":{},"interfaces/GetAccessTokenCallback.html":{},"interfaces/GetAccessTokenResponse.html":{},"interfaces/GetFederatedSignonCertsCallback.html":{},"interfaces/GetTokenCallback.html":{},"interfaces/GetTokenOptions.html":{},"interfaces/GetTokenResponse.html":{},"interfaces/OAuth2ClientOptions.html":{},"classes/PemVerifier.html":{},"interfaces/RefreshAccessTokenCallback.html":{},"interfaces/RefreshAccessTokenResponse.html":{},"interfaces/RefreshOptions.html":{},"interfaces/RequestMetadataCallback.html":{},"interfaces/RequestMetadataResponse.html":{},"interfaces/RevokeCredentialsResult.html":{},"interfaces/TokenInfo.html":{},"interfaces/TokenInfoRequest.html":{},"interfaces/VerifyIdTokenOptions.html":{}}}],["end",{"_index":426,"title":{},"body":{"interfaces/ADCCallback.html":{},"interfaces/ADCResponse.html":{},"interfaces/CredentialCallback.html":{},"interfaces/GoogleAuthOptions.html":{},"interfaces/ProjectIdCallback.html":{},"interfaces/SignBlobResponse.html":{},"interfaces/Warning.html":{},"index.html":{},"license.html":{},"miscellaneous/variables.html":{}}}],["endpoint",{"_index":932,"title":{},"body":{"interfaces/FederatedSignonCertsResponse.html":{},"interfaces/GetAccessTokenCallback.html":{},"interfaces/GetAccessTokenResponse.html":{},"interfaces/GetFederatedSignonCertsCallback.html":{},"interfaces/GetTokenCallback.html":{},"interfaces/GetTokenOptions.html":{},"interfaces/GetTokenResponse.html":{},"interfaces/OAuth2ClientOptions.html":{},"interfaces/RefreshAccessTokenCallback.html":{},"interfaces/RefreshAccessTokenResponse.html":{},"interfaces/RefreshOptions.html":{},"interfaces/RequestMetadataCallback.html":{},"interfaces/RequestMetadataResponse.html":{},"interfaces/RevokeCredentialsResult.html":{},"interfaces/TokenInfo.html":{},"interfaces/TokenInfoRequest.html":{},"interfaces/VerifyIdTokenOptions.html":{}}}],["enforc",{"_index":1384,"title":{},"body":{"classes/LoginTicket.html":{},"interfaces/TokenPayload.html":{}}}],["engin",{"_index":94,"title":{},"body":{"interfaces/ADCCallback.html":{},"interfaces/ADCResponse.html":{},"interfaces/ComputeOptions.html":{},"interfaces/CredentialCallback.html":{},"interfaces/GoogleAuthOptions.html":{},"interfaces/ProjectIdCallback.html":{},"interfaces/SignBlobResponse.html":{},"index.html":{}}}],["ensur",{"_index":526,"title":{},"body":{"interfaces/BodyResponseCallback.html":{},"classes/DefaultTransporter.html":{},"interfaces/FederatedSignonCertsResponse.html":{},"interfaces/GetAccessTokenCallback.html":{},"interfaces/GetAccessTokenResponse.html":{},"interfaces/GetFederatedSignonCertsCallback.html":{},"interfaces/GetTokenCallback.html":{},"interfaces/GetTokenOptions.html":{},"interfaces/GetTokenResponse.html":{},"classes/JWTAccess.html":{},"classes/LoginTicket.html":{},"interfaces/OAuth2ClientOptions.html":{},"interfaces/RefreshAccessTokenCallback.html":{},"interfaces/RefreshAccessTokenResponse.html":{},"interfaces/RefreshOptions.html":{},"interfaces/RequestError.html":{},"interfaces/RequestMetadataCallback.html":{},"interfaces/RequestMetadataResponse.html":{},"interfaces/RevokeCredentialsResult.html":{},"interfaces/TokenInfo.html":{},"interfaces/TokenInfoRequest.html":{},"interfaces/TokenPayload.html":{},"interfaces/Transporter.html":{},"interfaces/VerifyIdTokenOptions.html":{},"index.html":{}}}],["entiti",{"_index":1827,"title":{},"body":{"license.html":{}}}],["enum",{"_index":694,"title":{},"body":{"interfaces/FederatedSignonCertsResponse.html":{},"interfaces/GetAccessTokenCallback.html":{},"interfaces/GetAccessTokenResponse.html":{},"interfaces/GetFederatedSignonCertsCallback.html":{},"interfaces/GetTokenCallback.html":{},"interfaces/GetTokenOptions.html":{},"interfaces/GetTokenResponse.html":{},"interfaces/OAuth2ClientOptions.html":{},"interfaces/RefreshAccessTokenCallback.html":{},"interfaces/RefreshAccessTokenResponse.html":{},"interfaces/RefreshOptions.html":{},"interfaces/RequestMetadataCallback.html":{},"interfaces/RequestMetadataResponse.html":{},"interfaces/RevokeCredentialsResult.html":{},"interfaces/TokenInfo.html":{},"interfaces/TokenInfoRequest.html":{},"interfaces/VerifyIdTokenOptions.html":{},"interfaces/Warning.html":{}}}],["enumer",{"_index":1648,"title":{"miscellaneous/enumerations.html":{}},"body":{"miscellaneous/enumerations.html":{}}}],["env",{"_index":1349,"title":{},"body":{"classes/LoginTicket.html":{},"interfaces/TokenPayload.html":{},"miscellaneous/variables.html":{}}}],["envdetect",{"_index":45,"title":{},"body":{"interfaces/ADCCallback.html":{},"interfaces/ADCResponse.html":{},"interfaces/CredentialCallback.html":{},"interfaces/GoogleAuthOptions.html":{},"interfaces/ProjectIdCallback.html":{},"interfaces/SignBlobResponse.html":{}}}],["envelop",{"_index":1350,"title":{},"body":{"classes/LoginTicket.html":{},"interfaces/TokenPayload.html":{}}}],["environ",{"_index":160,"title":{},"body":{"interfaces/ADCCallback.html":{},"interfaces/ADCResponse.html":{},"interfaces/BodyResponseCallback.html":{},"interfaces/CredentialCallback.html":{},"classes/DefaultTransporter.html":{},"interfaces/GoogleAuthOptions.html":{},"interfaces/ProjectIdCallback.html":{},"interfaces/RequestError.html":{},"interfaces/SignBlobResponse.html":{},"interfaces/Transporter.html":{},"index.html":{}}}],["equival",{"_index":864,"title":{},"body":{"interfaces/FederatedSignonCertsResponse.html":{},"interfaces/GetAccessTokenCallback.html":{},"interfaces/GetAccessTokenResponse.html":{},"interfaces/GetFederatedSignonCertsCallback.html":{},"interfaces/GetTokenCallback.html":{},"interfaces/GetTokenOptions.html":{},"interfaces/GetTokenResponse.html":{},"interfaces/OAuth2ClientOptions.html":{},"interfaces/RefreshAccessTokenCallback.html":{},"interfaces/RefreshAccessTokenResponse.html":{},"interfaces/RefreshOptions.html":{},"interfaces/RequestMetadataCallback.html":{},"interfaces/RequestMetadataResponse.html":{},"interfaces/RevokeCredentialsResult.html":{},"interfaces/TokenInfo.html":{},"interfaces/TokenInfoRequest.html":{},"interfaces/VerifyIdTokenOptions.html":{}}}],["err",{"_index":11,"title":{},"body":{"interfaces/ADCCallback.html":{},"interfaces/ADCResponse.html":{},"interfaces/BodyResponseCallback.html":{},"interfaces/CredentialCallback.html":{},"classes/DefaultTransporter.html":{},"interfaces/FederatedSignonCertsResponse.html":{},"interfaces/GetAccessTokenCallback.html":{},"interfaces/GetAccessTokenResponse.html":{},"interfaces/GetFederatedSignonCertsCallback.html":{},"interfaces/GetTokenCallback.html":{},"interfaces/GetTokenOptions.html":{},"interfaces/GetTokenResponse.html":{},"interfaces/GoogleAuthOptions.html":{},"classes/IAMAuth.html":{},"classes/JWTAccess.html":{},"interfaces/JWTOptions.html":{},"interfaces/OAuth2ClientOptions.html":{},"interfaces/ProjectIdCallback.html":{},"interfaces/RefreshAccessTokenCallback.html":{},"interfaces/RefreshAccessTokenResponse.html":{},"interfaces/RefreshOptions.html":{},"interfaces/RequestError.html":{},"interfaces/RequestMetadata.html":{},"interfaces/RequestMetadataCallback.html":{},"interfaces/RequestMetadataResponse.html":{},"interfaces/RevokeCredentialsResult.html":{},"interfaces/SignBlobResponse.html":{},"interfaces/TokenInfo.html":{},"interfaces/TokenInfoRequest.html":{},"interfaces/Transporter.html":{},"interfaces/UserRefreshClientOptions.html":{},"interfaces/VerifyIdTokenOptions.html":{},"changelog.html":{}}}],["err.cod",{"_index":565,"title":{},"body":{"interfaces/BodyResponseCallback.html":{},"classes/DefaultTransporter.html":{},"interfaces/RequestError.html":{},"interfaces/Transporter.html":{}}}],["err.error",{"_index":571,"title":{},"body":{"interfaces/BodyResponseCallback.html":{},"classes/DefaultTransporter.html":{},"interfaces/RequestError.html":{},"interfaces/Transporter.html":{}}}],["err.messag",{"_index":564,"title":{},"body":{"interfaces/BodyResponseCallback.html":{},"classes/DefaultTransporter.html":{},"interfaces/RequestError.html":{},"interfaces/Transporter.html":{}}}],["err2.message).join('\\n",{"_index":569,"title":{},"body":{"interfaces/BodyResponseCallback.html":{},"classes/DefaultTransporter.html":{},"interfaces/RequestError.html":{},"interfaces/Transporter.html":{}}}],["error",{"_index":12,"title":{},"body":{"interfaces/ADCCallback.html":{},"interfaces/ADCResponse.html":{},"interfaces/BodyResponseCallback.html":{},"interfaces/ComputeOptions.html":{},"interfaces/CredentialCallback.html":{},"classes/DefaultTransporter.html":{},"interfaces/FederatedSignonCertsResponse.html":{},"interfaces/GetAccessTokenCallback.html":{},"interfaces/GetAccessTokenResponse.html":{},"interfaces/GetFederatedSignonCertsCallback.html":{},"interfaces/GetTokenCallback.html":{},"interfaces/GetTokenOptions.html":{},"interfaces/GetTokenResponse.html":{},"interfaces/GoogleAuthOptions.html":{},"classes/IAMAuth.html":{},"classes/JWTAccess.html":{},"interfaces/JWTOptions.html":{},"interfaces/OAuth2ClientOptions.html":{},"interfaces/ProjectIdCallback.html":{},"interfaces/RefreshAccessTokenCallback.html":{},"interfaces/RefreshAccessTokenResponse.html":{},"interfaces/RefreshOptions.html":{},"interfaces/RequestError.html":{},"interfaces/RequestMetadataCallback.html":{},"interfaces/RequestMetadataResponse.html":{},"interfaces/RevokeCredentialsResult.html":{},"interfaces/SignBlobResponse.html":{},"interfaces/TokenInfo.html":{},"interfaces/TokenInfoRequest.html":{},"interfaces/Transporter.html":{},"interfaces/UserRefreshClientOptions.html":{},"interfaces/VerifyIdTokenOptions.html":{},"interfaces/Warning.html":{},"miscellaneous/variables.html":{}}}],["error(",{"_index":394,"title":{},"body":{"interfaces/ADCCallback.html":{},"interfaces/ADCResponse.html":{},"interfaces/CredentialCallback.html":{},"interfaces/GoogleAuthOptions.html":{},"interfaces/ProjectIdCallback.html":{},"interfaces/SignBlobResponse.html":{}}}],["error('a",{"_index":1339,"title":{},"body":{"interfaces/JWTOptions.html":{}}}],["error('cannot",{"_index":482,"title":{},"body":{"interfaces/ADCCallback.html":{},"interfaces/ADCResponse.html":{},"interfaces/CredentialCallback.html":{},"interfaces/GoogleAuthOptions.html":{},"interfaces/ProjectIdCallback.html":{},"interfaces/SignBlobResponse.html":{}}}],["error('could",{"_index":1057,"title":{},"body":{"interfaces/FederatedSignonCertsResponse.html":{},"interfaces/GetAccessTokenCallback.html":{},"interfaces/GetAccessTokenResponse.html":{},"interfaces/GetFederatedSignonCertsCallback.html":{},"interfaces/GetTokenCallback.html":{},"interfaces/GetTokenOptions.html":{},"interfaces/GetTokenResponse.html":{},"interfaces/OAuth2ClientOptions.html":{},"interfaces/RefreshAccessTokenCallback.html":{},"interfaces/RefreshAccessTokenResponse.html":{},"interfaces/RefreshOptions.html":{},"interfaces/RequestMetadataCallback.html":{},"interfaces/RequestMetadataResponse.html":{},"interfaces/RevokeCredentialsResult.html":{},"interfaces/TokenInfo.html":{},"interfaces/TokenInfoRequest.html":{},"interfaces/VerifyIdTokenOptions.html":{}}}],["error('failur",{"_index":435,"title":{},"body":{"interfaces/ADCCallback.html":{},"interfaces/ADCResponse.html":{},"interfaces/CredentialCallback.html":{},"interfaces/GoogleAuthOptions.html":{},"interfaces/ProjectIdCallback.html":{},"interfaces/SignBlobResponse.html":{}}}],["error('must",{"_index":1335,"title":{},"body":{"interfaces/JWTOptions.html":{}}}],["error('no",{"_index":1044,"title":{},"body":{"interfaces/FederatedSignonCertsResponse.html":{},"interfaces/GetAccessTokenCallback.html":{},"interfaces/GetAccessTokenResponse.html":{},"interfaces/GetFederatedSignonCertsCallback.html":{},"interfaces/GetTokenCallback.html":{},"interfaces/GetTokenOptions.html":{},"interfaces/GetTokenResponse.html":{},"interfaces/JWTOptions.html":{},"interfaces/OAuth2ClientOptions.html":{},"interfaces/RefreshAccessTokenCallback.html":{},"interfaces/RefreshAccessTokenResponse.html":{},"interfaces/RefreshOptions.html":{},"interfaces/RequestMetadataCallback.html":{},"interfaces/RequestMetadataResponse.html":{},"interfaces/RevokeCredentialsResult.html":{},"interfaces/TokenInfo.html":{},"interfaces/TokenInfoRequest.html":{},"interfaces/VerifyIdTokenOptions.html":{}}}],["error('th",{"_index":293,"title":{},"body":{"interfaces/ADCCallback.html":{},"interfaces/ADCResponse.html":{},"interfaces/CredentialCallback.html":{},"interfaces/FederatedSignonCertsResponse.html":{},"interfaces/GetAccessTokenCallback.html":{},"interfaces/GetAccessTokenResponse.html":{},"interfaces/GetFederatedSignonCertsCallback.html":{},"interfaces/GetTokenCallback.html":{},"interfaces/GetTokenOptions.html":{},"interfaces/GetTokenResponse.html":{},"interfaces/GoogleAuthOptions.html":{},"interfaces/OAuth2ClientOptions.html":{},"interfaces/ProjectIdCallback.html":{},"interfaces/RefreshAccessTokenCallback.html":{},"interfaces/RefreshAccessTokenResponse.html":{},"interfaces/RefreshOptions.html":{},"interfaces/RequestMetadataCallback.html":{},"interfaces/RequestMetadataResponse.html":{},"interfaces/RevokeCredentialsResult.html":{},"interfaces/SignBlobResponse.html":{},"interfaces/TokenInfo.html":{},"interfaces/TokenInfoRequest.html":{},"interfaces/VerifyIdTokenOptions.html":{},"index.html":{}}}],["error('unknown",{"_index":422,"title":{},"body":{"interfaces/ADCCallback.html":{},"interfaces/ADCResponse.html":{},"interfaces/CredentialCallback.html":{},"interfaces/GoogleAuthOptions.html":{},"interfaces/ProjectIdCallback.html":{},"interfaces/SignBlobResponse.html":{}}}],["error(`th",{"_index":1264,"title":{},"body":{"classes/JWTAccess.html":{}}}],["error(helpfulmessag",{"_index":635,"title":{},"body":{"interfaces/ComputeOptions.html":{}}}],["errormessag",{"_index":390,"title":{},"body":{"interfaces/ADCCallback.html":{},"interfaces/ADCResponse.html":{},"interfaces/CredentialCallback.html":{},"interfaces/GoogleAuthOptions.html":{},"interfaces/ProjectIdCallback.html":{},"interfaces/SignBlobResponse.html":{}}}],["errormessage.length",{"_index":392,"title":{},"body":{"interfaces/ADCCallback.html":{},"interfaces/ADCResponse.html":{},"interfaces/CredentialCallback.html":{},"interfaces/GoogleAuthOptions.html":{},"interfaces/ProjectIdCallback.html":{},"interfaces/SignBlobResponse.html":{}}}],["error|nul",{"_index":55,"title":{},"body":{"interfaces/ADCCallback.html":{},"interfaces/ADCResponse.html":{},"interfaces/BodyResponseCallback.html":{},"interfaces/CredentialCallback.html":{},"classes/DefaultTransporter.html":{},"interfaces/FederatedSignonCertsResponse.html":{},"interfaces/GetAccessTokenCallback.html":{},"interfaces/GetAccessTokenResponse.html":{},"interfaces/GetFederatedSignonCertsCallback.html":{},"interfaces/GetTokenCallback.html":{},"interfaces/GetTokenOptions.html":{},"interfaces/GetTokenResponse.html":{},"interfaces/GoogleAuthOptions.html":{},"classes/IAMAuth.html":{},"interfaces/JWTOptions.html":{},"interfaces/OAuth2ClientOptions.html":{},"interfaces/ProjectIdCallback.html":{},"interfaces/RefreshAccessTokenCallback.html":{},"interfaces/RefreshAccessTokenResponse.html":{},"interfaces/RefreshOptions.html":{},"interfaces/RequestError.html":{},"interfaces/RequestMetadata.html":{},"interfaces/RequestMetadataCallback.html":{},"interfaces/RequestMetadataResponse.html":{},"interfaces/RevokeCredentialsResult.html":{},"interfaces/SignBlobResponse.html":{},"interfaces/TokenInfo.html":{},"interfaces/TokenInfoRequest.html":{},"interfaces/Transporter.html":{},"interfaces/VerifyIdTokenOptions.html":{}}}],["eslint",{"_index":1521,"title":{},"body":{"changelog.html":{}}}],["especi",{"_index":1146,"title":{},"body":{"interfaces/FederatedSignonCertsResponse.html":{},"interfaces/GetAccessTokenCallback.html":{},"interfaces/GetAccessTokenResponse.html":{},"interfaces/GetFederatedSignonCertsCallback.html":{},"interfaces/GetTokenCallback.html":{},"interfaces/GetTokenOptions.html":{},"interfaces/GetTokenResponse.html":{},"interfaces/OAuth2ClientOptions.html":{},"interfaces/RefreshAccessTokenCallback.html":{},"interfaces/RefreshAccessTokenResponse.html":{},"interfaces/RefreshOptions.html":{},"interfaces/RequestMetadataCallback.html":{},"interfaces/RequestMetadataResponse.html":{},"interfaces/RevokeCredentialsResult.html":{},"interfaces/TokenInfo.html":{},"interfaces/TokenInfoRequest.html":{},"interfaces/VerifyIdTokenOptions.html":{},"index.html":{}}}],["espow",{"_index":1614,"title":{},"body":{"changelog.html":{}}}],["etc",{"_index":1692,"title":{},"body":{"index.html":{}}}],["even",{"_index":1973,"title":{},"body":{"license.html":{}}}],["event",{"_index":1751,"title":{},"body":{"index.html":{},"license.html":{}}}],["exact",{"_index":816,"title":{},"body":{"interfaces/FederatedSignonCertsResponse.html":{},"interfaces/GetAccessTokenCallback.html":{},"interfaces/GetAccessTokenResponse.html":{},"interfaces/GetFederatedSignonCertsCallback.html":{},"interfaces/GetTokenCallback.html":{},"interfaces/GetTokenOptions.html":{},"interfaces/GetTokenResponse.html":{},"interfaces/OAuth2ClientOptions.html":{},"interfaces/RefreshAccessTokenCallback.html":{},"interfaces/RefreshAccessTokenResponse.html":{},"interfaces/RefreshOptions.html":{},"interfaces/RequestMetadataCallback.html":{},"interfaces/RequestMetadataResponse.html":{},"interfaces/RevokeCredentialsResult.html":{},"interfaces/TokenInfo.html":{},"interfaces/TokenInfoRequest.html":{},"interfaces/VerifyIdTokenOptions.html":{}}}],["exactli",{"_index":783,"title":{},"body":{"interfaces/FederatedSignonCertsResponse.html":{},"interfaces/GetAccessTokenCallback.html":{},"interfaces/GetAccessTokenResponse.html":{},"interfaces/GetFederatedSignonCertsCallback.html":{},"interfaces/GetTokenCallback.html":{},"interfaces/GetTokenOptions.html":{},"interfaces/GetTokenResponse.html":{},"interfaces/OAuth2ClientOptions.html":{},"interfaces/RefreshAccessTokenCallback.html":{},"interfaces/RefreshAccessTokenResponse.html":{},"interfaces/RefreshOptions.html":{},"interfaces/RequestMetadataCallback.html":{},"interfaces/RequestMetadataResponse.html":{},"interfaces/RevokeCredentialsResult.html":{},"interfaces/TokenInfo.html":{},"interfaces/TokenInfoRequest.html":{},"interfaces/VerifyIdTokenOptions.html":{}}}],["exampl",{"_index":763,"title":{},"body":{"interfaces/FederatedSignonCertsResponse.html":{},"interfaces/GetAccessTokenCallback.html":{},"interfaces/GetAccessTokenResponse.html":{},"interfaces/GetFederatedSignonCertsCallback.html":{},"interfaces/GetTokenCallback.html":{},"interfaces/GetTokenOptions.html":{},"interfaces/GetTokenResponse.html":{},"interfaces/OAuth2ClientOptions.html":{},"interfaces/RefreshAccessTokenCallback.html":{},"interfaces/RefreshAccessTokenResponse.html":{},"interfaces/RefreshOptions.html":{},"interfaces/RequestMetadataCallback.html":{},"interfaces/RequestMetadataResponse.html":{},"interfaces/RevokeCredentialsResult.html":{},"interfaces/TokenInfo.html":{},"interfaces/TokenInfoRequest.html":{},"interfaces/VerifyIdTokenOptions.html":{},"changelog.html":{},"index.html":{},"license.html":{}}}],["exceed",{"_index":1436,"title":{},"body":{"interfaces/Warning.html":{},"miscellaneous/variables.html":{}}}],["except",{"_index":659,"title":{},"body":{"interfaces/Credentials.html":{},"classes/LoginTicket.html":{},"miscellaneous/functions.html":{},"license.html":{}}}],["exchang",{"_index":749,"title":{},"body":{"interfaces/FederatedSignonCertsResponse.html":{},"interfaces/GetAccessTokenCallback.html":{},"interfaces/GetAccessTokenResponse.html":{},"interfaces/GetFederatedSignonCertsCallback.html":{},"interfaces/GetTokenCallback.html":{},"interfaces/GetTokenOptions.html":{},"interfaces/GetTokenResponse.html":{},"interfaces/OAuth2ClientOptions.html":{},"interfaces/RefreshAccessTokenCallback.html":{},"interfaces/RefreshAccessTokenResponse.html":{},"interfaces/RefreshOptions.html":{},"interfaces/RequestMetadataCallback.html":{},"interfaces/RequestMetadataResponse.html":{},"interfaces/RevokeCredentialsResult.html":{},"interfaces/TokenInfo.html":{},"interfaces/TokenInfoRequest.html":{},"interfaces/VerifyIdTokenOptions.html":{}}}],["exclud",{"_index":1874,"title":{},"body":{"license.html":{}}}],["exclus",{"_index":1885,"title":{},"body":{"license.html":{}}}],["exec",{"_index":24,"title":{},"body":{"interfaces/ADCCallback.html":{},"interfaces/ADCResponse.html":{},"interfaces/CredentialCallback.html":{},"interfaces/GoogleAuthOptions.html":{},"interfaces/ProjectIdCallback.html":{},"interfaces/SignBlobResponse.html":{}}}],["execut",{"_index":233,"title":{},"body":{"interfaces/ADCCallback.html":{},"interfaces/ADCResponse.html":{},"interfaces/CredentialCallback.html":{},"interfaces/GoogleAuthOptions.html":{},"interfaces/ProjectIdCallback.html":{},"interfaces/SignBlobResponse.html":{},"license.html":{}}}],["exercis",{"_index":1845,"title":{},"body":{"license.html":{}}}],["exist",{"_index":213,"title":{},"body":{"interfaces/ADCCallback.html":{},"interfaces/ADCResponse.html":{},"interfaces/CredentialCallback.html":{},"interfaces/FederatedSignonCertsResponse.html":{},"interfaces/GetAccessTokenCallback.html":{},"interfaces/GetAccessTokenResponse.html":{},"interfaces/GetFederatedSignonCertsCallback.html":{},"interfaces/GetTokenCallback.html":{},"interfaces/GetTokenOptions.html":{},"interfaces/GetTokenResponse.html":{},"interfaces/GoogleAuthOptions.html":{},"interfaces/JWTOptions.html":{},"interfaces/OAuth2ClientOptions.html":{},"interfaces/ProjectIdCallback.html":{},"interfaces/RefreshAccessTokenCallback.html":{},"interfaces/RefreshAccessTokenResponse.html":{},"interfaces/RefreshOptions.html":{},"interfaces/RequestMetadataCallback.html":{},"interfaces/RequestMetadataResponse.html":{},"interfaces/RevokeCredentialsResult.html":{},"interfaces/SignBlobResponse.html":{},"interfaces/TokenInfo.html":{},"interfaces/TokenInfoRequest.html":{},"interfaces/VerifyIdTokenOptions.html":{}}}],["exp",{"_index":752,"title":{},"body":{"interfaces/FederatedSignonCertsResponse.html":{},"interfaces/GetAccessTokenCallback.html":{},"interfaces/GetAccessTokenResponse.html":{},"interfaces/GetFederatedSignonCertsCallback.html":{},"interfaces/GetTokenCallback.html":{},"interfaces/GetTokenOptions.html":{},"interfaces/GetTokenResponse.html":{},"classes/JWTAccess.html":{},"classes/LoginTicket.html":{},"interfaces/OAuth2ClientOptions.html":{},"interfaces/RefreshAccessTokenCallback.html":{},"interfaces/RefreshAccessTokenResponse.html":{},"interfaces/RefreshOptions.html":{},"interfaces/RequestMetadataCallback.html":{},"interfaces/RequestMetadataResponse.html":{},"interfaces/RevokeCredentialsResult.html":{},"interfaces/TokenInfo.html":{},"interfaces/TokenInfoRequest.html":{},"interfaces/TokenPayload.html":{},"interfaces/VerifyIdTokenOptions.html":{}}}],["expand",{"_index":278,"title":{},"body":{"interfaces/ADCCallback.html":{},"interfaces/ADCResponse.html":{},"interfaces/CredentialCallback.html":{},"interfaces/GoogleAuthOptions.html":{},"interfaces/ProjectIdCallback.html":{},"interfaces/SignBlobResponse.html":{}}}],["expect",{"_index":299,"title":{},"body":{"interfaces/ADCCallback.html":{},"interfaces/ADCResponse.html":{},"interfaces/CredentialCallback.html":{},"interfaces/FederatedSignonCertsResponse.html":{},"interfaces/GetAccessTokenCallback.html":{},"interfaces/GetAccessTokenResponse.html":{},"interfaces/GetFederatedSignonCertsCallback.html":{},"interfaces/GetTokenCallback.html":{},"interfaces/GetTokenOptions.html":{},"interfaces/GetTokenResponse.html":{},"interfaces/GoogleAuthOptions.html":{},"interfaces/OAuth2ClientOptions.html":{},"interfaces/ProjectIdCallback.html":{},"interfaces/RefreshAccessTokenCallback.html":{},"interfaces/RefreshAccessTokenResponse.html":{},"interfaces/RefreshOptions.html":{},"interfaces/RequestMetadataCallback.html":{},"interfaces/RequestMetadataResponse.html":{},"interfaces/RevokeCredentialsResult.html":{},"interfaces/SignBlobResponse.html":{},"interfaces/TokenInfo.html":{},"interfaces/TokenInfoRequest.html":{},"interfaces/VerifyIdTokenOptions.html":{}}}],["expir",{"_index":590,"title":{},"body":{"interfaces/ComputeOptions.html":{},"interfaces/FederatedSignonCertsResponse.html":{},"interfaces/GetAccessTokenCallback.html":{},"interfaces/GetAccessTokenResponse.html":{},"interfaces/GetFederatedSignonCertsCallback.html":{},"interfaces/GetTokenCallback.html":{},"interfaces/GetTokenOptions.html":{},"interfaces/GetTokenResponse.html":{},"classes/JWTAccess.html":{},"classes/LoginTicket.html":{},"interfaces/OAuth2ClientOptions.html":{},"interfaces/RefreshAccessTokenCallback.html":{},"interfaces/RefreshAccessTokenResponse.html":{},"interfaces/RefreshOptions.html":{},"interfaces/RequestMetadataCallback.html":{},"interfaces/RequestMetadataResponse.html":{},"interfaces/RevokeCredentialsResult.html":{},"interfaces/TokenInfo.html":{},"interfaces/TokenInfoRequest.html":{},"interfaces/TokenPayload.html":{},"interfaces/VerifyIdTokenOptions.html":{},"index.html":{}}}],["expires_in",{"_index":642,"title":{},"body":{"interfaces/CredentialBody.html":{},"interfaces/CredentialRequest.html":{},"interfaces/Credentials.html":{},"interfaces/FederatedSignonCertsResponse.html":{},"interfaces/GetAccessTokenCallback.html":{},"interfaces/GetAccessTokenResponse.html":{},"interfaces/GetFederatedSignonCertsCallback.html":{},"interfaces/GetTokenCallback.html":{},"interfaces/GetTokenOptions.html":{},"interfaces/GetTokenResponse.html":{},"interfaces/JWTInput.html":{},"interfaces/OAuth2ClientOptions.html":{},"interfaces/RefreshAccessTokenCallback.html":{},"interfaces/RefreshAccessTokenResponse.html":{},"interfaces/RefreshOptions.html":{},"interfaces/RequestMetadataCallback.html":{},"interfaces/RequestMetadataResponse.html":{},"interfaces/RevokeCredentialsResult.html":{},"interfaces/TokenInfo.html":{},"interfaces/TokenInfoRequest.html":{},"interfaces/VerifyIdTokenOptions.html":{}}}],["expiri",{"_index":1187,"title":{},"body":{"interfaces/FederatedSignonCertsResponse.html":{},"interfaces/GetAccessTokenCallback.html":{},"interfaces/GetAccessTokenResponse.html":{},"interfaces/GetFederatedSignonCertsCallback.html":{},"interfaces/GetTokenCallback.html":{},"interfaces/GetTokenOptions.html":{},"interfaces/GetTokenResponse.html":{},"interfaces/OAuth2ClientOptions.html":{},"interfaces/RefreshAccessTokenCallback.html":{},"interfaces/RefreshAccessTokenResponse.html":{},"interfaces/RefreshOptions.html":{},"interfaces/RequestMetadataCallback.html":{},"interfaces/RequestMetadataResponse.html":{},"interfaces/RevokeCredentialsResult.html":{},"interfaces/TokenInfo.html":{},"interfaces/TokenInfoRequest.html":{},"interfaces/VerifyIdTokenOptions.html":{}}}],["expiry_d",{"_index":595,"title":{},"body":{"interfaces/ComputeOptions.html":{},"interfaces/CredentialBody.html":{},"interfaces/CredentialRequest.html":{},"interfaces/Credentials.html":{},"interfaces/FederatedSignonCertsResponse.html":{},"interfaces/GetAccessTokenCallback.html":{},"interfaces/GetAccessTokenResponse.html":{},"interfaces/GetFederatedSignonCertsCallback.html":{},"interfaces/GetTokenCallback.html":{},"interfaces/GetTokenOptions.html":{},"interfaces/GetTokenResponse.html":{},"interfaces/JWTInput.html":{},"interfaces/JWTOptions.html":{},"interfaces/OAuth2ClientOptions.html":{},"interfaces/RefreshAccessTokenCallback.html":{},"interfaces/RefreshAccessTokenResponse.html":{},"interfaces/RefreshOptions.html":{},"interfaces/RequestMetadataCallback.html":{},"interfaces/RequestMetadataResponse.html":{},"interfaces/RevokeCredentialsResult.html":{},"interfaces/TokenInfo.html":{},"interfaces/TokenInfoRequest.html":{},"interfaces/VerifyIdTokenOptions.html":{},"index.html":{}}}],["expiryd",{"_index":1189,"title":{},"body":{"interfaces/FederatedSignonCertsResponse.html":{},"interfaces/GetAccessTokenCallback.html":{},"interfaces/GetAccessTokenResponse.html":{},"interfaces/GetFederatedSignonCertsCallback.html":{},"interfaces/GetTokenCallback.html":{},"interfaces/GetTokenOptions.html":{},"interfaces/GetTokenResponse.html":{},"interfaces/OAuth2ClientOptions.html":{},"interfaces/RefreshAccessTokenCallback.html":{},"interfaces/RefreshAccessTokenResponse.html":{},"interfaces/RefreshOptions.html":{},"interfaces/RequestMetadataCallback.html":{},"interfaces/RequestMetadataResponse.html":{},"interfaces/RevokeCredentialsResult.html":{},"interfaces/TokenInfo.html":{},"interfaces/TokenInfoRequest.html":{},"interfaces/VerifyIdTokenOptions.html":{}}}],["explain",{"_index":1701,"title":{},"body":{"index.html":{}}}],["explicit",{"_index":1804,"title":{},"body":{"index.html":{}}}],["explicitli",{"_index":1938,"title":{},"body":{"license.html":{}}}],["export",{"_index":53,"title":{},"body":{"interfaces/ADCCallback.html":{},"interfaces/ADCResponse.html":{},"interfaces/BodyResponseCallback.html":{},"interfaces/ComputeOptions.html":{},"interfaces/CredentialBody.html":{},"interfaces/CredentialCallback.html":{},"interfaces/CredentialRequest.html":{},"interfaces/Credentials.html":{},"classes/DefaultTransporter.html":{},"interfaces/FederatedSignonCertsResponse.html":{},"interfaces/GetAccessTokenCallback.html":{},"interfaces/GetAccessTokenResponse.html":{},"interfaces/GetFederatedSignonCertsCallback.html":{},"interfaces/GetTokenCallback.html":{},"interfaces/GetTokenOptions.html":{},"interfaces/GetTokenResponse.html":{},"interfaces/GoogleAuthOptions.html":{},"classes/IAMAuth.html":{},"classes/JWTAccess.html":{},"interfaces/JWTInput.html":{},"interfaces/JWTOptions.html":{},"classes/LoginTicket.html":{},"interfaces/OAuth2ClientOptions.html":{},"classes/PemVerifier.html":{},"interfaces/ProjectIdCallback.html":{},"interfaces/RefreshAccessTokenCallback.html":{},"interfaces/RefreshAccessTokenResponse.html":{},"interfaces/RefreshOptions.html":{},"interfaces/RequestError.html":{},"interfaces/RequestMetadata.html":{},"interfaces/RequestMetadataCallback.html":{},"interfaces/RequestMetadataResponse.html":{},"interfaces/RevokeCredentialsResult.html":{},"interfaces/SignBlobResponse.html":{},"interfaces/TokenInfo.html":{},"interfaces/TokenInfoRequest.html":{},"interfaces/TokenPayload.html":{},"interfaces/Transporter.html":{},"interfaces/UserRefreshClientOptions.html":{},"interfaces/VerifyIdTokenOptions.html":{},"interfaces/Warning.html":{},"changelog.html":{},"index.html":{}}}],["express",{"_index":673,"title":{},"body":{"interfaces/Credentials.html":{},"classes/LoginTicket.html":{},"miscellaneous/functions.html":{},"license.html":{}}}],["extend",{"_index":517,"title":{},"body":{"interfaces/BodyResponseCallback.html":{},"interfaces/ComputeOptions.html":{},"classes/DefaultTransporter.html":{},"interfaces/FederatedSignonCertsResponse.html":{},"interfaces/GetAccessTokenCallback.html":{},"interfaces/GetAccessTokenResponse.html":{},"interfaces/GetFederatedSignonCertsCallback.html":{},"interfaces/GetTokenCallback.html":{},"interfaces/GetTokenOptions.html":{},"interfaces/GetTokenResponse.html":{},"interfaces/JWTOptions.html":{},"interfaces/OAuth2ClientOptions.html":{},"interfaces/RefreshAccessTokenCallback.html":{},"interfaces/RefreshAccessTokenResponse.html":{},"interfaces/RefreshOptions.html":{},"interfaces/RequestError.html":{},"interfaces/RequestMetadataCallback.html":{},"interfaces/RequestMetadataResponse.html":{},"interfaces/RevokeCredentialsResult.html":{},"interfaces/TokenInfo.html":{},"interfaces/TokenInfoRequest.html":{},"interfaces/Transporter.html":{},"interfaces/UserRefreshClientOptions.html":{},"interfaces/VerifyIdTokenOptions.html":{}}}],["extract",{"_index":1273,"title":{},"body":{"classes/JWTAccess.html":{},"interfaces/JWTOptions.html":{},"classes/LoginTicket.html":{},"interfaces/TokenPayload.html":{}}}],["fail",{"_index":235,"title":{},"body":{"interfaces/ADCCallback.html":{},"interfaces/ADCResponse.html":{},"interfaces/CredentialCallback.html":{},"interfaces/FederatedSignonCertsResponse.html":{},"interfaces/GetAccessTokenCallback.html":{},"interfaces/GetAccessTokenResponse.html":{},"interfaces/GetFederatedSignonCertsCallback.html":{},"interfaces/GetTokenCallback.html":{},"interfaces/GetTokenOptions.html":{},"interfaces/GetTokenResponse.html":{},"interfaces/GoogleAuthOptions.html":{},"interfaces/OAuth2ClientOptions.html":{},"interfaces/ProjectIdCallback.html":{},"interfaces/RefreshAccessTokenCallback.html":{},"interfaces/RefreshAccessTokenResponse.html":{},"interfaces/RefreshOptions.html":{},"interfaces/RequestMetadataCallback.html":{},"interfaces/RequestMetadataResponse.html":{},"interfaces/RevokeCredentialsResult.html":{},"interfaces/SignBlobResponse.html":{},"interfaces/TokenInfo.html":{},"interfaces/TokenInfoRequest.html":{},"interfaces/VerifyIdTokenOptions.html":{}}}],["failur",{"_index":1970,"title":{},"body":{"license.html":{}}}],["fals",{"_index":370,"title":{},"body":{"interfaces/ADCCallback.html":{},"interfaces/ADCResponse.html":{},"interfaces/BodyResponseCallback.html":{},"interfaces/ComputeOptions.html":{},"interfaces/CredentialCallback.html":{},"classes/DefaultTransporter.html":{},"interfaces/FederatedSignonCertsResponse.html":{},"interfaces/GetAccessTokenCallback.html":{},"interfaces/GetAccessTokenResponse.html":{},"interfaces/GetFederatedSignonCertsCallback.html":{},"interfaces/GetTokenCallback.html":{},"interfaces/GetTokenOptions.html":{},"interfaces/GetTokenResponse.html":{},"interfaces/GoogleAuthOptions.html":{},"classes/IAMAuth.html":{},"classes/JWTAccess.html":{},"interfaces/JWTOptions.html":{},"classes/LoginTicket.html":{},"interfaces/OAuth2ClientOptions.html":{},"interfaces/ProjectIdCallback.html":{},"interfaces/RefreshAccessTokenCallback.html":{},"interfaces/RefreshAccessTokenResponse.html":{},"interfaces/RefreshOptions.html":{},"interfaces/RequestError.html":{},"interfaces/RequestMetadata.html":{},"interfaces/RequestMetadataCallback.html":{},"interfaces/RequestMetadataResponse.html":{},"interfaces/RevokeCredentialsResult.html":{},"interfaces/SignBlobResponse.html":{},"interfaces/TokenInfo.html":{},"interfaces/TokenInfoRequest.html":{},"interfaces/TokenPayload.html":{},"interfaces/Transporter.html":{},"interfaces/VerifyIdTokenOptions.html":{}}}],["famili",{"_index":1379,"title":{},"body":{"classes/LoginTicket.html":{},"interfaces/TokenPayload.html":{}}}],["family_nam",{"_index":1380,"title":{},"body":{"classes/LoginTicket.html":{},"interfaces/TokenPayload.html":{}}}],["far",{"_index":1165,"title":{},"body":{"interfaces/FederatedSignonCertsResponse.html":{},"interfaces/GetAccessTokenCallback.html":{},"interfaces/GetAccessTokenResponse.html":{},"interfaces/GetFederatedSignonCertsCallback.html":{},"interfaces/GetTokenCallback.html":{},"interfaces/GetTokenOptions.html":{},"interfaces/GetTokenResponse.html":{},"interfaces/OAuth2ClientOptions.html":{},"interfaces/RefreshAccessTokenCallback.html":{},"interfaces/RefreshAccessTokenResponse.html":{},"interfaces/RefreshOptions.html":{},"interfaces/RequestMetadataCallback.html":{},"interfaces/RequestMetadataResponse.html":{},"interfaces/RevokeCredentialsResult.html":{},"interfaces/TokenInfo.html":{},"interfaces/TokenInfoRequest.html":{},"interfaces/VerifyIdTokenOptions.html":{}}}],["featur",{"_index":1557,"title":{},"body":{"changelog.html":{},"index.html":{}}}],["feder",{"_index":1155,"title":{},"body":{"interfaces/FederatedSignonCertsResponse.html":{},"interfaces/GetAccessTokenCallback.html":{},"interfaces/GetAccessTokenResponse.html":{},"interfaces/GetFederatedSignonCertsCallback.html":{},"interfaces/GetTokenCallback.html":{},"interfaces/GetTokenOptions.html":{},"interfaces/GetTokenResponse.html":{},"interfaces/OAuth2ClientOptions.html":{},"interfaces/RefreshAccessTokenCallback.html":{},"interfaces/RefreshAccessTokenResponse.html":{},"interfaces/RefreshOptions.html":{},"interfaces/RequestMetadataCallback.html":{},"interfaces/RequestMetadataResponse.html":{},"interfaces/RevokeCredentialsResult.html":{},"interfaces/TokenInfo.html":{},"interfaces/TokenInfoRequest.html":{},"interfaces/VerifyIdTokenOptions.html":{}}}],["federatedsignoncertsrespons",{"_index":686,"title":{"interfaces/FederatedSignonCertsResponse.html":{}},"body":{"interfaces/FederatedSignonCertsResponse.html":{},"interfaces/GetAccessTokenCallback.html":{},"interfaces/GetAccessTokenResponse.html":{},"interfaces/GetFederatedSignonCertsCallback.html":{},"interfaces/GetTokenCallback.html":{},"interfaces/GetTokenOptions.html":{},"interfaces/GetTokenResponse.html":{},"interfaces/OAuth2ClientOptions.html":{},"interfaces/RefreshAccessTokenCallback.html":{},"interfaces/RefreshAccessTokenResponse.html":{},"interfaces/RefreshOptions.html":{},"interfaces/RequestMetadataCallback.html":{},"interfaces/RequestMetadataResponse.html":{},"interfaces/RevokeCredentialsResult.html":{},"interfaces/TokenInfo.html":{},"interfaces/TokenInfoRequest.html":{},"interfaces/VerifyIdTokenOptions.html":{}}}],["fee",{"_index":1975,"title":{},"body":{"license.html":{}}}],["few",{"_index":989,"title":{},"body":{"interfaces/FederatedSignonCertsResponse.html":{},"interfaces/GetAccessTokenCallback.html":{},"interfaces/GetAccessTokenResponse.html":{},"interfaces/GetFederatedSignonCertsCallback.html":{},"interfaces/GetTokenCallback.html":{},"interfaces/GetTokenOptions.html":{},"interfaces/GetTokenResponse.html":{},"interfaces/OAuth2ClientOptions.html":{},"interfaces/RefreshAccessTokenCallback.html":{},"interfaces/RefreshAccessTokenResponse.html":{},"interfaces/RefreshOptions.html":{},"interfaces/RequestMetadataCallback.html":{},"interfaces/RequestMetadataResponse.html":{},"interfaces/RevokeCredentialsResult.html":{},"interfaces/TokenInfo.html":{},"interfaces/TokenInfoRequest.html":{},"interfaces/VerifyIdTokenOptions.html":{}}}],["field",{"_index":715,"title":{},"body":{"interfaces/FederatedSignonCertsResponse.html":{},"interfaces/GetAccessTokenCallback.html":{},"interfaces/GetAccessTokenResponse.html":{},"interfaces/GetFederatedSignonCertsCallback.html":{},"interfaces/GetTokenCallback.html":{},"interfaces/GetTokenOptions.html":{},"interfaces/GetTokenResponse.html":{},"classes/JWTAccess.html":{},"interfaces/JWTOptions.html":{},"interfaces/OAuth2ClientOptions.html":{},"interfaces/RefreshAccessTokenCallback.html":{},"interfaces/RefreshAccessTokenResponse.html":{},"interfaces/RefreshOptions.html":{},"interfaces/RequestMetadataCallback.html":{},"interfaces/RequestMetadataResponse.html":{},"interfaces/RevokeCredentialsResult.html":{},"interfaces/TokenInfo.html":{},"interfaces/TokenInfoRequest.html":{},"interfaces/UserRefreshClientOptions.html":{},"interfaces/VerifyIdTokenOptions.html":{},"license.html":{}}}],["fifti",{"_index":1838,"title":{},"body":{"license.html":{}}}],["figur",{"_index":264,"title":{},"body":{"interfaces/ADCCallback.html":{},"interfaces/ADCResponse.html":{},"interfaces/CredentialCallback.html":{},"interfaces/GoogleAuthOptions.html":{},"interfaces/ProjectIdCallback.html":{},"interfaces/SignBlobResponse.html":{}}}],["file",{"_index":4,"title":{},"body":{"interfaces/ADCCallback.html":{},"interfaces/ADCResponse.html":{},"interfaces/BodyResponseCallback.html":{},"interfaces/ComputeOptions.html":{},"interfaces/CredentialBody.html":{},"interfaces/CredentialCallback.html":{},"interfaces/CredentialRequest.html":{},"interfaces/Credentials.html":{},"classes/DefaultTransporter.html":{},"interfaces/FederatedSignonCertsResponse.html":{},"interfaces/GetAccessTokenCallback.html":{},"interfaces/GetAccessTokenResponse.html":{},"interfaces/GetFederatedSignonCertsCallback.html":{},"interfaces/GetTokenCallback.html":{},"interfaces/GetTokenOptions.html":{},"interfaces/GetTokenResponse.html":{},"interfaces/GoogleAuthOptions.html":{},"classes/IAMAuth.html":{},"classes/JWTAccess.html":{},"interfaces/JWTInput.html":{},"interfaces/JWTOptions.html":{},"classes/LoginTicket.html":{},"interfaces/OAuth2ClientOptions.html":{},"classes/PemVerifier.html":{},"interfaces/ProjectIdCallback.html":{},"interfaces/RefreshAccessTokenCallback.html":{},"interfaces/RefreshAccessTokenResponse.html":{},"interfaces/RefreshOptions.html":{},"interfaces/RequestError.html":{},"interfaces/RequestMetadata.html":{},"interfaces/RequestMetadataCallback.html":{},"interfaces/RequestMetadataResponse.html":{},"interfaces/RevokeCredentialsResult.html":{},"interfaces/SignBlobResponse.html":{},"interfaces/TokenInfo.html":{},"interfaces/TokenInfoRequest.html":{},"interfaces/TokenPayload.html":{},"interfaces/Transporter.html":{},"interfaces/UserRefreshClientOptions.html":{},"interfaces/VerifyIdTokenOptions.html":{},"interfaces/Warning.html":{},"changelog.html":{},"miscellaneous/functions.html":{},"index.html":{},"license.html":{}}}],["filepath",{"_index":288,"title":{},"body":{"interfaces/ADCCallback.html":{},"interfaces/ADCResponse.html":{},"interfaces/CredentialCallback.html":{},"interfaces/GoogleAuthOptions.html":{},"interfaces/ProjectIdCallback.html":{},"interfaces/SignBlobResponse.html":{}}}],["filepath.length",{"_index":292,"title":{},"body":{"interfaces/ADCCallback.html":{},"interfaces/ADCResponse.html":{},"interfaces/CredentialCallback.html":{},"interfaces/GoogleAuthOptions.html":{},"interfaces/ProjectIdCallback.html":{},"interfaces/SignBlobResponse.html":{}}}],["find",{"_index":236,"title":{},"body":{"interfaces/ADCCallback.html":{},"interfaces/ADCResponse.html":{},"interfaces/CredentialCallback.html":{},"interfaces/FederatedSignonCertsResponse.html":{},"interfaces/GetAccessTokenCallback.html":{},"interfaces/GetAccessTokenResponse.html":{},"interfaces/GetFederatedSignonCertsCallback.html":{},"interfaces/GetTokenCallback.html":{},"interfaces/GetTokenOptions.html":{},"interfaces/GetTokenResponse.html":{},"interfaces/GoogleAuthOptions.html":{},"interfaces/OAuth2ClientOptions.html":{},"interfaces/ProjectIdCallback.html":{},"interfaces/RefreshAccessTokenCallback.html":{},"interfaces/RefreshAccessTokenResponse.html":{},"interfaces/RefreshOptions.html":{},"interfaces/RequestMetadataCallback.html":{},"interfaces/RequestMetadataResponse.html":{},"interfaces/RevokeCredentialsResult.html":{},"interfaces/SignBlobResponse.html":{},"interfaces/TokenInfo.html":{},"interfaces/TokenInfoRequest.html":{},"interfaces/VerifyIdTokenOptions.html":{},"index.html":{}}}],["first",{"_index":263,"title":{},"body":{"interfaces/ADCCallback.html":{},"interfaces/ADCResponse.html":{},"interfaces/ComputeOptions.html":{},"interfaces/CredentialCallback.html":{},"interfaces/FederatedSignonCertsResponse.html":{},"interfaces/GetAccessTokenCallback.html":{},"interfaces/GetAccessTokenResponse.html":{},"interfaces/GetFederatedSignonCertsCallback.html":{},"interfaces/GetTokenCallback.html":{},"interfaces/GetTokenOptions.html":{},"interfaces/GetTokenResponse.html":{},"interfaces/GoogleAuthOptions.html":{},"interfaces/OAuth2ClientOptions.html":{},"interfaces/ProjectIdCallback.html":{},"interfaces/RefreshAccessTokenCallback.html":{},"interfaces/RefreshAccessTokenResponse.html":{},"interfaces/RefreshOptions.html":{},"interfaces/RequestMetadataCallback.html":{},"interfaces/RequestMetadataResponse.html":{},"interfaces/RevokeCredentialsResult.html":{},"interfaces/SignBlobResponse.html":{},"interfaces/TokenInfo.html":{},"interfaces/TokenInfoRequest.html":{},"interfaces/VerifyIdTokenOptions.html":{},"index.html":{}}}],["fit",{"_index":1950,"title":{},"body":{"license.html":{}}}],["five",{"_index":944,"title":{},"body":{"interfaces/FederatedSignonCertsResponse.html":{},"interfaces/GetAccessTokenCallback.html":{},"interfaces/GetAccessTokenResponse.html":{},"interfaces/GetFederatedSignonCertsCallback.html":{},"interfaces/GetTokenCallback.html":{},"interfaces/GetTokenOptions.html":{},"interfaces/GetTokenResponse.html":{},"interfaces/OAuth2ClientOptions.html":{},"interfaces/RefreshAccessTokenCallback.html":{},"interfaces/RefreshAccessTokenResponse.html":{},"interfaces/RefreshOptions.html":{},"interfaces/RequestMetadataCallback.html":{},"interfaces/RequestMetadataResponse.html":{},"interfaces/RevokeCredentialsResult.html":{},"interfaces/TokenInfo.html":{},"interfaces/TokenInfoRequest.html":{},"interfaces/VerifyIdTokenOptions.html":{}}}],["fix",{"_index":1459,"title":{},"body":{"changelog.html":{},"index.html":{}}}],["flow",{"_index":705,"title":{},"body":{"interfaces/FederatedSignonCertsResponse.html":{},"interfaces/GetAccessTokenCallback.html":{},"interfaces/GetAccessTokenResponse.html":{},"interfaces/GetFederatedSignonCertsCallback.html":{},"interfaces/GetTokenCallback.html":{},"interfaces/GetTokenOptions.html":{},"interfaces/GetTokenResponse.html":{},"classes/LoginTicket.html":{},"interfaces/OAuth2ClientOptions.html":{},"interfaces/RefreshAccessTokenCallback.html":{},"interfaces/RefreshAccessTokenResponse.html":{},"interfaces/RefreshOptions.html":{},"interfaces/RequestMetadataCallback.html":{},"interfaces/RequestMetadataResponse.html":{},"interfaces/RevokeCredentialsResult.html":{},"interfaces/TokenInfo.html":{},"interfaces/TokenInfoRequest.html":{},"interfaces/TokenPayload.html":{},"interfaces/VerifyIdTokenOptions.html":{}}}],["fn",{"_index":1002,"title":{},"body":{"interfaces/FederatedSignonCertsResponse.html":{},"interfaces/GetAccessTokenCallback.html":{},"interfaces/GetAccessTokenResponse.html":{},"interfaces/GetFederatedSignonCertsCallback.html":{},"interfaces/GetTokenCallback.html":{},"interfaces/GetTokenOptions.html":{},"interfaces/GetTokenResponse.html":{},"interfaces/OAuth2ClientOptions.html":{},"interfaces/RefreshAccessTokenCallback.html":{},"interfaces/RefreshAccessTokenResponse.html":{},"interfaces/RefreshOptions.html":{},"interfaces/RequestMetadataCallback.html":{},"interfaces/RequestMetadataResponse.html":{},"interfaces/RevokeCredentialsResult.html":{},"interfaces/TokenInfo.html":{},"interfaces/TokenInfoRequest.html":{},"interfaces/VerifyIdTokenOptions.html":{}}}],["follow",{"_index":1108,"title":{},"body":{"interfaces/FederatedSignonCertsResponse.html":{},"interfaces/GetAccessTokenCallback.html":{},"interfaces/GetAccessTokenResponse.html":{},"interfaces/GetFederatedSignonCertsCallback.html":{},"interfaces/GetTokenCallback.html":{},"interfaces/GetTokenOptions.html":{},"interfaces/GetTokenResponse.html":{},"classes/LoginTicket.html":{},"interfaces/OAuth2ClientOptions.html":{},"interfaces/RefreshAccessTokenCallback.html":{},"interfaces/RefreshAccessTokenResponse.html":{},"interfaces/RefreshOptions.html":{},"interfaces/RequestMetadataCallback.html":{},"interfaces/RequestMetadataResponse.html":{},"interfaces/RevokeCredentialsResult.html":{},"interfaces/TokenInfo.html":{},"interfaces/TokenInfoRequest.html":{},"interfaces/TokenPayload.html":{},"interfaces/VerifyIdTokenOptions.html":{},"index.html":{},"license.html":{}}}],["forbidden",{"_index":630,"title":{},"body":{"interfaces/ComputeOptions.html":{}}}],["forc",{"_index":1764,"title":{},"body":{"index.html":{}}}],["forgeri",{"_index":832,"title":{},"body":{"interfaces/FederatedSignonCertsResponse.html":{},"interfaces/GetAccessTokenCallback.html":{},"interfaces/GetAccessTokenResponse.html":{},"interfaces/GetFederatedSignonCertsCallback.html":{},"interfaces/GetTokenCallback.html":{},"interfaces/GetTokenOptions.html":{},"interfaces/GetTokenResponse.html":{},"classes/LoginTicket.html":{},"interfaces/OAuth2ClientOptions.html":{},"interfaces/RefreshAccessTokenCallback.html":{},"interfaces/RefreshAccessTokenResponse.html":{},"interfaces/RefreshOptions.html":{},"interfaces/RequestMetadataCallback.html":{},"interfaces/RequestMetadataResponse.html":{},"interfaces/RevokeCredentialsResult.html":{},"interfaces/TokenInfo.html":{},"interfaces/TokenInfoRequest.html":{},"interfaces/TokenPayload.html":{},"interfaces/VerifyIdTokenOptions.html":{}}}],["form",{"_index":861,"title":{},"body":{"interfaces/FederatedSignonCertsResponse.html":{},"interfaces/GetAccessTokenCallback.html":{},"interfaces/GetAccessTokenResponse.html":{},"interfaces/GetFederatedSignonCertsCallback.html":{},"interfaces/GetTokenCallback.html":{},"interfaces/GetTokenOptions.html":{},"interfaces/GetTokenResponse.html":{},"interfaces/JWTOptions.html":{},"classes/LoginTicket.html":{},"interfaces/OAuth2ClientOptions.html":{},"interfaces/RefreshAccessTokenCallback.html":{},"interfaces/RefreshAccessTokenResponse.html":{},"interfaces/RefreshOptions.html":{},"interfaces/RequestMetadataCallback.html":{},"interfaces/RequestMetadataResponse.html":{},"interfaces/RevokeCredentialsResult.html":{},"interfaces/TokenInfo.html":{},"interfaces/TokenInfoRequest.html":{},"interfaces/TokenPayload.html":{},"interfaces/VerifyIdTokenOptions.html":{},"index.html":{},"license.html":{}}}],["format",{"_index":172,"title":{},"body":{"interfaces/ADCCallback.html":{},"interfaces/ADCResponse.html":{},"interfaces/CredentialCallback.html":{},"interfaces/GoogleAuthOptions.html":{},"interfaces/ProjectIdCallback.html":{},"interfaces/SignBlobResponse.html":{},"changelog.html":{},"license.html":{}}}],["found",{"_index":276,"title":{},"body":{"interfaces/ADCCallback.html":{},"interfaces/ADCResponse.html":{},"interfaces/ComputeOptions.html":{},"interfaces/CredentialCallback.html":{},"interfaces/GoogleAuthOptions.html":{},"interfaces/ProjectIdCallback.html":{},"interfaces/SignBlobResponse.html":{},"index.html":{}}}],["fragment",{"_index":821,"title":{},"body":{"interfaces/FederatedSignonCertsResponse.html":{},"interfaces/GetAccessTokenCallback.html":{},"interfaces/GetAccessTokenResponse.html":{},"interfaces/GetFederatedSignonCertsCallback.html":{},"interfaces/GetTokenCallback.html":{},"interfaces/GetTokenOptions.html":{},"interfaces/GetTokenResponse.html":{},"interfaces/OAuth2ClientOptions.html":{},"interfaces/RefreshAccessTokenCallback.html":{},"interfaces/RefreshAccessTokenResponse.html":{},"interfaces/RefreshOptions.html":{},"interfaces/RequestMetadataCallback.html":{},"interfaces/RequestMetadataResponse.html":{},"interfaces/RevokeCredentialsResult.html":{},"interfaces/TokenInfo.html":{},"interfaces/TokenInfoRequest.html":{},"interfaces/VerifyIdTokenOptions.html":{}}}],["free",{"_index":1888,"title":{},"body":{"license.html":{}}}],["fromapikey(apikey",{"_index":356,"title":{},"body":{"interfaces/ADCCallback.html":{},"interfaces/ADCResponse.html":{},"interfaces/CredentialCallback.html":{},"interfaces/GoogleAuthOptions.html":{},"interfaces/JWTOptions.html":{},"interfaces/ProjectIdCallback.html":{},"interfaces/SignBlobResponse.html":{}}}],["fromjson",{"_index":1220,"title":{},"body":{"classes/JWTAccess.html":{}}}],["fromjson(json",{"_index":328,"title":{},"body":{"interfaces/ADCCallback.html":{},"interfaces/ADCResponse.html":{},"interfaces/CredentialCallback.html":{},"interfaces/GoogleAuthOptions.html":{},"classes/JWTAccess.html":{},"interfaces/JWTOptions.html":{},"interfaces/ProjectIdCallback.html":{},"interfaces/SignBlobResponse.html":{},"interfaces/UserRefreshClientOptions.html":{}}}],["fromstream",{"_index":340,"title":{},"body":{"interfaces/ADCCallback.html":{},"interfaces/ADCResponse.html":{},"interfaces/CredentialCallback.html":{},"interfaces/GoogleAuthOptions.html":{},"classes/JWTAccess.html":{},"interfaces/JWTOptions.html":{},"interfaces/ProjectIdCallback.html":{},"interfaces/SignBlobResponse.html":{}}}],["fromstream(inputstream",{"_index":338,"title":{},"body":{"interfaces/ADCCallback.html":{},"interfaces/ADCResponse.html":{},"interfaces/CredentialCallback.html":{},"interfaces/GoogleAuthOptions.html":{},"classes/JWTAccess.html":{},"interfaces/JWTOptions.html":{},"interfaces/ProjectIdCallback.html":{},"interfaces/SignBlobResponse.html":{},"interfaces/UserRefreshClientOptions.html":{}}}],["fromstreamasync",{"_index":344,"title":{},"body":{"interfaces/ADCCallback.html":{},"interfaces/ADCResponse.html":{},"interfaces/CredentialCallback.html":{},"interfaces/GoogleAuthOptions.html":{},"interfaces/ProjectIdCallback.html":{},"interfaces/SignBlobResponse.html":{}}}],["fromstreamasync(inputstream",{"_index":1279,"title":{},"body":{"classes/JWTAccess.html":{},"interfaces/JWTOptions.html":{},"interfaces/UserRefreshClientOptions.html":{}}}],["fs",{"_index":27,"title":{},"body":{"interfaces/ADCCallback.html":{},"interfaces/ADCResponse.html":{},"interfaces/CredentialCallback.html":{},"interfaces/GoogleAuthOptions.html":{},"interfaces/ProjectIdCallback.html":{},"interfaces/SignBlobResponse.html":{}}}],["fs.createreadstream(filepath",{"_index":374,"title":{},"body":{"interfaces/ADCCallback.html":{},"interfaces/ADCResponse.html":{},"interfaces/CredentialCallback.html":{},"interfaces/GoogleAuthOptions.html":{},"interfaces/ProjectIdCallback.html":{},"interfaces/SignBlobResponse.html":{}}}],["fs.existssync(filepath",{"_index":380,"title":{},"body":{"interfaces/ADCCallback.html":{},"interfaces/ADCResponse.html":{},"interfaces/CredentialCallback.html":{},"interfaces/GoogleAuthOptions.html":{},"interfaces/ProjectIdCallback.html":{},"interfaces/SignBlobResponse.html":{}}}],["fs.lstatsync(filepath).isfil",{"_index":302,"title":{},"body":{"interfaces/ADCCallback.html":{},"interfaces/ADCResponse.html":{},"interfaces/CredentialCallback.html":{},"interfaces/GoogleAuthOptions.html":{},"interfaces/ProjectIdCallback.html":{},"interfaces/SignBlobResponse.html":{}}}],["fs.realpathsync(filepath",{"_index":301,"title":{},"body":{"interfaces/ADCCallback.html":{},"interfaces/ADCResponse.html":{},"interfaces/CredentialCallback.html":{},"interfaces/GoogleAuthOptions.html":{},"interfaces/ProjectIdCallback.html":{},"interfaces/SignBlobResponse.html":{}}}],["full",{"_index":803,"title":{},"body":{"interfaces/FederatedSignonCertsResponse.html":{},"interfaces/GetAccessTokenCallback.html":{},"interfaces/GetAccessTokenResponse.html":{},"interfaces/GetFederatedSignonCertsCallback.html":{},"interfaces/GetTokenCallback.html":{},"interfaces/GetTokenOptions.html":{},"interfaces/GetTokenResponse.html":{},"classes/LoginTicket.html":{},"interfaces/OAuth2ClientOptions.html":{},"interfaces/RefreshAccessTokenCallback.html":{},"interfaces/RefreshAccessTokenResponse.html":{},"interfaces/RefreshOptions.html":{},"interfaces/RequestMetadataCallback.html":{},"interfaces/RequestMetadataResponse.html":{},"interfaces/RevokeCredentialsResult.html":{},"interfaces/TokenInfo.html":{},"interfaces/TokenInfoRequest.html":{},"interfaces/TokenPayload.html":{},"interfaces/VerifyIdTokenOptions.html":{},"index.html":{}}}],["func",{"_index":1059,"title":{},"body":{"interfaces/FederatedSignonCertsResponse.html":{},"interfaces/GetAccessTokenCallback.html":{},"interfaces/GetAccessTokenResponse.html":{},"interfaces/GetFederatedSignonCertsCallback.html":{},"interfaces/GetTokenCallback.html":{},"interfaces/GetTokenOptions.html":{},"interfaces/GetTokenResponse.html":{},"interfaces/OAuth2ClientOptions.html":{},"interfaces/RefreshAccessTokenCallback.html":{},"interfaces/RefreshAccessTokenResponse.html":{},"interfaces/RefreshOptions.html":{},"interfaces/RequestMetadataCallback.html":{},"interfaces/RequestMetadataResponse.html":{},"interfaces/RevokeCredentialsResult.html":{},"interfaces/TokenInfo.html":{},"interfaces/TokenInfoRequest.html":{},"interfaces/VerifyIdTokenOptions.html":{}}}],["function",{"_index":200,"title":{"miscellaneous/functions.html":{}},"body":{"interfaces/ADCCallback.html":{},"interfaces/ADCResponse.html":{},"interfaces/CredentialCallback.html":{},"interfaces/FederatedSignonCertsResponse.html":{},"interfaces/GetAccessTokenCallback.html":{},"interfaces/GetAccessTokenResponse.html":{},"interfaces/GetFederatedSignonCertsCallback.html":{},"interfaces/GetTokenCallback.html":{},"interfaces/GetTokenOptions.html":{},"interfaces/GetTokenResponse.html":{},"interfaces/GoogleAuthOptions.html":{},"classes/IAMAuth.html":{},"classes/JWTAccess.html":{},"interfaces/OAuth2ClientOptions.html":{},"interfaces/ProjectIdCallback.html":{},"interfaces/RefreshAccessTokenCallback.html":{},"interfaces/RefreshAccessTokenResponse.html":{},"interfaces/RefreshOptions.html":{},"interfaces/RequestMetadataCallback.html":{},"interfaces/RequestMetadataResponse.html":{},"interfaces/RevokeCredentialsResult.html":{},"interfaces/SignBlobResponse.html":{},"interfaces/TokenInfo.html":{},"interfaces/TokenInfoRequest.html":{},"interfaces/UserRefreshClientOptions.html":{},"interfaces/VerifyIdTokenOptions.html":{},"interfaces/Warning.html":{},"miscellaneous/functions.html":{},"index.html":{}}}],["futur",{"_index":1166,"title":{},"body":{"interfaces/FederatedSignonCertsResponse.html":{},"interfaces/GetAccessTokenCallback.html":{},"interfaces/GetAccessTokenResponse.html":{},"interfaces/GetFederatedSignonCertsCallback.html":{},"interfaces/GetTokenCallback.html":{},"interfaces/GetTokenOptions.html":{},"interfaces/GetTokenResponse.html":{},"interfaces/OAuth2ClientOptions.html":{},"interfaces/RefreshAccessTokenCallback.html":{},"interfaces/RefreshAccessTokenResponse.html":{},"interfaces/RefreshOptions.html":{},"interfaces/RequestMetadataCallback.html":{},"interfaces/RequestMetadataResponse.html":{},"interfaces/RevokeCredentialsResult.html":{},"interfaces/TokenInfo.html":{},"interfaces/TokenInfoRequest.html":{},"interfaces/UserRefreshClientOptions.html":{},"interfaces/VerifyIdTokenOptions.html":{}}}],["g",{"_index":761,"title":{},"body":{"interfaces/FederatedSignonCertsResponse.html":{},"interfaces/GetAccessTokenCallback.html":{},"interfaces/GetAccessTokenResponse.html":{},"interfaces/GetFederatedSignonCertsCallback.html":{},"interfaces/GetTokenCallback.html":{},"interfaces/GetTokenOptions.html":{},"interfaces/GetTokenResponse.html":{},"classes/LoginTicket.html":{},"interfaces/OAuth2ClientOptions.html":{},"interfaces/RefreshAccessTokenCallback.html":{},"interfaces/RefreshAccessTokenResponse.html":{},"interfaces/RefreshOptions.html":{},"interfaces/RequestMetadataCallback.html":{},"interfaces/RequestMetadataResponse.html":{},"interfaces/RevokeCredentialsResult.html":{},"interfaces/TokenInfo.html":{},"interfaces/TokenInfoRequest.html":{},"interfaces/TokenPayload.html":{},"interfaces/VerifyIdTokenOptions.html":{}}}],["gce",{"_index":173,"title":{},"body":{"interfaces/ADCCallback.html":{},"interfaces/ADCResponse.html":{},"interfaces/CredentialCallback.html":{},"interfaces/GoogleAuthOptions.html":{},"interfaces/ProjectIdCallback.html":{},"interfaces/SignBlobResponse.html":{}}}],["gcf",{"_index":428,"title":{},"body":{"interfaces/ADCCallback.html":{},"interfaces/ADCResponse.html":{},"interfaces/CredentialCallback.html":{},"interfaces/GoogleAuthOptions.html":{},"interfaces/ProjectIdCallback.html":{},"interfaces/SignBlobResponse.html":{}}}],["gcloud",{"_index":169,"title":{},"body":{"interfaces/ADCCallback.html":{},"interfaces/ADCResponse.html":{},"interfaces/CredentialCallback.html":{},"interfaces/GoogleAuthOptions.html":{},"interfaces/ProjectIdCallback.html":{},"interfaces/SignBlobResponse.html":{}}}],["gcloud_project",{"_index":163,"title":{},"body":{"interfaces/ADCCallback.html":{},"interfaces/ADCResponse.html":{},"interfaces/CredentialCallback.html":{},"interfaces/GoogleAuthOptions.html":{},"interfaces/ProjectIdCallback.html":{},"interfaces/SignBlobResponse.html":{}}}],["gcp",{"_index":29,"title":{},"body":{"interfaces/ADCCallback.html":{},"interfaces/ADCResponse.html":{},"interfaces/ComputeOptions.html":{},"interfaces/CredentialCallback.html":{},"interfaces/GoogleAuthOptions.html":{},"interfaces/ProjectIdCallback.html":{},"interfaces/SignBlobResponse.html":{},"changelog.html":{},"dependencies.html":{}}}],["gcpenv",{"_index":43,"title":{},"body":{"interfaces/ADCCallback.html":{},"interfaces/ADCResponse.html":{},"interfaces/CredentialCallback.html":{},"interfaces/GoogleAuthOptions.html":{},"interfaces/ProjectIdCallback.html":{},"interfaces/SignBlobResponse.html":{},"miscellaneous/enumerations.html":{},"miscellaneous/variables.html":{}}}],["gcpmetadata",{"_index":28,"title":{},"body":{"interfaces/ADCCallback.html":{},"interfaces/ADCResponse.html":{},"interfaces/ComputeOptions.html":{},"interfaces/CredentialCallback.html":{},"interfaces/GoogleAuthOptions.html":{},"interfaces/ProjectIdCallback.html":{},"interfaces/SignBlobResponse.html":{}}}],["gcpmetadata.inst",{"_index":431,"title":{},"body":{"interfaces/ADCCallback.html":{},"interfaces/ADCResponse.html":{},"interfaces/CredentialCallback.html":{},"interfaces/GoogleAuthOptions.html":{},"interfaces/ProjectIdCallback.html":{},"interfaces/SignBlobResponse.html":{}}}],["gcpmetadata.instance(tokenpath",{"_index":615,"title":{},"body":{"interfaces/ComputeOptions.html":{}}}],["gcpmetadata.isavail",{"_index":250,"title":{},"body":{"interfaces/ADCCallback.html":{},"interfaces/ADCResponse.html":{},"interfaces/CredentialCallback.html":{},"interfaces/GoogleAuthOptions.html":{},"interfaces/ProjectIdCallback.html":{},"interfaces/SignBlobResponse.html":{}}}],["gcpmetadata.project('project",{"_index":411,"title":{},"body":{"interfaces/ADCCallback.html":{},"interfaces/ADCResponse.html":{},"interfaces/CredentialCallback.html":{},"interfaces/GoogleAuthOptions.html":{},"interfaces/ProjectIdCallback.html":{},"interfaces/SignBlobResponse.html":{}}}],["gener",{"_index":768,"title":{},"body":{"interfaces/FederatedSignonCertsResponse.html":{},"interfaces/GetAccessTokenCallback.html":{},"interfaces/GetAccessTokenResponse.html":{},"interfaces/GetFederatedSignonCertsCallback.html":{},"interfaces/GetTokenCallback.html":{},"interfaces/GetTokenOptions.html":{},"interfaces/GetTokenResponse.html":{},"interfaces/OAuth2ClientOptions.html":{},"interfaces/RefreshAccessTokenCallback.html":{},"interfaces/RefreshAccessTokenResponse.html":{},"interfaces/RefreshOptions.html":{},"interfaces/RequestMetadataCallback.html":{},"interfaces/RequestMetadataResponse.html":{},"interfaces/RevokeCredentialsResult.html":{},"interfaces/TokenInfo.html":{},"interfaces/TokenInfoRequest.html":{},"interfaces/VerifyIdTokenOptions.html":{},"index.html":{},"license.html":{}}}],["generate128",{"_index":977,"title":{},"body":{"interfaces/FederatedSignonCertsResponse.html":{},"interfaces/GetAccessTokenCallback.html":{},"interfaces/GetAccessTokenResponse.html":{},"interfaces/GetFederatedSignonCertsCallback.html":{},"interfaces/GetTokenCallback.html":{},"interfaces/GetTokenOptions.html":{},"interfaces/GetTokenResponse.html":{},"interfaces/OAuth2ClientOptions.html":{},"interfaces/RefreshAccessTokenCallback.html":{},"interfaces/RefreshAccessTokenResponse.html":{},"interfaces/RefreshOptions.html":{},"interfaces/RequestMetadataCallback.html":{},"interfaces/RequestMetadataResponse.html":{},"interfaces/RevokeCredentialsResult.html":{},"interfaces/TokenInfo.html":{},"interfaces/TokenInfoRequest.html":{},"interfaces/VerifyIdTokenOptions.html":{}}}],["generateauthurl",{"_index":702,"title":{},"body":{"interfaces/FederatedSignonCertsResponse.html":{},"interfaces/GetAccessTokenCallback.html":{},"interfaces/GetAccessTokenResponse.html":{},"interfaces/GetFederatedSignonCertsCallback.html":{},"interfaces/GetTokenCallback.html":{},"interfaces/GetTokenOptions.html":{},"interfaces/GetTokenResponse.html":{},"interfaces/OAuth2ClientOptions.html":{},"interfaces/RefreshAccessTokenCallback.html":{},"interfaces/RefreshAccessTokenResponse.html":{},"interfaces/RefreshOptions.html":{},"interfaces/RequestMetadataCallback.html":{},"interfaces/RequestMetadataResponse.html":{},"interfaces/RevokeCredentialsResult.html":{},"interfaces/TokenInfo.html":{},"interfaces/TokenInfoRequest.html":{},"interfaces/VerifyIdTokenOptions.html":{},"index.html":{}}}],["generateauthurl(opt",{"_index":959,"title":{},"body":{"interfaces/FederatedSignonCertsResponse.html":{},"interfaces/GetAccessTokenCallback.html":{},"interfaces/GetAccessTokenResponse.html":{},"interfaces/GetFederatedSignonCertsCallback.html":{},"interfaces/GetTokenCallback.html":{},"interfaces/GetTokenOptions.html":{},"interfaces/GetTokenResponse.html":{},"interfaces/OAuth2ClientOptions.html":{},"interfaces/RefreshAccessTokenCallback.html":{},"interfaces/RefreshAccessTokenResponse.html":{},"interfaces/RefreshOptions.html":{},"interfaces/RequestMetadataCallback.html":{},"interfaces/RequestMetadataResponse.html":{},"interfaces/RevokeCredentialsResult.html":{},"interfaces/TokenInfo.html":{},"interfaces/TokenInfoRequest.html":{},"interfaces/VerifyIdTokenOptions.html":{}}}],["generateauthurlopt",{"_index":753,"title":{},"body":{"interfaces/FederatedSignonCertsResponse.html":{},"interfaces/GetAccessTokenCallback.html":{},"interfaces/GetAccessTokenResponse.html":{},"interfaces/GetFederatedSignonCertsCallback.html":{},"interfaces/GetTokenCallback.html":{},"interfaces/GetTokenOptions.html":{},"interfaces/GetTokenResponse.html":{},"interfaces/OAuth2ClientOptions.html":{},"interfaces/RefreshAccessTokenCallback.html":{},"interfaces/RefreshAccessTokenResponse.html":{},"interfaces/RefreshOptions.html":{},"interfaces/RequestMetadataCallback.html":{},"interfaces/RequestMetadataResponse.html":{},"interfaces/RevokeCredentialsResult.html":{},"interfaces/TokenInfo.html":{},"interfaces/TokenInfoRequest.html":{},"interfaces/VerifyIdTokenOptions.html":{}}}],["generatecodeverifi",{"_index":971,"title":{},"body":{"interfaces/FederatedSignonCertsResponse.html":{},"interfaces/GetAccessTokenCallback.html":{},"interfaces/GetAccessTokenResponse.html":{},"interfaces/GetFederatedSignonCertsCallback.html":{},"interfaces/GetTokenCallback.html":{},"interfaces/GetTokenOptions.html":{},"interfaces/GetTokenResponse.html":{},"interfaces/OAuth2ClientOptions.html":{},"interfaces/RefreshAccessTokenCallback.html":{},"interfaces/RefreshAccessTokenResponse.html":{},"interfaces/RefreshOptions.html":{},"interfaces/RequestMetadataCallback.html":{},"interfaces/RequestMetadataResponse.html":{},"interfaces/RevokeCredentialsResult.html":{},"interfaces/TokenInfo.html":{},"interfaces/TokenInfoRequest.html":{},"interfaces/VerifyIdTokenOptions.html":{}}}],["get",{"_index":375,"title":{"changelog.html":{},"index.html":{},"license.html":{}},"body":{"interfaces/ADCCallback.html":{},"interfaces/ADCResponse.html":{},"interfaces/CredentialCallback.html":{},"interfaces/FederatedSignonCertsResponse.html":{},"interfaces/GetAccessTokenCallback.html":{},"interfaces/GetAccessTokenResponse.html":{},"interfaces/GetFederatedSignonCertsCallback.html":{},"interfaces/GetTokenCallback.html":{},"interfaces/GetTokenOptions.html":{},"interfaces/GetTokenResponse.html":{},"interfaces/GoogleAuthOptions.html":{},"interfaces/OAuth2ClientOptions.html":{},"interfaces/ProjectIdCallback.html":{},"interfaces/RefreshAccessTokenCallback.html":{},"interfaces/RefreshAccessTokenResponse.html":{},"interfaces/RefreshOptions.html":{},"interfaces/RequestMetadataCallback.html":{},"interfaces/RequestMetadataResponse.html":{},"interfaces/RevokeCredentialsResult.html":{},"interfaces/SignBlobResponse.html":{},"interfaces/TokenInfo.html":{},"interfaces/TokenInfoRequest.html":{},"interfaces/VerifyIdTokenOptions.html":{}}}],["getaccesstoken",{"_index":451,"title":{},"body":{"interfaces/ADCCallback.html":{},"interfaces/ADCResponse.html":{},"interfaces/CredentialCallback.html":{},"interfaces/FederatedSignonCertsResponse.html":{},"interfaces/GetAccessTokenCallback.html":{},"interfaces/GetAccessTokenResponse.html":{},"interfaces/GetFederatedSignonCertsCallback.html":{},"interfaces/GetTokenCallback.html":{},"interfaces/GetTokenOptions.html":{},"interfaces/GetTokenResponse.html":{},"interfaces/GoogleAuthOptions.html":{},"interfaces/OAuth2ClientOptions.html":{},"interfaces/ProjectIdCallback.html":{},"interfaces/RefreshAccessTokenCallback.html":{},"interfaces/RefreshAccessTokenResponse.html":{},"interfaces/RefreshOptions.html":{},"interfaces/RequestMetadataCallback.html":{},"interfaces/RequestMetadataResponse.html":{},"interfaces/RevokeCredentialsResult.html":{},"interfaces/SignBlobResponse.html":{},"interfaces/TokenInfo.html":{},"interfaces/TokenInfoRequest.html":{},"interfaces/VerifyIdTokenOptions.html":{},"changelog.html":{}}}],["getaccesstoken(callback",{"_index":1049,"title":{},"body":{"interfaces/FederatedSignonCertsResponse.html":{},"interfaces/GetAccessTokenCallback.html":{},"interfaces/GetAccessTokenResponse.html":{},"interfaces/GetFederatedSignonCertsCallback.html":{},"interfaces/GetTokenCallback.html":{},"interfaces/GetTokenOptions.html":{},"interfaces/GetTokenResponse.html":{},"interfaces/OAuth2ClientOptions.html":{},"interfaces/RefreshAccessTokenCallback.html":{},"interfaces/RefreshAccessTokenResponse.html":{},"interfaces/RefreshOptions.html":{},"interfaces/RequestMetadataCallback.html":{},"interfaces/RequestMetadataResponse.html":{},"interfaces/RevokeCredentialsResult.html":{},"interfaces/TokenInfo.html":{},"interfaces/TokenInfoRequest.html":{},"interfaces/VerifyIdTokenOptions.html":{}}}],["getaccesstokenasync",{"_index":1052,"title":{},"body":{"interfaces/FederatedSignonCertsResponse.html":{},"interfaces/GetAccessTokenCallback.html":{},"interfaces/GetAccessTokenResponse.html":{},"interfaces/GetFederatedSignonCertsCallback.html":{},"interfaces/GetTokenCallback.html":{},"interfaces/GetTokenOptions.html":{},"interfaces/GetTokenResponse.html":{},"interfaces/OAuth2ClientOptions.html":{},"interfaces/RefreshAccessTokenCallback.html":{},"interfaces/RefreshAccessTokenResponse.html":{},"interfaces/RefreshOptions.html":{},"interfaces/RequestMetadataCallback.html":{},"interfaces/RequestMetadataResponse.html":{},"interfaces/RevokeCredentialsResult.html":{},"interfaces/TokenInfo.html":{},"interfaces/TokenInfoRequest.html":{},"interfaces/VerifyIdTokenOptions.html":{}}}],["getaccesstokencallback",{"_index":881,"title":{"interfaces/GetAccessTokenCallback.html":{}},"body":{"interfaces/FederatedSignonCertsResponse.html":{},"interfaces/GetAccessTokenCallback.html":{},"interfaces/GetAccessTokenResponse.html":{},"interfaces/GetFederatedSignonCertsCallback.html":{},"interfaces/GetTokenCallback.html":{},"interfaces/GetTokenOptions.html":{},"interfaces/GetTokenResponse.html":{},"interfaces/OAuth2ClientOptions.html":{},"interfaces/RefreshAccessTokenCallback.html":{},"interfaces/RefreshAccessTokenResponse.html":{},"interfaces/RefreshOptions.html":{},"interfaces/RequestMetadataCallback.html":{},"interfaces/RequestMetadataResponse.html":{},"interfaces/RevokeCredentialsResult.html":{},"interfaces/TokenInfo.html":{},"interfaces/TokenInfoRequest.html":{},"interfaces/VerifyIdTokenOptions.html":{}}}],["getaccesstokenrespons",{"_index":882,"title":{"interfaces/GetAccessTokenResponse.html":{}},"body":{"interfaces/FederatedSignonCertsResponse.html":{},"interfaces/GetAccessTokenCallback.html":{},"interfaces/GetAccessTokenResponse.html":{},"interfaces/GetFederatedSignonCertsCallback.html":{},"interfaces/GetTokenCallback.html":{},"interfaces/GetTokenOptions.html":{},"interfaces/GetTokenResponse.html":{},"interfaces/OAuth2ClientOptions.html":{},"interfaces/RefreshAccessTokenCallback.html":{},"interfaces/RefreshAccessTokenResponse.html":{},"interfaces/RefreshOptions.html":{},"interfaces/RequestMetadataCallback.html":{},"interfaces/RequestMetadataResponse.html":{},"interfaces/RevokeCredentialsResult.html":{},"interfaces/TokenInfo.html":{},"interfaces/TokenInfoRequest.html":{},"interfaces/VerifyIdTokenOptions.html":{}}}],["getapplicationdefault",{"_index":192,"title":{},"body":{"interfaces/ADCCallback.html":{},"interfaces/ADCResponse.html":{},"interfaces/CredentialCallback.html":{},"interfaces/GoogleAuthOptions.html":{},"interfaces/ProjectIdCallback.html":{},"interfaces/SignBlobResponse.html":{}}}],["getapplicationdefault(callback",{"_index":193,"title":{},"body":{"interfaces/ADCCallback.html":{},"interfaces/ADCResponse.html":{},"interfaces/CredentialCallback.html":{},"interfaces/GoogleAuthOptions.html":{},"interfaces/ProjectIdCallback.html":{},"interfaces/SignBlobResponse.html":{}}}],["getapplicationdefault(opt",{"_index":194,"title":{},"body":{"interfaces/ADCCallback.html":{},"interfaces/ADCResponse.html":{},"interfaces/CredentialCallback.html":{},"interfaces/GoogleAuthOptions.html":{},"interfaces/ProjectIdCallback.html":{},"interfaces/SignBlobResponse.html":{}}}],["getapplicationdefaultasync(opt",{"_index":207,"title":{},"body":{"interfaces/ADCCallback.html":{},"interfaces/ADCResponse.html":{},"interfaces/CredentialCallback.html":{},"interfaces/GoogleAuthOptions.html":{},"interfaces/ProjectIdCallback.html":{},"interfaces/SignBlobResponse.html":{}}}],["getattribut",{"_index":1341,"title":{},"body":{"classes/LoginTicket.html":{},"interfaces/TokenPayload.html":{}}}],["getauthenticatedcli",{"_index":1714,"title":{},"body":{"index.html":{}}}],["getclient(opt",{"_index":440,"title":{},"body":{"interfaces/ADCCallback.html":{},"interfaces/ADCResponse.html":{},"interfaces/CredentialCallback.html":{},"interfaces/GoogleAuthOptions.html":{},"interfaces/ProjectIdCallback.html":{},"interfaces/SignBlobResponse.html":{}}}],["getcredenti",{"_index":414,"title":{},"body":{"interfaces/ADCCallback.html":{},"interfaces/ADCResponse.html":{},"interfaces/CredentialCallback.html":{},"interfaces/GoogleAuthOptions.html":{},"interfaces/JWTOptions.html":{},"interfaces/ProjectIdCallback.html":{},"interfaces/SignBlobResponse.html":{}}}],["getcredentialsasync",{"_index":419,"title":{},"body":{"interfaces/ADCCallback.html":{},"interfaces/ADCResponse.html":{},"interfaces/CredentialCallback.html":{},"interfaces/GoogleAuthOptions.html":{},"interfaces/ProjectIdCallback.html":{},"interfaces/SignBlobResponse.html":{}}}],["getdefaultprojectid",{"_index":137,"title":{},"body":{"interfaces/ADCCallback.html":{},"interfaces/ADCResponse.html":{},"interfaces/CredentialCallback.html":{},"interfaces/GoogleAuthOptions.html":{},"interfaces/ProjectIdCallback.html":{},"interfaces/SignBlobResponse.html":{},"interfaces/Warning.html":{},"changelog.html":{},"miscellaneous/variables.html":{}}}],["getdefaultprojectid(callback",{"_index":138,"title":{},"body":{"interfaces/ADCCallback.html":{},"interfaces/ADCResponse.html":{},"interfaces/CredentialCallback.html":{},"interfaces/GoogleAuthOptions.html":{},"interfaces/ProjectIdCallback.html":{},"interfaces/SignBlobResponse.html":{}}}],["getdefaultserviceprojectid",{"_index":397,"title":{},"body":{"interfaces/ADCCallback.html":{},"interfaces/ADCResponse.html":{},"interfaces/CredentialCallback.html":{},"interfaces/GoogleAuthOptions.html":{},"interfaces/ProjectIdCallback.html":{},"interfaces/SignBlobResponse.html":{}}}],["getenv",{"_index":44,"title":{},"body":{"interfaces/ADCCallback.html":{},"interfaces/ADCResponse.html":{},"interfaces/CredentialCallback.html":{},"interfaces/GoogleAuthOptions.html":{},"interfaces/ProjectIdCallback.html":{},"interfaces/SignBlobResponse.html":{},"miscellaneous/functions.html":{}}}],["getenvelop",{"_index":1342,"title":{},"body":{"classes/LoginTicket.html":{},"interfaces/TokenPayload.html":{}}}],["getfederatedsignoncert",{"_index":1158,"title":{},"body":{"interfaces/FederatedSignonCertsResponse.html":{},"interfaces/GetAccessTokenCallback.html":{},"interfaces/GetAccessTokenResponse.html":{},"interfaces/GetFederatedSignonCertsCallback.html":{},"interfaces/GetTokenCallback.html":{},"interfaces/GetTokenOptions.html":{},"interfaces/GetTokenResponse.html":{},"interfaces/OAuth2ClientOptions.html":{},"interfaces/RefreshAccessTokenCallback.html":{},"interfaces/RefreshAccessTokenResponse.html":{},"interfaces/RefreshOptions.html":{},"interfaces/RequestMetadataCallback.html":{},"interfaces/RequestMetadataResponse.html":{},"interfaces/RevokeCredentialsResult.html":{},"interfaces/TokenInfo.html":{},"interfaces/TokenInfoRequest.html":{},"interfaces/VerifyIdTokenOptions.html":{}}}],["getfederatedsignoncerts(callback",{"_index":1159,"title":{},"body":{"interfaces/FederatedSignonCertsResponse.html":{},"interfaces/GetAccessTokenCallback.html":{},"interfaces/GetAccessTokenResponse.html":{},"interfaces/GetFederatedSignonCertsCallback.html":{},"interfaces/GetTokenCallback.html":{},"interfaces/GetTokenOptions.html":{},"interfaces/GetTokenResponse.html":{},"interfaces/OAuth2ClientOptions.html":{},"interfaces/RefreshAccessTokenCallback.html":{},"interfaces/RefreshAccessTokenResponse.html":{},"interfaces/RefreshOptions.html":{},"interfaces/RequestMetadataCallback.html":{},"interfaces/RequestMetadataResponse.html":{},"interfaces/RevokeCredentialsResult.html":{},"interfaces/TokenInfo.html":{},"interfaces/TokenInfoRequest.html":{},"interfaces/VerifyIdTokenOptions.html":{}}}],["getfederatedsignoncertsasync",{"_index":1162,"title":{},"body":{"interfaces/FederatedSignonCertsResponse.html":{},"interfaces/GetAccessTokenCallback.html":{},"interfaces/GetAccessTokenResponse.html":{},"interfaces/GetFederatedSignonCertsCallback.html":{},"interfaces/GetTokenCallback.html":{},"interfaces/GetTokenOptions.html":{},"interfaces/GetTokenResponse.html":{},"interfaces/OAuth2ClientOptions.html":{},"interfaces/RefreshAccessTokenCallback.html":{},"interfaces/RefreshAccessTokenResponse.html":{},"interfaces/RefreshOptions.html":{},"interfaces/RequestMetadataCallback.html":{},"interfaces/RequestMetadataResponse.html":{},"interfaces/RevokeCredentialsResult.html":{},"interfaces/TokenInfo.html":{},"interfaces/TokenInfoRequest.html":{},"interfaces/VerifyIdTokenOptions.html":{}}}],["getfederatedsignoncertscallback",{"_index":887,"title":{"interfaces/GetFederatedSignonCertsCallback.html":{}},"body":{"interfaces/FederatedSignonCertsResponse.html":{},"interfaces/GetAccessTokenCallback.html":{},"interfaces/GetAccessTokenResponse.html":{},"interfaces/GetFederatedSignonCertsCallback.html":{},"interfaces/GetTokenCallback.html":{},"interfaces/GetTokenOptions.html":{},"interfaces/GetTokenResponse.html":{},"interfaces/OAuth2ClientOptions.html":{},"interfaces/RefreshAccessTokenCallback.html":{},"interfaces/RefreshAccessTokenResponse.html":{},"interfaces/RefreshOptions.html":{},"interfaces/RequestMetadataCallback.html":{},"interfaces/RequestMetadataResponse.html":{},"interfaces/RevokeCredentialsResult.html":{},"interfaces/TokenInfo.html":{},"interfaces/TokenInfoRequest.html":{},"interfaces/VerifyIdTokenOptions.html":{}}}],["getfileprojectid",{"_index":407,"title":{},"body":{"interfaces/ADCCallback.html":{},"interfaces/ADCResponse.html":{},"interfaces/CredentialCallback.html":{},"interfaces/GoogleAuthOptions.html":{},"interfaces/ProjectIdCallback.html":{},"interfaces/SignBlobResponse.html":{}}}],["getgceprojectid",{"_index":410,"title":{},"body":{"interfaces/ADCCallback.html":{},"interfaces/ADCResponse.html":{},"interfaces/CredentialCallback.html":{},"interfaces/GoogleAuthOptions.html":{},"interfaces/ProjectIdCallback.html":{},"interfaces/SignBlobResponse.html":{}}}],["getpayload",{"_index":1343,"title":{},"body":{"classes/LoginTicket.html":{},"interfaces/TokenPayload.html":{}}}],["getproductionprojectid",{"_index":404,"title":{},"body":{"interfaces/ADCCallback.html":{},"interfaces/ADCResponse.html":{},"interfaces/CredentialCallback.html":{},"interfaces/GoogleAuthOptions.html":{},"interfaces/ProjectIdCallback.html":{},"interfaces/SignBlobResponse.html":{}}}],["getprojectid",{"_index":135,"title":{},"body":{"interfaces/ADCCallback.html":{},"interfaces/ADCResponse.html":{},"interfaces/CredentialCallback.html":{},"interfaces/GoogleAuthOptions.html":{},"interfaces/ProjectIdCallback.html":{},"interfaces/SignBlobResponse.html":{},"interfaces/Warning.html":{},"miscellaneous/variables.html":{}}}],["getprojectid(callback",{"_index":153,"title":{},"body":{"interfaces/ADCCallback.html":{},"interfaces/ADCResponse.html":{},"interfaces/CredentialCallback.html":{},"interfaces/GoogleAuthOptions.html":{},"interfaces/ProjectIdCallback.html":{},"interfaces/SignBlobResponse.html":{}}}],["getprojectidasync",{"_index":154,"title":{},"body":{"interfaces/ADCCallback.html":{},"interfaces/ADCResponse.html":{},"interfaces/CredentialCallback.html":{},"interfaces/GoogleAuthOptions.html":{},"interfaces/ProjectIdCallback.html":{},"interfaces/SignBlobResponse.html":{}}}],["getrequesthead",{"_index":1036,"title":{},"body":{"interfaces/FederatedSignonCertsResponse.html":{},"interfaces/GetAccessTokenCallback.html":{},"interfaces/GetAccessTokenResponse.html":{},"interfaces/GetFederatedSignonCertsCallback.html":{},"interfaces/GetTokenCallback.html":{},"interfaces/GetTokenOptions.html":{},"interfaces/GetTokenResponse.html":{},"classes/IAMAuth.html":{},"classes/JWTAccess.html":{},"interfaces/OAuth2ClientOptions.html":{},"interfaces/RefreshAccessTokenCallback.html":{},"interfaces/RefreshAccessTokenResponse.html":{},"interfaces/RefreshOptions.html":{},"interfaces/RequestMetadata.html":{},"interfaces/RequestMetadataCallback.html":{},"interfaces/RequestMetadataResponse.html":{},"interfaces/RevokeCredentialsResult.html":{},"interfaces/TokenInfo.html":{},"interfaces/TokenInfoRequest.html":{},"interfaces/VerifyIdTokenOptions.html":{},"interfaces/Warning.html":{},"changelog.html":{},"miscellaneous/variables.html":{}}}],["getrequestheaders(url",{"_index":455,"title":{},"body":{"interfaces/ADCCallback.html":{},"interfaces/ADCResponse.html":{},"interfaces/CredentialCallback.html":{},"interfaces/FederatedSignonCertsResponse.html":{},"interfaces/GetAccessTokenCallback.html":{},"interfaces/GetAccessTokenResponse.html":{},"interfaces/GetFederatedSignonCertsCallback.html":{},"interfaces/GetTokenCallback.html":{},"interfaces/GetTokenOptions.html":{},"interfaces/GetTokenResponse.html":{},"interfaces/GoogleAuthOptions.html":{},"classes/JWTAccess.html":{},"interfaces/OAuth2ClientOptions.html":{},"interfaces/ProjectIdCallback.html":{},"interfaces/RefreshAccessTokenCallback.html":{},"interfaces/RefreshAccessTokenResponse.html":{},"interfaces/RefreshOptions.html":{},"interfaces/RequestMetadataCallback.html":{},"interfaces/RequestMetadataResponse.html":{},"interfaces/RevokeCredentialsResult.html":{},"interfaces/SignBlobResponse.html":{},"interfaces/TokenInfo.html":{},"interfaces/TokenInfoRequest.html":{},"interfaces/VerifyIdTokenOptions.html":{}}}],["getrequestmetadata",{"_index":1193,"title":{},"body":{"classes/IAMAuth.html":{},"classes/JWTAccess.html":{},"interfaces/RequestMetadata.html":{},"interfaces/Warning.html":{},"changelog.html":{},"miscellaneous/variables.html":{}}}],["getrequestmetadata(unuseduri",{"_index":1202,"title":{},"body":{"classes/IAMAuth.html":{}}}],["getrequestmetadata(url",{"_index":1060,"title":{},"body":{"interfaces/FederatedSignonCertsResponse.html":{},"interfaces/GetAccessTokenCallback.html":{},"interfaces/GetAccessTokenResponse.html":{},"interfaces/GetFederatedSignonCertsCallback.html":{},"interfaces/GetTokenCallback.html":{},"interfaces/GetTokenOptions.html":{},"interfaces/GetTokenResponse.html":{},"classes/JWTAccess.html":{},"interfaces/OAuth2ClientOptions.html":{},"interfaces/RefreshAccessTokenCallback.html":{},"interfaces/RefreshAccessTokenResponse.html":{},"interfaces/RefreshOptions.html":{},"interfaces/RequestMetadataCallback.html":{},"interfaces/RequestMetadataResponse.html":{},"interfaces/RevokeCredentialsResult.html":{},"interfaces/TokenInfo.html":{},"interfaces/TokenInfoRequest.html":{},"interfaces/VerifyIdTokenOptions.html":{}}}],["getrequestmetadataasync(url",{"_index":1069,"title":{},"body":{"interfaces/FederatedSignonCertsResponse.html":{},"interfaces/GetAccessTokenCallback.html":{},"interfaces/GetAccessTokenResponse.html":{},"interfaces/GetFederatedSignonCertsCallback.html":{},"interfaces/GetTokenCallback.html":{},"interfaces/GetTokenOptions.html":{},"interfaces/GetTokenResponse.html":{},"interfaces/JWTOptions.html":{},"interfaces/OAuth2ClientOptions.html":{},"interfaces/RefreshAccessTokenCallback.html":{},"interfaces/RefreshAccessTokenResponse.html":{},"interfaces/RefreshOptions.html":{},"interfaces/RequestMetadataCallback.html":{},"interfaces/RequestMetadataResponse.html":{},"interfaces/RevokeCredentialsResult.html":{},"interfaces/TokenInfo.html":{},"interfaces/TokenInfoRequest.html":{},"interfaces/VerifyIdTokenOptions.html":{}}}],["gettoken(cod",{"_index":1003,"title":{},"body":{"interfaces/FederatedSignonCertsResponse.html":{},"interfaces/GetAccessTokenCallback.html":{},"interfaces/GetAccessTokenResponse.html":{},"interfaces/GetFederatedSignonCertsCallback.html":{},"interfaces/GetTokenCallback.html":{},"interfaces/GetTokenOptions.html":{},"interfaces/GetTokenResponse.html":{},"interfaces/OAuth2ClientOptions.html":{},"interfaces/RefreshAccessTokenCallback.html":{},"interfaces/RefreshAccessTokenResponse.html":{},"interfaces/RefreshOptions.html":{},"interfaces/RequestMetadataCallback.html":{},"interfaces/RequestMetadataResponse.html":{},"interfaces/RevokeCredentialsResult.html":{},"interfaces/TokenInfo.html":{},"interfaces/TokenInfoRequest.html":{},"interfaces/VerifyIdTokenOptions.html":{}}}],["gettoken(codeoropt",{"_index":1005,"title":{},"body":{"interfaces/FederatedSignonCertsResponse.html":{},"interfaces/GetAccessTokenCallback.html":{},"interfaces/GetAccessTokenResponse.html":{},"interfaces/GetFederatedSignonCertsCallback.html":{},"interfaces/GetTokenCallback.html":{},"interfaces/GetTokenOptions.html":{},"interfaces/GetTokenResponse.html":{},"interfaces/OAuth2ClientOptions.html":{},"interfaces/RefreshAccessTokenCallback.html":{},"interfaces/RefreshAccessTokenResponse.html":{},"interfaces/RefreshOptions.html":{},"interfaces/RequestMetadataCallback.html":{},"interfaces/RequestMetadataResponse.html":{},"interfaces/RevokeCredentialsResult.html":{},"interfaces/TokenInfo.html":{},"interfaces/TokenInfoRequest.html":{},"interfaces/VerifyIdTokenOptions.html":{}}}],["gettoken(opt",{"_index":1004,"title":{},"body":{"interfaces/FederatedSignonCertsResponse.html":{},"interfaces/GetAccessTokenCallback.html":{},"interfaces/GetAccessTokenResponse.html":{},"interfaces/GetFederatedSignonCertsCallback.html":{},"interfaces/GetTokenCallback.html":{},"interfaces/GetTokenOptions.html":{},"interfaces/GetTokenResponse.html":{},"interfaces/OAuth2ClientOptions.html":{},"interfaces/RefreshAccessTokenCallback.html":{},"interfaces/RefreshAccessTokenResponse.html":{},"interfaces/RefreshOptions.html":{},"interfaces/RequestMetadataCallback.html":{},"interfaces/RequestMetadataResponse.html":{},"interfaces/RevokeCredentialsResult.html":{},"interfaces/TokenInfo.html":{},"interfaces/TokenInfoRequest.html":{},"interfaces/VerifyIdTokenOptions.html":{}}}],["gettokenasync(opt",{"_index":1012,"title":{},"body":{"interfaces/FederatedSignonCertsResponse.html":{},"interfaces/GetAccessTokenCallback.html":{},"interfaces/GetAccessTokenResponse.html":{},"interfaces/GetFederatedSignonCertsCallback.html":{},"interfaces/GetTokenCallback.html":{},"interfaces/GetTokenOptions.html":{},"interfaces/GetTokenResponse.html":{},"interfaces/OAuth2ClientOptions.html":{},"interfaces/RefreshAccessTokenCallback.html":{},"interfaces/RefreshAccessTokenResponse.html":{},"interfaces/RefreshOptions.html":{},"interfaces/RequestMetadataCallback.html":{},"interfaces/RequestMetadataResponse.html":{},"interfaces/RevokeCredentialsResult.html":{},"interfaces/TokenInfo.html":{},"interfaces/TokenInfoRequest.html":{},"interfaces/VerifyIdTokenOptions.html":{}}}],["gettokencallback",{"_index":878,"title":{"interfaces/GetTokenCallback.html":{}},"body":{"interfaces/FederatedSignonCertsResponse.html":{},"interfaces/GetAccessTokenCallback.html":{},"interfaces/GetAccessTokenResponse.html":{},"interfaces/GetFederatedSignonCertsCallback.html":{},"interfaces/GetTokenCallback.html":{},"interfaces/GetTokenOptions.html":{},"interfaces/GetTokenResponse.html":{},"interfaces/OAuth2ClientOptions.html":{},"interfaces/RefreshAccessTokenCallback.html":{},"interfaces/RefreshAccessTokenResponse.html":{},"interfaces/RefreshOptions.html":{},"interfaces/RequestMetadataCallback.html":{},"interfaces/RequestMetadataResponse.html":{},"interfaces/RevokeCredentialsResult.html":{},"interfaces/TokenInfo.html":{},"interfaces/TokenInfoRequest.html":{},"interfaces/VerifyIdTokenOptions.html":{}}}],["gettokeninfo",{"_index":1771,"title":{},"body":{"index.html":{}}}],["gettokeninfo(accesstoken",{"_index":1148,"title":{},"body":{"interfaces/FederatedSignonCertsResponse.html":{},"interfaces/GetAccessTokenCallback.html":{},"interfaces/GetAccessTokenResponse.html":{},"interfaces/GetFederatedSignonCertsCallback.html":{},"interfaces/GetTokenCallback.html":{},"interfaces/GetTokenOptions.html":{},"interfaces/GetTokenResponse.html":{},"interfaces/OAuth2ClientOptions.html":{},"interfaces/RefreshAccessTokenCallback.html":{},"interfaces/RefreshAccessTokenResponse.html":{},"interfaces/RefreshOptions.html":{},"interfaces/RequestMetadataCallback.html":{},"interfaces/RequestMetadataResponse.html":{},"interfaces/RevokeCredentialsResult.html":{},"interfaces/TokenInfo.html":{},"interfaces/TokenInfoRequest.html":{},"interfaces/VerifyIdTokenOptions.html":{}}}],["gettokenopt",{"_index":698,"title":{"interfaces/GetTokenOptions.html":{}},"body":{"interfaces/FederatedSignonCertsResponse.html":{},"interfaces/GetAccessTokenCallback.html":{},"interfaces/GetAccessTokenResponse.html":{},"interfaces/GetFederatedSignonCertsCallback.html":{},"interfaces/GetTokenCallback.html":{},"interfaces/GetTokenOptions.html":{},"interfaces/GetTokenResponse.html":{},"interfaces/OAuth2ClientOptions.html":{},"interfaces/RefreshAccessTokenCallback.html":{},"interfaces/RefreshAccessTokenResponse.html":{},"interfaces/RefreshOptions.html":{},"interfaces/RequestMetadataCallback.html":{},"interfaces/RequestMetadataResponse.html":{},"interfaces/RevokeCredentialsResult.html":{},"interfaces/TokenInfo.html":{},"interfaces/TokenInfoRequest.html":{},"interfaces/VerifyIdTokenOptions.html":{}}}],["gettokenrespons",{"_index":585,"title":{"interfaces/GetTokenResponse.html":{}},"body":{"interfaces/ComputeOptions.html":{},"interfaces/FederatedSignonCertsResponse.html":{},"interfaces/GetAccessTokenCallback.html":{},"interfaces/GetAccessTokenResponse.html":{},"interfaces/GetFederatedSignonCertsCallback.html":{},"interfaces/GetTokenCallback.html":{},"interfaces/GetTokenOptions.html":{},"interfaces/GetTokenResponse.html":{},"interfaces/JWTOptions.html":{},"interfaces/OAuth2ClientOptions.html":{},"interfaces/RefreshAccessTokenCallback.html":{},"interfaces/RefreshAccessTokenResponse.html":{},"interfaces/RefreshOptions.html":{},"interfaces/RequestMetadataCallback.html":{},"interfaces/RequestMetadataResponse.html":{},"interfaces/RevokeCredentialsResult.html":{},"interfaces/TokenInfo.html":{},"interfaces/TokenInfoRequest.html":{},"interfaces/UserRefreshClientOptions.html":{},"interfaces/VerifyIdTokenOptions.html":{}}}],["gettokenresponse|nul",{"_index":1075,"title":{},"body":{"interfaces/FederatedSignonCertsResponse.html":{},"interfaces/GetAccessTokenCallback.html":{},"interfaces/GetAccessTokenResponse.html":{},"interfaces/GetFederatedSignonCertsCallback.html":{},"interfaces/GetTokenCallback.html":{},"interfaces/GetTokenOptions.html":{},"interfaces/GetTokenResponse.html":{},"interfaces/OAuth2ClientOptions.html":{},"interfaces/RefreshAccessTokenCallback.html":{},"interfaces/RefreshAccessTokenResponse.html":{},"interfaces/RefreshOptions.html":{},"interfaces/RequestMetadataCallback.html":{},"interfaces/RequestMetadataResponse.html":{},"interfaces/RevokeCredentialsResult.html":{},"interfaces/TokenInfo.html":{},"interfaces/TokenInfoRequest.html":{},"interfaces/VerifyIdTokenOptions.html":{}}}],["getuserid",{"_index":1344,"title":{},"body":{"classes/LoginTicket.html":{},"interfaces/TokenPayload.html":{}}}],["gh",{"_index":1474,"title":{},"body":{"changelog.html":{}}}],["github",{"_index":1814,"title":{},"body":{"index.html":{}}}],["give",{"_index":1915,"title":{},"body":{"license.html":{}}}],["given",{"_index":287,"title":{},"body":{"interfaces/ADCCallback.html":{},"interfaces/ADCResponse.html":{},"interfaces/BodyResponseCallback.html":{},"interfaces/CredentialCallback.html":{},"classes/DefaultTransporter.html":{},"interfaces/FederatedSignonCertsResponse.html":{},"interfaces/GetAccessTokenCallback.html":{},"interfaces/GetAccessTokenResponse.html":{},"interfaces/GetFederatedSignonCertsCallback.html":{},"interfaces/GetTokenCallback.html":{},"interfaces/GetTokenOptions.html":{},"interfaces/GetTokenResponse.html":{},"interfaces/GoogleAuthOptions.html":{},"classes/JWTAccess.html":{},"interfaces/JWTOptions.html":{},"classes/LoginTicket.html":{},"interfaces/OAuth2ClientOptions.html":{},"interfaces/ProjectIdCallback.html":{},"interfaces/RefreshAccessTokenCallback.html":{},"interfaces/RefreshAccessTokenResponse.html":{},"interfaces/RefreshOptions.html":{},"interfaces/RequestError.html":{},"interfaces/RequestMetadataCallback.html":{},"interfaces/RequestMetadataResponse.html":{},"interfaces/RevokeCredentialsResult.html":{},"interfaces/SignBlobResponse.html":{},"interfaces/TokenInfo.html":{},"interfaces/TokenInfoRequest.html":{},"interfaces/TokenPayload.html":{},"interfaces/Transporter.html":{},"interfaces/UserRefreshClientOptions.html":{},"interfaces/VerifyIdTokenOptions.html":{},"interfaces/Warning.html":{}}}],["given_nam",{"_index":1378,"title":{},"body":{"classes/LoginTicket.html":{},"interfaces/TokenPayload.html":{}}}],["go",{"_index":473,"title":{},"body":{"interfaces/ADCCallback.html":{},"interfaces/ADCResponse.html":{},"interfaces/CredentialCallback.html":{},"interfaces/GoogleAuthOptions.html":{},"interfaces/ProjectIdCallback.html":{},"interfaces/SignBlobResponse.html":{},"index.html":{}}}],["goodwil",{"_index":1968,"title":{},"body":{"license.html":{}}}],["goog",{"_index":1201,"title":{},"body":{"classes/IAMAuth.html":{},"interfaces/RequestMetadata.html":{}}}],["googl",{"_index":93,"title":{},"body":{"interfaces/ADCCallback.html":{},"interfaces/ADCResponse.html":{},"interfaces/BodyResponseCallback.html":{},"interfaces/ComputeOptions.html":{},"interfaces/CredentialCallback.html":{},"interfaces/Credentials.html":{},"classes/DefaultTransporter.html":{},"interfaces/FederatedSignonCertsResponse.html":{},"interfaces/GetAccessTokenCallback.html":{},"interfaces/GetAccessTokenResponse.html":{},"interfaces/GetFederatedSignonCertsCallback.html":{},"interfaces/GetTokenCallback.html":{},"interfaces/GetTokenOptions.html":{},"interfaces/GetTokenResponse.html":{},"interfaces/GoogleAuthOptions.html":{},"classes/LoginTicket.html":{},"interfaces/OAuth2ClientOptions.html":{},"interfaces/ProjectIdCallback.html":{},"interfaces/RefreshAccessTokenCallback.html":{},"interfaces/RefreshAccessTokenResponse.html":{},"interfaces/RefreshOptions.html":{},"interfaces/RequestError.html":{},"interfaces/RequestMetadataCallback.html":{},"interfaces/RequestMetadataResponse.html":{},"interfaces/RevokeCredentialsResult.html":{},"interfaces/SignBlobResponse.html":{},"interfaces/TokenInfo.html":{},"interfaces/TokenInfoRequest.html":{},"interfaces/TokenPayload.html":{},"interfaces/Transporter.html":{},"interfaces/VerifyIdTokenOptions.html":{},"interfaces/Warning.html":{},"changelog.html":{},"miscellaneous/functions.html":{},"index.html":{},"miscellaneous/variables.html":{}}}],["google'",{"_index":1664,"title":{},"body":{"index.html":{}}}],["google_application_credenti",{"_index":166,"title":{},"body":{"interfaces/ADCCallback.html":{},"interfaces/ADCResponse.html":{},"interfaces/CredentialCallback.html":{},"interfaces/GoogleAuthOptions.html":{},"interfaces/ProjectIdCallback.html":{},"interfaces/SignBlobResponse.html":{},"index.html":{}}}],["google_cloud_project",{"_index":164,"title":{},"body":{"interfaces/ADCCallback.html":{},"interfaces/ADCResponse.html":{},"interfaces/CredentialCallback.html":{},"interfaces/GoogleAuthOptions.html":{},"interfaces/ProjectIdCallback.html":{},"interfaces/SignBlobResponse.html":{}}}],["google_oauth2_auth_base_url_",{"_index":933,"title":{},"body":{"interfaces/FederatedSignonCertsResponse.html":{},"interfaces/GetAccessTokenCallback.html":{},"interfaces/GetAccessTokenResponse.html":{},"interfaces/GetFederatedSignonCertsCallback.html":{},"interfaces/GetTokenCallback.html":{},"interfaces/GetTokenOptions.html":{},"interfaces/GetTokenResponse.html":{},"interfaces/OAuth2ClientOptions.html":{},"interfaces/RefreshAccessTokenCallback.html":{},"interfaces/RefreshAccessTokenResponse.html":{},"interfaces/RefreshOptions.html":{},"interfaces/RequestMetadataCallback.html":{},"interfaces/RequestMetadataResponse.html":{},"interfaces/RevokeCredentialsResult.html":{},"interfaces/TokenInfo.html":{},"interfaces/TokenInfoRequest.html":{},"interfaces/VerifyIdTokenOptions.html":{}}}],["google_oauth2_federated_signon_certs_url_",{"_index":940,"title":{},"body":{"interfaces/FederatedSignonCertsResponse.html":{},"interfaces/GetAccessTokenCallback.html":{},"interfaces/GetAccessTokenResponse.html":{},"interfaces/GetFederatedSignonCertsCallback.html":{},"interfaces/GetTokenCallback.html":{},"interfaces/GetTokenOptions.html":{},"interfaces/GetTokenResponse.html":{},"interfaces/OAuth2ClientOptions.html":{},"interfaces/RefreshAccessTokenCallback.html":{},"interfaces/RefreshAccessTokenResponse.html":{},"interfaces/RefreshOptions.html":{},"interfaces/RequestMetadataCallback.html":{},"interfaces/RequestMetadataResponse.html":{},"interfaces/RevokeCredentialsResult.html":{},"interfaces/TokenInfo.html":{},"interfaces/TokenInfoRequest.html":{},"interfaces/VerifyIdTokenOptions.html":{}}}],["google_oauth2_revoke_url_",{"_index":938,"title":{},"body":{"interfaces/FederatedSignonCertsResponse.html":{},"interfaces/GetAccessTokenCallback.html":{},"interfaces/GetAccessTokenResponse.html":{},"interfaces/GetFederatedSignonCertsCallback.html":{},"interfaces/GetTokenCallback.html":{},"interfaces/GetTokenOptions.html":{},"interfaces/GetTokenResponse.html":{},"interfaces/OAuth2ClientOptions.html":{},"interfaces/RefreshAccessTokenCallback.html":{},"interfaces/RefreshAccessTokenResponse.html":{},"interfaces/RefreshOptions.html":{},"interfaces/RequestMetadataCallback.html":{},"interfaces/RequestMetadataResponse.html":{},"interfaces/RevokeCredentialsResult.html":{},"interfaces/TokenInfo.html":{},"interfaces/TokenInfoRequest.html":{},"interfaces/VerifyIdTokenOptions.html":{}}}],["google_oauth2_token_url_",{"_index":935,"title":{},"body":{"interfaces/FederatedSignonCertsResponse.html":{},"interfaces/GetAccessTokenCallback.html":{},"interfaces/GetAccessTokenResponse.html":{},"interfaces/GetFederatedSignonCertsCallback.html":{},"interfaces/GetTokenCallback.html":{},"interfaces/GetTokenOptions.html":{},"interfaces/GetTokenResponse.html":{},"interfaces/OAuth2ClientOptions.html":{},"interfaces/RefreshAccessTokenCallback.html":{},"interfaces/RefreshAccessTokenResponse.html":{},"interfaces/RefreshOptions.html":{},"interfaces/RequestMetadataCallback.html":{},"interfaces/RequestMetadataResponse.html":{},"interfaces/RevokeCredentialsResult.html":{},"interfaces/TokenInfo.html":{},"interfaces/TokenInfoRequest.html":{},"interfaces/VerifyIdTokenOptions.html":{}}}],["google_token_info_url",{"_index":930,"title":{},"body":{"interfaces/FederatedSignonCertsResponse.html":{},"interfaces/GetAccessTokenCallback.html":{},"interfaces/GetAccessTokenResponse.html":{},"interfaces/GetFederatedSignonCertsCallback.html":{},"interfaces/GetTokenCallback.html":{},"interfaces/GetTokenOptions.html":{},"interfaces/GetTokenResponse.html":{},"interfaces/OAuth2ClientOptions.html":{},"interfaces/RefreshAccessTokenCallback.html":{},"interfaces/RefreshAccessTokenResponse.html":{},"interfaces/RefreshOptions.html":{},"interfaces/RequestMetadataCallback.html":{},"interfaces/RequestMetadataResponse.html":{},"interfaces/RevokeCredentialsResult.html":{},"interfaces/TokenInfo.html":{},"interfaces/TokenInfoRequest.html":{},"interfaces/VerifyIdTokenOptions.html":{}}}],["googleapi",{"_index":523,"title":{},"body":{"interfaces/BodyResponseCallback.html":{},"classes/DefaultTransporter.html":{},"interfaces/RequestError.html":{},"interfaces/Transporter.html":{},"changelog.html":{}}}],["googleauth",{"_index":85,"title":{},"body":{"interfaces/ADCCallback.html":{},"interfaces/ADCResponse.html":{},"interfaces/CredentialCallback.html":{},"interfaces/GoogleAuthOptions.html":{},"interfaces/ProjectIdCallback.html":{},"interfaces/SignBlobResponse.html":{},"miscellaneous/variables.html":{}}}],["googleauth.fromjson",{"_index":1787,"title":{},"body":{"index.html":{}}}],["googleauth.getcli",{"_index":1547,"title":{},"body":{"changelog.html":{}}}],["googleauthopt",{"_index":61,"title":{"interfaces/GoogleAuthOptions.html":{}},"body":{"interfaces/ADCCallback.html":{},"interfaces/ADCResponse.html":{},"interfaces/CredentialCallback.html":{},"interfaces/GoogleAuthOptions.html":{},"interfaces/ProjectIdCallback.html":{},"interfaces/SignBlobResponse.html":{}}}],["googlelogin",{"_index":1126,"title":{},"body":{"interfaces/FederatedSignonCertsResponse.html":{},"interfaces/GetAccessTokenCallback.html":{},"interfaces/GetAccessTokenResponse.html":{},"interfaces/GetFederatedSignonCertsCallback.html":{},"interfaces/GetTokenCallback.html":{},"interfaces/GetTokenOptions.html":{},"interfaces/GetTokenResponse.html":{},"interfaces/OAuth2ClientOptions.html":{},"interfaces/RefreshAccessTokenCallback.html":{},"interfaces/RefreshAccessTokenResponse.html":{},"interfaces/RefreshOptions.html":{},"interfaces/RequestMetadataCallback.html":{},"interfaces/RequestMetadataResponse.html":{},"interfaces/RevokeCredentialsResult.html":{},"interfaces/TokenInfo.html":{},"interfaces/TokenInfoRequest.html":{},"interfaces/VerifyIdTokenOptions.html":{}}}],["googletoken",{"_index":1284,"title":{},"body":{"interfaces/JWTOptions.html":{}}}],["govern",{"_index":677,"title":{},"body":{"interfaces/Credentials.html":{},"classes/LoginTicket.html":{},"miscellaneous/functions.html":{},"license.html":{}}}],["grant",{"_index":726,"title":{},"body":{"interfaces/FederatedSignonCertsResponse.html":{},"interfaces/GetAccessTokenCallback.html":{},"interfaces/GetAccessTokenResponse.html":{},"interfaces/GetFederatedSignonCertsCallback.html":{},"interfaces/GetTokenCallback.html":{},"interfaces/GetTokenOptions.html":{},"interfaces/GetTokenResponse.html":{},"interfaces/OAuth2ClientOptions.html":{},"interfaces/RefreshAccessTokenCallback.html":{},"interfaces/RefreshAccessTokenResponse.html":{},"interfaces/RefreshOptions.html":{},"interfaces/RequestMetadataCallback.html":{},"interfaces/RequestMetadataResponse.html":{},"interfaces/RevokeCredentialsResult.html":{},"interfaces/TokenInfo.html":{},"interfaces/TokenInfoRequest.html":{},"interfaces/VerifyIdTokenOptions.html":{},"license.html":{}}}],["grant_typ",{"_index":1017,"title":{},"body":{"interfaces/FederatedSignonCertsResponse.html":{},"interfaces/GetAccessTokenCallback.html":{},"interfaces/GetAccessTokenResponse.html":{},"interfaces/GetFederatedSignonCertsCallback.html":{},"interfaces/GetTokenCallback.html":{},"interfaces/GetTokenOptions.html":{},"interfaces/GetTokenResponse.html":{},"interfaces/OAuth2ClientOptions.html":{},"interfaces/RefreshAccessTokenCallback.html":{},"interfaces/RefreshAccessTokenResponse.html":{},"interfaces/RefreshOptions.html":{},"interfaces/RequestMetadataCallback.html":{},"interfaces/RequestMetadataResponse.html":{},"interfaces/RevokeCredentialsResult.html":{},"interfaces/TokenInfo.html":{},"interfaces/TokenInfoRequest.html":{},"interfaces/VerifyIdTokenOptions.html":{}}}],["greenkeep",{"_index":1610,"title":{},"body":{"changelog.html":{}}}],["grossli",{"_index":1959,"title":{},"body":{"license.html":{}}}],["gt",{"_index":1400,"title":{},"body":{"interfaces/UserRefreshClientOptions.html":{},"changelog.html":{}}}],["gtoken",{"_index":1285,"title":{},"body":{"interfaces/JWTOptions.html":{},"dependencies.html":{}}}],["gtoken.expiresat",{"_index":1330,"title":{},"body":{"interfaces/JWTOptions.html":{}}}],["gtoken.getcredentials(this.keyfil",{"_index":1336,"title":{},"body":{"interfaces/JWTOptions.html":{}}}],["gtoken.gettoken",{"_index":1329,"title":{},"body":{"interfaces/JWTOptions.html":{}}}],["gtoken.rawtoken",{"_index":1331,"title":{},"body":{"interfaces/JWTOptions.html":{}}}],["guarante",{"_index":1376,"title":{},"body":{"classes/LoginTicket.html":{},"interfaces/TokenPayload.html":{}}}],["guess",{"_index":833,"title":{},"body":{"interfaces/FederatedSignonCertsResponse.html":{},"interfaces/GetAccessTokenCallback.html":{},"interfaces/GetAccessTokenResponse.html":{},"interfaces/GetFederatedSignonCertsCallback.html":{},"interfaces/GetTokenCallback.html":{},"interfaces/GetTokenOptions.html":{},"interfaces/GetTokenResponse.html":{},"interfaces/OAuth2ClientOptions.html":{},"interfaces/RefreshAccessTokenCallback.html":{},"interfaces/RefreshAccessTokenResponse.html":{},"interfaces/RefreshOptions.html":{},"interfaces/RequestMetadataCallback.html":{},"interfaces/RequestMetadataResponse.html":{},"interfaces/RevokeCredentialsResult.html":{},"interfaces/TokenInfo.html":{},"interfaces/TokenInfoRequest.html":{},"interfaces/VerifyIdTokenOptions.html":{}}}],["guid",{"_index":1669,"title":{},"body":{"index.html":{}}}],["handl",{"_index":413,"title":{},"body":{"interfaces/ADCCallback.html":{},"interfaces/ADCResponse.html":{},"interfaces/CredentialCallback.html":{},"interfaces/FederatedSignonCertsResponse.html":{},"interfaces/GetAccessTokenCallback.html":{},"interfaces/GetAccessTokenResponse.html":{},"interfaces/GetFederatedSignonCertsCallback.html":{},"interfaces/GetTokenCallback.html":{},"interfaces/GetTokenOptions.html":{},"interfaces/GetTokenResponse.html":{},"interfaces/GoogleAuthOptions.html":{},"interfaces/OAuth2ClientOptions.html":{},"interfaces/ProjectIdCallback.html":{},"interfaces/RefreshAccessTokenCallback.html":{},"interfaces/RefreshAccessTokenResponse.html":{},"interfaces/RefreshOptions.html":{},"interfaces/RequestMetadataCallback.html":{},"interfaces/RequestMetadataResponse.html":{},"interfaces/RevokeCredentialsResult.html":{},"interfaces/SignBlobResponse.html":{},"interfaces/TokenInfo.html":{},"interfaces/TokenInfoRequest.html":{},"interfaces/VerifyIdTokenOptions.html":{}}}],["happen",{"_index":1116,"title":{},"body":{"interfaces/FederatedSignonCertsResponse.html":{},"interfaces/GetAccessTokenCallback.html":{},"interfaces/GetAccessTokenResponse.html":{},"interfaces/GetFederatedSignonCertsCallback.html":{},"interfaces/GetTokenCallback.html":{},"interfaces/GetTokenOptions.html":{},"interfaces/GetTokenResponse.html":{},"interfaces/OAuth2ClientOptions.html":{},"interfaces/RefreshAccessTokenCallback.html":{},"interfaces/RefreshAccessTokenResponse.html":{},"interfaces/RefreshOptions.html":{},"interfaces/RequestMetadataCallback.html":{},"interfaces/RequestMetadataResponse.html":{},"interfaces/RevokeCredentialsResult.html":{},"interfaces/TokenInfo.html":{},"interfaces/TokenInfoRequest.html":{},"interfaces/VerifyIdTokenOptions.html":{}}}],["hard",{"_index":1404,"title":{},"body":{"interfaces/UserRefreshClientOptions.html":{},"changelog.html":{}}}],["harmless",{"_index":1982,"title":{},"body":{"license.html":{}}}],["hash",{"_index":820,"title":{},"body":{"interfaces/FederatedSignonCertsResponse.html":{},"interfaces/GetAccessTokenCallback.html":{},"interfaces/GetAccessTokenResponse.html":{},"interfaces/GetFederatedSignonCertsCallback.html":{},"interfaces/GetTokenCallback.html":{},"interfaces/GetTokenOptions.html":{},"interfaces/GetTokenResponse.html":{},"classes/LoginTicket.html":{},"interfaces/OAuth2ClientOptions.html":{},"interfaces/RefreshAccessTokenCallback.html":{},"interfaces/RefreshAccessTokenResponse.html":{},"interfaces/RefreshOptions.html":{},"interfaces/RequestMetadataCallback.html":{},"interfaces/RequestMetadataResponse.html":{},"interfaces/RevokeCredentialsResult.html":{},"interfaces/TokenInfo.html":{},"interfaces/TokenInfoRequest.html":{},"interfaces/TokenPayload.html":{},"interfaces/VerifyIdTokenOptions.html":{}}}],["hasscop",{"_index":1314,"title":{},"body":{"interfaces/JWTOptions.html":{}}}],["haven't",{"_index":1110,"title":{},"body":{"interfaces/FederatedSignonCertsResponse.html":{},"interfaces/GetAccessTokenCallback.html":{},"interfaces/GetAccessTokenResponse.html":{},"interfaces/GetFederatedSignonCertsCallback.html":{},"interfaces/GetTokenCallback.html":{},"interfaces/GetTokenOptions.html":{},"interfaces/GetTokenResponse.html":{},"interfaces/OAuth2ClientOptions.html":{},"interfaces/RefreshAccessTokenCallback.html":{},"interfaces/RefreshAccessTokenResponse.html":{},"interfaces/RefreshOptions.html":{},"interfaces/RequestMetadataCallback.html":{},"interfaces/RequestMetadataResponse.html":{},"interfaces/RevokeCredentialsResult.html":{},"interfaces/TokenInfo.html":{},"interfaces/TokenInfoRequest.html":{},"interfaces/VerifyIdTokenOptions.html":{}}}],["hd",{"_index":755,"title":{},"body":{"interfaces/FederatedSignonCertsResponse.html":{},"interfaces/GetAccessTokenCallback.html":{},"interfaces/GetAccessTokenResponse.html":{},"interfaces/GetFederatedSignonCertsCallback.html":{},"interfaces/GetTokenCallback.html":{},"interfaces/GetTokenOptions.html":{},"interfaces/GetTokenResponse.html":{},"classes/LoginTicket.html":{},"interfaces/OAuth2ClientOptions.html":{},"interfaces/RefreshAccessTokenCallback.html":{},"interfaces/RefreshAccessTokenResponse.html":{},"interfaces/RefreshOptions.html":{},"interfaces/RequestMetadataCallback.html":{},"interfaces/RequestMetadataResponse.html":{},"interfaces/RevokeCredentialsResult.html":{},"interfaces/TokenInfo.html":{},"interfaces/TokenInfoRequest.html":{},"interfaces/TokenPayload.html":{},"interfaces/VerifyIdTokenOptions.html":{},"changelog.html":{}}}],["header",{"_index":49,"title":{},"body":{"interfaces/ADCCallback.html":{},"interfaces/ADCResponse.html":{},"interfaces/CredentialCallback.html":{},"interfaces/FederatedSignonCertsResponse.html":{},"interfaces/GetAccessTokenCallback.html":{},"interfaces/GetAccessTokenResponse.html":{},"interfaces/GetFederatedSignonCertsCallback.html":{},"interfaces/GetTokenCallback.html":{},"interfaces/GetTokenOptions.html":{},"interfaces/GetTokenResponse.html":{},"interfaces/GoogleAuthOptions.html":{},"classes/IAMAuth.html":{},"classes/JWTAccess.html":{},"interfaces/JWTOptions.html":{},"interfaces/OAuth2ClientOptions.html":{},"interfaces/ProjectIdCallback.html":{},"interfaces/RefreshAccessTokenCallback.html":{},"interfaces/RefreshAccessTokenResponse.html":{},"interfaces/RefreshOptions.html":{},"interfaces/RequestMetadata.html":{},"interfaces/RequestMetadataCallback.html":{},"interfaces/RequestMetadataResponse.html":{},"interfaces/RevokeCredentialsResult.html":{},"interfaces/SignBlobResponse.html":{},"interfaces/TokenInfo.html":{},"interfaces/TokenInfoRequest.html":{},"interfaces/VerifyIdTokenOptions.html":{},"changelog.html":{},"miscellaneous/typealiases.html":{}}}],["hello",{"_index":1530,"title":{},"body":{"changelog.html":{}}}],["help",{"_index":809,"title":{},"body":{"interfaces/FederatedSignonCertsResponse.html":{},"interfaces/GetAccessTokenCallback.html":{},"interfaces/GetAccessTokenResponse.html":{},"interfaces/GetFederatedSignonCertsCallback.html":{},"interfaces/GetTokenCallback.html":{},"interfaces/GetTokenOptions.html":{},"interfaces/GetTokenResponse.html":{},"interfaces/OAuth2ClientOptions.html":{},"interfaces/RefreshAccessTokenCallback.html":{},"interfaces/RefreshAccessTokenResponse.html":{},"interfaces/RefreshOptions.html":{},"interfaces/RequestMetadataCallback.html":{},"interfaces/RequestMetadataResponse.html":{},"interfaces/RevokeCredentialsResult.html":{},"interfaces/TokenInfo.html":{},"interfaces/TokenInfoRequest.html":{},"interfaces/VerifyIdTokenOptions.html":{},"changelog.html":{}}}],["helper",{"_index":171,"title":{},"body":{"interfaces/ADCCallback.html":{},"interfaces/ADCResponse.html":{},"interfaces/CredentialCallback.html":{},"interfaces/GoogleAuthOptions.html":{},"interfaces/ProjectIdCallback.html":{},"interfaces/SignBlobResponse.html":{}}}],["helpfulmessag",{"_index":628,"title":{},"body":{"interfaces/ComputeOptions.html":{}}}],["here",{"_index":1706,"title":{},"body":{"index.html":{}}}],["herebi",{"_index":1882,"title":{},"body":{"license.html":{}}}],["herein",{"_index":1940,"title":{},"body":{"license.html":{}}}],["heroku",{"_index":1789,"title":{},"body":{"index.html":{}}}],["hint",{"_index":858,"title":{},"body":{"interfaces/FederatedSignonCertsResponse.html":{},"interfaces/GetAccessTokenCallback.html":{},"interfaces/GetAccessTokenResponse.html":{},"interfaces/GetFederatedSignonCertsCallback.html":{},"interfaces/GetTokenCallback.html":{},"interfaces/GetTokenOptions.html":{},"interfaces/GetTokenResponse.html":{},"interfaces/OAuth2ClientOptions.html":{},"interfaces/RefreshAccessTokenCallback.html":{},"interfaces/RefreshAccessTokenResponse.html":{},"interfaces/RefreshOptions.html":{},"interfaces/RequestMetadataCallback.html":{},"interfaces/RequestMetadataResponse.html":{},"interfaces/RevokeCredentialsResult.html":{},"interfaces/TokenInfo.html":{},"interfaces/TokenInfoRequest.html":{},"interfaces/VerifyIdTokenOptions.html":{}}}],["histori",{"_index":1457,"title":{},"body":{"changelog.html":{}}}],["hold",{"_index":1981,"title":{},"body":{"license.html":{}}}],["home",{"_index":273,"title":{},"body":{"interfaces/ADCCallback.html":{},"interfaces/ADCResponse.html":{},"interfaces/CredentialCallback.html":{},"interfaces/GoogleAuthOptions.html":{},"interfaces/ProjectIdCallback.html":{},"interfaces/SignBlobResponse.html":{}}}],["host",{"_index":756,"title":{},"body":{"interfaces/FederatedSignonCertsResponse.html":{},"interfaces/GetAccessTokenCallback.html":{},"interfaces/GetAccessTokenResponse.html":{},"interfaces/GetFederatedSignonCertsCallback.html":{},"interfaces/GetTokenCallback.html":{},"interfaces/GetTokenOptions.html":{},"interfaces/GetTokenResponse.html":{},"classes/LoginTicket.html":{},"interfaces/OAuth2ClientOptions.html":{},"interfaces/RefreshAccessTokenCallback.html":{},"interfaces/RefreshAccessTokenResponse.html":{},"interfaces/RefreshOptions.html":{},"interfaces/RequestMetadataCallback.html":{},"interfaces/RequestMetadataResponse.html":{},"interfaces/RevokeCredentialsResult.html":{},"interfaces/TokenInfo.html":{},"interfaces/TokenInfoRequest.html":{},"interfaces/TokenPayload.html":{},"interfaces/VerifyIdTokenOptions.html":{}}}],["hour",{"_index":1259,"title":{},"body":{"classes/JWTAccess.html":{}}}],["http",{"_index":31,"title":{},"body":{"interfaces/ADCCallback.html":{},"interfaces/ADCResponse.html":{},"interfaces/CredentialCallback.html":{},"interfaces/FederatedSignonCertsResponse.html":{},"interfaces/GetAccessTokenCallback.html":{},"interfaces/GetAccessTokenResponse.html":{},"interfaces/GetFederatedSignonCertsCallback.html":{},"interfaces/GetTokenCallback.html":{},"interfaces/GetTokenOptions.html":{},"interfaces/GetTokenResponse.html":{},"interfaces/GoogleAuthOptions.html":{},"classes/IAMAuth.html":{},"interfaces/OAuth2ClientOptions.html":{},"interfaces/ProjectIdCallback.html":{},"interfaces/RefreshAccessTokenCallback.html":{},"interfaces/RefreshAccessTokenResponse.html":{},"interfaces/RefreshOptions.html":{},"interfaces/RequestMetadata.html":{},"interfaces/RequestMetadataCallback.html":{},"interfaces/RequestMetadataResponse.html":{},"interfaces/RevokeCredentialsResult.html":{},"interfaces/SignBlobResponse.html":{},"interfaces/TokenInfo.html":{},"interfaces/TokenInfoRequest.html":{},"interfaces/VerifyIdTokenOptions.html":{},"changelog.html":{},"dependencies.html":{},"index.html":{}}}],["http.createserver(async",{"_index":1735,"title":{},"body":{"index.html":{}}}],["http://www.apache.org/licens",{"_index":1819,"title":{},"body":{"license.html":{}}}],["http://www.apache.org/licenses/licens",{"_index":662,"title":{},"body":{"interfaces/Credentials.html":{},"classes/LoginTicket.html":{},"miscellaneous/functions.html":{},"license.html":{}}}],["https://accounts.google.com",{"_index":956,"title":{},"body":{"interfaces/FederatedSignonCertsResponse.html":{},"interfaces/GetAccessTokenCallback.html":{},"interfaces/GetAccessTokenResponse.html":{},"interfaces/GetFederatedSignonCertsCallback.html":{},"interfaces/GetTokenCallback.html":{},"interfaces/GetTokenOptions.html":{},"interfaces/GetTokenResponse.html":{},"classes/LoginTicket.html":{},"interfaces/OAuth2ClientOptions.html":{},"interfaces/RefreshAccessTokenCallback.html":{},"interfaces/RefreshAccessTokenResponse.html":{},"interfaces/RefreshOptions.html":{},"interfaces/RequestMetadataCallback.html":{},"interfaces/RequestMetadataResponse.html":{},"interfaces/RevokeCredentialsResult.html":{},"interfaces/TokenInfo.html":{},"interfaces/TokenInfoRequest.html":{},"interfaces/TokenPayload.html":{},"interfaces/VerifyIdTokenOptions.html":{}}}],["https://accounts.google.com/o/oauth2/auth",{"_index":1792,"title":{},"body":{"index.html":{}}}],["https://accounts.google.com/o/oauth2/token",{"_index":1794,"title":{},"body":{"index.html":{}}}],["https://accounts.google.com/o/oauth2/v2/auth",{"_index":934,"title":{},"body":{"interfaces/FederatedSignonCertsResponse.html":{},"interfaces/GetAccessTokenCallback.html":{},"interfaces/GetAccessTokenResponse.html":{},"interfaces/GetFederatedSignonCertsCallback.html":{},"interfaces/GetTokenCallback.html":{},"interfaces/GetTokenOptions.html":{},"interfaces/GetTokenResponse.html":{},"interfaces/OAuth2ClientOptions.html":{},"interfaces/RefreshAccessTokenCallback.html":{},"interfaces/RefreshAccessTokenResponse.html":{},"interfaces/RefreshOptions.html":{},"interfaces/RequestMetadataCallback.html":{},"interfaces/RequestMetadataResponse.html":{},"interfaces/RevokeCredentialsResult.html":{},"interfaces/TokenInfo.html":{},"interfaces/TokenInfoRequest.html":{},"interfaces/VerifyIdTokenOptions.html":{}}}],["https://cloud.google.com/docs/authent",{"_index":1437,"title":{},"body":{"interfaces/Warning.html":{},"miscellaneous/variables.html":{}}}],["https://cloud.google.com/docs/authentication/get",{"_index":241,"title":{},"body":{"interfaces/ADCCallback.html":{},"interfaces/ADCResponse.html":{},"interfaces/CredentialCallback.html":{},"interfaces/GoogleAuthOptions.html":{},"interfaces/ProjectIdCallback.html":{},"interfaces/SignBlobResponse.html":{}}}],["https://developers.google.com/compute/docs/authent",{"_index":588,"title":{},"body":{"interfaces/ComputeOptions.html":{}}}],["https://github.com/axios/axios#request",{"_index":1717,"title":{},"body":{"index.html":{}}}],["https://github.com/google/googl",{"_index":528,"title":{},"body":{"interfaces/BodyResponseCallback.html":{},"classes/DefaultTransporter.html":{},"interfaces/RequestError.html":{},"interfaces/Transporter.html":{}}}],["https://github.com/microsoft/typescript/issues/5228",{"_index":105,"title":{},"body":{"interfaces/ADCCallback.html":{},"interfaces/ADCResponse.html":{},"interfaces/CredentialCallback.html":{},"interfaces/GoogleAuthOptions.html":{},"interfaces/ProjectIdCallback.html":{},"interfaces/SignBlobResponse.html":{}}}],["https://iam.googleapis.com/v1/${id}:signblob",{"_index":490,"title":{},"body":{"interfaces/ADCCallback.html":{},"interfaces/ADCResponse.html":{},"interfaces/CredentialCallback.html":{},"interfaces/GoogleAuthOptions.html":{},"interfaces/ProjectIdCallback.html":{},"interfaces/SignBlobResponse.html":{}}}],["https://nodejs.org/docs/latest",{"_index":1425,"title":{},"body":{"interfaces/Warning.html":{}}}],["https://oauth2.googleapis.com/revok",{"_index":939,"title":{},"body":{"interfaces/FederatedSignonCertsResponse.html":{},"interfaces/GetAccessTokenCallback.html":{},"interfaces/GetAccessTokenResponse.html":{},"interfaces/GetFederatedSignonCertsCallback.html":{},"interfaces/GetTokenCallback.html":{},"interfaces/GetTokenOptions.html":{},"interfaces/GetTokenResponse.html":{},"interfaces/OAuth2ClientOptions.html":{},"interfaces/RefreshAccessTokenCallback.html":{},"interfaces/RefreshAccessTokenResponse.html":{},"interfaces/RefreshOptions.html":{},"interfaces/RequestMetadataCallback.html":{},"interfaces/RequestMetadataResponse.html":{},"interfaces/RevokeCredentialsResult.html":{},"interfaces/TokenInfo.html":{},"interfaces/TokenInfoRequest.html":{},"interfaces/VerifyIdTokenOptions.html":{}}}],["https://oauth2.googleapis.com/token",{"_index":936,"title":{},"body":{"interfaces/FederatedSignonCertsResponse.html":{},"interfaces/GetAccessTokenCallback.html":{},"interfaces/GetAccessTokenResponse.html":{},"interfaces/GetFederatedSignonCertsCallback.html":{},"interfaces/GetTokenCallback.html":{},"interfaces/GetTokenOptions.html":{},"interfaces/GetTokenResponse.html":{},"interfaces/OAuth2ClientOptions.html":{},"interfaces/RefreshAccessTokenCallback.html":{},"interfaces/RefreshAccessTokenResponse.html":{},"interfaces/RefreshOptions.html":{},"interfaces/RequestMetadataCallback.html":{},"interfaces/RequestMetadataResponse.html":{},"interfaces/RevokeCredentialsResult.html":{},"interfaces/TokenInfo.html":{},"interfaces/TokenInfoRequest.html":{},"interfaces/VerifyIdTokenOptions.html":{}}}],["https://oauth2.googleapis.com/tokeninfo",{"_index":931,"title":{},"body":{"interfaces/FederatedSignonCertsResponse.html":{},"interfaces/GetAccessTokenCallback.html":{},"interfaces/GetAccessTokenResponse.html":{},"interfaces/GetFederatedSignonCertsCallback.html":{},"interfaces/GetTokenCallback.html":{},"interfaces/GetTokenOptions.html":{},"interfaces/GetTokenResponse.html":{},"interfaces/OAuth2ClientOptions.html":{},"interfaces/RefreshAccessTokenCallback.html":{},"interfaces/RefreshAccessTokenResponse.html":{},"interfaces/RefreshOptions.html":{},"interfaces/RequestMetadataCallback.html":{},"interfaces/RequestMetadataResponse.html":{},"interfaces/RevokeCredentialsResult.html":{},"interfaces/TokenInfo.html":{},"interfaces/TokenInfoRequest.html":{},"interfaces/VerifyIdTokenOptions.html":{}}}],["https://www.googleapis.com/auth/cloud",{"_index":1553,"title":{},"body":{"changelog.html":{},"index.html":{}}}],["https://www.googleapis.com/auth/plus.m",{"_index":1732,"title":{},"body":{"index.html":{}}}],["https://www.googleapis.com/dns/v1/projects/${keys.project_id",{"_index":1783,"title":{},"body":{"index.html":{}}}],["https://www.googleapis.com/dns/v1/projects/${project_id",{"_index":1806,"title":{},"body":{"index.html":{}}}],["https://www.googleapis.com/dns/v1/projects/${projectid",{"_index":1694,"title":{},"body":{"index.html":{}}}],["https://www.googleapis.com/oauth2/v1/cert",{"_index":941,"title":{},"body":{"interfaces/FederatedSignonCertsResponse.html":{},"interfaces/GetAccessTokenCallback.html":{},"interfaces/GetAccessTokenResponse.html":{},"interfaces/GetFederatedSignonCertsCallback.html":{},"interfaces/GetTokenCallback.html":{},"interfaces/GetTokenOptions.html":{},"interfaces/GetTokenResponse.html":{},"interfaces/OAuth2ClientOptions.html":{},"interfaces/RefreshAccessTokenCallback.html":{},"interfaces/RefreshAccessTokenResponse.html":{},"interfaces/RefreshOptions.html":{},"interfaces/RequestMetadataCallback.html":{},"interfaces/RequestMetadataResponse.html":{},"interfaces/RevokeCredentialsResult.html":{},"interfaces/TokenInfo.html":{},"interfaces/TokenInfoRequest.html":{},"interfaces/VerifyIdTokenOptions.html":{},"index.html":{}}}],["https://www.googleapis.com/plus/v1/people?query=pizza",{"_index":1718,"title":{},"body":{"index.html":{}}}],["https_proxi",{"_index":547,"title":{},"body":{"interfaces/BodyResponseCallback.html":{},"classes/DefaultTransporter.html":{},"interfaces/RequestError.html":{},"interfaces/Transporter.html":{},"index.html":{}}}],["httpsproxyag",{"_index":502,"title":{},"body":{"interfaces/BodyResponseCallback.html":{},"classes/DefaultTransporter.html":{},"interfaces/RequestError.html":{},"interfaces/Transporter.html":{},"miscellaneous/variables.html":{}}}],["httpsproxyagent(proxi",{"_index":551,"title":{},"body":{"interfaces/BodyResponseCallback.html":{},"classes/DefaultTransporter.html":{},"interfaces/RequestError.html":{},"interfaces/Transporter.html":{}}}],["hybrid",{"_index":739,"title":{},"body":{"interfaces/FederatedSignonCertsResponse.html":{},"interfaces/GetAccessTokenCallback.html":{},"interfaces/GetAccessTokenResponse.html":{},"interfaces/GetFederatedSignonCertsCallback.html":{},"interfaces/GetTokenCallback.html":{},"interfaces/GetTokenOptions.html":{},"interfaces/GetTokenResponse.html":{},"classes/LoginTicket.html":{},"interfaces/OAuth2ClientOptions.html":{},"interfaces/RefreshAccessTokenCallback.html":{},"interfaces/RefreshAccessTokenResponse.html":{},"interfaces/RefreshOptions.html":{},"interfaces/RequestMetadataCallback.html":{},"interfaces/RequestMetadataResponse.html":{},"interfaces/RevokeCredentialsResult.html":{},"interfaces/TokenInfo.html":{},"interfaces/TokenInfoRequest.html":{},"interfaces/TokenPayload.html":{},"interfaces/VerifyIdTokenOptions.html":{}}}],["iam",{"_index":474,"title":{},"body":{"interfaces/ADCCallback.html":{},"interfaces/ADCResponse.html":{},"interfaces/CredentialCallback.html":{},"interfaces/GoogleAuthOptions.html":{},"classes/IAMAuth.html":{},"interfaces/ProjectIdCallback.html":{},"interfaces/RequestMetadata.html":{},"interfaces/SignBlobResponse.html":{},"interfaces/Warning.html":{},"changelog.html":{},"miscellaneous/variables.html":{}}}],["iam_create_scoped_deprec",{"_index":1446,"title":{},"body":{"interfaces/Warning.html":{},"miscellaneous/variables.html":{}}}],["iam_get_request_metadata_deprec",{"_index":1453,"title":{},"body":{"interfaces/Warning.html":{},"miscellaneous/variables.html":{}}}],["iamauth",{"_index":1190,"title":{"classes/IAMAuth.html":{}},"body":{"classes/IAMAuth.html":{},"interfaces/RequestMetadata.html":{}}}],["iat",{"_index":1169,"title":{},"body":{"interfaces/FederatedSignonCertsResponse.html":{},"interfaces/GetAccessTokenCallback.html":{},"interfaces/GetAccessTokenResponse.html":{},"interfaces/GetFederatedSignonCertsCallback.html":{},"interfaces/GetTokenCallback.html":{},"interfaces/GetTokenOptions.html":{},"interfaces/GetTokenResponse.html":{},"classes/JWTAccess.html":{},"classes/LoginTicket.html":{},"interfaces/OAuth2ClientOptions.html":{},"interfaces/RefreshAccessTokenCallback.html":{},"interfaces/RefreshAccessTokenResponse.html":{},"interfaces/RefreshOptions.html":{},"interfaces/RequestMetadataCallback.html":{},"interfaces/RequestMetadataResponse.html":{},"interfaces/RevokeCredentialsResult.html":{},"interfaces/TokenInfo.html":{},"interfaces/TokenInfoRequest.html":{},"interfaces/TokenPayload.html":{},"interfaces/VerifyIdTokenOptions.html":{}}}],["id",{"_index":79,"title":{},"body":{"interfaces/ADCCallback.html":{},"interfaces/ADCResponse.html":{},"interfaces/CredentialCallback.html":{},"interfaces/FederatedSignonCertsResponse.html":{},"interfaces/GetAccessTokenCallback.html":{},"interfaces/GetAccessTokenResponse.html":{},"interfaces/GetFederatedSignonCertsCallback.html":{},"interfaces/GetTokenCallback.html":{},"interfaces/GetTokenOptions.html":{},"interfaces/GetTokenResponse.html":{},"interfaces/GoogleAuthOptions.html":{},"classes/JWTAccess.html":{},"interfaces/JWTOptions.html":{},"classes/LoginTicket.html":{},"interfaces/OAuth2ClientOptions.html":{},"interfaces/ProjectIdCallback.html":{},"interfaces/RefreshAccessTokenCallback.html":{},"interfaces/RefreshAccessTokenResponse.html":{},"interfaces/RefreshOptions.html":{},"interfaces/RequestMetadataCallback.html":{},"interfaces/RequestMetadataResponse.html":{},"interfaces/RevokeCredentialsResult.html":{},"interfaces/SignBlobResponse.html":{},"interfaces/TokenInfo.html":{},"interfaces/TokenInfoRequest.html":{},"interfaces/TokenPayload.html":{},"interfaces/UserRefreshClientOptions.html":{},"interfaces/VerifyIdTokenOptions.html":{},"index.html":{}}}],["id_token",{"_index":641,"title":{},"body":{"interfaces/CredentialBody.html":{},"interfaces/CredentialRequest.html":{},"interfaces/Credentials.html":{},"interfaces/JWTInput.html":{},"interfaces/JWTOptions.html":{}}}],["ident",{"_index":1156,"title":{},"body":{"interfaces/FederatedSignonCertsResponse.html":{},"interfaces/GetAccessTokenCallback.html":{},"interfaces/GetAccessTokenResponse.html":{},"interfaces/GetFederatedSignonCertsCallback.html":{},"interfaces/GetTokenCallback.html":{},"interfaces/GetTokenOptions.html":{},"interfaces/GetTokenResponse.html":{},"classes/LoginTicket.html":{},"interfaces/OAuth2ClientOptions.html":{},"interfaces/RefreshAccessTokenCallback.html":{},"interfaces/RefreshAccessTokenResponse.html":{},"interfaces/RefreshOptions.html":{},"interfaces/RequestMetadataCallback.html":{},"interfaces/RequestMetadataResponse.html":{},"interfaces/RevokeCredentialsResult.html":{},"interfaces/TokenInfo.html":{},"interfaces/TokenInfoRequest.html":{},"interfaces/TokenPayload.html":{},"interfaces/VerifyIdTokenOptions.html":{},"index.html":{}}}],["identif",{"_index":1989,"title":{},"body":{"license.html":{}}}],["identifi",{"_index":717,"title":{},"body":{"interfaces/FederatedSignonCertsResponse.html":{},"interfaces/GetAccessTokenCallback.html":{},"interfaces/GetAccessTokenResponse.html":{},"interfaces/GetFederatedSignonCertsCallback.html":{},"interfaces/GetTokenCallback.html":{},"interfaces/GetTokenOptions.html":{},"interfaces/GetTokenResponse.html":{},"classes/LoginTicket.html":{},"interfaces/OAuth2ClientOptions.html":{},"interfaces/RefreshAccessTokenCallback.html":{},"interfaces/RefreshAccessTokenResponse.html":{},"interfaces/RefreshOptions.html":{},"interfaces/RequestMetadataCallback.html":{},"interfaces/RequestMetadataResponse.html":{},"interfaces/RevokeCredentialsResult.html":{},"interfaces/TokenInfo.html":{},"interfaces/TokenInfoRequest.html":{},"interfaces/TokenPayload.html":{},"interfaces/VerifyIdTokenOptions.html":{},"license.html":{}}}],["idtoken",{"_index":891,"title":{},"body":{"interfaces/FederatedSignonCertsResponse.html":{},"interfaces/GetAccessTokenCallback.html":{},"interfaces/GetAccessTokenResponse.html":{},"interfaces/GetFederatedSignonCertsCallback.html":{},"interfaces/GetTokenCallback.html":{},"interfaces/GetTokenOptions.html":{},"interfaces/GetTokenResponse.html":{},"interfaces/OAuth2ClientOptions.html":{},"interfaces/RefreshAccessTokenCallback.html":{},"interfaces/RefreshAccessTokenResponse.html":{},"interfaces/RefreshOptions.html":{},"interfaces/RequestMetadataCallback.html":{},"interfaces/RequestMetadataResponse.html":{},"interfaces/RevokeCredentialsResult.html":{},"interfaces/TokenInfo.html":{},"interfaces/TokenInfoRequest.html":{},"interfaces/VerifyIdTokenOptions.html":{}}}],["ignor",{"_index":402,"title":{},"body":{"interfaces/ADCCallback.html":{},"interfaces/ADCResponse.html":{},"interfaces/CredentialCallback.html":{},"interfaces/GoogleAuthOptions.html":{},"interfaces/JWTOptions.html":{},"interfaces/ProjectIdCallback.html":{},"interfaces/SignBlobResponse.html":{},"interfaces/UserRefreshClientOptions.html":{},"changelog.html":{}}}],["ii",{"_index":1836,"title":{},"body":{"license.html":{}}}],["iii",{"_index":1842,"title":{},"body":{"license.html":{}}}],["illustr",{"_index":1765,"title":{},"body":{"index.html":{}}}],["immut",{"_index":716,"title":{},"body":{"interfaces/FederatedSignonCertsResponse.html":{},"interfaces/GetAccessTokenCallback.html":{},"interfaces/GetAccessTokenResponse.html":{},"interfaces/GetFederatedSignonCertsCallback.html":{},"interfaces/GetTokenCallback.html":{},"interfaces/GetTokenOptions.html":{},"interfaces/GetTokenResponse.html":{},"interfaces/OAuth2ClientOptions.html":{},"interfaces/RefreshAccessTokenCallback.html":{},"interfaces/RefreshAccessTokenResponse.html":{},"interfaces/RefreshOptions.html":{},"interfaces/RequestMetadataCallback.html":{},"interfaces/RequestMetadataResponse.html":{},"interfaces/RevokeCredentialsResult.html":{},"interfaces/TokenInfo.html":{},"interfaces/TokenInfoRequest.html":{},"interfaces/VerifyIdTokenOptions.html":{}}}],["imperson",{"_index":1287,"title":{},"body":{"interfaces/JWTOptions.html":{}}}],["implement",{"_index":1094,"title":{},"body":{"interfaces/FederatedSignonCertsResponse.html":{},"interfaces/GetAccessTokenCallback.html":{},"interfaces/GetAccessTokenResponse.html":{},"interfaces/GetFederatedSignonCertsCallback.html":{},"interfaces/GetTokenCallback.html":{},"interfaces/GetTokenOptions.html":{},"interfaces/GetTokenResponse.html":{},"interfaces/OAuth2ClientOptions.html":{},"interfaces/RefreshAccessTokenCallback.html":{},"interfaces/RefreshAccessTokenResponse.html":{},"interfaces/RefreshOptions.html":{},"interfaces/RequestMetadataCallback.html":{},"interfaces/RequestMetadataResponse.html":{},"interfaces/RevokeCredentialsResult.html":{},"interfaces/TokenInfo.html":{},"interfaces/TokenInfoRequest.html":{},"interfaces/VerifyIdTokenOptions.html":{},"changelog.html":{},"index.html":{}}}],["impli",{"_index":674,"title":{},"body":{"interfaces/Credentials.html":{},"classes/LoginTicket.html":{},"miscellaneous/functions.html":{},"license.html":{}}}],["implicit",{"_index":156,"title":{},"body":{"interfaces/ADCCallback.html":{},"interfaces/ADCResponse.html":{},"interfaces/CredentialCallback.html":{},"interfaces/GoogleAuthOptions.html":{},"interfaces/ProjectIdCallback.html":{},"interfaces/SignBlobResponse.html":{}}}],["import",{"_index":20,"title":{},"body":{"interfaces/ADCCallback.html":{},"interfaces/ADCResponse.html":{},"interfaces/BodyResponseCallback.html":{},"interfaces/ComputeOptions.html":{},"interfaces/CredentialCallback.html":{},"classes/DefaultTransporter.html":{},"interfaces/FederatedSignonCertsResponse.html":{},"interfaces/GetAccessTokenCallback.html":{},"interfaces/GetAccessTokenResponse.html":{},"interfaces/GetFederatedSignonCertsCallback.html":{},"interfaces/GetTokenCallback.html":{},"interfaces/GetTokenOptions.html":{},"interfaces/GetTokenResponse.html":{},"interfaces/GoogleAuthOptions.html":{},"classes/IAMAuth.html":{},"classes/JWTAccess.html":{},"interfaces/JWTOptions.html":{},"interfaces/OAuth2ClientOptions.html":{},"classes/PemVerifier.html":{},"interfaces/ProjectIdCallback.html":{},"interfaces/RefreshAccessTokenCallback.html":{},"interfaces/RefreshAccessTokenResponse.html":{},"interfaces/RefreshOptions.html":{},"interfaces/RequestError.html":{},"interfaces/RequestMetadata.html":{},"interfaces/RequestMetadataCallback.html":{},"interfaces/RequestMetadataResponse.html":{},"interfaces/RevokeCredentialsResult.html":{},"interfaces/SignBlobResponse.html":{},"interfaces/TokenInfo.html":{},"interfaces/TokenInfoRequest.html":{},"interfaces/Transporter.html":{},"interfaces/UserRefreshClientOptions.html":{},"interfaces/VerifyIdTokenOptions.html":{},"interfaces/Warning.html":{},"license.html":{}}}],["improv",{"_index":1873,"title":{},"body":{"license.html":{}}}],["inabl",{"_index":1966,"title":{},"body":{"license.html":{}}}],["inc",{"_index":651,"title":{},"body":{"interfaces/Credentials.html":{},"classes/LoginTicket.html":{},"miscellaneous/functions.html":{}}}],["incident",{"_index":1963,"title":{},"body":{"license.html":{}}}],["includ",{"_index":388,"title":{},"body":{"interfaces/ADCCallback.html":{},"interfaces/ADCResponse.html":{},"interfaces/BodyResponseCallback.html":{},"interfaces/CredentialCallback.html":{},"classes/DefaultTransporter.html":{},"interfaces/FederatedSignonCertsResponse.html":{},"interfaces/GetAccessTokenCallback.html":{},"interfaces/GetAccessTokenResponse.html":{},"interfaces/GetFederatedSignonCertsCallback.html":{},"interfaces/GetTokenCallback.html":{},"interfaces/GetTokenOptions.html":{},"interfaces/GetTokenResponse.html":{},"interfaces/GoogleAuthOptions.html":{},"classes/JWTAccess.html":{},"classes/LoginTicket.html":{},"interfaces/OAuth2ClientOptions.html":{},"interfaces/ProjectIdCallback.html":{},"interfaces/RefreshAccessTokenCallback.html":{},"interfaces/RefreshAccessTokenResponse.html":{},"interfaces/RefreshOptions.html":{},"interfaces/RequestError.html":{},"interfaces/RequestMetadataCallback.html":{},"interfaces/RequestMetadataResponse.html":{},"interfaces/RevokeCredentialsResult.html":{},"interfaces/SignBlobResponse.html":{},"interfaces/TokenInfo.html":{},"interfaces/TokenInfoRequest.html":{},"interfaces/TokenPayload.html":{},"interfaces/Transporter.html":{},"interfaces/VerifyIdTokenOptions.html":{},"index.html":{},"license.html":{}}}],["include_granted_scop",{"_index":856,"title":{},"body":{"interfaces/FederatedSignonCertsResponse.html":{},"interfaces/GetAccessTokenCallback.html":{},"interfaces/GetAccessTokenResponse.html":{},"interfaces/GetFederatedSignonCertsCallback.html":{},"interfaces/GetTokenCallback.html":{},"interfaces/GetTokenOptions.html":{},"interfaces/GetTokenResponse.html":{},"interfaces/OAuth2ClientOptions.html":{},"interfaces/RefreshAccessTokenCallback.html":{},"interfaces/RefreshAccessTokenResponse.html":{},"interfaces/RefreshOptions.html":{},"interfaces/RequestMetadataCallback.html":{},"interfaces/RequestMetadataResponse.html":{},"interfaces/RevokeCredentialsResult.html":{},"interfaces/TokenInfo.html":{},"interfaces/TokenInfoRequest.html":{},"interfaces/VerifyIdTokenOptions.html":{}}}],["inclus",{"_index":1868,"title":{},"body":{"license.html":{}}}],["incom",{"_index":836,"title":{},"body":{"interfaces/FederatedSignonCertsResponse.html":{},"interfaces/GetAccessTokenCallback.html":{},"interfaces/GetAccessTokenResponse.html":{},"interfaces/GetFederatedSignonCertsCallback.html":{},"interfaces/GetTokenCallback.html":{},"interfaces/GetTokenOptions.html":{},"interfaces/GetTokenResponse.html":{},"classes/JWTAccess.html":{},"interfaces/JWTOptions.html":{},"interfaces/OAuth2ClientOptions.html":{},"interfaces/RefreshAccessTokenCallback.html":{},"interfaces/RefreshAccessTokenResponse.html":{},"interfaces/RefreshOptions.html":{},"interfaces/RequestMetadataCallback.html":{},"interfaces/RequestMetadataResponse.html":{},"interfaces/RevokeCredentialsResult.html":{},"interfaces/TokenInfo.html":{},"interfaces/TokenInfoRequest.html":{},"interfaces/UserRefreshClientOptions.html":{},"interfaces/VerifyIdTokenOptions.html":{}}}],["incorpor",{"_index":1880,"title":{},"body":{"license.html":{}}}],["increas",{"_index":834,"title":{},"body":{"interfaces/FederatedSignonCertsResponse.html":{},"interfaces/GetAccessTokenCallback.html":{},"interfaces/GetAccessTokenResponse.html":{},"interfaces/GetFederatedSignonCertsCallback.html":{},"interfaces/GetTokenCallback.html":{},"interfaces/GetTokenOptions.html":{},"interfaces/GetTokenResponse.html":{},"interfaces/OAuth2ClientOptions.html":{},"interfaces/RefreshAccessTokenCallback.html":{},"interfaces/RefreshAccessTokenResponse.html":{},"interfaces/RefreshOptions.html":{},"interfaces/RequestMetadataCallback.html":{},"interfaces/RequestMetadataResponse.html":{},"interfaces/RevokeCredentialsResult.html":{},"interfaces/TokenInfo.html":{},"interfaces/TokenInfoRequest.html":{},"interfaces/VerifyIdTokenOptions.html":{}}}],["increment",{"_index":808,"title":{},"body":{"interfaces/FederatedSignonCertsResponse.html":{},"interfaces/GetAccessTokenCallback.html":{},"interfaces/GetAccessTokenResponse.html":{},"interfaces/GetFederatedSignonCertsCallback.html":{},"interfaces/GetTokenCallback.html":{},"interfaces/GetTokenOptions.html":{},"interfaces/GetTokenResponse.html":{},"interfaces/OAuth2ClientOptions.html":{},"interfaces/RefreshAccessTokenCallback.html":{},"interfaces/RefreshAccessTokenResponse.html":{},"interfaces/RefreshOptions.html":{},"interfaces/RequestMetadataCallback.html":{},"interfaces/RequestMetadataResponse.html":{},"interfaces/RevokeCredentialsResult.html":{},"interfaces/TokenInfo.html":{},"interfaces/TokenInfoRequest.html":{},"interfaces/VerifyIdTokenOptions.html":{}}}],["incur",{"_index":1983,"title":{},"body":{"license.html":{}}}],["indemn",{"_index":1976,"title":{},"body":{"license.html":{}}}],["indemnifi",{"_index":1979,"title":{},"body":{"license.html":{}}}],["independ",{"_index":1676,"title":{},"body":{"index.html":{}}}],["index",{"_index":6,"title":{"index.html":{}},"body":{"interfaces/ADCCallback.html":{},"interfaces/ADCResponse.html":{},"interfaces/BodyResponseCallback.html":{},"interfaces/ComputeOptions.html":{},"interfaces/CredentialBody.html":{},"interfaces/CredentialCallback.html":{},"interfaces/CredentialRequest.html":{},"interfaces/Credentials.html":{},"classes/DefaultTransporter.html":{},"interfaces/FederatedSignonCertsResponse.html":{},"interfaces/GetAccessTokenCallback.html":{},"interfaces/GetAccessTokenResponse.html":{},"interfaces/GetFederatedSignonCertsCallback.html":{},"interfaces/GetTokenCallback.html":{},"interfaces/GetTokenOptions.html":{},"interfaces/GetTokenResponse.html":{},"interfaces/GoogleAuthOptions.html":{},"classes/IAMAuth.html":{},"classes/JWTAccess.html":{},"interfaces/JWTInput.html":{},"interfaces/JWTOptions.html":{},"classes/LoginTicket.html":{},"interfaces/OAuth2ClientOptions.html":{},"classes/PemVerifier.html":{},"interfaces/ProjectIdCallback.html":{},"interfaces/RefreshAccessTokenCallback.html":{},"interfaces/RefreshAccessTokenResponse.html":{},"interfaces/RefreshOptions.html":{},"interfaces/RequestError.html":{},"interfaces/RequestMetadata.html":{},"interfaces/RequestMetadataCallback.html":{},"interfaces/RequestMetadataResponse.html":{},"interfaces/RevokeCredentialsResult.html":{},"interfaces/SignBlobResponse.html":{},"interfaces/TokenInfo.html":{},"interfaces/TokenInfoRequest.html":{},"interfaces/TokenPayload.html":{},"interfaces/Transporter.html":{},"interfaces/UserRefreshClientOptions.html":{},"interfaces/VerifyIdTokenOptions.html":{},"interfaces/Warning.html":{},"miscellaneous/enumerations.html":{},"miscellaneous/functions.html":{},"miscellaneous/typealiases.html":{},"miscellaneous/variables.html":{}}}],["indic",{"_index":88,"title":{},"body":{"interfaces/ADCCallback.html":{},"interfaces/ADCResponse.html":{},"interfaces/ComputeOptions.html":{},"interfaces/CredentialCallback.html":{},"interfaces/FederatedSignonCertsResponse.html":{},"interfaces/GetAccessTokenCallback.html":{},"interfaces/GetAccessTokenResponse.html":{},"interfaces/GetFederatedSignonCertsCallback.html":{},"interfaces/GetTokenCallback.html":{},"interfaces/GetTokenOptions.html":{},"interfaces/GetTokenResponse.html":{},"interfaces/GoogleAuthOptions.html":{},"classes/IAMAuth.html":{},"classes/JWTAccess.html":{},"interfaces/JWTOptions.html":{},"interfaces/OAuth2ClientOptions.html":{},"interfaces/ProjectIdCallback.html":{},"interfaces/RefreshAccessTokenCallback.html":{},"interfaces/RefreshAccessTokenResponse.html":{},"interfaces/RefreshOptions.html":{},"interfaces/RequestMetadata.html":{},"interfaces/RequestMetadataCallback.html":{},"interfaces/RequestMetadataResponse.html":{},"interfaces/RevokeCredentialsResult.html":{},"interfaces/SignBlobResponse.html":{},"interfaces/TokenInfo.html":{},"interfaces/TokenInfoRequest.html":{},"interfaces/VerifyIdTokenOptions.html":{},"license.html":{}}}],["indirect",{"_index":1833,"title":{},"body":{"license.html":{}}}],["individu",{"_index":1844,"title":{},"body":{"license.html":{}}}],["infer",{"_index":409,"title":{},"body":{"interfaces/ADCCallback.html":{},"interfaces/ADCResponse.html":{},"interfaces/CredentialCallback.html":{},"interfaces/GoogleAuthOptions.html":{},"interfaces/ProjectIdCallback.html":{},"interfaces/SignBlobResponse.html":{}}}],["info",{"_index":2,"title":{},"body":{"interfaces/ADCCallback.html":{},"interfaces/ADCResponse.html":{},"interfaces/BodyResponseCallback.html":{},"interfaces/ComputeOptions.html":{},"interfaces/CredentialBody.html":{},"interfaces/CredentialCallback.html":{},"interfaces/CredentialRequest.html":{},"interfaces/Credentials.html":{},"classes/DefaultTransporter.html":{},"interfaces/FederatedSignonCertsResponse.html":{},"interfaces/GetAccessTokenCallback.html":{},"interfaces/GetAccessTokenResponse.html":{},"interfaces/GetFederatedSignonCertsCallback.html":{},"interfaces/GetTokenCallback.html":{},"interfaces/GetTokenOptions.html":{},"interfaces/GetTokenResponse.html":{},"interfaces/GoogleAuthOptions.html":{},"classes/IAMAuth.html":{},"classes/JWTAccess.html":{},"interfaces/JWTInput.html":{},"interfaces/JWTOptions.html":{},"classes/LoginTicket.html":{},"interfaces/OAuth2ClientOptions.html":{},"classes/PemVerifier.html":{},"interfaces/ProjectIdCallback.html":{},"interfaces/RefreshAccessTokenCallback.html":{},"interfaces/RefreshAccessTokenResponse.html":{},"interfaces/RefreshOptions.html":{},"interfaces/RequestError.html":{},"interfaces/RequestMetadata.html":{},"interfaces/RequestMetadataCallback.html":{},"interfaces/RequestMetadataResponse.html":{},"interfaces/RevokeCredentialsResult.html":{},"interfaces/SignBlobResponse.html":{},"interfaces/TokenInfo.html":{},"interfaces/TokenInfoRequest.html":{},"interfaces/TokenPayload.html":{},"interfaces/Transporter.html":{},"interfaces/UserRefreshClientOptions.html":{},"interfaces/VerifyIdTokenOptions.html":{},"interfaces/Warning.html":{},"index.html":{}}}],["info.expires_in",{"_index":1153,"title":{},"body":{"interfaces/FederatedSignonCertsResponse.html":{},"interfaces/GetAccessTokenCallback.html":{},"interfaces/GetAccessTokenResponse.html":{},"interfaces/GetFederatedSignonCertsCallback.html":{},"interfaces/GetTokenCallback.html":{},"interfaces/GetTokenOptions.html":{},"interfaces/GetTokenResponse.html":{},"interfaces/OAuth2ClientOptions.html":{},"interfaces/RefreshAccessTokenCallback.html":{},"interfaces/RefreshAccessTokenResponse.html":{},"interfaces/RefreshOptions.html":{},"interfaces/RequestMetadataCallback.html":{},"interfaces/RequestMetadataResponse.html":{},"interfaces/RevokeCredentialsResult.html":{},"interfaces/TokenInfo.html":{},"interfaces/TokenInfoRequest.html":{},"interfaces/VerifyIdTokenOptions.html":{}}}],["info.scop",{"_index":1154,"title":{},"body":{"interfaces/FederatedSignonCertsResponse.html":{},"interfaces/GetAccessTokenCallback.html":{},"interfaces/GetAccessTokenResponse.html":{},"interfaces/GetFederatedSignonCertsCallback.html":{},"interfaces/GetTokenCallback.html":{},"interfaces/GetTokenOptions.html":{},"interfaces/GetTokenResponse.html":{},"interfaces/OAuth2ClientOptions.html":{},"interfaces/RefreshAccessTokenCallback.html":{},"interfaces/RefreshAccessTokenResponse.html":{},"interfaces/RefreshOptions.html":{},"interfaces/RequestMetadataCallback.html":{},"interfaces/RequestMetadataResponse.html":{},"interfaces/RevokeCredentialsResult.html":{},"interfaces/TokenInfo.html":{},"interfaces/TokenInfoRequest.html":{},"interfaces/VerifyIdTokenOptions.html":{}}}],["inform",{"_index":244,"title":{},"body":{"interfaces/ADCCallback.html":{},"interfaces/ADCResponse.html":{},"interfaces/CredentialCallback.html":{},"interfaces/FederatedSignonCertsResponse.html":{},"interfaces/GetAccessTokenCallback.html":{},"interfaces/GetAccessTokenResponse.html":{},"interfaces/GetFederatedSignonCertsCallback.html":{},"interfaces/GetTokenCallback.html":{},"interfaces/GetTokenOptions.html":{},"interfaces/GetTokenResponse.html":{},"interfaces/GoogleAuthOptions.html":{},"classes/JWTAccess.html":{},"interfaces/JWTOptions.html":{},"classes/LoginTicket.html":{},"interfaces/OAuth2ClientOptions.html":{},"interfaces/ProjectIdCallback.html":{},"interfaces/RefreshAccessTokenCallback.html":{},"interfaces/RefreshAccessTokenResponse.html":{},"interfaces/RefreshOptions.html":{},"interfaces/RequestMetadataCallback.html":{},"interfaces/RequestMetadataResponse.html":{},"interfaces/RevokeCredentialsResult.html":{},"interfaces/SignBlobResponse.html":{},"interfaces/TokenInfo.html":{},"interfaces/TokenInfoRequest.html":{},"interfaces/TokenPayload.html":{},"interfaces/VerifyIdTokenOptions.html":{},"interfaces/Warning.html":{},"changelog.html":{},"index.html":{},"license.html":{},"miscellaneous/variables.html":{}}}],["infring",{"_index":1900,"title":{},"body":{"license.html":{}}}],["initi",{"_index":1320,"title":{},"body":{"interfaces/JWTOptions.html":{}}}],["input",{"_index":325,"title":{},"body":{"interfaces/ADCCallback.html":{},"interfaces/ADCResponse.html":{},"interfaces/CredentialCallback.html":{},"interfaces/GoogleAuthOptions.html":{},"classes/JWTAccess.html":{},"interfaces/JWTOptions.html":{},"interfaces/ProjectIdCallback.html":{},"interfaces/SignBlobResponse.html":{},"interfaces/UserRefreshClientOptions.html":{}}}],["inputstream",{"_index":337,"title":{},"body":{"interfaces/ADCCallback.html":{},"interfaces/ADCResponse.html":{},"interfaces/CredentialCallback.html":{},"interfaces/GoogleAuthOptions.html":{},"classes/JWTAccess.html":{},"interfaces/JWTOptions.html":{},"interfaces/ProjectIdCallback.html":{},"interfaces/SignBlobResponse.html":{},"interfaces/UserRefreshClientOptions.html":{}}}],["inputstream.setencoding('utf8",{"_index":346,"title":{},"body":{"interfaces/ADCCallback.html":{},"interfaces/ADCResponse.html":{},"interfaces/CredentialCallback.html":{},"interfaces/GoogleAuthOptions.html":{},"classes/JWTAccess.html":{},"interfaces/JWTOptions.html":{},"interfaces/ProjectIdCallback.html":{},"interfaces/SignBlobResponse.html":{},"interfaces/UserRefreshClientOptions.html":{}}}],["insid",{"_index":1775,"title":{},"body":{"index.html":{}}}],["instal",{"_index":1526,"title":{},"body":{"changelog.html":{},"index.html":{}}}],["instanc",{"_index":324,"title":{},"body":{"interfaces/ADCCallback.html":{},"interfaces/ADCResponse.html":{},"interfaces/ComputeOptions.html":{},"interfaces/CredentialCallback.html":{},"interfaces/GoogleAuthOptions.html":{},"classes/JWTAccess.html":{},"interfaces/JWTOptions.html":{},"interfaces/ProjectIdCallback.html":{},"interfaces/SignBlobResponse.html":{},"interfaces/UserRefreshClientOptions.html":{}}}],["instance'",{"_index":603,"title":{},"body":{"interfaces/ComputeOptions.html":{}}}],["instanceof",{"_index":221,"title":{},"body":{"interfaces/ADCCallback.html":{},"interfaces/ADCResponse.html":{},"interfaces/CredentialCallback.html":{},"interfaces/FederatedSignonCertsResponse.html":{},"interfaces/GetAccessTokenCallback.html":{},"interfaces/GetAccessTokenResponse.html":{},"interfaces/GetFederatedSignonCertsCallback.html":{},"interfaces/GetTokenCallback.html":{},"interfaces/GetTokenOptions.html":{},"interfaces/GetTokenResponse.html":{},"interfaces/GoogleAuthOptions.html":{},"interfaces/JWTOptions.html":{},"interfaces/OAuth2ClientOptions.html":{},"interfaces/ProjectIdCallback.html":{},"interfaces/RefreshAccessTokenCallback.html":{},"interfaces/RefreshAccessTokenResponse.html":{},"interfaces/RefreshOptions.html":{},"interfaces/RequestMetadataCallback.html":{},"interfaces/RequestMetadataResponse.html":{},"interfaces/RevokeCredentialsResult.html":{},"interfaces/SignBlobResponse.html":{},"interfaces/TokenInfo.html":{},"interfaces/TokenInfoRequest.html":{},"interfaces/VerifyIdTokenOptions.html":{}}}],["instead",{"_index":136,"title":{},"body":{"interfaces/ADCCallback.html":{},"interfaces/ADCResponse.html":{},"interfaces/CredentialCallback.html":{},"interfaces/FederatedSignonCertsResponse.html":{},"interfaces/GetAccessTokenCallback.html":{},"interfaces/GetAccessTokenResponse.html":{},"interfaces/GetFederatedSignonCertsCallback.html":{},"interfaces/GetTokenCallback.html":{},"interfaces/GetTokenOptions.html":{},"interfaces/GetTokenResponse.html":{},"interfaces/GoogleAuthOptions.html":{},"classes/JWTAccess.html":{},"interfaces/OAuth2ClientOptions.html":{},"interfaces/ProjectIdCallback.html":{},"interfaces/RefreshAccessTokenCallback.html":{},"interfaces/RefreshAccessTokenResponse.html":{},"interfaces/RefreshOptions.html":{},"interfaces/RequestMetadataCallback.html":{},"interfaces/RequestMetadataResponse.html":{},"interfaces/RevokeCredentialsResult.html":{},"interfaces/SignBlobResponse.html":{},"interfaces/TokenInfo.html":{},"interfaces/TokenInfoRequest.html":{},"interfaces/VerifyIdTokenOptions.html":{},"interfaces/Warning.html":{},"changelog.html":{},"index.html":{},"miscellaneous/variables.html":{}}}],["institut",{"_index":1904,"title":{},"body":{"license.html":{}}}],["instruct",{"_index":748,"title":{},"body":{"interfaces/FederatedSignonCertsResponse.html":{},"interfaces/GetAccessTokenCallback.html":{},"interfaces/GetAccessTokenResponse.html":{},"interfaces/GetFederatedSignonCertsCallback.html":{},"interfaces/GetTokenCallback.html":{},"interfaces/GetTokenOptions.html":{},"interfaces/GetTokenResponse.html":{},"interfaces/OAuth2ClientOptions.html":{},"interfaces/RefreshAccessTokenCallback.html":{},"interfaces/RefreshAccessTokenResponse.html":{},"interfaces/RefreshOptions.html":{},"interfaces/RequestMetadataCallback.html":{},"interfaces/RequestMetadataResponse.html":{},"interfaces/RevokeCredentialsResult.html":{},"interfaces/TokenInfo.html":{},"interfaces/TokenInfoRequest.html":{},"interfaces/VerifyIdTokenOptions.html":{}}}],["integ",{"_index":1383,"title":{},"body":{"classes/LoginTicket.html":{},"interfaces/TokenPayload.html":{}}}],["intelli",{"_index":1613,"title":{},"body":{"changelog.html":{}}}],["intend",{"_index":708,"title":{},"body":{"interfaces/FederatedSignonCertsResponse.html":{},"interfaces/GetAccessTokenCallback.html":{},"interfaces/GetAccessTokenResponse.html":{},"interfaces/GetFederatedSignonCertsCallback.html":{},"interfaces/GetTokenCallback.html":{},"interfaces/GetTokenOptions.html":{},"interfaces/GetTokenResponse.html":{},"classes/LoginTicket.html":{},"interfaces/OAuth2ClientOptions.html":{},"interfaces/RefreshAccessTokenCallback.html":{},"interfaces/RefreshAccessTokenResponse.html":{},"interfaces/RefreshOptions.html":{},"interfaces/RequestMetadataCallback.html":{},"interfaces/RequestMetadataResponse.html":{},"interfaces/RevokeCredentialsResult.html":{},"interfaces/TokenInfo.html":{},"interfaces/TokenInfoRequest.html":{},"interfaces/TokenPayload.html":{},"interfaces/VerifyIdTokenOptions.html":{}}}],["intention",{"_index":1866,"title":{},"body":{"license.html":{}}}],["interfac",{"_index":0,"title":{"interfaces/ADCCallback.html":{},"interfaces/ADCResponse.html":{},"interfaces/BodyResponseCallback.html":{},"interfaces/ComputeOptions.html":{},"interfaces/CredentialBody.html":{},"interfaces/CredentialCallback.html":{},"interfaces/CredentialRequest.html":{},"interfaces/Credentials.html":{},"interfaces/FederatedSignonCertsResponse.html":{},"interfaces/GetAccessTokenCallback.html":{},"interfaces/GetAccessTokenResponse.html":{},"interfaces/GetFederatedSignonCertsCallback.html":{},"interfaces/GetTokenCallback.html":{},"interfaces/GetTokenOptions.html":{},"interfaces/GetTokenResponse.html":{},"interfaces/GoogleAuthOptions.html":{},"interfaces/JWTInput.html":{},"interfaces/JWTOptions.html":{},"interfaces/OAuth2ClientOptions.html":{},"interfaces/ProjectIdCallback.html":{},"interfaces/RefreshAccessTokenCallback.html":{},"interfaces/RefreshAccessTokenResponse.html":{},"interfaces/RefreshOptions.html":{},"interfaces/RequestError.html":{},"interfaces/RequestMetadata.html":{},"interfaces/RequestMetadataCallback.html":{},"interfaces/RequestMetadataResponse.html":{},"interfaces/RevokeCredentialsResult.html":{},"interfaces/SignBlobResponse.html":{},"interfaces/TokenInfo.html":{},"interfaces/TokenInfoRequest.html":{},"interfaces/TokenPayload.html":{},"interfaces/Transporter.html":{},"interfaces/UserRefreshClientOptions.html":{},"interfaces/VerifyIdTokenOptions.html":{},"interfaces/Warning.html":{}},"body":{"interfaces/ADCCallback.html":{},"interfaces/ADCResponse.html":{},"interfaces/BodyResponseCallback.html":{},"interfaces/ComputeOptions.html":{},"interfaces/CredentialBody.html":{},"interfaces/CredentialCallback.html":{},"interfaces/CredentialRequest.html":{},"interfaces/Credentials.html":{},"classes/DefaultTransporter.html":{},"interfaces/FederatedSignonCertsResponse.html":{},"interfaces/GetAccessTokenCallback.html":{},"interfaces/GetAccessTokenResponse.html":{},"interfaces/GetFederatedSignonCertsCallback.html":{},"interfaces/GetTokenCallback.html":{},"interfaces/GetTokenOptions.html":{},"interfaces/GetTokenResponse.html":{},"interfaces/GoogleAuthOptions.html":{},"classes/IAMAuth.html":{},"interfaces/JWTInput.html":{},"interfaces/JWTOptions.html":{},"classes/LoginTicket.html":{},"interfaces/OAuth2ClientOptions.html":{},"interfaces/ProjectIdCallback.html":{},"interfaces/RefreshAccessTokenCallback.html":{},"interfaces/RefreshAccessTokenResponse.html":{},"interfaces/RefreshOptions.html":{},"interfaces/RequestError.html":{},"interfaces/RequestMetadata.html":{},"interfaces/RequestMetadataCallback.html":{},"interfaces/RequestMetadataResponse.html":{},"interfaces/RevokeCredentialsResult.html":{},"interfaces/SignBlobResponse.html":{},"interfaces/TokenInfo.html":{},"interfaces/TokenInfoRequest.html":{},"interfaces/TokenPayload.html":{},"interfaces/Transporter.html":{},"interfaces/UserRefreshClientOptions.html":{},"interfaces/VerifyIdTokenOptions.html":{},"interfaces/Warning.html":{},"changelog.html":{},"license.html":{},"overview.html":{}}}],["intern",{"_index":1489,"title":{},"body":{"changelog.html":{}}}],["invalid",{"_index":294,"title":{},"body":{"interfaces/ADCCallback.html":{},"interfaces/ADCResponse.html":{},"interfaces/CredentialCallback.html":{},"interfaces/FederatedSignonCertsResponse.html":{},"interfaces/GetAccessTokenCallback.html":{},"interfaces/GetAccessTokenResponse.html":{},"interfaces/GetFederatedSignonCertsCallback.html":{},"interfaces/GetTokenCallback.html":{},"interfaces/GetTokenOptions.html":{},"interfaces/GetTokenResponse.html":{},"interfaces/GoogleAuthOptions.html":{},"interfaces/OAuth2ClientOptions.html":{},"interfaces/ProjectIdCallback.html":{},"interfaces/RefreshAccessTokenCallback.html":{},"interfaces/RefreshAccessTokenResponse.html":{},"interfaces/RefreshOptions.html":{},"interfaces/RequestMetadataCallback.html":{},"interfaces/RequestMetadataResponse.html":{},"interfaces/RevokeCredentialsResult.html":{},"interfaces/SignBlobResponse.html":{},"interfaces/TokenInfo.html":{},"interfaces/TokenInfoRequest.html":{},"interfaces/VerifyIdTokenOptions.html":{},"index.html":{}}}],["invers",{"_index":797,"title":{},"body":{"interfaces/FederatedSignonCertsResponse.html":{},"interfaces/GetAccessTokenCallback.html":{},"interfaces/GetAccessTokenResponse.html":{},"interfaces/GetFederatedSignonCertsCallback.html":{},"interfaces/GetTokenCallback.html":{},"interfaces/GetTokenOptions.html":{},"interfaces/GetTokenResponse.html":{},"interfaces/OAuth2ClientOptions.html":{},"interfaces/RefreshAccessTokenCallback.html":{},"interfaces/RefreshAccessTokenResponse.html":{},"interfaces/RefreshOptions.html":{},"interfaces/RequestMetadataCallback.html":{},"interfaces/RequestMetadataResponse.html":{},"interfaces/RevokeCredentialsResult.html":{},"interfaces/TokenInfo.html":{},"interfaces/TokenInfoRequest.html":{},"interfaces/VerifyIdTokenOptions.html":{}}}],["invok",{"_index":1208,"title":{},"body":{"classes/IAMAuth.html":{},"interfaces/RequestMetadata.html":{}}}],["io",{"_index":1778,"title":{},"body":{"index.html":{}}}],["irrevoc",{"_index":1889,"title":{},"body":{"license.html":{}}}],["isappengin",{"_index":1657,"title":{},"body":{"miscellaneous/functions.html":{}}}],["isautherr",{"_index":1123,"title":{},"body":{"interfaces/FederatedSignonCertsResponse.html":{},"interfaces/GetAccessTokenCallback.html":{},"interfaces/GetAccessTokenResponse.html":{},"interfaces/GetFederatedSignonCertsCallback.html":{},"interfaces/GetTokenCallback.html":{},"interfaces/GetTokenOptions.html":{},"interfaces/GetTokenResponse.html":{},"interfaces/OAuth2ClientOptions.html":{},"interfaces/RefreshAccessTokenCallback.html":{},"interfaces/RefreshAccessTokenResponse.html":{},"interfaces/RefreshOptions.html":{},"interfaces/RequestMetadataCallback.html":{},"interfaces/RequestMetadataResponse.html":{},"interfaces/RevokeCredentialsResult.html":{},"interfaces/TokenInfo.html":{},"interfaces/TokenInfoRequest.html":{},"interfaces/VerifyIdTokenOptions.html":{}}}],["isavail",{"_index":1626,"title":{},"body":{"changelog.html":{}}}],["iscloudfunct",{"_index":1658,"title":{},"body":{"miscellaneous/functions.html":{}}}],["iscomputeengin",{"_index":1659,"title":{},"body":{"miscellaneous/functions.html":{}}}],["isgc",{"_index":106,"title":{},"body":{"interfaces/ADCCallback.html":{},"interfaces/ADCResponse.html":{},"interfaces/CredentialCallback.html":{},"interfaces/GoogleAuthOptions.html":{},"interfaces/ProjectIdCallback.html":{},"interfaces/SignBlobResponse.html":{}}}],["iskubernetesengin",{"_index":1660,"title":{},"body":{"miscellaneous/functions.html":{}}}],["isn't",{"_index":542,"title":{},"body":{"interfaces/BodyResponseCallback.html":{},"classes/DefaultTransporter.html":{},"interfaces/RequestError.html":{},"interfaces/Transporter.html":{}}}],["isreadablestream",{"_index":1121,"title":{},"body":{"interfaces/FederatedSignonCertsResponse.html":{},"interfaces/GetAccessTokenCallback.html":{},"interfaces/GetAccessTokenResponse.html":{},"interfaces/GetFederatedSignonCertsCallback.html":{},"interfaces/GetTokenCallback.html":{},"interfaces/GetTokenOptions.html":{},"interfaces/GetTokenResponse.html":{},"interfaces/OAuth2ClientOptions.html":{},"interfaces/RefreshAccessTokenCallback.html":{},"interfaces/RefreshAccessTokenResponse.html":{},"interfaces/RefreshOptions.html":{},"interfaces/RequestMetadataCallback.html":{},"interfaces/RequestMetadataResponse.html":{},"interfaces/RevokeCredentialsResult.html":{},"interfaces/TokenInfo.html":{},"interfaces/TokenInfoRequest.html":{},"interfaces/VerifyIdTokenOptions.html":{}}}],["iss",{"_index":1260,"title":{},"body":{"classes/JWTAccess.html":{},"interfaces/JWTOptions.html":{},"classes/LoginTicket.html":{},"interfaces/TokenPayload.html":{}}}],["issu",{"_index":1364,"title":{},"body":{"classes/LoginTicket.html":{},"interfaces/TokenPayload.html":{},"changelog.html":{},"license.html":{}}}],["issuer",{"_index":953,"title":{},"body":{"interfaces/FederatedSignonCertsResponse.html":{},"interfaces/GetAccessTokenCallback.html":{},"interfaces/GetAccessTokenResponse.html":{},"interfaces/GetFederatedSignonCertsCallback.html":{},"interfaces/GetTokenCallback.html":{},"interfaces/GetTokenOptions.html":{},"interfaces/GetTokenResponse.html":{},"classes/LoginTicket.html":{},"interfaces/OAuth2ClientOptions.html":{},"interfaces/RefreshAccessTokenCallback.html":{},"interfaces/RefreshAccessTokenResponse.html":{},"interfaces/RefreshOptions.html":{},"interfaces/RequestMetadataCallback.html":{},"interfaces/RequestMetadataResponse.html":{},"interfaces/RevokeCredentialsResult.html":{},"interfaces/TokenInfo.html":{},"interfaces/TokenInfoRequest.html":{},"interfaces/TokenPayload.html":{},"interfaces/VerifyIdTokenOptions.html":{}}}],["issuers.indexof(payload.iss",{"_index":1173,"title":{},"body":{"interfaces/FederatedSignonCertsResponse.html":{},"interfaces/GetAccessTokenCallback.html":{},"interfaces/GetAccessTokenResponse.html":{},"interfaces/GetFederatedSignonCertsCallback.html":{},"interfaces/GetTokenCallback.html":{},"interfaces/GetTokenOptions.html":{},"interfaces/GetTokenResponse.html":{},"interfaces/OAuth2ClientOptions.html":{},"interfaces/RefreshAccessTokenCallback.html":{},"interfaces/RefreshAccessTokenResponse.html":{},"interfaces/RefreshOptions.html":{},"interfaces/RequestMetadataCallback.html":{},"interfaces/RequestMetadataResponse.html":{},"interfaces/RevokeCredentialsResult.html":{},"interfaces/TokenInfo.html":{},"interfaces/TokenInfoRequest.html":{},"interfaces/VerifyIdTokenOptions.html":{}}}],["issuers_",{"_index":954,"title":{},"body":{"interfaces/FederatedSignonCertsResponse.html":{},"interfaces/GetAccessTokenCallback.html":{},"interfaces/GetAccessTokenResponse.html":{},"interfaces/GetFederatedSignonCertsCallback.html":{},"interfaces/GetTokenCallback.html":{},"interfaces/GetTokenOptions.html":{},"interfaces/GetTokenResponse.html":{},"interfaces/OAuth2ClientOptions.html":{},"interfaces/RefreshAccessTokenCallback.html":{},"interfaces/RefreshAccessTokenResponse.html":{},"interfaces/RefreshOptions.html":{},"interfaces/RequestMetadataCallback.html":{},"interfaces/RequestMetadataResponse.html":{},"interfaces/RevokeCredentialsResult.html":{},"interfaces/TokenInfo.html":{},"interfaces/TokenInfoRequest.html":{},"interfaces/VerifyIdTokenOptions.html":{}}}],["istokenexpir",{"_index":1188,"title":{},"body":{"interfaces/FederatedSignonCertsResponse.html":{},"interfaces/GetAccessTokenCallback.html":{},"interfaces/GetAccessTokenResponse.html":{},"interfaces/GetFederatedSignonCertsCallback.html":{},"interfaces/GetTokenCallback.html":{},"interfaces/GetTokenOptions.html":{},"interfaces/GetTokenResponse.html":{},"interfaces/OAuth2ClientOptions.html":{},"interfaces/RefreshAccessTokenCallback.html":{},"interfaces/RefreshAccessTokenResponse.html":{},"interfaces/RefreshOptions.html":{},"interfaces/RequestMetadataCallback.html":{},"interfaces/RequestMetadataResponse.html":{},"interfaces/RevokeCredentialsResult.html":{},"interfaces/TokenInfo.html":{},"interfaces/TokenInfoRequest.html":{},"interfaces/VerifyIdTokenOptions.html":{}}}],["it'",{"_index":970,"title":{},"body":{"interfaces/FederatedSignonCertsResponse.html":{},"interfaces/GetAccessTokenCallback.html":{},"interfaces/GetAccessTokenResponse.html":{},"interfaces/GetFederatedSignonCertsCallback.html":{},"interfaces/GetTokenCallback.html":{},"interfaces/GetTokenOptions.html":{},"interfaces/GetTokenResponse.html":{},"interfaces/OAuth2ClientOptions.html":{},"interfaces/RefreshAccessTokenCallback.html":{},"interfaces/RefreshAccessTokenResponse.html":{},"interfaces/RefreshOptions.html":{},"interfaces/RequestMetadataCallback.html":{},"interfaces/RequestMetadataResponse.html":{},"interfaces/RevokeCredentialsResult.html":{},"interfaces/TokenInfo.html":{},"interfaces/TokenInfoRequest.html":{},"interfaces/VerifyIdTokenOptions.html":{}}}],["item2",{"_index":385,"title":{},"body":{"interfaces/ADCCallback.html":{},"interfaces/ADCResponse.html":{},"interfaces/CredentialCallback.html":{},"interfaces/GoogleAuthOptions.html":{},"interfaces/ProjectIdCallback.html":{},"interfaces/SignBlobResponse.html":{}}}],["januari",{"_index":1817,"title":{},"body":{"license.html":{}}}],["join",{"_index":381,"title":{},"body":{"interfaces/ADCCallback.html":{},"interfaces/ADCResponse.html":{},"interfaces/CredentialCallback.html":{},"interfaces/GoogleAuthOptions.html":{},"interfaces/ProjectIdCallback.html":{},"interfaces/SignBlobResponse.html":{},"interfaces/Warning.html":{},"miscellaneous/variables.html":{}}}],["json",{"_index":62,"title":{},"body":{"interfaces/ADCCallback.html":{},"interfaces/ADCResponse.html":{},"interfaces/CredentialCallback.html":{},"interfaces/GoogleAuthOptions.html":{},"classes/JWTAccess.html":{},"interfaces/JWTOptions.html":{},"interfaces/ProjectIdCallback.html":{},"interfaces/SignBlobResponse.html":{},"interfaces/UserRefreshClientOptions.html":{},"index.html":{}}}],["json.client_email",{"_index":1271,"title":{},"body":{"classes/JWTAccess.html":{},"interfaces/JWTOptions.html":{}}}],["json.client_id",{"_index":1410,"title":{},"body":{"interfaces/UserRefreshClientOptions.html":{}}}],["json.client_secret",{"_index":1411,"title":{},"body":{"interfaces/UserRefreshClientOptions.html":{}}}],["json.parse(",{"_index":351,"title":{},"body":{"interfaces/ADCCallback.html":{},"interfaces/ADCResponse.html":{},"interfaces/CredentialCallback.html":{},"interfaces/GoogleAuthOptions.html":{},"classes/JWTAccess.html":{},"interfaces/JWTOptions.html":{},"interfaces/ProjectIdCallback.html":{},"interfaces/SignBlobResponse.html":{},"interfaces/UserRefreshClientOptions.html":{}}}],["json.parse(keysenvvar",{"_index":1799,"title":{},"body":{"index.html":{}}}],["json.parse(stdout).configuration.properties.core.project",{"_index":401,"title":{},"body":{"interfaces/ADCCallback.html":{},"interfaces/ADCResponse.html":{},"interfaces/CredentialCallback.html":{},"interfaces/GoogleAuthOptions.html":{},"interfaces/ProjectIdCallback.html":{},"interfaces/SignBlobResponse.html":{}}}],["json.private_key",{"_index":1272,"title":{},"body":{"classes/JWTAccess.html":{},"interfaces/JWTOptions.html":{}}}],["json.private_key_id",{"_index":1275,"title":{},"body":{"classes/JWTAccess.html":{},"interfaces/JWTOptions.html":{}}}],["json.project_id",{"_index":1277,"title":{},"body":{"classes/JWTAccess.html":{},"interfaces/JWTOptions.html":{}}}],["json.refresh_token",{"_index":1412,"title":{},"body":{"interfaces/UserRefreshClientOptions.html":{}}}],["json.stringify(payload",{"_index":1167,"title":{},"body":{"interfaces/FederatedSignonCertsResponse.html":{},"interfaces/GetAccessTokenCallback.html":{},"interfaces/GetAccessTokenResponse.html":{},"interfaces/GetFederatedSignonCertsCallback.html":{},"interfaces/GetTokenCallback.html":{},"interfaces/GetTokenOptions.html":{},"interfaces/GetTokenResponse.html":{},"interfaces/OAuth2ClientOptions.html":{},"interfaces/RefreshAccessTokenCallback.html":{},"interfaces/RefreshAccessTokenResponse.html":{},"interfaces/RefreshOptions.html":{},"interfaces/RequestMetadataCallback.html":{},"interfaces/RequestMetadataResponse.html":{},"interfaces/RevokeCredentialsResult.html":{},"interfaces/TokenInfo.html":{},"interfaces/TokenInfoRequest.html":{},"interfaces/VerifyIdTokenOptions.html":{}}}],["json.typ",{"_index":331,"title":{},"body":{"interfaces/ADCCallback.html":{},"interfaces/ADCResponse.html":{},"interfaces/CredentialCallback.html":{},"interfaces/GoogleAuthOptions.html":{},"interfaces/ProjectIdCallback.html":{},"interfaces/SignBlobResponse.html":{},"interfaces/UserRefreshClientOptions.html":{}}}],["jsoncont",{"_index":113,"title":{},"body":{"interfaces/ADCCallback.html":{},"interfaces/ADCResponse.html":{},"interfaces/CredentialCallback.html":{},"interfaces/GoogleAuthOptions.html":{},"interfaces/ProjectIdCallback.html":{},"interfaces/SignBlobResponse.html":{}}}],["jw",{"_index":1237,"title":{},"body":{"classes/JWTAccess.html":{},"dependencies.html":{}}}],["jws.header",{"_index":1240,"title":{},"body":{"classes/JWTAccess.html":{},"miscellaneous/variables.html":{}}}],["jws.sign({head",{"_index":1269,"title":{},"body":{"classes/JWTAccess.html":{}}}],["jwt",{"_index":46,"title":{},"body":{"interfaces/ADCCallback.html":{},"interfaces/ADCResponse.html":{},"interfaces/CredentialCallback.html":{},"interfaces/GoogleAuthOptions.html":{},"classes/JWTAccess.html":{},"interfaces/JWTOptions.html":{},"classes/LoginTicket.html":{},"interfaces/ProjectIdCallback.html":{},"interfaces/SignBlobResponse.html":{},"interfaces/TokenPayload.html":{},"interfaces/Warning.html":{},"changelog.html":{},"index.html":{},"miscellaneous/variables.html":{}}}],["jwt(option",{"_index":335,"title":{},"body":{"interfaces/ADCCallback.html":{},"interfaces/ADCResponse.html":{},"interfaces/CredentialCallback.html":{},"interfaces/GoogleAuthOptions.html":{},"interfaces/ProjectIdCallback.html":{},"interfaces/SignBlobResponse.html":{}}}],["jwt_access_create_scoped_deprec",{"_index":1448,"title":{},"body":{"interfaces/Warning.html":{},"miscellaneous/variables.html":{}}}],["jwt_access_get_request_metadata_deprec",{"_index":1454,"title":{},"body":{"interfaces/Warning.html":{},"miscellaneous/variables.html":{}}}],["jwt_create_scoped_deprec",{"_index":1444,"title":{},"body":{"interfaces/Warning.html":{},"miscellaneous/variables.html":{}}}],["jwtaccess",{"_index":1217,"title":{"classes/JWTAccess.html":{}},"body":{"classes/JWTAccess.html":{},"interfaces/JWTOptions.html":{},"interfaces/Warning.html":{},"changelog.html":{},"miscellaneous/variables.html":{}}}],["jwtaccess(this.email",{"_index":1309,"title":{},"body":{"interfaces/JWTOptions.html":{}}}],["jwtclient",{"_index":48,"title":{},"body":{"interfaces/ADCCallback.html":{},"interfaces/ADCResponse.html":{},"interfaces/CredentialCallback.html":{},"interfaces/GoogleAuthOptions.html":{},"interfaces/ProjectIdCallback.html":{},"interfaces/SignBlobResponse.html":{}}}],["jwtinput",{"_index":42,"title":{"interfaces/JWTInput.html":{}},"body":{"interfaces/ADCCallback.html":{},"interfaces/ADCResponse.html":{},"interfaces/CredentialBody.html":{},"interfaces/CredentialCallback.html":{},"interfaces/CredentialRequest.html":{},"interfaces/Credentials.html":{},"interfaces/GoogleAuthOptions.html":{},"classes/JWTAccess.html":{},"interfaces/JWTInput.html":{},"interfaces/JWTOptions.html":{},"interfaces/ProjectIdCallback.html":{},"interfaces/SignBlobResponse.html":{},"interfaces/UserRefreshClientOptions.html":{}}}],["jwtinput|nul",{"_index":114,"title":{},"body":{"interfaces/ADCCallback.html":{},"interfaces/ADCResponse.html":{},"interfaces/CredentialCallback.html":{},"interfaces/GoogleAuthOptions.html":{},"interfaces/ProjectIdCallback.html":{},"interfaces/SignBlobResponse.html":{}}}],["jwtoption",{"_index":47,"title":{"interfaces/JWTOptions.html":{}},"body":{"interfaces/ADCCallback.html":{},"interfaces/ADCResponse.html":{},"interfaces/CredentialCallback.html":{},"interfaces/GoogleAuthOptions.html":{},"interfaces/JWTOptions.html":{},"interfaces/ProjectIdCallback.html":{},"interfaces/SignBlobResponse.html":{}}}],["jwtoptions).scop",{"_index":334,"title":{},"body":{"interfaces/ADCCallback.html":{},"interfaces/ADCResponse.html":{},"interfaces/CredentialCallback.html":{},"interfaces/GoogleAuthOptions.html":{},"interfaces/ProjectIdCallback.html":{},"interfaces/SignBlobResponse.html":{}}}],["jwt|userrefreshcli",{"_index":329,"title":{},"body":{"interfaces/ADCCallback.html":{},"interfaces/ADCResponse.html":{},"interfaces/CredentialCallback.html":{},"interfaces/GoogleAuthOptions.html":{},"interfaces/ProjectIdCallback.html":{},"interfaces/SignBlobResponse.html":{}}}],["jwt|userrefreshclient|compute|nul",{"_index":116,"title":{},"body":{"interfaces/ADCCallback.html":{},"interfaces/ADCResponse.html":{},"interfaces/CredentialCallback.html":{},"interfaces/GoogleAuthOptions.html":{},"interfaces/ProjectIdCallback.html":{},"interfaces/SignBlobResponse.html":{}}}],["jwt|userrefreshclient|nul",{"_index":211,"title":{},"body":{"interfaces/ADCCallback.html":{},"interfaces/ADCResponse.html":{},"interfaces/CredentialCallback.html":{},"interfaces/GoogleAuthOptions.html":{},"interfaces/ProjectIdCallback.html":{},"interfaces/SignBlobResponse.html":{}}}],["kept",{"_index":1724,"title":{},"body":{"index.html":{}}}],["key",{"_index":65,"title":{},"body":{"interfaces/ADCCallback.html":{},"interfaces/ADCResponse.html":{},"interfaces/CredentialCallback.html":{},"interfaces/FederatedSignonCertsResponse.html":{},"interfaces/GetAccessTokenCallback.html":{},"interfaces/GetAccessTokenResponse.html":{},"interfaces/GetFederatedSignonCertsCallback.html":{},"interfaces/GetTokenCallback.html":{},"interfaces/GetTokenOptions.html":{},"interfaces/GetTokenResponse.html":{},"interfaces/GoogleAuthOptions.html":{},"classes/JWTAccess.html":{},"interfaces/JWTOptions.html":{},"classes/LoginTicket.html":{},"interfaces/OAuth2ClientOptions.html":{},"interfaces/ProjectIdCallback.html":{},"interfaces/RefreshAccessTokenCallback.html":{},"interfaces/RefreshAccessTokenResponse.html":{},"interfaces/RefreshOptions.html":{},"interfaces/RequestMetadataCallback.html":{},"interfaces/RequestMetadataResponse.html":{},"interfaces/RevokeCredentialsResult.html":{},"interfaces/SignBlobResponse.html":{},"interfaces/TokenInfo.html":{},"interfaces/TokenInfoRequest.html":{},"interfaces/TokenPayload.html":{},"interfaces/VerifyIdTokenOptions.html":{},"index.html":{}}}],["key_id",{"_index":1289,"title":{},"body":{"interfaces/JWTOptions.html":{}}}],["keyfil",{"_index":67,"title":{},"body":{"interfaces/ADCCallback.html":{},"interfaces/ADCResponse.html":{},"interfaces/CredentialCallback.html":{},"interfaces/GoogleAuthOptions.html":{},"interfaces/JWTOptions.html":{},"interfaces/ProjectIdCallback.html":{},"interfaces/SignBlobResponse.html":{}}}],["keyfilenam",{"_index":66,"title":{},"body":{"interfaces/ADCCallback.html":{},"interfaces/ADCResponse.html":{},"interfaces/CredentialCallback.html":{},"interfaces/GoogleAuthOptions.html":{},"interfaces/ProjectIdCallback.html":{},"interfaces/SignBlobResponse.html":{}}}],["keyid",{"_index":1219,"title":{},"body":{"classes/JWTAccess.html":{},"interfaces/JWTOptions.html":{}}}],["keys.client_email",{"_index":1781,"title":{},"body":{"index.html":{}}}],["keys.json",{"_index":1725,"title":{},"body":{"index.html":{}}}],["keys.private_key",{"_index":1782,"title":{},"body":{"index.html":{}}}],["keys.web.client_id",{"_index":1726,"title":{},"body":{"index.html":{}}}],["keys.web.client_secret",{"_index":1727,"title":{},"body":{"index.html":{}}}],["keys.web.redirect_uris[0",{"_index":1728,"title":{},"body":{"index.html":{}}}],["keysenvvar",{"_index":1797,"title":{},"body":{"index.html":{}}}],["kid",{"_index":1265,"title":{},"body":{"classes/JWTAccess.html":{}}}],["kind",{"_index":672,"title":{},"body":{"interfaces/Credentials.html":{},"classes/LoginTicket.html":{},"miscellaneous/functions.html":{},"license.html":{}}}],["kitchen",{"_index":1499,"title":{},"body":{"changelog.html":{}}}],["know",{"_index":857,"title":{},"body":{"interfaces/FederatedSignonCertsResponse.html":{},"interfaces/GetAccessTokenCallback.html":{},"interfaces/GetAccessTokenResponse.html":{},"interfaces/GetFederatedSignonCertsCallback.html":{},"interfaces/GetTokenCallback.html":{},"interfaces/GetTokenOptions.html":{},"interfaces/GetTokenResponse.html":{},"interfaces/OAuth2ClientOptions.html":{},"interfaces/RefreshAccessTokenCallback.html":{},"interfaces/RefreshAccessTokenResponse.html":{},"interfaces/RefreshOptions.html":{},"interfaces/RequestMetadataCallback.html":{},"interfaces/RequestMetadataResponse.html":{},"interfaces/RevokeCredentialsResult.html":{},"interfaces/TokenInfo.html":{},"interfaces/TokenInfoRequest.html":{},"interfaces/VerifyIdTokenOptions.html":{},"changelog.html":{}}}],["known",{"_index":226,"title":{},"body":{"interfaces/ADCCallback.html":{},"interfaces/ADCResponse.html":{},"interfaces/CredentialCallback.html":{},"interfaces/GoogleAuthOptions.html":{},"interfaces/ProjectIdCallback.html":{},"interfaces/SignBlobResponse.html":{}}}],["kokoro",{"_index":1508,"title":{},"body":{"changelog.html":{}}}],["kubernetes_engin",{"_index":1654,"title":{},"body":{"miscellaneous/enumerations.html":{}}}],["land",{"_index":958,"title":{},"body":{"interfaces/FederatedSignonCertsResponse.html":{},"interfaces/GetAccessTokenCallback.html":{},"interfaces/GetAccessTokenResponse.html":{},"interfaces/GetFederatedSignonCertsCallback.html":{},"interfaces/GetTokenCallback.html":{},"interfaces/GetTokenOptions.html":{},"interfaces/GetTokenResponse.html":{},"interfaces/OAuth2ClientOptions.html":{},"interfaces/RefreshAccessTokenCallback.html":{},"interfaces/RefreshAccessTokenResponse.html":{},"interfaces/RefreshOptions.html":{},"interfaces/RequestMetadataCallback.html":{},"interfaces/RequestMetadataResponse.html":{},"interfaces/RevokeCredentialsResult.html":{},"interfaces/TokenInfo.html":{},"interfaces/TokenInfoRequest.html":{},"interfaces/VerifyIdTokenOptions.html":{}}}],["languag",{"_index":676,"title":{},"body":{"interfaces/Credentials.html":{},"classes/LoginTicket.html":{},"miscellaneous/functions.html":{},"license.html":{}}}],["larg",{"_index":1545,"title":{},"body":{"changelog.html":{}}}],["late",{"_index":1172,"title":{},"body":{"interfaces/FederatedSignonCertsResponse.html":{},"interfaces/GetAccessTokenCallback.html":{},"interfaces/GetAccessTokenResponse.html":{},"interfaces/GetFederatedSignonCertsCallback.html":{},"interfaces/GetTokenCallback.html":{},"interfaces/GetTokenOptions.html":{},"interfaces/GetTokenResponse.html":{},"interfaces/OAuth2ClientOptions.html":{},"interfaces/RefreshAccessTokenCallback.html":{},"interfaces/RefreshAccessTokenResponse.html":{},"interfaces/RefreshOptions.html":{},"interfaces/RequestMetadataCallback.html":{},"interfaces/RequestMetadataResponse.html":{},"interfaces/RevokeCredentialsResult.html":{},"interfaces/TokenInfo.html":{},"interfaces/TokenInfoRequest.html":{},"interfaces/VerifyIdTokenOptions.html":{}}}],["later",{"_index":1118,"title":{},"body":{"interfaces/FederatedSignonCertsResponse.html":{},"interfaces/GetAccessTokenCallback.html":{},"interfaces/GetAccessTokenResponse.html":{},"interfaces/GetFederatedSignonCertsCallback.html":{},"interfaces/GetTokenCallback.html":{},"interfaces/GetTokenOptions.html":{},"interfaces/GetTokenResponse.html":{},"interfaces/OAuth2ClientOptions.html":{},"interfaces/RefreshAccessTokenCallback.html":{},"interfaces/RefreshAccessTokenResponse.html":{},"interfaces/RefreshOptions.html":{},"interfaces/RequestMetadataCallback.html":{},"interfaces/RequestMetadataResponse.html":{},"interfaces/RevokeCredentialsResult.html":{},"interfaces/TokenInfo.html":{},"interfaces/TokenInfoRequest.html":{},"interfaces/VerifyIdTokenOptions.html":{},"index.html":{}}}],["latest",{"_index":1171,"title":{},"body":{"interfaces/FederatedSignonCertsResponse.html":{},"interfaces/GetAccessTokenCallback.html":{},"interfaces/GetAccessTokenResponse.html":{},"interfaces/GetFederatedSignonCertsCallback.html":{},"interfaces/GetTokenCallback.html":{},"interfaces/GetTokenOptions.html":{},"interfaces/GetTokenResponse.html":{},"interfaces/OAuth2ClientOptions.html":{},"interfaces/RefreshAccessTokenCallback.html":{},"interfaces/RefreshAccessTokenResponse.html":{},"interfaces/RefreshOptions.html":{},"interfaces/RequestMetadataCallback.html":{},"interfaces/RequestMetadataResponse.html":{},"interfaces/RevokeCredentialsResult.html":{},"interfaces/TokenInfo.html":{},"interfaces/TokenInfoRequest.html":{},"interfaces/VerifyIdTokenOptions.html":{},"changelog.html":{}}}],["law",{"_index":664,"title":{},"body":{"interfaces/Credentials.html":{},"classes/LoginTicket.html":{},"miscellaneous/functions.html":{},"license.html":{}}}],["lawsuit",{"_index":1907,"title":{},"body":{"license.html":{}}}],["layer",{"_index":91,"title":{},"body":{"interfaces/ADCCallback.html":{},"interfaces/ADCResponse.html":{},"interfaces/CredentialCallback.html":{},"interfaces/GoogleAuthOptions.html":{},"interfaces/ProjectIdCallback.html":{},"interfaces/SignBlobResponse.html":{}}}],["lead",{"_index":521,"title":{},"body":{"interfaces/BodyResponseCallback.html":{},"classes/DefaultTransporter.html":{},"interfaces/RequestError.html":{},"interfaces/Transporter.html":{}}}],["legal",{"_index":1828,"title":{},"body":{"license.html":{}}}],["length",{"_index":1315,"title":{},"body":{"interfaces/JWTOptions.html":{}}}],["less",{"_index":1132,"title":{},"body":{"interfaces/FederatedSignonCertsResponse.html":{},"interfaces/GetAccessTokenCallback.html":{},"interfaces/GetAccessTokenResponse.html":{},"interfaces/GetFederatedSignonCertsCallback.html":{},"interfaces/GetTokenCallback.html":{},"interfaces/GetTokenOptions.html":{},"interfaces/GetTokenResponse.html":{},"interfaces/OAuth2ClientOptions.html":{},"interfaces/RefreshAccessTokenCallback.html":{},"interfaces/RefreshAccessTokenResponse.html":{},"interfaces/RefreshOptions.html":{},"interfaces/RequestMetadataCallback.html":{},"interfaces/RequestMetadataResponse.html":{},"interfaces/RevokeCredentialsResult.html":{},"interfaces/TokenInfo.html":{},"interfaces/TokenInfoRequest.html":{},"interfaces/VerifyIdTokenOptions.html":{}}}],["let",{"_index":710,"title":{},"body":{"interfaces/FederatedSignonCertsResponse.html":{},"interfaces/GetAccessTokenCallback.html":{},"interfaces/GetAccessTokenResponse.html":{},"interfaces/GetFederatedSignonCertsCallback.html":{},"interfaces/GetTokenCallback.html":{},"interfaces/GetTokenOptions.html":{},"interfaces/GetTokenResponse.html":{},"interfaces/OAuth2ClientOptions.html":{},"interfaces/RefreshAccessTokenCallback.html":{},"interfaces/RefreshAccessTokenResponse.html":{},"interfaces/RefreshOptions.html":{},"interfaces/RequestMetadataCallback.html":{},"interfaces/RequestMetadataResponse.html":{},"interfaces/RevokeCredentialsResult.html":{},"interfaces/TokenInfo.html":{},"interfaces/TokenInfoRequest.html":{},"interfaces/VerifyIdTokenOptions.html":{}}}],["let'",{"_index":1707,"title":{},"body":{"index.html":{}}}],["level",{"_index":190,"title":{},"body":{"interfaces/ADCCallback.html":{},"interfaces/ADCResponse.html":{},"interfaces/CredentialCallback.html":{},"interfaces/GoogleAuthOptions.html":{},"interfaces/ProjectIdCallback.html":{},"interfaces/SignBlobResponse.html":{},"index.html":{}}}],["liabil",{"_index":1954,"title":{},"body":{"license.html":{}}}],["liabl",{"_index":1960,"title":{},"body":{"license.html":{}}}],["librari",{"_index":1441,"title":{},"body":{"interfaces/Warning.html":{},"changelog.html":{},"index.html":{},"miscellaneous/variables.html":{}}}],["library:00001",{"_index":1432,"title":{},"body":{"interfaces/Warning.html":{},"miscellaneous/variables.html":{}}}],["library:dep002",{"_index":1439,"title":{},"body":{"interfaces/Warning.html":{},"miscellaneous/variables.html":{}}}],["library:dep003",{"_index":1443,"title":{},"body":{"interfaces/Warning.html":{},"miscellaneous/variables.html":{}}}],["library:dep004",{"_index":1445,"title":{},"body":{"interfaces/Warning.html":{},"miscellaneous/variables.html":{}}}],["library:dep005",{"_index":1447,"title":{},"body":{"interfaces/Warning.html":{},"miscellaneous/variables.html":{}}}],["library:dep006",{"_index":1449,"title":{},"body":{"interfaces/Warning.html":{},"miscellaneous/variables.html":{}}}],["library:dep007",{"_index":1451,"title":{},"body":{"interfaces/Warning.html":{},"miscellaneous/variables.html":{}}}],["libraryupgrad",{"_index":1666,"title":{},"body":{"index.html":{}}}],["licens",{"_index":654,"title":{"license.html":{}},"body":{"interfaces/Credentials.html":{},"classes/LoginTicket.html":{},"miscellaneous/functions.html":{},"index.html":{},"license.html":{}}}],["license.y",{"_index":1933,"title":{},"body":{"license.html":{}}}],["licensor",{"_index":1825,"title":{},"body":{"license.html":{}}}],["lifetim",{"_index":949,"title":{},"body":{"interfaces/FederatedSignonCertsResponse.html":{},"interfaces/GetAccessTokenCallback.html":{},"interfaces/GetAccessTokenResponse.html":{},"interfaces/GetFederatedSignonCertsCallback.html":{},"interfaces/GetTokenCallback.html":{},"interfaces/GetTokenOptions.html":{},"interfaces/GetTokenResponse.html":{},"interfaces/OAuth2ClientOptions.html":{},"interfaces/RefreshAccessTokenCallback.html":{},"interfaces/RefreshAccessTokenResponse.html":{},"interfaces/RefreshOptions.html":{},"interfaces/RequestMetadataCallback.html":{},"interfaces/RequestMetadataResponse.html":{},"interfaces/RevokeCredentialsResult.html":{},"interfaces/TokenInfo.html":{},"interfaces/TokenInfoRequest.html":{},"interfaces/VerifyIdTokenOptions.html":{}}}],["lift",{"_index":1403,"title":{},"body":{"interfaces/UserRefreshClientOptions.html":{}}}],["likelihood",{"_index":800,"title":{},"body":{"interfaces/FederatedSignonCertsResponse.html":{},"interfaces/GetAccessTokenCallback.html":{},"interfaces/GetAccessTokenResponse.html":{},"interfaces/GetFederatedSignonCertsCallback.html":{},"interfaces/GetTokenCallback.html":{},"interfaces/GetTokenOptions.html":{},"interfaces/GetTokenResponse.html":{},"interfaces/OAuth2ClientOptions.html":{},"interfaces/RefreshAccessTokenCallback.html":{},"interfaces/RefreshAccessTokenResponse.html":{},"interfaces/RefreshOptions.html":{},"interfaces/RequestMetadataCallback.html":{},"interfaces/RequestMetadataResponse.html":{},"interfaces/RevokeCredentialsResult.html":{},"interfaces/TokenInfo.html":{},"interfaces/TokenInfoRequest.html":{},"interfaces/VerifyIdTokenOptions.html":{}}}],["limit",{"_index":316,"title":{},"body":{"interfaces/ADCCallback.html":{},"interfaces/ADCResponse.html":{},"interfaces/CredentialCallback.html":{},"interfaces/Credentials.html":{},"interfaces/GoogleAuthOptions.html":{},"classes/LoginTicket.html":{},"interfaces/ProjectIdCallback.html":{},"interfaces/SignBlobResponse.html":{},"miscellaneous/functions.html":{},"license.html":{}}}],["line",{"_index":468,"title":{},"body":{"interfaces/ADCCallback.html":{},"interfaces/ADCResponse.html":{},"interfaces/BodyResponseCallback.html":{},"interfaces/CredentialCallback.html":{},"classes/DefaultTransporter.html":{},"interfaces/GoogleAuthOptions.html":{},"interfaces/JWTOptions.html":{},"interfaces/ProjectIdCallback.html":{},"interfaces/RequestError.html":{},"interfaces/SignBlobResponse.html":{},"interfaces/Transporter.html":{},"interfaces/Warning.html":{}}}],["link",{"_index":1564,"title":{},"body":{"changelog.html":{},"license.html":{}}}],["linux",{"_index":271,"title":{},"body":{"interfaces/ADCCallback.html":{},"interfaces/ADCResponse.html":{},"interfaces/CredentialCallback.html":{},"interfaces/GoogleAuthOptions.html":{},"interfaces/ProjectIdCallback.html":{},"interfaces/SignBlobResponse.html":{}}}],["list",{"_index":784,"title":{},"body":{"interfaces/FederatedSignonCertsResponse.html":{},"interfaces/GetAccessTokenCallback.html":{},"interfaces/GetAccessTokenResponse.html":{},"interfaces/GetFederatedSignonCertsCallback.html":{},"interfaces/GetTokenCallback.html":{},"interfaces/GetTokenOptions.html":{},"interfaces/GetTokenResponse.html":{},"interfaces/JWTOptions.html":{},"interfaces/OAuth2ClientOptions.html":{},"interfaces/RefreshAccessTokenCallback.html":{},"interfaces/RefreshAccessTokenResponse.html":{},"interfaces/RefreshOptions.html":{},"interfaces/RequestMetadataCallback.html":{},"interfaces/RequestMetadataResponse.html":{},"interfaces/RevokeCredentialsResult.html":{},"interfaces/TokenInfo.html":{},"interfaces/TokenInfoRequest.html":{},"interfaces/VerifyIdTokenOptions.html":{},"index.html":{},"license.html":{}}}],["listen(3000",{"_index":1748,"title":{},"body":{"index.html":{}}}],["liter",{"_index":1283,"title":{},"body":{"interfaces/JWTOptions.html":{},"miscellaneous/typealiases.html":{}}}],["litig",{"_index":1905,"title":{},"body":{"license.html":{}}}],["load",{"_index":239,"title":{},"body":{"interfaces/ADCCallback.html":{},"interfaces/ADCResponse.html":{},"interfaces/CredentialCallback.html":{},"interfaces/GoogleAuthOptions.html":{},"interfaces/ProjectIdCallback.html":{},"interfaces/SignBlobResponse.html":{},"index.html":{}}}],["loader",{"_index":1615,"title":{},"body":{"changelog.html":{}}}],["local",{"_index":214,"title":{},"body":{"interfaces/ADCCallback.html":{},"interfaces/ADCResponse.html":{},"interfaces/CredentialCallback.html":{},"interfaces/GoogleAuthOptions.html":{},"interfaces/ProjectIdCallback.html":{},"interfaces/SignBlobResponse.html":{},"index.html":{}}}],["locat",{"_index":216,"title":{},"body":{"interfaces/ADCCallback.html":{},"interfaces/ADCResponse.html":{},"interfaces/CredentialCallback.html":{},"interfaces/GoogleAuthOptions.html":{},"interfaces/ProjectIdCallback.html":{},"interfaces/SignBlobResponse.html":{}}}],["lock",{"_index":1607,"title":{},"body":{"changelog.html":{}}}],["lock.json",{"_index":1603,"title":{},"body":{"changelog.html":{}}}],["log",{"_index":718,"title":{},"body":{"interfaces/FederatedSignonCertsResponse.html":{},"interfaces/GetAccessTokenCallback.html":{},"interfaces/GetAccessTokenResponse.html":{},"interfaces/GetFederatedSignonCertsCallback.html":{},"interfaces/GetTokenCallback.html":{},"interfaces/GetTokenOptions.html":{},"interfaces/GetTokenResponse.html":{},"interfaces/OAuth2ClientOptions.html":{},"interfaces/RefreshAccessTokenCallback.html":{},"interfaces/RefreshAccessTokenResponse.html":{},"interfaces/RefreshOptions.html":{},"interfaces/RequestMetadataCallback.html":{},"interfaces/RequestMetadataResponse.html":{},"interfaces/RevokeCredentialsResult.html":{},"interfaces/TokenInfo.html":{},"interfaces/TokenInfoRequest.html":{},"interfaces/VerifyIdTokenOptions.html":{}}}],["login",{"_index":759,"title":{},"body":{"interfaces/FederatedSignonCertsResponse.html":{},"interfaces/GetAccessTokenCallback.html":{},"interfaces/GetAccessTokenResponse.html":{},"interfaces/GetFederatedSignonCertsCallback.html":{},"interfaces/GetTokenCallback.html":{},"interfaces/GetTokenOptions.html":{},"interfaces/GetTokenResponse.html":{},"classes/LoginTicket.html":{},"interfaces/OAuth2ClientOptions.html":{},"interfaces/RefreshAccessTokenCallback.html":{},"interfaces/RefreshAccessTokenResponse.html":{},"interfaces/RefreshOptions.html":{},"interfaces/RequestMetadataCallback.html":{},"interfaces/RequestMetadataResponse.html":{},"interfaces/RevokeCredentialsResult.html":{},"interfaces/TokenInfo.html":{},"interfaces/TokenInfoRequest.html":{},"interfaces/TokenPayload.html":{},"interfaces/VerifyIdTokenOptions.html":{}}}],["login_hint",{"_index":865,"title":{},"body":{"interfaces/FederatedSignonCertsResponse.html":{},"interfaces/GetAccessTokenCallback.html":{},"interfaces/GetAccessTokenResponse.html":{},"interfaces/GetFederatedSignonCertsCallback.html":{},"interfaces/GetTokenCallback.html":{},"interfaces/GetTokenOptions.html":{},"interfaces/GetTokenResponse.html":{},"interfaces/OAuth2ClientOptions.html":{},"interfaces/RefreshAccessTokenCallback.html":{},"interfaces/RefreshAccessTokenResponse.html":{},"interfaces/RefreshOptions.html":{},"interfaces/RequestMetadataCallback.html":{},"interfaces/RequestMetadataResponse.html":{},"interfaces/RevokeCredentialsResult.html":{},"interfaces/TokenInfo.html":{},"interfaces/TokenInfoRequest.html":{},"interfaces/VerifyIdTokenOptions.html":{}}}],["loginticket",{"_index":692,"title":{"classes/LoginTicket.html":{}},"body":{"interfaces/FederatedSignonCertsResponse.html":{},"interfaces/GetAccessTokenCallback.html":{},"interfaces/GetAccessTokenResponse.html":{},"interfaces/GetFederatedSignonCertsCallback.html":{},"interfaces/GetTokenCallback.html":{},"interfaces/GetTokenOptions.html":{},"interfaces/GetTokenResponse.html":{},"classes/LoginTicket.html":{},"interfaces/OAuth2ClientOptions.html":{},"interfaces/RefreshAccessTokenCallback.html":{},"interfaces/RefreshAccessTokenResponse.html":{},"interfaces/RefreshOptions.html":{},"interfaces/RequestMetadataCallback.html":{},"interfaces/RequestMetadataResponse.html":{},"interfaces/RevokeCredentialsResult.html":{},"interfaces/TokenInfo.html":{},"interfaces/TokenInfoRequest.html":{},"interfaces/TokenPayload.html":{},"interfaces/VerifyIdTokenOptions.html":{}}}],["loginticket(envelop",{"_index":1179,"title":{},"body":{"interfaces/FederatedSignonCertsResponse.html":{},"interfaces/GetAccessTokenCallback.html":{},"interfaces/GetAccessTokenResponse.html":{},"interfaces/GetFederatedSignonCertsCallback.html":{},"interfaces/GetTokenCallback.html":{},"interfaces/GetTokenOptions.html":{},"interfaces/GetTokenResponse.html":{},"interfaces/OAuth2ClientOptions.html":{},"interfaces/RefreshAccessTokenCallback.html":{},"interfaces/RefreshAccessTokenResponse.html":{},"interfaces/RefreshOptions.html":{},"interfaces/RequestMetadataCallback.html":{},"interfaces/RequestMetadataResponse.html":{},"interfaces/RevokeCredentialsResult.html":{},"interfaces/TokenInfo.html":{},"interfaces/TokenInfoRequest.html":{},"interfaces/VerifyIdTokenOptions.html":{}}}],["longer",{"_index":1538,"title":{},"body":{"changelog.html":{}}}],["look",{"_index":224,"title":{},"body":{"interfaces/ADCCallback.html":{},"interfaces/ADCResponse.html":{},"interfaces/CredentialCallback.html":{},"interfaces/GoogleAuthOptions.html":{},"interfaces/ProjectIdCallback.html":{},"interfaces/SignBlobResponse.html":{},"index.html":{}}}],["loss",{"_index":1967,"title":{},"body":{"license.html":{}}}],["lot",{"_index":1533,"title":{},"body":{"changelog.html":{}}}],["lru",{"_index":1238,"title":{},"body":{"classes/JWTAccess.html":{},"dependencies.html":{}}}],["lru({max",{"_index":1244,"title":{},"body":{"classes/JWTAccess.html":{}}}],["lstatsync",{"_index":295,"title":{},"body":{"interfaces/ADCCallback.html":{},"interfaces/ADCResponse.html":{},"interfaces/CredentialCallback.html":{},"interfaces/GoogleAuthOptions.html":{},"interfaces/ProjectIdCallback.html":{},"interfaces/SignBlobResponse.html":{}}}],["mac",{"_index":272,"title":{},"body":{"interfaces/ADCCallback.html":{},"interfaces/ADCResponse.html":{},"interfaces/CredentialCallback.html":{},"interfaces/GoogleAuthOptions.html":{},"interfaces/ProjectIdCallback.html":{},"interfaces/SignBlobResponse.html":{}}}],["machin",{"_index":1688,"title":{},"body":{"index.html":{}}}],["made",{"_index":593,"title":{},"body":{"interfaces/ComputeOptions.html":{},"license.html":{}}}],["mail",{"_index":1368,"title":{},"body":{"classes/LoginTicket.html":{},"interfaces/TokenPayload.html":{},"license.html":{}}}],["main",{"_index":1065,"title":{},"body":{"interfaces/FederatedSignonCertsResponse.html":{},"interfaces/GetAccessTokenCallback.html":{},"interfaces/GetAccessTokenResponse.html":{},"interfaces/GetFederatedSignonCertsCallback.html":{},"interfaces/GetTokenCallback.html":{},"interfaces/GetTokenOptions.html":{},"interfaces/GetTokenResponse.html":{},"interfaces/OAuth2ClientOptions.html":{},"interfaces/RefreshAccessTokenCallback.html":{},"interfaces/RefreshAccessTokenResponse.html":{},"interfaces/RefreshOptions.html":{},"interfaces/RequestMetadataCallback.html":{},"interfaces/RequestMetadataResponse.html":{},"interfaces/RevokeCredentialsResult.html":{},"interfaces/TokenInfo.html":{},"interfaces/TokenInfoRequest.html":{},"interfaces/VerifyIdTokenOptions.html":{},"index.html":{}}}],["main().catch(console.error);oauth2",{"_index":1697,"title":{},"body":{"index.html":{}}}],["main().catch(console.error);questions/problem",{"_index":1807,"title":{},"body":{"index.html":{}}}],["main().catch(console.error);th",{"_index":1785,"title":{},"body":{"index.html":{}}}],["main().catch(console.error);us",{"_index":1802,"title":{},"body":{"index.html":{}}}],["main();handl",{"_index":1750,"title":{},"body":{"index.html":{}}}],["maintain",{"_index":813,"title":{},"body":{"interfaces/FederatedSignonCertsResponse.html":{},"interfaces/GetAccessTokenCallback.html":{},"interfaces/GetAccessTokenResponse.html":{},"interfaces/GetFederatedSignonCertsCallback.html":{},"interfaces/GetTokenCallback.html":{},"interfaces/GetTokenOptions.html":{},"interfaces/GetTokenResponse.html":{},"interfaces/OAuth2ClientOptions.html":{},"interfaces/RefreshAccessTokenCallback.html":{},"interfaces/RefreshAccessTokenResponse.html":{},"interfaces/RefreshOptions.html":{},"interfaces/RequestMetadataCallback.html":{},"interfaces/RequestMetadataResponse.html":{},"interfaces/RevokeCredentialsResult.html":{},"interfaces/TokenInfo.html":{},"interfaces/TokenInfoRequest.html":{},"interfaces/VerifyIdTokenOptions.html":{}}}],["mainten",{"_index":1608,"title":{},"body":{"changelog.html":{}}}],["make",{"_index":290,"title":{},"body":{"interfaces/ADCCallback.html":{},"interfaces/ADCResponse.html":{},"interfaces/BodyResponseCallback.html":{},"interfaces/CredentialCallback.html":{},"classes/DefaultTransporter.html":{},"interfaces/FederatedSignonCertsResponse.html":{},"interfaces/GetAccessTokenCallback.html":{},"interfaces/GetAccessTokenResponse.html":{},"interfaces/GetFederatedSignonCertsCallback.html":{},"interfaces/GetTokenCallback.html":{},"interfaces/GetTokenOptions.html":{},"interfaces/GetTokenResponse.html":{},"interfaces/GoogleAuthOptions.html":{},"classes/IAMAuth.html":{},"interfaces/OAuth2ClientOptions.html":{},"interfaces/ProjectIdCallback.html":{},"interfaces/RefreshAccessTokenCallback.html":{},"interfaces/RefreshAccessTokenResponse.html":{},"interfaces/RefreshOptions.html":{},"interfaces/RequestError.html":{},"interfaces/RequestMetadata.html":{},"interfaces/RequestMetadataCallback.html":{},"interfaces/RequestMetadataResponse.html":{},"interfaces/RevokeCredentialsResult.html":{},"interfaces/SignBlobResponse.html":{},"interfaces/TokenInfo.html":{},"interfaces/TokenInfoRequest.html":{},"interfaces/Transporter.html":{},"interfaces/UserRefreshClientOptions.html":{},"interfaces/VerifyIdTokenOptions.html":{},"changelog.html":{},"index.html":{},"license.html":{}}}],["malfunct",{"_index":1971,"title":{},"body":{"license.html":{}}}],["manag",{"_index":719,"title":{},"body":{"interfaces/FederatedSignonCertsResponse.html":{},"interfaces/GetAccessTokenCallback.html":{},"interfaces/GetAccessTokenResponse.html":{},"interfaces/GetFederatedSignonCertsCallback.html":{},"interfaces/GetTokenCallback.html":{},"interfaces/GetTokenOptions.html":{},"interfaces/GetTokenResponse.html":{},"interfaces/OAuth2ClientOptions.html":{},"interfaces/RefreshAccessTokenCallback.html":{},"interfaces/RefreshAccessTokenResponse.html":{},"interfaces/RefreshOptions.html":{},"interfaces/RequestMetadataCallback.html":{},"interfaces/RequestMetadataResponse.html":{},"interfaces/RevokeCredentialsResult.html":{},"interfaces/TokenInfo.html":{},"interfaces/TokenInfoRequest.html":{},"interfaces/VerifyIdTokenOptions.html":{},"license.html":{}}}],["mani",{"_index":899,"title":{},"body":{"interfaces/FederatedSignonCertsResponse.html":{},"interfaces/GetAccessTokenCallback.html":{},"interfaces/GetAccessTokenResponse.html":{},"interfaces/GetFederatedSignonCertsCallback.html":{},"interfaces/GetTokenCallback.html":{},"interfaces/GetTokenOptions.html":{},"interfaces/GetTokenResponse.html":{},"interfaces/OAuth2ClientOptions.html":{},"interfaces/RefreshAccessTokenCallback.html":{},"interfaces/RefreshAccessTokenResponse.html":{},"interfaces/RefreshOptions.html":{},"interfaces/RequestMetadataCallback.html":{},"interfaces/RequestMetadataResponse.html":{},"interfaces/RevokeCredentialsResult.html":{},"interfaces/TokenInfo.html":{},"interfaces/TokenInfoRequest.html":{},"interfaces/VerifyIdTokenOptions.html":{}}}],["manual",{"_index":1555,"title":{},"body":{"changelog.html":{},"index.html":{}}}],["map",{"_index":909,"title":{},"body":{"interfaces/FederatedSignonCertsResponse.html":{},"interfaces/GetAccessTokenCallback.html":{},"interfaces/GetAccessTokenResponse.html":{},"interfaces/GetFederatedSignonCertsCallback.html":{},"interfaces/GetTokenCallback.html":{},"interfaces/GetTokenOptions.html":{},"interfaces/GetTokenResponse.html":{},"interfaces/OAuth2ClientOptions.html":{},"interfaces/RefreshAccessTokenCallback.html":{},"interfaces/RefreshAccessTokenResponse.html":{},"interfaces/RefreshOptions.html":{},"interfaces/RequestMetadataCallback.html":{},"interfaces/RequestMetadataResponse.html":{},"interfaces/RevokeCredentialsResult.html":{},"interfaces/TokenInfo.html":{},"interfaces/TokenInfoRequest.html":{},"interfaces/VerifyIdTokenOptions.html":{}}}],["mark",{"_index":1876,"title":{},"body":{"license.html":{}}}],["match",{"_index":495,"title":{},"body":{"interfaces/ADCCallback.html":{},"interfaces/ADCResponse.html":{},"interfaces/BodyResponseCallback.html":{},"interfaces/ComputeOptions.html":{},"interfaces/CredentialBody.html":{},"interfaces/CredentialCallback.html":{},"interfaces/CredentialRequest.html":{},"interfaces/Credentials.html":{},"classes/DefaultTransporter.html":{},"interfaces/FederatedSignonCertsResponse.html":{},"interfaces/GetAccessTokenCallback.html":{},"interfaces/GetAccessTokenResponse.html":{},"interfaces/GetFederatedSignonCertsCallback.html":{},"interfaces/GetTokenCallback.html":{},"interfaces/GetTokenOptions.html":{},"interfaces/GetTokenResponse.html":{},"interfaces/GoogleAuthOptions.html":{},"classes/IAMAuth.html":{},"classes/JWTAccess.html":{},"interfaces/JWTInput.html":{},"interfaces/JWTOptions.html":{},"classes/LoginTicket.html":{},"interfaces/OAuth2ClientOptions.html":{},"classes/PemVerifier.html":{},"interfaces/ProjectIdCallback.html":{},"interfaces/RefreshAccessTokenCallback.html":{},"interfaces/RefreshAccessTokenResponse.html":{},"interfaces/RefreshOptions.html":{},"interfaces/RequestError.html":{},"interfaces/RequestMetadata.html":{},"interfaces/RequestMetadataCallback.html":{},"interfaces/RequestMetadataResponse.html":{},"interfaces/RevokeCredentialsResult.html":{},"interfaces/SignBlobResponse.html":{},"interfaces/TokenInfo.html":{},"interfaces/TokenInfoRequest.html":{},"interfaces/TokenPayload.html":{},"interfaces/Transporter.html":{},"interfaces/UserRefreshClientOptions.html":{},"interfaces/VerifyIdTokenOptions.html":{},"interfaces/Warning.html":{},"changelog.html":{},"dependencies.html":{},"miscellaneous/enumerations.html":{},"miscellaneous/functions.html":{},"index.html":{},"license.html":{},"modules.html":{},"overview.html":{},"miscellaneous/typealiases.html":{},"miscellaneous/variables.html":{}}}],["math.floor(new",{"_index":1256,"title":{},"body":{"classes/JWTAccess.html":{}}}],["max",{"_index":948,"title":{},"body":{"interfaces/FederatedSignonCertsResponse.html":{},"interfaces/GetAccessTokenCallback.html":{},"interfaces/GetAccessTokenResponse.html":{},"interfaces/GetFederatedSignonCertsCallback.html":{},"interfaces/GetTokenCallback.html":{},"interfaces/GetTokenOptions.html":{},"interfaces/GetTokenResponse.html":{},"interfaces/OAuth2ClientOptions.html":{},"interfaces/RefreshAccessTokenCallback.html":{},"interfaces/RefreshAccessTokenResponse.html":{},"interfaces/RefreshOptions.html":{},"interfaces/RequestMetadataCallback.html":{},"interfaces/RequestMetadataResponse.html":{},"interfaces/RevokeCredentialsResult.html":{},"interfaces/TokenInfo.html":{},"interfaces/TokenInfoRequest.html":{},"interfaces/VerifyIdTokenOptions.html":{}}}],["max_token_lifetime_secs_",{"_index":951,"title":{},"body":{"interfaces/FederatedSignonCertsResponse.html":{},"interfaces/GetAccessTokenCallback.html":{},"interfaces/GetAccessTokenResponse.html":{},"interfaces/GetFederatedSignonCertsCallback.html":{},"interfaces/GetTokenCallback.html":{},"interfaces/GetTokenOptions.html":{},"interfaces/GetTokenResponse.html":{},"interfaces/OAuth2ClientOptions.html":{},"interfaces/RefreshAccessTokenCallback.html":{},"interfaces/RefreshAccessTokenResponse.html":{},"interfaces/RefreshOptions.html":{},"interfaces/RequestMetadataCallback.html":{},"interfaces/RequestMetadataResponse.html":{},"interfaces/RevokeCredentialsResult.html":{},"interfaces/TokenInfo.html":{},"interfaces/TokenInfoRequest.html":{},"interfaces/VerifyIdTokenOptions.html":{}}}],["maxag",{"_index":1246,"title":{},"body":{"classes/JWTAccess.html":{}}}],["maxexpiri",{"_index":892,"title":{},"body":{"interfaces/FederatedSignonCertsResponse.html":{},"interfaces/GetAccessTokenCallback.html":{},"interfaces/GetAccessTokenResponse.html":{},"interfaces/GetFederatedSignonCertsCallback.html":{},"interfaces/GetTokenCallback.html":{},"interfaces/GetTokenOptions.html":{},"interfaces/GetTokenResponse.html":{},"interfaces/OAuth2ClientOptions.html":{},"interfaces/RefreshAccessTokenCallback.html":{},"interfaces/RefreshAccessTokenResponse.html":{},"interfaces/RefreshOptions.html":{},"interfaces/RequestMetadataCallback.html":{},"interfaces/RequestMetadataResponse.html":{},"interfaces/RevokeCredentialsResult.html":{},"interfaces/TokenInfo.html":{},"interfaces/TokenInfoRequest.html":{},"interfaces/VerifyIdTokenOptions.html":{}}}],["mayrequirerefresh",{"_index":1119,"title":{},"body":{"interfaces/FederatedSignonCertsResponse.html":{},"interfaces/GetAccessTokenCallback.html":{},"interfaces/GetAccessTokenResponse.html":{},"interfaces/GetFederatedSignonCertsCallback.html":{},"interfaces/GetTokenCallback.html":{},"interfaces/GetTokenOptions.html":{},"interfaces/GetTokenResponse.html":{},"interfaces/OAuth2ClientOptions.html":{},"interfaces/RefreshAccessTokenCallback.html":{},"interfaces/RefreshAccessTokenResponse.html":{},"interfaces/RefreshOptions.html":{},"interfaces/RequestMetadataCallback.html":{},"interfaces/RequestMetadataResponse.html":{},"interfaces/RevokeCredentialsResult.html":{},"interfaces/TokenInfo.html":{},"interfaces/TokenInfoRequest.html":{},"interfaces/VerifyIdTokenOptions.html":{}}}],["mean",{"_index":1824,"title":{},"body":{"license.html":{}}}],["mechan",{"_index":1366,"title":{},"body":{"classes/LoginTicket.html":{},"interfaces/TokenPayload.html":{},"license.html":{}}}],["media",{"_index":1851,"title":{},"body":{"license.html":{}}}],["medium",{"_index":1913,"title":{},"body":{"license.html":{}}}],["meet",{"_index":1914,"title":{},"body":{"license.html":{}}}],["merchant",{"_index":1949,"title":{},"body":{"license.html":{}}}],["mere",{"_index":1863,"title":{},"body":{"license.html":{}}}],["messag",{"_index":36,"title":{},"body":{"interfaces/ADCCallback.html":{},"interfaces/ADCResponse.html":{},"interfaces/ComputeOptions.html":{},"interfaces/CredentialCallback.html":{},"interfaces/FederatedSignonCertsResponse.html":{},"interfaces/GetAccessTokenCallback.html":{},"interfaces/GetAccessTokenResponse.html":{},"interfaces/GetFederatedSignonCertsCallback.html":{},"interfaces/GetTokenCallback.html":{},"interfaces/GetTokenOptions.html":{},"interfaces/GetTokenResponse.html":{},"interfaces/GoogleAuthOptions.html":{},"classes/IAMAuth.html":{},"classes/JWTAccess.html":{},"interfaces/JWTOptions.html":{},"interfaces/OAuth2ClientOptions.html":{},"interfaces/ProjectIdCallback.html":{},"interfaces/RefreshAccessTokenCallback.html":{},"interfaces/RefreshAccessTokenResponse.html":{},"interfaces/RefreshOptions.html":{},"interfaces/RequestMetadata.html":{},"interfaces/RequestMetadataCallback.html":{},"interfaces/RequestMetadataResponse.html":{},"interfaces/RevokeCredentialsResult.html":{},"interfaces/SignBlobResponse.html":{},"interfaces/TokenInfo.html":{},"interfaces/TokenInfoRequest.html":{},"interfaces/VerifyIdTokenOptions.html":{},"interfaces/Warning.html":{},"miscellaneous/variables.html":{}}}],["messages.warn(messages.compute_create_scoped_deprec",{"_index":608,"title":{},"body":{"interfaces/ComputeOptions.html":{}}}],["messages.warn(messages.default_project_id_deprec",{"_index":140,"title":{},"body":{"interfaces/ADCCallback.html":{},"interfaces/ADCResponse.html":{},"interfaces/CredentialCallback.html":{},"interfaces/GoogleAuthOptions.html":{},"interfaces/ProjectIdCallback.html":{},"interfaces/SignBlobResponse.html":{}}}],["messages.warn(messages.iam_create_scoped_deprec",{"_index":1212,"title":{},"body":{"classes/IAMAuth.html":{},"interfaces/RequestMetadata.html":{}}}],["messages.warn(messages.iam_get_request_metadata_deprec",{"_index":1214,"title":{},"body":{"classes/IAMAuth.html":{},"interfaces/RequestMetadata.html":{}}}],["messages.warn(messages.jwt_access_create_scoped_deprec",{"_index":1250,"title":{},"body":{"classes/JWTAccess.html":{}}}],["messages.warn(messages.jwt_access_get_request_metadata_deprec",{"_index":1252,"title":{},"body":{"classes/JWTAccess.html":{}}}],["messages.warn(messages.jwt_create_scoped_deprec",{"_index":1313,"title":{},"body":{"interfaces/JWTOptions.html":{}}}],["messages.warn(messages.oauth_get_request_metadata_deprec",{"_index":1061,"title":{},"body":{"interfaces/FederatedSignonCertsResponse.html":{},"interfaces/GetAccessTokenCallback.html":{},"interfaces/GetAccessTokenResponse.html":{},"interfaces/GetFederatedSignonCertsCallback.html":{},"interfaces/GetTokenCallback.html":{},"interfaces/GetTokenOptions.html":{},"interfaces/GetTokenResponse.html":{},"interfaces/OAuth2ClientOptions.html":{},"interfaces/RefreshAccessTokenCallback.html":{},"interfaces/RefreshAccessTokenResponse.html":{},"interfaces/RefreshOptions.html":{},"interfaces/RequestMetadataCallback.html":{},"interfaces/RequestMetadataResponse.html":{},"interfaces/RevokeCredentialsResult.html":{},"interfaces/TokenInfo.html":{},"interfaces/TokenInfoRequest.html":{},"interfaces/VerifyIdTokenOptions.html":{}}}],["messages.warn(messages.problematic_credentials_warn",{"_index":322,"title":{},"body":{"interfaces/ADCCallback.html":{},"interfaces/ADCResponse.html":{},"interfaces/CredentialCallback.html":{},"interfaces/GoogleAuthOptions.html":{},"interfaces/ProjectIdCallback.html":{},"interfaces/SignBlobResponse.html":{}}}],["messages.warn(messages.refresh_access_token_deprec",{"_index":1039,"title":{},"body":{"interfaces/FederatedSignonCertsResponse.html":{},"interfaces/GetAccessTokenCallback.html":{},"interfaces/GetAccessTokenResponse.html":{},"interfaces/GetFederatedSignonCertsCallback.html":{},"interfaces/GetTokenCallback.html":{},"interfaces/GetTokenOptions.html":{},"interfaces/GetTokenResponse.html":{},"interfaces/OAuth2ClientOptions.html":{},"interfaces/RefreshAccessTokenCallback.html":{},"interfaces/RefreshAccessTokenResponse.html":{},"interfaces/RefreshOptions.html":{},"interfaces/RequestMetadataCallback.html":{},"interfaces/RequestMetadataResponse.html":{},"interfaces/RevokeCredentialsResult.html":{},"interfaces/TokenInfo.html":{},"interfaces/TokenInfoRequest.html":{},"interfaces/VerifyIdTokenOptions.html":{}}}],["metadata",{"_index":30,"title":{},"body":{"interfaces/ADCCallback.html":{},"interfaces/ADCResponse.html":{},"interfaces/ComputeOptions.html":{},"interfaces/CredentialCallback.html":{},"interfaces/FederatedSignonCertsResponse.html":{},"interfaces/GetAccessTokenCallback.html":{},"interfaces/GetAccessTokenResponse.html":{},"interfaces/GetFederatedSignonCertsCallback.html":{},"interfaces/GetTokenCallback.html":{},"interfaces/GetTokenOptions.html":{},"interfaces/GetTokenResponse.html":{},"interfaces/GoogleAuthOptions.html":{},"classes/IAMAuth.html":{},"interfaces/JWTOptions.html":{},"interfaces/OAuth2ClientOptions.html":{},"interfaces/ProjectIdCallback.html":{},"interfaces/RefreshAccessTokenCallback.html":{},"interfaces/RefreshAccessTokenResponse.html":{},"interfaces/RefreshOptions.html":{},"interfaces/RequestMetadata.html":{},"interfaces/RequestMetadataCallback.html":{},"interfaces/RequestMetadataResponse.html":{},"interfaces/RevokeCredentialsResult.html":{},"interfaces/SignBlobResponse.html":{},"interfaces/TokenInfo.html":{},"interfaces/TokenInfoRequest.html":{},"interfaces/VerifyIdTokenOptions.html":{},"changelog.html":{},"dependencies.html":{}}}],["metadatafn",{"_index":1203,"title":{},"body":{"classes/IAMAuth.html":{},"interfaces/RequestMetadata.html":{}}}],["metadatafn(nul",{"_index":1215,"title":{},"body":{"classes/IAMAuth.html":{},"interfaces/RequestMetadata.html":{}}}],["method",{"_index":129,"title":{},"body":{"interfaces/ADCCallback.html":{},"interfaces/ADCResponse.html":{},"interfaces/CredentialCallback.html":{},"classes/DefaultTransporter.html":{},"interfaces/FederatedSignonCertsResponse.html":{},"interfaces/GetAccessTokenCallback.html":{},"interfaces/GetAccessTokenResponse.html":{},"interfaces/GetFederatedSignonCertsCallback.html":{},"interfaces/GetTokenCallback.html":{},"interfaces/GetTokenOptions.html":{},"interfaces/GetTokenResponse.html":{},"interfaces/GoogleAuthOptions.html":{},"classes/IAMAuth.html":{},"classes/JWTAccess.html":{},"classes/LoginTicket.html":{},"interfaces/OAuth2ClientOptions.html":{},"classes/PemVerifier.html":{},"interfaces/ProjectIdCallback.html":{},"interfaces/RefreshAccessTokenCallback.html":{},"interfaces/RefreshAccessTokenResponse.html":{},"interfaces/RefreshOptions.html":{},"interfaces/RequestMetadataCallback.html":{},"interfaces/RequestMetadataResponse.html":{},"interfaces/RevokeCredentialsResult.html":{},"interfaces/SignBlobResponse.html":{},"interfaces/TokenInfo.html":{},"interfaces/TokenInfoRequest.html":{},"interfaces/Transporter.html":{},"interfaces/VerifyIdTokenOptions.html":{},"interfaces/Warning.html":{},"changelog.html":{},"index.html":{},"miscellaneous/variables.html":{}}}],["millisecond",{"_index":900,"title":{},"body":{"interfaces/FederatedSignonCertsResponse.html":{},"interfaces/GetAccessTokenCallback.html":{},"interfaces/GetAccessTokenResponse.html":{},"interfaces/GetFederatedSignonCertsCallback.html":{},"interfaces/GetTokenCallback.html":{},"interfaces/GetTokenOptions.html":{},"interfaces/GetTokenResponse.html":{},"interfaces/OAuth2ClientOptions.html":{},"interfaces/RefreshAccessTokenCallback.html":{},"interfaces/RefreshAccessTokenResponse.html":{},"interfaces/RefreshOptions.html":{},"interfaces/RequestMetadataCallback.html":{},"interfaces/RequestMetadataResponse.html":{},"interfaces/RevokeCredentialsResult.html":{},"interfaces/TokenInfo.html":{},"interfaces/TokenInfoRequest.html":{},"interfaces/VerifyIdTokenOptions.html":{}}}],["minut",{"_index":903,"title":{},"body":{"interfaces/FederatedSignonCertsResponse.html":{},"interfaces/GetAccessTokenCallback.html":{},"interfaces/GetAccessTokenResponse.html":{},"interfaces/GetFederatedSignonCertsCallback.html":{},"interfaces/GetTokenCallback.html":{},"interfaces/GetTokenOptions.html":{},"interfaces/GetTokenResponse.html":{},"interfaces/OAuth2ClientOptions.html":{},"interfaces/RefreshAccessTokenCallback.html":{},"interfaces/RefreshAccessTokenResponse.html":{},"interfaces/RefreshOptions.html":{},"interfaces/RequestMetadataCallback.html":{},"interfaces/RequestMetadataResponse.html":{},"interfaces/RevokeCredentialsResult.html":{},"interfaces/TokenInfo.html":{},"interfaces/TokenInfoRequest.html":{},"interfaces/VerifyIdTokenOptions.html":{}}}],["miscellan",{"_index":1647,"title":{"miscellaneous/enumerations.html":{},"miscellaneous/functions.html":{},"miscellaneous/typealiases.html":{},"miscellaneous/variables.html":{}},"body":{"miscellaneous/enumerations.html":{},"miscellaneous/functions.html":{},"miscellaneous/typealiases.html":{},"miscellaneous/variables.html":{}}}],["miss",{"_index":1560,"title":{},"body":{"changelog.html":{}}}],["mitig",{"_index":829,"title":{},"body":{"interfaces/FederatedSignonCertsResponse.html":{},"interfaces/GetAccessTokenCallback.html":{},"interfaces/GetAccessTokenResponse.html":{},"interfaces/GetFederatedSignonCertsCallback.html":{},"interfaces/GetTokenCallback.html":{},"interfaces/GetTokenOptions.html":{},"interfaces/GetTokenResponse.html":{},"interfaces/OAuth2ClientOptions.html":{},"interfaces/RefreshAccessTokenCallback.html":{},"interfaces/RefreshAccessTokenResponse.html":{},"interfaces/RefreshOptions.html":{},"interfaces/RequestMetadataCallback.html":{},"interfaces/RequestMetadataResponse.html":{},"interfaces/RevokeCredentialsResult.html":{},"interfaces/TokenInfo.html":{},"interfaces/TokenInfoRequest.html":{},"interfaces/VerifyIdTokenOptions.html":{}}}],["mock",{"_index":372,"title":{},"body":{"interfaces/ADCCallback.html":{},"interfaces/ADCResponse.html":{},"interfaces/CredentialCallback.html":{},"interfaces/GoogleAuthOptions.html":{},"interfaces/ProjectIdCallback.html":{},"interfaces/SignBlobResponse.html":{}}}],["modif",{"_index":1846,"title":{},"body":{"license.html":{}}}],["modifi",{"_index":775,"title":{},"body":{"interfaces/FederatedSignonCertsResponse.html":{},"interfaces/GetAccessTokenCallback.html":{},"interfaces/GetAccessTokenResponse.html":{},"interfaces/GetFederatedSignonCertsCallback.html":{},"interfaces/GetTokenCallback.html":{},"interfaces/GetTokenOptions.html":{},"interfaces/GetTokenResponse.html":{},"interfaces/OAuth2ClientOptions.html":{},"interfaces/RefreshAccessTokenCallback.html":{},"interfaces/RefreshAccessTokenResponse.html":{},"interfaces/RefreshOptions.html":{},"interfaces/RequestMetadataCallback.html":{},"interfaces/RequestMetadataResponse.html":{},"interfaces/RevokeCredentialsResult.html":{},"interfaces/TokenInfo.html":{},"interfaces/TokenInfoRequest.html":{},"interfaces/VerifyIdTokenOptions.html":{},"license.html":{}}}],["modul",{"_index":1992,"title":{"modules.html":{}},"body":{"modules.html":{}}}],["more",{"_index":243,"title":{},"body":{"interfaces/ADCCallback.html":{},"interfaces/ADCResponse.html":{},"interfaces/CredentialCallback.html":{},"interfaces/FederatedSignonCertsResponse.html":{},"interfaces/GetAccessTokenCallback.html":{},"interfaces/GetAccessTokenResponse.html":{},"interfaces/GetFederatedSignonCertsCallback.html":{},"interfaces/GetTokenCallback.html":{},"interfaces/GetTokenOptions.html":{},"interfaces/GetTokenResponse.html":{},"interfaces/GoogleAuthOptions.html":{},"interfaces/OAuth2ClientOptions.html":{},"interfaces/ProjectIdCallback.html":{},"interfaces/RefreshAccessTokenCallback.html":{},"interfaces/RefreshAccessTokenResponse.html":{},"interfaces/RefreshOptions.html":{},"interfaces/RequestMetadataCallback.html":{},"interfaces/RequestMetadataResponse.html":{},"interfaces/RevokeCredentialsResult.html":{},"interfaces/SignBlobResponse.html":{},"interfaces/TokenInfo.html":{},"interfaces/TokenInfoRequest.html":{},"interfaces/VerifyIdTokenOptions.html":{},"interfaces/Warning.html":{},"index.html":{},"license.html":{},"miscellaneous/variables.html":{}}}],["move",{"_index":1510,"title":{},"body":{"changelog.html":{}}}],["multi",{"_index":862,"title":{},"body":{"interfaces/FederatedSignonCertsResponse.html":{},"interfaces/GetAccessTokenCallback.html":{},"interfaces/GetAccessTokenResponse.html":{},"interfaces/GetFederatedSignonCertsCallback.html":{},"interfaces/GetTokenCallback.html":{},"interfaces/GetTokenOptions.html":{},"interfaces/GetTokenResponse.html":{},"interfaces/OAuth2ClientOptions.html":{},"interfaces/RefreshAccessTokenCallback.html":{},"interfaces/RefreshAccessTokenResponse.html":{},"interfaces/RefreshOptions.html":{},"interfaces/RequestMetadataCallback.html":{},"interfaces/RequestMetadataResponse.html":{},"interfaces/RevokeCredentialsResult.html":{},"interfaces/TokenInfo.html":{},"interfaces/TokenInfoRequest.html":{},"interfaces/VerifyIdTokenOptions.html":{}}}],["multipl",{"_index":583,"title":{},"body":{"interfaces/ComputeOptions.html":{},"interfaces/FederatedSignonCertsResponse.html":{},"interfaces/GetAccessTokenCallback.html":{},"interfaces/GetAccessTokenResponse.html":{},"interfaces/GetFederatedSignonCertsCallback.html":{},"interfaces/GetTokenCallback.html":{},"interfaces/GetTokenOptions.html":{},"interfaces/GetTokenResponse.html":{},"classes/LoginTicket.html":{},"interfaces/OAuth2ClientOptions.html":{},"interfaces/RefreshAccessTokenCallback.html":{},"interfaces/RefreshAccessTokenResponse.html":{},"interfaces/RefreshOptions.html":{},"interfaces/RequestMetadataCallback.html":{},"interfaces/RequestMetadataResponse.html":{},"interfaces/RevokeCredentialsResult.html":{},"interfaces/TokenInfo.html":{},"interfaces/TokenInfoRequest.html":{},"interfaces/TokenPayload.html":{},"interfaces/VerifyIdTokenOptions.html":{},"changelog.html":{}}}],["mycolledge.edu",{"_index":777,"title":{},"body":{"interfaces/FederatedSignonCertsResponse.html":{},"interfaces/GetAccessTokenCallback.html":{},"interfaces/GetAccessTokenResponse.html":{},"interfaces/GetFederatedSignonCertsCallback.html":{},"interfaces/GetTokenCallback.html":{},"interfaces/GetTokenOptions.html":{},"interfaces/GetTokenResponse.html":{},"interfaces/OAuth2ClientOptions.html":{},"interfaces/RefreshAccessTokenCallback.html":{},"interfaces/RefreshAccessTokenResponse.html":{},"interfaces/RefreshOptions.html":{},"interfaces/RequestMetadataCallback.html":{},"interfaces/RequestMetadataResponse.html":{},"interfaces/RevokeCredentialsResult.html":{},"interfaces/TokenInfo.html":{},"interfaces/TokenInfoRequest.html":{},"interfaces/VerifyIdTokenOptions.html":{}}}],["mycollege.edu",{"_index":764,"title":{},"body":{"interfaces/FederatedSignonCertsResponse.html":{},"interfaces/GetAccessTokenCallback.html":{},"interfaces/GetAccessTokenResponse.html":{},"interfaces/GetFederatedSignonCertsCallback.html":{},"interfaces/GetTokenCallback.html":{},"interfaces/GetTokenOptions.html":{},"interfaces/GetTokenResponse.html":{},"interfaces/OAuth2ClientOptions.html":{},"interfaces/RefreshAccessTokenCallback.html":{},"interfaces/RefreshAccessTokenResponse.html":{},"interfaces/RefreshOptions.html":{},"interfaces/RequestMetadataCallback.html":{},"interfaces/RequestMetadataResponse.html":{},"interfaces/RevokeCredentialsResult.html":{},"interfaces/TokenInfo.html":{},"interfaces/TokenInfoRequest.html":{},"interfaces/VerifyIdTokenOptions.html":{}}}],["name",{"_index":501,"title":{},"body":{"interfaces/BodyResponseCallback.html":{},"classes/DefaultTransporter.html":{},"classes/IAMAuth.html":{},"classes/JWTAccess.html":{},"classes/LoginTicket.html":{},"classes/PemVerifier.html":{},"interfaces/RequestError.html":{},"interfaces/TokenPayload.html":{},"interfaces/Transporter.html":{},"miscellaneous/functions.html":{},"license.html":{}}}],["name=valu",{"_index":818,"title":{},"body":{"interfaces/FederatedSignonCertsResponse.html":{},"interfaces/GetAccessTokenCallback.html":{},"interfaces/GetAccessTokenResponse.html":{},"interfaces/GetFederatedSignonCertsCallback.html":{},"interfaces/GetTokenCallback.html":{},"interfaces/GetTokenOptions.html":{},"interfaces/GetTokenResponse.html":{},"interfaces/OAuth2ClientOptions.html":{},"interfaces/RefreshAccessTokenCallback.html":{},"interfaces/RefreshAccessTokenResponse.html":{},"interfaces/RefreshOptions.html":{},"interfaces/RequestMetadataCallback.html":{},"interfaces/RequestMetadataResponse.html":{},"interfaces/RevokeCredentialsResult.html":{},"interfaces/TokenInfo.html":{},"interfaces/TokenInfoRequest.html":{},"interfaces/VerifyIdTokenOptions.html":{}}}],["necessari",{"_index":1048,"title":{},"body":{"interfaces/FederatedSignonCertsResponse.html":{},"interfaces/GetAccessTokenCallback.html":{},"interfaces/GetAccessTokenResponse.html":{},"interfaces/GetFederatedSignonCertsCallback.html":{},"interfaces/GetTokenCallback.html":{},"interfaces/GetTokenOptions.html":{},"interfaces/GetTokenResponse.html":{},"classes/JWTAccess.html":{},"classes/LoginTicket.html":{},"interfaces/OAuth2ClientOptions.html":{},"interfaces/RefreshAccessTokenCallback.html":{},"interfaces/RefreshAccessTokenResponse.html":{},"interfaces/RefreshOptions.html":{},"interfaces/RequestMetadataCallback.html":{},"interfaces/RequestMetadataResponse.html":{},"interfaces/RevokeCredentialsResult.html":{},"interfaces/TokenInfo.html":{},"interfaces/TokenInfoRequest.html":{},"interfaces/TokenPayload.html":{},"interfaces/VerifyIdTokenOptions.html":{}}}],["necessarili",{"_index":1899,"title":{},"body":{"license.html":{}}}],["need",{"_index":736,"title":{},"body":{"interfaces/FederatedSignonCertsResponse.html":{},"interfaces/GetAccessTokenCallback.html":{},"interfaces/GetAccessTokenResponse.html":{},"interfaces/GetFederatedSignonCertsCallback.html":{},"interfaces/GetTokenCallback.html":{},"interfaces/GetTokenOptions.html":{},"interfaces/GetTokenResponse.html":{},"interfaces/JWTOptions.html":{},"classes/LoginTicket.html":{},"interfaces/OAuth2ClientOptions.html":{},"interfaces/RefreshAccessTokenCallback.html":{},"interfaces/RefreshAccessTokenResponse.html":{},"interfaces/RefreshOptions.html":{},"interfaces/RequestMetadataCallback.html":{},"interfaces/RequestMetadataResponse.html":{},"interfaces/RevokeCredentialsResult.html":{},"interfaces/TokenInfo.html":{},"interfaces/TokenInfoRequest.html":{},"interfaces/TokenPayload.html":{},"interfaces/VerifyIdTokenOptions.html":{},"changelog.html":{},"index.html":{}}}],["neglig",{"_index":1957,"title":{},"body":{"license.html":{}}}],["nest",{"_index":1633,"title":{},"body":{"changelog.html":{}}}],["never",{"_index":730,"title":{},"body":{"interfaces/FederatedSignonCertsResponse.html":{},"interfaces/GetAccessTokenCallback.html":{},"interfaces/GetAccessTokenResponse.html":{},"interfaces/GetFederatedSignonCertsCallback.html":{},"interfaces/GetTokenCallback.html":{},"interfaces/GetTokenOptions.html":{},"interfaces/GetTokenResponse.html":{},"classes/LoginTicket.html":{},"interfaces/OAuth2ClientOptions.html":{},"interfaces/RefreshAccessTokenCallback.html":{},"interfaces/RefreshAccessTokenResponse.html":{},"interfaces/RefreshOptions.html":{},"interfaces/RequestMetadataCallback.html":{},"interfaces/RequestMetadataResponse.html":{},"interfaces/RevokeCredentialsResult.html":{},"interfaces/TokenInfo.html":{},"interfaces/TokenInfoRequest.html":{},"interfaces/TokenPayload.html":{},"interfaces/VerifyIdTokenOptions.html":{},"changelog.html":{},"index.html":{}}}],["new",{"_index":176,"title":{},"body":{"interfaces/ADCCallback.html":{},"interfaces/ADCResponse.html":{},"interfaces/BodyResponseCallback.html":{},"interfaces/ComputeOptions.html":{},"interfaces/CredentialCallback.html":{},"classes/DefaultTransporter.html":{},"interfaces/FederatedSignonCertsResponse.html":{},"interfaces/GetAccessTokenCallback.html":{},"interfaces/GetAccessTokenResponse.html":{},"interfaces/GetFederatedSignonCertsCallback.html":{},"interfaces/GetTokenCallback.html":{},"interfaces/GetTokenOptions.html":{},"interfaces/GetTokenResponse.html":{},"interfaces/GoogleAuthOptions.html":{},"classes/JWTAccess.html":{},"interfaces/JWTOptions.html":{},"interfaces/OAuth2ClientOptions.html":{},"interfaces/ProjectIdCallback.html":{},"interfaces/RefreshAccessTokenCallback.html":{},"interfaces/RefreshAccessTokenResponse.html":{},"interfaces/RefreshOptions.html":{},"interfaces/RequestError.html":{},"interfaces/RequestMetadataCallback.html":{},"interfaces/RequestMetadataResponse.html":{},"interfaces/RevokeCredentialsResult.html":{},"interfaces/SignBlobResponse.html":{},"interfaces/TokenInfo.html":{},"interfaces/TokenInfoRequest.html":{},"interfaces/Transporter.html":{},"interfaces/UserRefreshClientOptions.html":{},"interfaces/VerifyIdTokenOptions.html":{},"changelog.html":{},"index.html":{},"miscellaneous/variables.html":{}}}],["next",{"_index":467,"title":{},"body":{"interfaces/ADCCallback.html":{},"interfaces/ADCResponse.html":{},"interfaces/BodyResponseCallback.html":{},"interfaces/CredentialCallback.html":{},"classes/DefaultTransporter.html":{},"interfaces/GoogleAuthOptions.html":{},"interfaces/JWTOptions.html":{},"interfaces/ProjectIdCallback.html":{},"interfaces/RequestError.html":{},"interfaces/SignBlobResponse.html":{},"interfaces/Transporter.html":{},"interfaces/Warning.html":{}}}],["nock",{"_index":1465,"title":{},"body":{"changelog.html":{}}}],["node",{"_index":527,"title":{},"body":{"interfaces/BodyResponseCallback.html":{},"classes/DefaultTransporter.html":{},"interfaces/RequestError.html":{},"interfaces/Transporter.html":{},"interfaces/Warning.html":{}}}],["node.j",{"_index":1535,"title":{},"body":{"changelog.html":{},"index.html":{}}}],["node11",{"_index":1496,"title":{},"body":{"changelog.html":{}}}],["nodej",{"_index":510,"title":{},"body":{"interfaces/BodyResponseCallback.html":{},"classes/DefaultTransporter.html":{},"interfaces/RequestError.html":{},"interfaces/Transporter.html":{},"miscellaneous/variables.html":{}}}],["nodejs.errnoexception).cod",{"_index":636,"title":{},"body":{"interfaces/ComputeOptions.html":{}}}],["non",{"_index":1047,"title":{},"body":{"interfaces/FederatedSignonCertsResponse.html":{},"interfaces/GetAccessTokenCallback.html":{},"interfaces/GetAccessTokenResponse.html":{},"interfaces/GetFederatedSignonCertsCallback.html":{},"interfaces/GetTokenCallback.html":{},"interfaces/GetTokenOptions.html":{},"interfaces/GetTokenResponse.html":{},"classes/JWTAccess.html":{},"interfaces/OAuth2ClientOptions.html":{},"interfaces/RefreshAccessTokenCallback.html":{},"interfaces/RefreshAccessTokenResponse.html":{},"interfaces/RefreshOptions.html":{},"interfaces/RequestMetadataCallback.html":{},"interfaces/RequestMetadataResponse.html":{},"interfaces/RevokeCredentialsResult.html":{},"interfaces/TokenInfo.html":{},"interfaces/TokenInfoRequest.html":{},"interfaces/VerifyIdTokenOptions.html":{},"license.html":{}}}],["nonc",{"_index":828,"title":{},"body":{"interfaces/FederatedSignonCertsResponse.html":{},"interfaces/GetAccessTokenCallback.html":{},"interfaces/GetAccessTokenResponse.html":{},"interfaces/GetFederatedSignonCertsCallback.html":{},"interfaces/GetTokenCallback.html":{},"interfaces/GetTokenOptions.html":{},"interfaces/GetTokenResponse.html":{},"classes/LoginTicket.html":{},"interfaces/OAuth2ClientOptions.html":{},"interfaces/RefreshAccessTokenCallback.html":{},"interfaces/RefreshAccessTokenResponse.html":{},"interfaces/RefreshOptions.html":{},"interfaces/RequestMetadataCallback.html":{},"interfaces/RequestMetadataResponse.html":{},"interfaces/RevokeCredentialsResult.html":{},"interfaces/TokenInfo.html":{},"interfaces/TokenInfoRequest.html":{},"interfaces/TokenPayload.html":{},"interfaces/VerifyIdTokenOptions.html":{}}}],["none",{"_index":868,"title":{},"body":{"interfaces/FederatedSignonCertsResponse.html":{},"interfaces/GetAccessTokenCallback.html":{},"interfaces/GetAccessTokenResponse.html":{},"interfaces/GetFederatedSignonCertsCallback.html":{},"interfaces/GetTokenCallback.html":{},"interfaces/GetTokenOptions.html":{},"interfaces/GetTokenResponse.html":{},"interfaces/OAuth2ClientOptions.html":{},"interfaces/RefreshAccessTokenCallback.html":{},"interfaces/RefreshAccessTokenResponse.html":{},"interfaces/RefreshOptions.html":{},"interfaces/RequestMetadataCallback.html":{},"interfaces/RequestMetadataResponse.html":{},"interfaces/RevokeCredentialsResult.html":{},"interfaces/TokenInfo.html":{},"interfaces/TokenInfoRequest.html":{},"interfaces/VerifyIdTokenOptions.html":{},"miscellaneous/enumerations.html":{}}}],["normal",{"_index":1928,"title":{},"body":{"license.html":{}}}],["note",{"_index":99,"title":{},"body":{"interfaces/ADCCallback.html":{},"interfaces/ADCResponse.html":{},"interfaces/CredentialCallback.html":{},"interfaces/FederatedSignonCertsResponse.html":{},"interfaces/GetAccessTokenCallback.html":{},"interfaces/GetAccessTokenResponse.html":{},"interfaces/GetFederatedSignonCertsCallback.html":{},"interfaces/GetTokenCallback.html":{},"interfaces/GetTokenOptions.html":{},"interfaces/GetTokenResponse.html":{},"interfaces/GoogleAuthOptions.html":{},"classes/LoginTicket.html":{},"interfaces/OAuth2ClientOptions.html":{},"interfaces/ProjectIdCallback.html":{},"interfaces/RefreshAccessTokenCallback.html":{},"interfaces/RefreshAccessTokenResponse.html":{},"interfaces/RefreshOptions.html":{},"interfaces/RequestMetadataCallback.html":{},"interfaces/RequestMetadataResponse.html":{},"interfaces/RevokeCredentialsResult.html":{},"interfaces/SignBlobResponse.html":{},"interfaces/TokenInfo.html":{},"interfaces/TokenInfoRequest.html":{},"interfaces/TokenPayload.html":{},"interfaces/VerifyIdTokenOptions.html":{},"index.html":{}}}],["noth",{"_index":296,"title":{},"body":{"interfaces/ADCCallback.html":{},"interfaces/ADCResponse.html":{},"interfaces/CredentialCallback.html":{},"interfaces/GoogleAuthOptions.html":{},"interfaces/ProjectIdCallback.html":{},"interfaces/SignBlobResponse.html":{},"license.html":{}}}],["notic",{"_index":1853,"title":{},"body":{"license.html":{}}}],["notwithstand",{"_index":1939,"title":{},"body":{"license.html":{}}}],["now",{"_index":305,"title":{},"body":{"interfaces/ADCCallback.html":{},"interfaces/ADCResponse.html":{},"interfaces/CredentialCallback.html":{},"interfaces/FederatedSignonCertsResponse.html":{},"interfaces/GetAccessTokenCallback.html":{},"interfaces/GetAccessTokenResponse.html":{},"interfaces/GetFederatedSignonCertsCallback.html":{},"interfaces/GetTokenCallback.html":{},"interfaces/GetTokenOptions.html":{},"interfaces/GetTokenResponse.html":{},"interfaces/GoogleAuthOptions.html":{},"interfaces/OAuth2ClientOptions.html":{},"interfaces/ProjectIdCallback.html":{},"interfaces/RefreshAccessTokenCallback.html":{},"interfaces/RefreshAccessTokenResponse.html":{},"interfaces/RefreshOptions.html":{},"interfaces/RequestMetadataCallback.html":{},"interfaces/RequestMetadataResponse.html":{},"interfaces/RevokeCredentialsResult.html":{},"interfaces/SignBlobResponse.html":{},"interfaces/TokenInfo.html":{},"interfaces/TokenInfoRequest.html":{},"interfaces/VerifyIdTokenOptions.html":{},"index.html":{}}}],["nowtim",{"_index":1163,"title":{},"body":{"interfaces/FederatedSignonCertsResponse.html":{},"interfaces/GetAccessTokenCallback.html":{},"interfaces/GetAccessTokenResponse.html":{},"interfaces/GetFederatedSignonCertsCallback.html":{},"interfaces/GetTokenCallback.html":{},"interfaces/GetTokenOptions.html":{},"interfaces/GetTokenResponse.html":{},"interfaces/OAuth2ClientOptions.html":{},"interfaces/RefreshAccessTokenCallback.html":{},"interfaces/RefreshAccessTokenResponse.html":{},"interfaces/RefreshOptions.html":{},"interfaces/RequestMetadataCallback.html":{},"interfaces/RequestMetadataResponse.html":{},"interfaces/RevokeCredentialsResult.html":{},"interfaces/TokenInfo.html":{},"interfaces/TokenInfoRequest.html":{},"interfaces/VerifyIdTokenOptions.html":{}}}],["npm",{"_index":1456,"title":{},"body":{"changelog.html":{},"index.html":{}}}],["null",{"_index":13,"title":{},"body":{"interfaces/ADCCallback.html":{},"interfaces/ADCResponse.html":{},"interfaces/BodyResponseCallback.html":{},"interfaces/ComputeOptions.html":{},"interfaces/CredentialCallback.html":{},"interfaces/Credentials.html":{},"classes/DefaultTransporter.html":{},"interfaces/FederatedSignonCertsResponse.html":{},"interfaces/GetAccessTokenCallback.html":{},"interfaces/GetAccessTokenResponse.html":{},"interfaces/GetFederatedSignonCertsCallback.html":{},"interfaces/GetTokenCallback.html":{},"interfaces/GetTokenOptions.html":{},"interfaces/GetTokenResponse.html":{},"interfaces/GoogleAuthOptions.html":{},"classes/IAMAuth.html":{},"classes/JWTAccess.html":{},"interfaces/JWTOptions.html":{},"classes/LoginTicket.html":{},"interfaces/OAuth2ClientOptions.html":{},"interfaces/ProjectIdCallback.html":{},"interfaces/RefreshAccessTokenCallback.html":{},"interfaces/RefreshAccessTokenResponse.html":{},"interfaces/RefreshOptions.html":{},"interfaces/RequestError.html":{},"interfaces/RequestMetadataCallback.html":{},"interfaces/RequestMetadataResponse.html":{},"interfaces/RevokeCredentialsResult.html":{},"interfaces/SignBlobResponse.html":{},"interfaces/TokenInfo.html":{},"interfaces/TokenInfoRequest.html":{},"interfaces/TokenPayload.html":{},"interfaces/Transporter.html":{},"interfaces/UserRefreshClientOptions.html":{},"interfaces/VerifyIdTokenOptions.html":{},"changelog.html":{},"index.html":{}}}],["null,metadata",{"_index":1204,"title":{},"body":{"classes/IAMAuth.html":{}}}],["number",{"_index":643,"title":{},"body":{"interfaces/CredentialBody.html":{},"interfaces/CredentialRequest.html":{},"interfaces/Credentials.html":{},"interfaces/FederatedSignonCertsResponse.html":{},"interfaces/GetAccessTokenCallback.html":{},"interfaces/GetAccessTokenResponse.html":{},"interfaces/GetFederatedSignonCertsCallback.html":{},"interfaces/GetTokenCallback.html":{},"interfaces/GetTokenOptions.html":{},"interfaces/GetTokenResponse.html":{},"interfaces/JWTInput.html":{},"classes/LoginTicket.html":{},"interfaces/OAuth2ClientOptions.html":{},"interfaces/RefreshAccessTokenCallback.html":{},"interfaces/RefreshAccessTokenResponse.html":{},"interfaces/RefreshOptions.html":{},"interfaces/RequestMetadataCallback.html":{},"interfaces/RequestMetadataResponse.html":{},"interfaces/RevokeCredentialsResult.html":{},"interfaces/TokenInfo.html":{},"interfaces/TokenInfoRequest.html":{},"interfaces/TokenPayload.html":{},"interfaces/UserRefreshClientOptions.html":{},"interfaces/VerifyIdTokenOptions.html":{}}}],["number|nul",{"_index":638,"title":{},"body":{"interfaces/CredentialBody.html":{},"interfaces/CredentialRequest.html":{},"interfaces/Credentials.html":{},"interfaces/JWTInput.html":{}}}],["nyc",{"_index":1593,"title":{},"body":{"changelog.html":{}}}],["oauth",{"_index":801,"title":{},"body":{"interfaces/FederatedSignonCertsResponse.html":{},"interfaces/GetAccessTokenCallback.html":{},"interfaces/GetAccessTokenResponse.html":{},"interfaces/GetFederatedSignonCertsCallback.html":{},"interfaces/GetTokenCallback.html":{},"interfaces/GetTokenOptions.html":{},"interfaces/GetTokenResponse.html":{},"classes/LoginTicket.html":{},"interfaces/OAuth2ClientOptions.html":{},"interfaces/RefreshAccessTokenCallback.html":{},"interfaces/RefreshAccessTokenResponse.html":{},"interfaces/RefreshOptions.html":{},"interfaces/RequestMetadataCallback.html":{},"interfaces/RequestMetadataResponse.html":{},"interfaces/RevokeCredentialsResult.html":{},"interfaces/TokenInfo.html":{},"interfaces/TokenInfoRequest.html":{},"interfaces/TokenPayload.html":{},"interfaces/VerifyIdTokenOptions.html":{},"index.html":{}}}],["oauth2",{"_index":914,"title":{},"body":{"interfaces/FederatedSignonCertsResponse.html":{},"interfaces/GetAccessTokenCallback.html":{},"interfaces/GetAccessTokenResponse.html":{},"interfaces/GetFederatedSignonCertsCallback.html":{},"interfaces/GetTokenCallback.html":{},"interfaces/GetTokenOptions.html":{},"interfaces/GetTokenResponse.html":{},"interfaces/OAuth2ClientOptions.html":{},"interfaces/RefreshAccessTokenCallback.html":{},"interfaces/RefreshAccessTokenResponse.html":{},"interfaces/RefreshOptions.html":{},"interfaces/RequestMetadataCallback.html":{},"interfaces/RequestMetadataResponse.html":{},"interfaces/RevokeCredentialsResult.html":{},"interfaces/TokenInfo.html":{},"interfaces/TokenInfoRequest.html":{},"interfaces/VerifyIdTokenOptions.html":{},"interfaces/Warning.html":{},"changelog.html":{},"index.html":{},"miscellaneous/variables.html":{}}}],["oauth2.refreshaccesstoken",{"_index":1554,"title":{},"body":{"changelog.html":{}}}],["oauth2callback?cod",{"_index":1734,"title":{},"body":{"index.html":{}}}],["oauth2client",{"_index":15,"title":{},"body":{"interfaces/ADCCallback.html":{},"interfaces/ADCResponse.html":{},"interfaces/ComputeOptions.html":{},"interfaces/CredentialCallback.html":{},"interfaces/FederatedSignonCertsResponse.html":{},"interfaces/GetAccessTokenCallback.html":{},"interfaces/GetAccessTokenResponse.html":{},"interfaces/GetFederatedSignonCertsCallback.html":{},"interfaces/GetTokenCallback.html":{},"interfaces/GetTokenOptions.html":{},"interfaces/GetTokenResponse.html":{},"interfaces/GoogleAuthOptions.html":{},"classes/JWTAccess.html":{},"interfaces/JWTOptions.html":{},"interfaces/OAuth2ClientOptions.html":{},"interfaces/ProjectIdCallback.html":{},"interfaces/RefreshAccessTokenCallback.html":{},"interfaces/RefreshAccessTokenResponse.html":{},"interfaces/RefreshOptions.html":{},"interfaces/RequestMetadataCallback.html":{},"interfaces/RequestMetadataResponse.html":{},"interfaces/RevokeCredentialsResult.html":{},"interfaces/SignBlobResponse.html":{},"interfaces/TokenInfo.html":{},"interfaces/TokenInfoRequest.html":{},"interfaces/UserRefreshClientOptions.html":{},"interfaces/VerifyIdTokenOptions.html":{},"index.html":{}}}],["oauth2client.clock_skew_secs_",{"_index":1170,"title":{},"body":{"interfaces/FederatedSignonCertsResponse.html":{},"interfaces/GetAccessTokenCallback.html":{},"interfaces/GetAccessTokenResponse.html":{},"interfaces/GetFederatedSignonCertsCallback.html":{},"interfaces/GetTokenCallback.html":{},"interfaces/GetTokenOptions.html":{},"interfaces/GetTokenResponse.html":{},"interfaces/OAuth2ClientOptions.html":{},"interfaces/RefreshAccessTokenCallback.html":{},"interfaces/RefreshAccessTokenResponse.html":{},"interfaces/RefreshOptions.html":{},"interfaces/RequestMetadataCallback.html":{},"interfaces/RequestMetadataResponse.html":{},"interfaces/RevokeCredentialsResult.html":{},"interfaces/TokenInfo.html":{},"interfaces/TokenInfoRequest.html":{},"interfaces/VerifyIdTokenOptions.html":{}}}],["oauth2client.credentials.refresh_token",{"_index":1767,"title":{},"body":{"index.html":{}}}],["oauth2client.generateauthurl",{"_index":1731,"title":{},"body":{"index.html":{}}}],["oauth2client.gettoken(cod",{"_index":1762,"title":{},"body":{"index.html":{}}}],["oauth2client.gettoken(qs.cod",{"_index":1744,"title":{},"body":{"index.html":{}}}],["oauth2client.gettokeninfo('mi",{"_index":1772,"title":{},"body":{"index.html":{}}}],["oauth2client.google_oauth2_auth_base_url_",{"_index":967,"title":{},"body":{"interfaces/FederatedSignonCertsResponse.html":{},"interfaces/GetAccessTokenCallback.html":{},"interfaces/GetAccessTokenResponse.html":{},"interfaces/GetFederatedSignonCertsCallback.html":{},"interfaces/GetTokenCallback.html":{},"interfaces/GetTokenOptions.html":{},"interfaces/GetTokenResponse.html":{},"interfaces/OAuth2ClientOptions.html":{},"interfaces/RefreshAccessTokenCallback.html":{},"interfaces/RefreshAccessTokenResponse.html":{},"interfaces/RefreshOptions.html":{},"interfaces/RequestMetadataCallback.html":{},"interfaces/RequestMetadataResponse.html":{},"interfaces/RevokeCredentialsResult.html":{},"interfaces/TokenInfo.html":{},"interfaces/TokenInfoRequest.html":{},"interfaces/VerifyIdTokenOptions.html":{}}}],["oauth2client.google_oauth2_revoke_url_",{"_index":1083,"title":{},"body":{"interfaces/FederatedSignonCertsResponse.html":{},"interfaces/GetAccessTokenCallback.html":{},"interfaces/GetAccessTokenResponse.html":{},"interfaces/GetFederatedSignonCertsCallback.html":{},"interfaces/GetTokenCallback.html":{},"interfaces/GetTokenOptions.html":{},"interfaces/GetTokenResponse.html":{},"interfaces/OAuth2ClientOptions.html":{},"interfaces/RefreshAccessTokenCallback.html":{},"interfaces/RefreshAccessTokenResponse.html":{},"interfaces/RefreshOptions.html":{},"interfaces/RequestMetadataCallback.html":{},"interfaces/RequestMetadataResponse.html":{},"interfaces/RevokeCredentialsResult.html":{},"interfaces/TokenInfo.html":{},"interfaces/TokenInfoRequest.html":{},"interfaces/VerifyIdTokenOptions.html":{}}}],["oauth2client.google_oauth2_token_url_",{"_index":1013,"title":{},"body":{"interfaces/FederatedSignonCertsResponse.html":{},"interfaces/GetAccessTokenCallback.html":{},"interfaces/GetAccessTokenResponse.html":{},"interfaces/GetFederatedSignonCertsCallback.html":{},"interfaces/GetTokenCallback.html":{},"interfaces/GetTokenOptions.html":{},"interfaces/GetTokenResponse.html":{},"interfaces/OAuth2ClientOptions.html":{},"interfaces/RefreshAccessTokenCallback.html":{},"interfaces/RefreshAccessTokenResponse.html":{},"interfaces/RefreshOptions.html":{},"interfaces/RequestMetadataCallback.html":{},"interfaces/RequestMetadataResponse.html":{},"interfaces/RevokeCredentialsResult.html":{},"interfaces/TokenInfo.html":{},"interfaces/TokenInfoRequest.html":{},"interfaces/VerifyIdTokenOptions.html":{}}}],["oauth2client.google_token_info_url",{"_index":1149,"title":{},"body":{"interfaces/FederatedSignonCertsResponse.html":{},"interfaces/GetAccessTokenCallback.html":{},"interfaces/GetAccessTokenResponse.html":{},"interfaces/GetFederatedSignonCertsCallback.html":{},"interfaces/GetTokenCallback.html":{},"interfaces/GetTokenOptions.html":{},"interfaces/GetTokenResponse.html":{},"interfaces/OAuth2ClientOptions.html":{},"interfaces/RefreshAccessTokenCallback.html":{},"interfaces/RefreshAccessTokenResponse.html":{},"interfaces/RefreshOptions.html":{},"interfaces/RequestMetadataCallback.html":{},"interfaces/RequestMetadataResponse.html":{},"interfaces/RevokeCredentialsResult.html":{},"interfaces/TokenInfo.html":{},"interfaces/TokenInfoRequest.html":{},"interfaces/VerifyIdTokenOptions.html":{}}}],["oauth2client.issuers_",{"_index":1143,"title":{},"body":{"interfaces/FederatedSignonCertsResponse.html":{},"interfaces/GetAccessTokenCallback.html":{},"interfaces/GetAccessTokenResponse.html":{},"interfaces/GetFederatedSignonCertsCallback.html":{},"interfaces/GetTokenCallback.html":{},"interfaces/GetTokenOptions.html":{},"interfaces/GetTokenResponse.html":{},"interfaces/OAuth2ClientOptions.html":{},"interfaces/RefreshAccessTokenCallback.html":{},"interfaces/RefreshAccessTokenResponse.html":{},"interfaces/RefreshOptions.html":{},"interfaces/RequestMetadataCallback.html":{},"interfaces/RequestMetadataResponse.html":{},"interfaces/RevokeCredentialsResult.html":{},"interfaces/TokenInfo.html":{},"interfaces/TokenInfoRequest.html":{},"interfaces/VerifyIdTokenOptions.html":{}}}],["oauth2client.refreshaccesstoken",{"_index":1768,"title":{},"body":{"index.html":{}}}],["oauth2client.request({url",{"_index":1719,"title":{},"body":{"index.html":{}}}],["oauth2client.setcredentials(r.token",{"_index":1745,"title":{},"body":{"index.html":{}}}],["oauth2client.setcredentials(tokens);manu",{"_index":1763,"title":{},"body":{"index.html":{}}}],["oauth2clientopt",{"_index":893,"title":{"interfaces/OAuth2ClientOptions.html":{}},"body":{"interfaces/FederatedSignonCertsResponse.html":{},"interfaces/GetAccessTokenCallback.html":{},"interfaces/GetAccessTokenResponse.html":{},"interfaces/GetFederatedSignonCertsCallback.html":{},"interfaces/GetTokenCallback.html":{},"interfaces/GetTokenOptions.html":{},"interfaces/GetTokenResponse.html":{},"interfaces/OAuth2ClientOptions.html":{},"interfaces/RefreshAccessTokenCallback.html":{},"interfaces/RefreshAccessTokenResponse.html":{},"interfaces/RefreshOptions.html":{},"interfaces/RequestMetadataCallback.html":{},"interfaces/RequestMetadataResponse.html":{},"interfaces/RevokeCredentialsResult.html":{},"interfaces/TokenInfo.html":{},"interfaces/TokenInfoRequest.html":{},"interfaces/VerifyIdTokenOptions.html":{}}}],["oauth_get_request_metadata_deprec",{"_index":1452,"title":{},"body":{"interfaces/Warning.html":{},"miscellaneous/variables.html":{}}}],["object",{"_index":68,"title":{},"body":{"interfaces/ADCCallback.html":{},"interfaces/ADCResponse.html":{},"interfaces/BodyResponseCallback.html":{},"interfaces/CredentialCallback.html":{},"classes/DefaultTransporter.html":{},"interfaces/FederatedSignonCertsResponse.html":{},"interfaces/GetAccessTokenCallback.html":{},"interfaces/GetAccessTokenResponse.html":{},"interfaces/GetFederatedSignonCertsCallback.html":{},"interfaces/GetTokenCallback.html":{},"interfaces/GetTokenOptions.html":{},"interfaces/GetTokenResponse.html":{},"interfaces/GoogleAuthOptions.html":{},"classes/IAMAuth.html":{},"classes/JWTAccess.html":{},"interfaces/JWTOptions.html":{},"interfaces/OAuth2ClientOptions.html":{},"interfaces/ProjectIdCallback.html":{},"interfaces/RefreshAccessTokenCallback.html":{},"interfaces/RefreshAccessTokenResponse.html":{},"interfaces/RefreshOptions.html":{},"interfaces/RequestError.html":{},"interfaces/RequestMetadata.html":{},"interfaces/RequestMetadataCallback.html":{},"interfaces/RequestMetadataResponse.html":{},"interfaces/RevokeCredentialsResult.html":{},"interfaces/SignBlobResponse.html":{},"interfaces/TokenInfo.html":{},"interfaces/TokenInfoRequest.html":{},"interfaces/Transporter.html":{},"interfaces/UserRefreshClientOptions.html":{},"interfaces/VerifyIdTokenOptions.html":{},"interfaces/Warning.html":{},"changelog.html":{},"index.html":{},"license.html":{},"miscellaneous/variables.html":{}}}],["object.assign",{"_index":1150,"title":{},"body":{"interfaces/FederatedSignonCertsResponse.html":{},"interfaces/GetAccessTokenCallback.html":{},"interfaces/GetAccessTokenResponse.html":{},"interfaces/GetFederatedSignonCertsCallback.html":{},"interfaces/GetTokenCallback.html":{},"interfaces/GetTokenOptions.html":{},"interfaces/GetTokenResponse.html":{},"interfaces/OAuth2ClientOptions.html":{},"interfaces/RefreshAccessTokenCallback.html":{},"interfaces/RefreshAccessTokenResponse.html":{},"interfaces/RefreshOptions.html":{},"interfaces/RequestMetadataCallback.html":{},"interfaces/RequestMetadataResponse.html":{},"interfaces/RevokeCredentialsResult.html":{},"interfaces/TokenInfo.html":{},"interfaces/TokenInfoRequest.html":{},"interfaces/VerifyIdTokenOptions.html":{}}}],["object.assign(defaultclaim",{"_index":1266,"title":{},"body":{"classes/JWTAccess.html":{}}}],["object.assign(opts.head",{"_index":465,"title":{},"body":{"interfaces/ADCCallback.html":{},"interfaces/ADCResponse.html":{},"interfaces/CredentialCallback.html":{},"interfaces/GoogleAuthOptions.html":{},"interfaces/ProjectIdCallback.html":{},"interfaces/SignBlobResponse.html":{}}}],["object.assign(opts.param",{"_index":1106,"title":{},"body":{"interfaces/FederatedSignonCertsResponse.html":{},"interfaces/GetAccessTokenCallback.html":{},"interfaces/GetAccessTokenResponse.html":{},"interfaces/GetFederatedSignonCertsCallback.html":{},"interfaces/GetTokenCallback.html":{},"interfaces/GetTokenOptions.html":{},"interfaces/GetTokenResponse.html":{},"interfaces/OAuth2ClientOptions.html":{},"interfaces/RefreshAccessTokenCallback.html":{},"interfaces/RefreshAccessTokenResponse.html":{},"interfaces/RefreshOptions.html":{},"interfaces/RequestMetadataCallback.html":{},"interfaces/RequestMetadataResponse.html":{},"interfaces/RevokeCredentialsResult.html":{},"interfaces/TokenInfo.html":{},"interfaces/TokenInfoRequest.html":{},"interfaces/VerifyIdTokenOptions.html":{}}}],["oblig",{"_index":1977,"title":{},"body":{"license.html":{}}}],["obtain",{"_index":146,"title":{},"body":{"interfaces/ADCCallback.html":{},"interfaces/ADCResponse.html":{},"interfaces/CredentialCallback.html":{},"interfaces/Credentials.html":{},"interfaces/FederatedSignonCertsResponse.html":{},"interfaces/GetAccessTokenCallback.html":{},"interfaces/GetAccessTokenResponse.html":{},"interfaces/GetFederatedSignonCertsCallback.html":{},"interfaces/GetTokenCallback.html":{},"interfaces/GetTokenOptions.html":{},"interfaces/GetTokenResponse.html":{},"interfaces/GoogleAuthOptions.html":{},"interfaces/JWTOptions.html":{},"classes/LoginTicket.html":{},"interfaces/OAuth2ClientOptions.html":{},"interfaces/ProjectIdCallback.html":{},"interfaces/RefreshAccessTokenCallback.html":{},"interfaces/RefreshAccessTokenResponse.html":{},"interfaces/RefreshOptions.html":{},"interfaces/RequestMetadataCallback.html":{},"interfaces/RequestMetadataResponse.html":{},"interfaces/RevokeCredentialsResult.html":{},"interfaces/SignBlobResponse.html":{},"interfaces/TokenInfo.html":{},"interfaces/TokenInfoRequest.html":{},"interfaces/VerifyIdTokenOptions.html":{},"miscellaneous/functions.html":{},"index.html":{},"license.html":{}}}],["offer",{"_index":1895,"title":{},"body":{"license.html":{}}}],["offici",{"_index":1665,"title":{},"body":{"index.html":{}}}],["offlin",{"_index":747,"title":{},"body":{"interfaces/FederatedSignonCertsResponse.html":{},"interfaces/GetAccessTokenCallback.html":{},"interfaces/GetAccessTokenResponse.html":{},"interfaces/GetFederatedSignonCertsCallback.html":{},"interfaces/GetTokenCallback.html":{},"interfaces/GetTokenOptions.html":{},"interfaces/GetTokenResponse.html":{},"interfaces/OAuth2ClientOptions.html":{},"interfaces/RefreshAccessTokenCallback.html":{},"interfaces/RefreshAccessTokenResponse.html":{},"interfaces/RefreshOptions.html":{},"interfaces/RequestMetadataCallback.html":{},"interfaces/RequestMetadataResponse.html":{},"interfaces/RevokeCredentialsResult.html":{},"interfaces/TokenInfo.html":{},"interfaces/TokenInfoRequest.html":{},"interfaces/VerifyIdTokenOptions.html":{},"index.html":{}}}],["old",{"_index":1493,"title":{},"body":{"changelog.html":{}}}],["omit",{"_index":1462,"title":{},"body":{"changelog.html":{}}}],["on",{"_index":769,"title":{},"body":{"interfaces/FederatedSignonCertsResponse.html":{},"interfaces/GetAccessTokenCallback.html":{},"interfaces/GetAccessTokenResponse.html":{},"interfaces/GetFederatedSignonCertsCallback.html":{},"interfaces/GetTokenCallback.html":{},"interfaces/GetTokenOptions.html":{},"interfaces/GetTokenResponse.html":{},"classes/LoginTicket.html":{},"interfaces/OAuth2ClientOptions.html":{},"interfaces/RefreshAccessTokenCallback.html":{},"interfaces/RefreshAccessTokenResponse.html":{},"interfaces/RefreshOptions.html":{},"interfaces/RequestMetadataCallback.html":{},"interfaces/RequestMetadataResponse.html":{},"interfaces/RevokeCredentialsResult.html":{},"interfaces/TokenInfo.html":{},"interfaces/TokenInfoRequest.html":{},"interfaces/TokenPayload.html":{},"interfaces/UserRefreshClientOptions.html":{},"interfaces/VerifyIdTokenOptions.html":{},"license.html":{}}}],["on('data",{"_index":348,"title":{},"body":{"interfaces/ADCCallback.html":{},"interfaces/ADCResponse.html":{},"interfaces/CredentialCallback.html":{},"interfaces/GoogleAuthOptions.html":{},"classes/JWTAccess.html":{},"interfaces/JWTOptions.html":{},"interfaces/ProjectIdCallback.html":{},"interfaces/SignBlobResponse.html":{},"interfaces/UserRefreshClientOptions.html":{}}}],["on('end",{"_index":350,"title":{},"body":{"interfaces/ADCCallback.html":{},"interfaces/ADCResponse.html":{},"interfaces/CredentialCallback.html":{},"interfaces/GoogleAuthOptions.html":{},"classes/JWTAccess.html":{},"interfaces/JWTOptions.html":{},"interfaces/ProjectIdCallback.html":{},"interfaces/SignBlobResponse.html":{},"interfaces/UserRefreshClientOptions.html":{}}}],["on('error",{"_index":347,"title":{},"body":{"interfaces/ADCCallback.html":{},"interfaces/ADCResponse.html":{},"interfaces/CredentialCallback.html":{},"interfaces/GoogleAuthOptions.html":{},"classes/JWTAccess.html":{},"interfaces/JWTOptions.html":{},"interfaces/ProjectIdCallback.html":{},"interfaces/SignBlobResponse.html":{},"interfaces/UserRefreshClientOptions.html":{}}}],["onc",{"_index":1112,"title":{},"body":{"interfaces/FederatedSignonCertsResponse.html":{},"interfaces/GetAccessTokenCallback.html":{},"interfaces/GetAccessTokenResponse.html":{},"interfaces/GetFederatedSignonCertsCallback.html":{},"interfaces/GetTokenCallback.html":{},"interfaces/GetTokenOptions.html":{},"interfaces/GetTokenResponse.html":{},"classes/LoginTicket.html":{},"interfaces/OAuth2ClientOptions.html":{},"interfaces/RefreshAccessTokenCallback.html":{},"interfaces/RefreshAccessTokenResponse.html":{},"interfaces/RefreshOptions.html":{},"interfaces/RequestMetadataCallback.html":{},"interfaces/RequestMetadataResponse.html":{},"interfaces/RevokeCredentialsResult.html":{},"interfaces/TokenInfo.html":{},"interfaces/TokenInfoRequest.html":{},"interfaces/TokenPayload.html":{},"interfaces/VerifyIdTokenOptions.html":{},"interfaces/Warning.html":{},"index.html":{}}}],["onlin",{"_index":746,"title":{},"body":{"interfaces/FederatedSignonCertsResponse.html":{},"interfaces/GetAccessTokenCallback.html":{},"interfaces/GetAccessTokenResponse.html":{},"interfaces/GetFederatedSignonCertsCallback.html":{},"interfaces/GetTokenCallback.html":{},"interfaces/GetTokenOptions.html":{},"interfaces/GetTokenResponse.html":{},"interfaces/OAuth2ClientOptions.html":{},"interfaces/RefreshAccessTokenCallback.html":{},"interfaces/RefreshAccessTokenResponse.html":{},"interfaces/RefreshOptions.html":{},"interfaces/RequestMetadataCallback.html":{},"interfaces/RequestMetadataResponse.html":{},"interfaces/RevokeCredentialsResult.html":{},"interfaces/TokenInfo.html":{},"interfaces/TokenInfoRequest.html":{},"interfaces/VerifyIdTokenOptions.html":{}}}],["open",{"_index":306,"title":{},"body":{"interfaces/ADCCallback.html":{},"interfaces/ADCResponse.html":{},"interfaces/CredentialCallback.html":{},"interfaces/GoogleAuthOptions.html":{},"interfaces/ProjectIdCallback.html":{},"interfaces/SignBlobResponse.html":{},"index.html":{}}}],["openid",{"_index":849,"title":{},"body":{"interfaces/FederatedSignonCertsResponse.html":{},"interfaces/GetAccessTokenCallback.html":{},"interfaces/GetAccessTokenResponse.html":{},"interfaces/GetFederatedSignonCertsCallback.html":{},"interfaces/GetTokenCallback.html":{},"interfaces/GetTokenOptions.html":{},"interfaces/GetTokenResponse.html":{},"interfaces/OAuth2ClientOptions.html":{},"interfaces/RefreshAccessTokenCallback.html":{},"interfaces/RefreshAccessTokenResponse.html":{},"interfaces/RefreshOptions.html":{},"interfaces/RequestMetadataCallback.html":{},"interfaces/RequestMetadataResponse.html":{},"interfaces/RevokeCredentialsResult.html":{},"interfaces/TokenInfo.html":{},"interfaces/TokenInfoRequest.html":{},"interfaces/VerifyIdTokenOptions.html":{}}}],["oper",{"_index":359,"title":{},"body":{"interfaces/ADCCallback.html":{},"interfaces/ADCResponse.html":{},"interfaces/CredentialCallback.html":{},"interfaces/GoogleAuthOptions.html":{},"interfaces/ProjectIdCallback.html":{},"interfaces/SignBlobResponse.html":{}}}],["opn",{"_index":1710,"title":{},"body":{"index.html":{}}}],["opn(authorizeurl",{"_index":1749,"title":{},"body":{"index.html":{}}}],["opt",{"_index":119,"title":{},"body":{"interfaces/ADCCallback.html":{},"interfaces/ADCResponse.html":{},"interfaces/BodyResponseCallback.html":{},"interfaces/CredentialCallback.html":{},"classes/DefaultTransporter.html":{},"interfaces/FederatedSignonCertsResponse.html":{},"interfaces/GetAccessTokenCallback.html":{},"interfaces/GetAccessTokenResponse.html":{},"interfaces/GetFederatedSignonCertsCallback.html":{},"interfaces/GetTokenCallback.html":{},"interfaces/GetTokenOptions.html":{},"interfaces/GetTokenResponse.html":{},"interfaces/GoogleAuthOptions.html":{},"interfaces/JWTOptions.html":{},"interfaces/OAuth2ClientOptions.html":{},"interfaces/ProjectIdCallback.html":{},"interfaces/RefreshAccessTokenCallback.html":{},"interfaces/RefreshAccessTokenResponse.html":{},"interfaces/RefreshOptions.html":{},"interfaces/RequestError.html":{},"interfaces/RequestMetadataCallback.html":{},"interfaces/RequestMetadataResponse.html":{},"interfaces/RevokeCredentialsResult.html":{},"interfaces/SignBlobResponse.html":{},"interfaces/TokenInfo.html":{},"interfaces/TokenInfoRequest.html":{},"interfaces/Transporter.html":{},"interfaces/UserRefreshClientOptions.html":{},"interfaces/VerifyIdTokenOptions.html":{}}}],["optim",{"_index":767,"title":{},"body":{"interfaces/FederatedSignonCertsResponse.html":{},"interfaces/GetAccessTokenCallback.html":{},"interfaces/GetAccessTokenResponse.html":{},"interfaces/GetFederatedSignonCertsCallback.html":{},"interfaces/GetTokenCallback.html":{},"interfaces/GetTokenOptions.html":{},"interfaces/GetTokenResponse.html":{},"interfaces/OAuth2ClientOptions.html":{},"interfaces/RefreshAccessTokenCallback.html":{},"interfaces/RefreshAccessTokenResponse.html":{},"interfaces/RefreshOptions.html":{},"interfaces/RequestMetadataCallback.html":{},"interfaces/RequestMetadataResponse.html":{},"interfaces/RevokeCredentialsResult.html":{},"interfaces/TokenInfo.html":{},"interfaces/TokenInfoRequest.html":{},"interfaces/VerifyIdTokenOptions.html":{}}}],["option",{"_index":150,"title":{},"body":{"interfaces/ADCCallback.html":{},"interfaces/ADCResponse.html":{},"interfaces/BodyResponseCallback.html":{},"interfaces/ComputeOptions.html":{},"interfaces/CredentialBody.html":{},"interfaces/CredentialCallback.html":{},"interfaces/CredentialRequest.html":{},"interfaces/Credentials.html":{},"classes/DefaultTransporter.html":{},"interfaces/FederatedSignonCertsResponse.html":{},"interfaces/GetAccessTokenCallback.html":{},"interfaces/GetAccessTokenResponse.html":{},"interfaces/GetFederatedSignonCertsCallback.html":{},"interfaces/GetTokenCallback.html":{},"interfaces/GetTokenOptions.html":{},"interfaces/GetTokenResponse.html":{},"interfaces/GoogleAuthOptions.html":{},"classes/IAMAuth.html":{},"classes/JWTAccess.html":{},"interfaces/JWTInput.html":{},"interfaces/JWTOptions.html":{},"classes/LoginTicket.html":{},"interfaces/OAuth2ClientOptions.html":{},"classes/PemVerifier.html":{},"interfaces/ProjectIdCallback.html":{},"interfaces/RefreshAccessTokenCallback.html":{},"interfaces/RefreshAccessTokenResponse.html":{},"interfaces/RefreshOptions.html":{},"interfaces/RequestError.html":{},"interfaces/RequestMetadataCallback.html":{},"interfaces/RequestMetadataResponse.html":{},"interfaces/RevokeCredentialsResult.html":{},"interfaces/SignBlobResponse.html":{},"interfaces/TokenInfo.html":{},"interfaces/TokenInfoRequest.html":{},"interfaces/TokenPayload.html":{},"interfaces/Transporter.html":{},"interfaces/UserRefreshClientOptions.html":{},"interfaces/VerifyIdTokenOptions.html":{},"interfaces/Warning.html":{},"miscellaneous/functions.html":{},"index.html":{}}}],["options.audi",{"_index":1142,"title":{},"body":{"interfaces/FederatedSignonCertsResponse.html":{},"interfaces/GetAccessTokenCallback.html":{},"interfaces/GetAccessTokenResponse.html":{},"interfaces/GetFederatedSignonCertsCallback.html":{},"interfaces/GetTokenCallback.html":{},"interfaces/GetTokenOptions.html":{},"interfaces/GetTokenResponse.html":{},"interfaces/OAuth2ClientOptions.html":{},"interfaces/RefreshAccessTokenCallback.html":{},"interfaces/RefreshAccessTokenResponse.html":{},"interfaces/RefreshOptions.html":{},"interfaces/RequestMetadataCallback.html":{},"interfaces/RequestMetadataResponse.html":{},"interfaces/RevokeCredentialsResult.html":{},"interfaces/TokenInfo.html":{},"interfaces/TokenInfoRequest.html":{},"interfaces/VerifyIdTokenOptions.html":{}}}],["options.client_id",{"_index":1015,"title":{},"body":{"interfaces/FederatedSignonCertsResponse.html":{},"interfaces/GetAccessTokenCallback.html":{},"interfaces/GetAccessTokenResponse.html":{},"interfaces/GetFederatedSignonCertsCallback.html":{},"interfaces/GetTokenCallback.html":{},"interfaces/GetTokenOptions.html":{},"interfaces/GetTokenResponse.html":{},"interfaces/OAuth2ClientOptions.html":{},"interfaces/RefreshAccessTokenCallback.html":{},"interfaces/RefreshAccessTokenResponse.html":{},"interfaces/RefreshOptions.html":{},"interfaces/RequestMetadataCallback.html":{},"interfaces/RequestMetadataResponse.html":{},"interfaces/RevokeCredentialsResult.html":{},"interfaces/TokenInfo.html":{},"interfaces/TokenInfoRequest.html":{},"interfaces/VerifyIdTokenOptions.html":{}}}],["options.cod",{"_index":1014,"title":{},"body":{"interfaces/FederatedSignonCertsResponse.html":{},"interfaces/GetAccessTokenCallback.html":{},"interfaces/GetAccessTokenResponse.html":{},"interfaces/GetFederatedSignonCertsCallback.html":{},"interfaces/GetTokenCallback.html":{},"interfaces/GetTokenOptions.html":{},"interfaces/GetTokenResponse.html":{},"interfaces/OAuth2ClientOptions.html":{},"interfaces/RefreshAccessTokenCallback.html":{},"interfaces/RefreshAccessTokenResponse.html":{},"interfaces/RefreshOptions.html":{},"interfaces/RequestMetadataCallback.html":{},"interfaces/RequestMetadataResponse.html":{},"interfaces/RevokeCredentialsResult.html":{},"interfaces/TokenInfo.html":{},"interfaces/TokenInfoRequest.html":{},"interfaces/VerifyIdTokenOptions.html":{}}}],["options.codeverifi",{"_index":1019,"title":{},"body":{"interfaces/FederatedSignonCertsResponse.html":{},"interfaces/GetAccessTokenCallback.html":{},"interfaces/GetAccessTokenResponse.html":{},"interfaces/GetFederatedSignonCertsCallback.html":{},"interfaces/GetTokenCallback.html":{},"interfaces/GetTokenOptions.html":{},"interfaces/GetTokenResponse.html":{},"interfaces/OAuth2ClientOptions.html":{},"interfaces/RefreshAccessTokenCallback.html":{},"interfaces/RefreshAccessTokenResponse.html":{},"interfaces/RefreshOptions.html":{},"interfaces/RequestMetadataCallback.html":{},"interfaces/RequestMetadataResponse.html":{},"interfaces/RevokeCredentialsResult.html":{},"interfaces/TokenInfo.html":{},"interfaces/TokenInfoRequest.html":{},"interfaces/VerifyIdTokenOptions.html":{}}}],["options.credenti",{"_index":444,"title":{},"body":{"interfaces/ADCCallback.html":{},"interfaces/ADCResponse.html":{},"interfaces/CredentialCallback.html":{},"interfaces/GoogleAuthOptions.html":{},"interfaces/ProjectIdCallback.html":{},"interfaces/SignBlobResponse.html":{}}}],["options.idtoken",{"_index":1138,"title":{},"body":{"interfaces/FederatedSignonCertsResponse.html":{},"interfaces/GetAccessTokenCallback.html":{},"interfaces/GetAccessTokenResponse.html":{},"interfaces/GetFederatedSignonCertsCallback.html":{},"interfaces/GetTokenCallback.html":{},"interfaces/GetTokenOptions.html":{},"interfaces/GetTokenResponse.html":{},"interfaces/OAuth2ClientOptions.html":{},"interfaces/RefreshAccessTokenCallback.html":{},"interfaces/RefreshAccessTokenResponse.html":{},"interfaces/RefreshOptions.html":{},"interfaces/RequestMetadataCallback.html":{},"interfaces/RequestMetadataResponse.html":{},"interfaces/RevokeCredentialsResult.html":{},"interfaces/TokenInfo.html":{},"interfaces/TokenInfoRequest.html":{},"interfaces/VerifyIdTokenOptions.html":{}}}],["options.keyfil",{"_index":442,"title":{},"body":{"interfaces/ADCCallback.html":{},"interfaces/ADCResponse.html":{},"interfaces/CredentialCallback.html":{},"interfaces/GoogleAuthOptions.html":{},"interfaces/ProjectIdCallback.html":{},"interfaces/SignBlobResponse.html":{}}}],["options.keyfilenam",{"_index":441,"title":{},"body":{"interfaces/ADCCallback.html":{},"interfaces/ADCResponse.html":{},"interfaces/CredentialCallback.html":{},"interfaces/GoogleAuthOptions.html":{},"interfaces/ProjectIdCallback.html":{},"interfaces/SignBlobResponse.html":{}}}],["options.maxexpiri",{"_index":1144,"title":{},"body":{"interfaces/FederatedSignonCertsResponse.html":{},"interfaces/GetAccessTokenCallback.html":{},"interfaces/GetAccessTokenResponse.html":{},"interfaces/GetFederatedSignonCertsCallback.html":{},"interfaces/GetTokenCallback.html":{},"interfaces/GetTokenOptions.html":{},"interfaces/GetTokenResponse.html":{},"interfaces/OAuth2ClientOptions.html":{},"interfaces/RefreshAccessTokenCallback.html":{},"interfaces/RefreshAccessTokenResponse.html":{},"interfaces/RefreshOptions.html":{},"interfaces/RequestMetadataCallback.html":{},"interfaces/RequestMetadataResponse.html":{},"interfaces/RevokeCredentialsResult.html":{},"interfaces/TokenInfo.html":{},"interfaces/TokenInfoRequest.html":{},"interfaces/VerifyIdTokenOptions.html":{}}}],["options.redirect_uri",{"_index":1016,"title":{},"body":{"interfaces/FederatedSignonCertsResponse.html":{},"interfaces/GetAccessTokenCallback.html":{},"interfaces/GetAccessTokenResponse.html":{},"interfaces/GetFederatedSignonCertsCallback.html":{},"interfaces/GetTokenCallback.html":{},"interfaces/GetTokenOptions.html":{},"interfaces/GetTokenResponse.html":{},"interfaces/OAuth2ClientOptions.html":{},"interfaces/RefreshAccessTokenCallback.html":{},"interfaces/RefreshAccessTokenResponse.html":{},"interfaces/RefreshOptions.html":{},"interfaces/RequestMetadataCallback.html":{},"interfaces/RequestMetadataResponse.html":{},"interfaces/RevokeCredentialsResult.html":{},"interfaces/TokenInfo.html":{},"interfaces/TokenInfoRequest.html":{},"interfaces/VerifyIdTokenOptions.html":{}}}],["options.scop",{"_index":443,"title":{},"body":{"interfaces/ADCCallback.html":{},"interfaces/ADCResponse.html":{},"interfaces/CredentialCallback.html":{},"interfaces/GoogleAuthOptions.html":{},"interfaces/ProjectIdCallback.html":{},"interfaces/SignBlobResponse.html":{}}}],["options.serviceaccountemail",{"_index":600,"title":{},"body":{"interfaces/ComputeOptions.html":{}}}],["optionsorcallback",{"_index":195,"title":{},"body":{"interfaces/ADCCallback.html":{},"interfaces/ADCResponse.html":{},"interfaces/CredentialCallback.html":{},"interfaces/GoogleAuthOptions.html":{},"interfaces/ProjectIdCallback.html":{},"interfaces/SignBlobResponse.html":{}}}],["optionsorclientid",{"_index":918,"title":{},"body":{"interfaces/FederatedSignonCertsResponse.html":{},"interfaces/GetAccessTokenCallback.html":{},"interfaces/GetAccessTokenResponse.html":{},"interfaces/GetFederatedSignonCertsCallback.html":{},"interfaces/GetTokenCallback.html":{},"interfaces/GetTokenOptions.html":{},"interfaces/GetTokenResponse.html":{},"interfaces/OAuth2ClientOptions.html":{},"interfaces/RefreshAccessTokenCallback.html":{},"interfaces/RefreshAccessTokenResponse.html":{},"interfaces/RefreshOptions.html":{},"interfaces/RequestMetadataCallback.html":{},"interfaces/RequestMetadataResponse.html":{},"interfaces/RevokeCredentialsResult.html":{},"interfaces/TokenInfo.html":{},"interfaces/TokenInfoRequest.html":{},"interfaces/UserRefreshClientOptions.html":{},"interfaces/VerifyIdTokenOptions.html":{}}}],["optionsoremail",{"_index":1290,"title":{},"body":{"interfaces/JWTOptions.html":{}}}],["opts.additionalclaim",{"_index":1300,"title":{},"body":{"interfaces/JWTOptions.html":{}}}],["opts.client_id",{"_index":963,"title":{},"body":{"interfaces/FederatedSignonCertsResponse.html":{},"interfaces/GetAccessTokenCallback.html":{},"interfaces/GetAccessTokenResponse.html":{},"interfaces/GetFederatedSignonCertsCallback.html":{},"interfaces/GetTokenCallback.html":{},"interfaces/GetTokenOptions.html":{},"interfaces/GetTokenResponse.html":{},"interfaces/OAuth2ClientOptions.html":{},"interfaces/RefreshAccessTokenCallback.html":{},"interfaces/RefreshAccessTokenResponse.html":{},"interfaces/RefreshOptions.html":{},"interfaces/RequestMetadataCallback.html":{},"interfaces/RequestMetadataResponse.html":{},"interfaces/RevokeCredentialsResult.html":{},"interfaces/TokenInfo.html":{},"interfaces/TokenInfoRequest.html":{},"interfaces/VerifyIdTokenOptions.html":{}}}],["opts.clientid",{"_index":922,"title":{},"body":{"interfaces/FederatedSignonCertsResponse.html":{},"interfaces/GetAccessTokenCallback.html":{},"interfaces/GetAccessTokenResponse.html":{},"interfaces/GetFederatedSignonCertsCallback.html":{},"interfaces/GetTokenCallback.html":{},"interfaces/GetTokenOptions.html":{},"interfaces/GetTokenResponse.html":{},"interfaces/OAuth2ClientOptions.html":{},"interfaces/RefreshAccessTokenCallback.html":{},"interfaces/RefreshAccessTokenResponse.html":{},"interfaces/RefreshOptions.html":{},"interfaces/RequestMetadataCallback.html":{},"interfaces/RequestMetadataResponse.html":{},"interfaces/RevokeCredentialsResult.html":{},"interfaces/TokenInfo.html":{},"interfaces/TokenInfoRequest.html":{},"interfaces/UserRefreshClientOptions.html":{},"interfaces/VerifyIdTokenOptions.html":{}}}],["opts.clientsecret",{"_index":924,"title":{},"body":{"interfaces/FederatedSignonCertsResponse.html":{},"interfaces/GetAccessTokenCallback.html":{},"interfaces/GetAccessTokenResponse.html":{},"interfaces/GetFederatedSignonCertsCallback.html":{},"interfaces/GetTokenCallback.html":{},"interfaces/GetTokenOptions.html":{},"interfaces/GetTokenResponse.html":{},"interfaces/OAuth2ClientOptions.html":{},"interfaces/RefreshAccessTokenCallback.html":{},"interfaces/RefreshAccessTokenResponse.html":{},"interfaces/RefreshOptions.html":{},"interfaces/RequestMetadataCallback.html":{},"interfaces/RequestMetadataResponse.html":{},"interfaces/RevokeCredentialsResult.html":{},"interfaces/TokenInfo.html":{},"interfaces/TokenInfoRequest.html":{},"interfaces/UserRefreshClientOptions.html":{},"interfaces/VerifyIdTokenOptions.html":{}}}],["opts.code_challeng",{"_index":961,"title":{},"body":{"interfaces/FederatedSignonCertsResponse.html":{},"interfaces/GetAccessTokenCallback.html":{},"interfaces/GetAccessTokenResponse.html":{},"interfaces/GetFederatedSignonCertsCallback.html":{},"interfaces/GetTokenCallback.html":{},"interfaces/GetTokenOptions.html":{},"interfaces/GetTokenResponse.html":{},"interfaces/OAuth2ClientOptions.html":{},"interfaces/RefreshAccessTokenCallback.html":{},"interfaces/RefreshAccessTokenResponse.html":{},"interfaces/RefreshOptions.html":{},"interfaces/RequestMetadataCallback.html":{},"interfaces/RequestMetadataResponse.html":{},"interfaces/RevokeCredentialsResult.html":{},"interfaces/TokenInfo.html":{},"interfaces/TokenInfoRequest.html":{},"interfaces/VerifyIdTokenOptions.html":{}}}],["opts.code_challenge_method",{"_index":960,"title":{},"body":{"interfaces/FederatedSignonCertsResponse.html":{},"interfaces/GetAccessTokenCallback.html":{},"interfaces/GetAccessTokenResponse.html":{},"interfaces/GetFederatedSignonCertsCallback.html":{},"interfaces/GetTokenCallback.html":{},"interfaces/GetTokenOptions.html":{},"interfaces/GetTokenResponse.html":{},"interfaces/OAuth2ClientOptions.html":{},"interfaces/RefreshAccessTokenCallback.html":{},"interfaces/RefreshAccessTokenResponse.html":{},"interfaces/RefreshOptions.html":{},"interfaces/RequestMetadataCallback.html":{},"interfaces/RequestMetadataResponse.html":{},"interfaces/RevokeCredentialsResult.html":{},"interfaces/TokenInfo.html":{},"interfaces/TokenInfoRequest.html":{},"interfaces/VerifyIdTokenOptions.html":{}}}],["opts.credenti",{"_index":128,"title":{},"body":{"interfaces/ADCCallback.html":{},"interfaces/ADCResponse.html":{},"interfaces/CredentialCallback.html":{},"interfaces/GoogleAuthOptions.html":{},"interfaces/ProjectIdCallback.html":{},"interfaces/SignBlobResponse.html":{}}}],["opts.eagerrefreshthresholdmilli",{"_index":928,"title":{},"body":{"interfaces/FederatedSignonCertsResponse.html":{},"interfaces/GetAccessTokenCallback.html":{},"interfaces/GetAccessTokenResponse.html":{},"interfaces/GetFederatedSignonCertsCallback.html":{},"interfaces/GetTokenCallback.html":{},"interfaces/GetTokenOptions.html":{},"interfaces/GetTokenResponse.html":{},"interfaces/JWTOptions.html":{},"interfaces/OAuth2ClientOptions.html":{},"interfaces/RefreshAccessTokenCallback.html":{},"interfaces/RefreshAccessTokenResponse.html":{},"interfaces/RefreshOptions.html":{},"interfaces/RequestMetadataCallback.html":{},"interfaces/RequestMetadataResponse.html":{},"interfaces/RevokeCredentialsResult.html":{},"interfaces/TokenInfo.html":{},"interfaces/TokenInfoRequest.html":{},"interfaces/UserRefreshClientOptions.html":{},"interfaces/VerifyIdTokenOptions.html":{}}}],["opts.email",{"_index":1293,"title":{},"body":{"interfaces/JWTOptions.html":{}}}],["opts.head",{"_index":464,"title":{},"body":{"interfaces/ADCCallback.html":{},"interfaces/ADCResponse.html":{},"interfaces/BodyResponseCallback.html":{},"interfaces/CredentialCallback.html":{},"classes/DefaultTransporter.html":{},"interfaces/FederatedSignonCertsResponse.html":{},"interfaces/GetAccessTokenCallback.html":{},"interfaces/GetAccessTokenResponse.html":{},"interfaces/GetFederatedSignonCertsCallback.html":{},"interfaces/GetTokenCallback.html":{},"interfaces/GetTokenOptions.html":{},"interfaces/GetTokenResponse.html":{},"interfaces/GoogleAuthOptions.html":{},"interfaces/OAuth2ClientOptions.html":{},"interfaces/ProjectIdCallback.html":{},"interfaces/RefreshAccessTokenCallback.html":{},"interfaces/RefreshAccessTokenResponse.html":{},"interfaces/RefreshOptions.html":{},"interfaces/RequestError.html":{},"interfaces/RequestMetadataCallback.html":{},"interfaces/RequestMetadataResponse.html":{},"interfaces/RevokeCredentialsResult.html":{},"interfaces/SignBlobResponse.html":{},"interfaces/TokenInfo.html":{},"interfaces/TokenInfoRequest.html":{},"interfaces/Transporter.html":{},"interfaces/VerifyIdTokenOptions.html":{}}}],["opts.headers.author",{"_index":1104,"title":{},"body":{"interfaces/FederatedSignonCertsResponse.html":{},"interfaces/GetAccessTokenCallback.html":{},"interfaces/GetAccessTokenResponse.html":{},"interfaces/GetFederatedSignonCertsCallback.html":{},"interfaces/GetTokenCallback.html":{},"interfaces/GetTokenOptions.html":{},"interfaces/GetTokenResponse.html":{},"interfaces/OAuth2ClientOptions.html":{},"interfaces/RefreshAccessTokenCallback.html":{},"interfaces/RefreshAccessTokenResponse.html":{},"interfaces/RefreshOptions.html":{},"interfaces/RequestMetadataCallback.html":{},"interfaces/RequestMetadataResponse.html":{},"interfaces/RevokeCredentialsResult.html":{},"interfaces/TokenInfo.html":{},"interfaces/TokenInfoRequest.html":{},"interfaces/VerifyIdTokenOptions.html":{}}}],["opts.headers['us",{"_index":538,"title":{},"body":{"interfaces/BodyResponseCallback.html":{},"classes/DefaultTransporter.html":{},"interfaces/RequestError.html":{},"interfaces/Transporter.html":{}}}],["opts.httpsag",{"_index":550,"title":{},"body":{"interfaces/BodyResponseCallback.html":{},"classes/DefaultTransporter.html":{},"interfaces/RequestError.html":{},"interfaces/Transporter.html":{}}}],["opts.key",{"_index":1295,"title":{},"body":{"interfaces/JWTOptions.html":{}}}],["opts.keyfil",{"_index":124,"title":{},"body":{"interfaces/ADCCallback.html":{},"interfaces/ADCResponse.html":{},"interfaces/CredentialCallback.html":{},"interfaces/GoogleAuthOptions.html":{},"interfaces/JWTOptions.html":{},"interfaces/ProjectIdCallback.html":{},"interfaces/SignBlobResponse.html":{}}}],["opts.keyfilenam",{"_index":123,"title":{},"body":{"interfaces/ADCCallback.html":{},"interfaces/ADCResponse.html":{},"interfaces/CredentialCallback.html":{},"interfaces/GoogleAuthOptions.html":{},"interfaces/ProjectIdCallback.html":{},"interfaces/SignBlobResponse.html":{}}}],["opts.keyid",{"_index":1296,"title":{},"body":{"interfaces/JWTOptions.html":{}}}],["opts.param",{"_index":1105,"title":{},"body":{"interfaces/FederatedSignonCertsResponse.html":{},"interfaces/GetAccessTokenCallback.html":{},"interfaces/GetAccessTokenResponse.html":{},"interfaces/GetFederatedSignonCertsCallback.html":{},"interfaces/GetTokenCallback.html":{},"interfaces/GetTokenOptions.html":{},"interfaces/GetTokenResponse.html":{},"interfaces/OAuth2ClientOptions.html":{},"interfaces/RefreshAccessTokenCallback.html":{},"interfaces/RefreshAccessTokenResponse.html":{},"interfaces/RefreshOptions.html":{},"interfaces/RequestMetadataCallback.html":{},"interfaces/RequestMetadataResponse.html":{},"interfaces/RevokeCredentialsResult.html":{},"interfaces/TokenInfo.html":{},"interfaces/TokenInfoRequest.html":{},"interfaces/VerifyIdTokenOptions.html":{}}}],["opts.projectid",{"_index":121,"title":{},"body":{"interfaces/ADCCallback.html":{},"interfaces/ADCResponse.html":{},"interfaces/CredentialCallback.html":{},"interfaces/GoogleAuthOptions.html":{},"interfaces/ProjectIdCallback.html":{},"interfaces/SignBlobResponse.html":{}}}],["opts.proxi",{"_index":552,"title":{},"body":{"interfaces/BodyResponseCallback.html":{},"classes/DefaultTransporter.html":{},"interfaces/RequestError.html":{},"interfaces/Transporter.html":{}}}],["opts.redirect_uri",{"_index":964,"title":{},"body":{"interfaces/FederatedSignonCertsResponse.html":{},"interfaces/GetAccessTokenCallback.html":{},"interfaces/GetAccessTokenResponse.html":{},"interfaces/GetFederatedSignonCertsCallback.html":{},"interfaces/GetTokenCallback.html":{},"interfaces/GetTokenOptions.html":{},"interfaces/GetTokenResponse.html":{},"interfaces/OAuth2ClientOptions.html":{},"interfaces/RefreshAccessTokenCallback.html":{},"interfaces/RefreshAccessTokenResponse.html":{},"interfaces/RefreshOptions.html":{},"interfaces/RequestMetadataCallback.html":{},"interfaces/RequestMetadataResponse.html":{},"interfaces/RevokeCredentialsResult.html":{},"interfaces/TokenInfo.html":{},"interfaces/TokenInfoRequest.html":{},"interfaces/VerifyIdTokenOptions.html":{}}}],["opts.redirecturi",{"_index":926,"title":{},"body":{"interfaces/FederatedSignonCertsResponse.html":{},"interfaces/GetAccessTokenCallback.html":{},"interfaces/GetAccessTokenResponse.html":{},"interfaces/GetFederatedSignonCertsCallback.html":{},"interfaces/GetTokenCallback.html":{},"interfaces/GetTokenOptions.html":{},"interfaces/GetTokenResponse.html":{},"interfaces/OAuth2ClientOptions.html":{},"interfaces/RefreshAccessTokenCallback.html":{},"interfaces/RefreshAccessTokenResponse.html":{},"interfaces/RefreshOptions.html":{},"interfaces/RequestMetadataCallback.html":{},"interfaces/RequestMetadataResponse.html":{},"interfaces/RevokeCredentialsResult.html":{},"interfaces/TokenInfo.html":{},"interfaces/TokenInfoRequest.html":{},"interfaces/VerifyIdTokenOptions.html":{}}}],["opts.refreshtoken",{"_index":1408,"title":{},"body":{"interfaces/UserRefreshClientOptions.html":{}}}],["opts.response_typ",{"_index":962,"title":{},"body":{"interfaces/FederatedSignonCertsResponse.html":{},"interfaces/GetAccessTokenCallback.html":{},"interfaces/GetAccessTokenResponse.html":{},"interfaces/GetFederatedSignonCertsCallback.html":{},"interfaces/GetTokenCallback.html":{},"interfaces/GetTokenOptions.html":{},"interfaces/GetTokenResponse.html":{},"interfaces/OAuth2ClientOptions.html":{},"interfaces/RefreshAccessTokenCallback.html":{},"interfaces/RefreshAccessTokenResponse.html":{},"interfaces/RefreshOptions.html":{},"interfaces/RequestMetadataCallback.html":{},"interfaces/RequestMetadataResponse.html":{},"interfaces/RevokeCredentialsResult.html":{},"interfaces/TokenInfo.html":{},"interfaces/TokenInfoRequest.html":{},"interfaces/VerifyIdTokenOptions.html":{}}}],["opts.scop",{"_index":126,"title":{},"body":{"interfaces/ADCCallback.html":{},"interfaces/ADCResponse.html":{},"interfaces/CredentialCallback.html":{},"interfaces/FederatedSignonCertsResponse.html":{},"interfaces/GetAccessTokenCallback.html":{},"interfaces/GetAccessTokenResponse.html":{},"interfaces/GetFederatedSignonCertsCallback.html":{},"interfaces/GetTokenCallback.html":{},"interfaces/GetTokenOptions.html":{},"interfaces/GetTokenResponse.html":{},"interfaces/GoogleAuthOptions.html":{},"interfaces/JWTOptions.html":{},"interfaces/OAuth2ClientOptions.html":{},"interfaces/ProjectIdCallback.html":{},"interfaces/RefreshAccessTokenCallback.html":{},"interfaces/RefreshAccessTokenResponse.html":{},"interfaces/RefreshOptions.html":{},"interfaces/RequestMetadataCallback.html":{},"interfaces/RequestMetadataResponse.html":{},"interfaces/RevokeCredentialsResult.html":{},"interfaces/SignBlobResponse.html":{},"interfaces/TokenInfo.html":{},"interfaces/TokenInfoRequest.html":{},"interfaces/VerifyIdTokenOptions.html":{}}}],["opts.scope.join",{"_index":965,"title":{},"body":{"interfaces/FederatedSignonCertsResponse.html":{},"interfaces/GetAccessTokenCallback.html":{},"interfaces/GetAccessTokenResponse.html":{},"interfaces/GetFederatedSignonCertsCallback.html":{},"interfaces/GetTokenCallback.html":{},"interfaces/GetTokenOptions.html":{},"interfaces/GetTokenResponse.html":{},"interfaces/OAuth2ClientOptions.html":{},"interfaces/RefreshAccessTokenCallback.html":{},"interfaces/RefreshAccessTokenResponse.html":{},"interfaces/RefreshOptions.html":{},"interfaces/RequestMetadataCallback.html":{},"interfaces/RequestMetadataResponse.html":{},"interfaces/RevokeCredentialsResult.html":{},"interfaces/TokenInfo.html":{},"interfaces/TokenInfoRequest.html":{},"interfaces/VerifyIdTokenOptions.html":{}}}],["opts.subject",{"_index":1298,"title":{},"body":{"interfaces/JWTOptions.html":{}}}],["opts.uri",{"_index":463,"title":{},"body":{"interfaces/ADCCallback.html":{},"interfaces/ADCResponse.html":{},"interfaces/CredentialCallback.html":{},"interfaces/GoogleAuthOptions.html":{},"interfaces/ProjectIdCallback.html":{},"interfaces/SignBlobResponse.html":{}}}],["opts.url",{"_index":462,"title":{},"body":{"interfaces/ADCCallback.html":{},"interfaces/ADCResponse.html":{},"interfaces/CredentialCallback.html":{},"interfaces/GoogleAuthOptions.html":{},"interfaces/ProjectIdCallback.html":{},"interfaces/SignBlobResponse.html":{}}}],["order",{"_index":161,"title":{},"body":{"interfaces/ADCCallback.html":{},"interfaces/ADCResponse.html":{},"interfaces/CredentialCallback.html":{},"interfaces/GoogleAuthOptions.html":{},"interfaces/ProjectIdCallback.html":{},"interfaces/SignBlobResponse.html":{}}}],["organ",{"_index":723,"title":{},"body":{"interfaces/FederatedSignonCertsResponse.html":{},"interfaces/GetAccessTokenCallback.html":{},"interfaces/GetAccessTokenResponse.html":{},"interfaces/GetFederatedSignonCertsCallback.html":{},"interfaces/GetTokenCallback.html":{},"interfaces/GetTokenOptions.html":{},"interfaces/GetTokenResponse.html":{},"interfaces/OAuth2ClientOptions.html":{},"interfaces/RefreshAccessTokenCallback.html":{},"interfaces/RefreshAccessTokenResponse.html":{},"interfaces/RefreshOptions.html":{},"interfaces/RequestMetadataCallback.html":{},"interfaces/RequestMetadataResponse.html":{},"interfaces/RevokeCredentialsResult.html":{},"interfaces/TokenInfo.html":{},"interfaces/TokenInfoRequest.html":{},"interfaces/VerifyIdTokenOptions.html":{}}}],["origin",{"_index":846,"title":{},"body":{"interfaces/FederatedSignonCertsResponse.html":{},"interfaces/GetAccessTokenCallback.html":{},"interfaces/GetAccessTokenResponse.html":{},"interfaces/GetFederatedSignonCertsCallback.html":{},"interfaces/GetTokenCallback.html":{},"interfaces/GetTokenOptions.html":{},"interfaces/GetTokenResponse.html":{},"interfaces/OAuth2ClientOptions.html":{},"interfaces/RefreshAccessTokenCallback.html":{},"interfaces/RefreshAccessTokenResponse.html":{},"interfaces/RefreshOptions.html":{},"interfaces/RequestMetadataCallback.html":{},"interfaces/RequestMetadataResponse.html":{},"interfaces/RevokeCredentialsResult.html":{},"interfaces/TokenInfo.html":{},"interfaces/TokenInfoRequest.html":{},"interfaces/VerifyIdTokenOptions.html":{},"index.html":{},"license.html":{}}}],["os",{"_index":32,"title":{},"body":{"interfaces/ADCCallback.html":{},"interfaces/ADCResponse.html":{},"interfaces/CredentialCallback.html":{},"interfaces/GoogleAuthOptions.html":{},"interfaces/ProjectIdCallback.html":{},"interfaces/SignBlobResponse.html":{}}}],["os.platform",{"_index":378,"title":{},"body":{"interfaces/ADCCallback.html":{},"interfaces/ADCResponse.html":{},"interfaces/CredentialCallback.html":{},"interfaces/GoogleAuthOptions.html":{},"interfaces/ProjectIdCallback.html":{},"interfaces/SignBlobResponse.html":{}}}],["other",{"_index":1317,"title":{},"body":{"interfaces/JWTOptions.html":{}}}],["otherwis",{"_index":1369,"title":{},"body":{"classes/LoginTicket.html":{},"interfaces/TokenPayload.html":{},"license.html":{}}}],["out",{"_index":238,"title":{},"body":{"interfaces/ADCCallback.html":{},"interfaces/ADCResponse.html":{},"interfaces/CredentialCallback.html":{},"interfaces/FederatedSignonCertsResponse.html":{},"interfaces/GetAccessTokenCallback.html":{},"interfaces/GetAccessTokenResponse.html":{},"interfaces/GetFederatedSignonCertsCallback.html":{},"interfaces/GetTokenCallback.html":{},"interfaces/GetTokenOptions.html":{},"interfaces/GetTokenResponse.html":{},"interfaces/GoogleAuthOptions.html":{},"interfaces/OAuth2ClientOptions.html":{},"interfaces/ProjectIdCallback.html":{},"interfaces/RefreshAccessTokenCallback.html":{},"interfaces/RefreshAccessTokenResponse.html":{},"interfaces/RefreshOptions.html":{},"interfaces/RequestMetadataCallback.html":{},"interfaces/RequestMetadataResponse.html":{},"interfaces/RevokeCredentialsResult.html":{},"interfaces/SignBlobResponse.html":{},"interfaces/TokenInfo.html":{},"interfaces/TokenInfoRequest.html":{},"interfaces/VerifyIdTokenOptions.html":{},"license.html":{}}}],["outstand",{"_index":1841,"title":{},"body":{"license.html":{}}}],["overflow",{"_index":1811,"title":{},"body":{"index.html":{}}}],["overrid",{"_index":916,"title":{},"body":{"interfaces/FederatedSignonCertsResponse.html":{},"interfaces/GetAccessTokenCallback.html":{},"interfaces/GetAccessTokenResponse.html":{},"interfaces/GetFederatedSignonCertsCallback.html":{},"interfaces/GetTokenCallback.html":{},"interfaces/GetTokenOptions.html":{},"interfaces/GetTokenResponse.html":{},"interfaces/OAuth2ClientOptions.html":{},"interfaces/RefreshAccessTokenCallback.html":{},"interfaces/RefreshAccessTokenResponse.html":{},"interfaces/RefreshOptions.html":{},"interfaces/RequestMetadataCallback.html":{},"interfaces/RequestMetadataResponse.html":{},"interfaces/RevokeCredentialsResult.html":{},"interfaces/TokenInfo.html":{},"interfaces/TokenInfoRequest.html":{},"interfaces/VerifyIdTokenOptions.html":{}}}],["overview",{"_index":1993,"title":{"overview.html":{}},"body":{"overview.html":{}}}],["owner",{"_index":1826,"title":{},"body":{"license.html":{}}}],["ownership",{"_index":1837,"title":{},"body":{"license.html":{}}}],["p",{"_index":1029,"title":{},"body":{"interfaces/FederatedSignonCertsResponse.html":{},"interfaces/GetAccessTokenCallback.html":{},"interfaces/GetAccessTokenResponse.html":{},"interfaces/GetFederatedSignonCertsCallback.html":{},"interfaces/GetTokenCallback.html":{},"interfaces/GetTokenOptions.html":{},"interfaces/GetTokenResponse.html":{},"interfaces/OAuth2ClientOptions.html":{},"interfaces/RefreshAccessTokenCallback.html":{},"interfaces/RefreshAccessTokenResponse.html":{},"interfaces/RefreshOptions.html":{},"interfaces/RequestMetadataCallback.html":{},"interfaces/RequestMetadataResponse.html":{},"interfaces/RevokeCredentialsResult.html":{},"interfaces/TokenInfo.html":{},"interfaces/TokenInfoRequest.html":{},"interfaces/VerifyIdTokenOptions.html":{}}}],["p12",{"_index":64,"title":{},"body":{"interfaces/ADCCallback.html":{},"interfaces/ADCResponse.html":{},"interfaces/CredentialCallback.html":{},"interfaces/GoogleAuthOptions.html":{},"interfaces/ProjectIdCallback.html":{},"interfaces/SignBlobResponse.html":{}}}],["packag",{"_index":1602,"title":{"dependencies.html":{}},"body":{"changelog.html":{}}}],["package.json",{"_index":1587,"title":{},"body":{"changelog.html":{}}}],["page",{"_index":957,"title":{},"body":{"interfaces/FederatedSignonCertsResponse.html":{},"interfaces/GetAccessTokenCallback.html":{},"interfaces/GetAccessTokenResponse.html":{},"interfaces/GetFederatedSignonCertsCallback.html":{},"interfaces/GetTokenCallback.html":{},"interfaces/GetTokenOptions.html":{},"interfaces/GetTokenResponse.html":{},"classes/LoginTicket.html":{},"interfaces/OAuth2ClientOptions.html":{},"interfaces/RefreshAccessTokenCallback.html":{},"interfaces/RefreshAccessTokenResponse.html":{},"interfaces/RefreshOptions.html":{},"interfaces/RequestMetadataCallback.html":{},"interfaces/RequestMetadataResponse.html":{},"interfaces/RevokeCredentialsResult.html":{},"interfaces/TokenInfo.html":{},"interfaces/TokenInfoRequest.html":{},"interfaces/TokenPayload.html":{},"interfaces/VerifyIdTokenOptions.html":{},"changelog.html":{},"license.html":{}}}],["pain",{"_index":1133,"title":{},"body":{"interfaces/FederatedSignonCertsResponse.html":{},"interfaces/GetAccessTokenCallback.html":{},"interfaces/GetAccessTokenResponse.html":{},"interfaces/GetFederatedSignonCertsCallback.html":{},"interfaces/GetTokenCallback.html":{},"interfaces/GetTokenOptions.html":{},"interfaces/GetTokenResponse.html":{},"interfaces/OAuth2ClientOptions.html":{},"interfaces/RefreshAccessTokenCallback.html":{},"interfaces/RefreshAccessTokenResponse.html":{},"interfaces/RefreshOptions.html":{},"interfaces/RequestMetadataCallback.html":{},"interfaces/RequestMetadataResponse.html":{},"interfaces/RevokeCredentialsResult.html":{},"interfaces/TokenInfo.html":{},"interfaces/TokenInfoRequest.html":{},"interfaces/VerifyIdTokenOptions.html":{}}}],["pair",{"_index":819,"title":{},"body":{"interfaces/FederatedSignonCertsResponse.html":{},"interfaces/GetAccessTokenCallback.html":{},"interfaces/GetAccessTokenResponse.html":{},"interfaces/GetFederatedSignonCertsCallback.html":{},"interfaces/GetTokenCallback.html":{},"interfaces/GetTokenOptions.html":{},"interfaces/GetTokenResponse.html":{},"interfaces/OAuth2ClientOptions.html":{},"interfaces/RefreshAccessTokenCallback.html":{},"interfaces/RefreshAccessTokenResponse.html":{},"interfaces/RefreshOptions.html":{},"interfaces/RequestMetadataCallback.html":{},"interfaces/RequestMetadataResponse.html":{},"interfaces/RevokeCredentialsResult.html":{},"interfaces/TokenInfo.html":{},"interfaces/TokenInfoRequest.html":{},"interfaces/VerifyIdTokenOptions.html":{}}}],["param",{"_index":149,"title":{},"body":{"interfaces/ADCCallback.html":{},"interfaces/ADCResponse.html":{},"interfaces/BodyResponseCallback.html":{},"interfaces/ComputeOptions.html":{},"interfaces/CredentialCallback.html":{},"classes/DefaultTransporter.html":{},"interfaces/FederatedSignonCertsResponse.html":{},"interfaces/GetAccessTokenCallback.html":{},"interfaces/GetAccessTokenResponse.html":{},"interfaces/GetFederatedSignonCertsCallback.html":{},"interfaces/GetTokenCallback.html":{},"interfaces/GetTokenOptions.html":{},"interfaces/GetTokenResponse.html":{},"interfaces/GoogleAuthOptions.html":{},"classes/IAMAuth.html":{},"classes/JWTAccess.html":{},"interfaces/JWTOptions.html":{},"classes/LoginTicket.html":{},"interfaces/OAuth2ClientOptions.html":{},"interfaces/ProjectIdCallback.html":{},"interfaces/RefreshAccessTokenCallback.html":{},"interfaces/RefreshAccessTokenResponse.html":{},"interfaces/RefreshOptions.html":{},"interfaces/RequestError.html":{},"interfaces/RequestMetadata.html":{},"interfaces/RequestMetadataCallback.html":{},"interfaces/RequestMetadataResponse.html":{},"interfaces/RevokeCredentialsResult.html":{},"interfaces/SignBlobResponse.html":{},"interfaces/TokenInfo.html":{},"interfaces/TokenInfoRequest.html":{},"interfaces/TokenPayload.html":{},"interfaces/Transporter.html":{},"interfaces/UserRefreshClientOptions.html":{},"interfaces/VerifyIdTokenOptions.html":{}}}],["paramet",{"_index":611,"title":{},"body":{"interfaces/ComputeOptions.html":{},"classes/DefaultTransporter.html":{},"interfaces/FederatedSignonCertsResponse.html":{},"interfaces/GetAccessTokenCallback.html":{},"interfaces/GetAccessTokenResponse.html":{},"interfaces/GetFederatedSignonCertsCallback.html":{},"interfaces/GetTokenCallback.html":{},"interfaces/GetTokenOptions.html":{},"interfaces/GetTokenResponse.html":{},"classes/IAMAuth.html":{},"classes/JWTAccess.html":{},"classes/LoginTicket.html":{},"interfaces/OAuth2ClientOptions.html":{},"classes/PemVerifier.html":{},"interfaces/RefreshAccessTokenCallback.html":{},"interfaces/RefreshAccessTokenResponse.html":{},"interfaces/RefreshOptions.html":{},"interfaces/RequestMetadataCallback.html":{},"interfaces/RequestMetadataResponse.html":{},"interfaces/RevokeCredentialsResult.html":{},"interfaces/TokenInfo.html":{},"interfaces/TokenInfoRequest.html":{},"interfaces/Transporter.html":{},"interfaces/VerifyIdTokenOptions.html":{},"changelog.html":{},"miscellaneous/functions.html":{},"index.html":{}}}],["parameter'",{"_index":852,"title":{},"body":{"interfaces/FederatedSignonCertsResponse.html":{},"interfaces/GetAccessTokenCallback.html":{},"interfaces/GetAccessTokenResponse.html":{},"interfaces/GetFederatedSignonCertsCallback.html":{},"interfaces/GetTokenCallback.html":{},"interfaces/GetTokenOptions.html":{},"interfaces/GetTokenResponse.html":{},"interfaces/OAuth2ClientOptions.html":{},"interfaces/RefreshAccessTokenCallback.html":{},"interfaces/RefreshAccessTokenResponse.html":{},"interfaces/RefreshOptions.html":{},"interfaces/RequestMetadataCallback.html":{},"interfaces/RequestMetadataResponse.html":{},"interfaces/RevokeCredentialsResult.html":{},"interfaces/TokenInfo.html":{},"interfaces/TokenInfoRequest.html":{},"interfaces/VerifyIdTokenOptions.html":{}}}],["pars",{"_index":307,"title":{},"body":{"interfaces/ADCCallback.html":{},"interfaces/ADCResponse.html":{},"interfaces/CredentialCallback.html":{},"interfaces/GoogleAuthOptions.html":{},"interfaces/ProjectIdCallback.html":{},"interfaces/SignBlobResponse.html":{}}}],["part",{"_index":383,"title":{},"body":{"interfaces/ADCCallback.html":{},"interfaces/ADCResponse.html":{},"interfaces/CredentialCallback.html":{},"interfaces/GoogleAuthOptions.html":{},"interfaces/ProjectIdCallback.html":{},"interfaces/SignBlobResponse.html":{},"license.html":{}}}],["parti",{"_index":737,"title":{},"body":{"interfaces/FederatedSignonCertsResponse.html":{},"interfaces/GetAccessTokenCallback.html":{},"interfaces/GetAccessTokenResponse.html":{},"interfaces/GetFederatedSignonCertsCallback.html":{},"interfaces/GetTokenCallback.html":{},"interfaces/GetTokenOptions.html":{},"interfaces/GetTokenResponse.html":{},"classes/LoginTicket.html":{},"interfaces/OAuth2ClientOptions.html":{},"interfaces/RefreshAccessTokenCallback.html":{},"interfaces/RefreshAccessTokenResponse.html":{},"interfaces/RefreshOptions.html":{},"interfaces/RequestMetadataCallback.html":{},"interfaces/RequestMetadataResponse.html":{},"interfaces/RevokeCredentialsResult.html":{},"interfaces/TokenInfo.html":{},"interfaces/TokenInfoRequest.html":{},"interfaces/TokenPayload.html":{},"interfaces/VerifyIdTokenOptions.html":{},"license.html":{}}}],["particular",{"_index":1951,"title":{},"body":{"license.html":{}}}],["particularli",{"_index":1678,"title":{},"body":{"index.html":{}}}],["pass",{"_index":191,"title":{},"body":{"interfaces/ADCCallback.html":{},"interfaces/ADCResponse.html":{},"interfaces/BodyResponseCallback.html":{},"interfaces/CredentialCallback.html":{},"classes/DefaultTransporter.html":{},"interfaces/FederatedSignonCertsResponse.html":{},"interfaces/GetAccessTokenCallback.html":{},"interfaces/GetAccessTokenResponse.html":{},"interfaces/GetFederatedSignonCertsCallback.html":{},"interfaces/GetTokenCallback.html":{},"interfaces/GetTokenOptions.html":{},"interfaces/GetTokenResponse.html":{},"interfaces/GoogleAuthOptions.html":{},"classes/IAMAuth.html":{},"classes/JWTAccess.html":{},"interfaces/JWTOptions.html":{},"interfaces/OAuth2ClientOptions.html":{},"interfaces/ProjectIdCallback.html":{},"interfaces/RefreshAccessTokenCallback.html":{},"interfaces/RefreshAccessTokenResponse.html":{},"interfaces/RefreshOptions.html":{},"interfaces/RequestError.html":{},"interfaces/RequestMetadata.html":{},"interfaces/RequestMetadataCallback.html":{},"interfaces/RequestMetadataResponse.html":{},"interfaces/RevokeCredentialsResult.html":{},"interfaces/SignBlobResponse.html":{},"interfaces/TokenInfo.html":{},"interfaces/TokenInfoRequest.html":{},"interfaces/Transporter.html":{},"interfaces/UserRefreshClientOptions.html":{},"interfaces/VerifyIdTokenOptions.html":{},"changelog.html":{},"index.html":{}}}],["patent",{"_index":1894,"title":{},"body":{"license.html":{}}}],["path",{"_index":33,"title":{},"body":{"interfaces/ADCCallback.html":{},"interfaces/ADCResponse.html":{},"interfaces/CredentialCallback.html":{},"interfaces/GoogleAuthOptions.html":{},"interfaces/JWTOptions.html":{},"interfaces/ProjectIdCallback.html":{},"interfaces/SignBlobResponse.html":{},"interfaces/Warning.html":{},"index.html":{}}}],["path.join(item1",{"_index":386,"title":{},"body":{"interfaces/ADCCallback.html":{},"interfaces/ADCResponse.html":{},"interfaces/CredentialCallback.html":{},"interfaces/GoogleAuthOptions.html":{},"interfaces/ProjectIdCallback.html":{},"interfaces/SignBlobResponse.html":{}}}],["path.resolve(this.keyfilenam",{"_index":446,"title":{},"body":{"interfaces/ADCCallback.html":{},"interfaces/ADCResponse.html":{},"interfaces/CredentialCallback.html":{},"interfaces/GoogleAuthOptions.html":{},"interfaces/ProjectIdCallback.html":{},"interfaces/SignBlobResponse.html":{}}}],["pay",{"_index":1346,"title":{},"body":{"classes/LoginTicket.html":{},"interfaces/TokenPayload.html":{}}}],["payload",{"_index":1178,"title":{},"body":{"interfaces/FederatedSignonCertsResponse.html":{},"interfaces/GetAccessTokenCallback.html":{},"interfaces/GetAccessTokenResponse.html":{},"interfaces/GetFederatedSignonCertsCallback.html":{},"interfaces/GetTokenCallback.html":{},"interfaces/GetTokenOptions.html":{},"interfaces/GetTokenResponse.html":{},"classes/JWTAccess.html":{},"classes/LoginTicket.html":{},"interfaces/OAuth2ClientOptions.html":{},"interfaces/RefreshAccessTokenCallback.html":{},"interfaces/RefreshAccessTokenResponse.html":{},"interfaces/RefreshOptions.html":{},"interfaces/RequestMetadataCallback.html":{},"interfaces/RequestMetadataResponse.html":{},"interfaces/RevokeCredentialsResult.html":{},"interfaces/TokenInfo.html":{},"interfaces/TokenInfoRequest.html":{},"interfaces/TokenPayload.html":{},"interfaces/VerifyIdTokenOptions.html":{}}}],["payload.sub",{"_index":1361,"title":{},"body":{"classes/LoginTicket.html":{},"interfaces/TokenPayload.html":{}}}],["pem",{"_index":63,"title":{},"body":{"interfaces/ADCCallback.html":{},"interfaces/ADCResponse.html":{},"interfaces/CredentialCallback.html":{},"interfaces/FederatedSignonCertsResponse.html":{},"interfaces/GetAccessTokenCallback.html":{},"interfaces/GetAccessTokenResponse.html":{},"interfaces/GetFederatedSignonCertsCallback.html":{},"interfaces/GetTokenCallback.html":{},"interfaces/GetTokenOptions.html":{},"interfaces/GetTokenResponse.html":{},"interfaces/GoogleAuthOptions.html":{},"interfaces/OAuth2ClientOptions.html":{},"interfaces/ProjectIdCallback.html":{},"interfaces/RefreshAccessTokenCallback.html":{},"interfaces/RefreshAccessTokenResponse.html":{},"interfaces/RefreshOptions.html":{},"interfaces/RequestMetadataCallback.html":{},"interfaces/RequestMetadataResponse.html":{},"interfaces/RevokeCredentialsResult.html":{},"interfaces/SignBlobResponse.html":{},"interfaces/TokenInfo.html":{},"interfaces/TokenInfoRequest.html":{},"interfaces/VerifyIdTokenOptions.html":{},"index.html":{}}}],["pemverifi",{"_index":690,"title":{"classes/PemVerifier.html":{}},"body":{"interfaces/FederatedSignonCertsResponse.html":{},"interfaces/GetAccessTokenCallback.html":{},"interfaces/GetAccessTokenResponse.html":{},"interfaces/GetFederatedSignonCertsCallback.html":{},"interfaces/GetTokenCallback.html":{},"interfaces/GetTokenOptions.html":{},"interfaces/GetTokenResponse.html":{},"interfaces/OAuth2ClientOptions.html":{},"classes/PemVerifier.html":{},"interfaces/RefreshAccessTokenCallback.html":{},"interfaces/RefreshAccessTokenResponse.html":{},"interfaces/RefreshOptions.html":{},"interfaces/RequestMetadataCallback.html":{},"interfaces/RequestMetadataResponse.html":{},"interfaces/RevokeCredentialsResult.html":{},"interfaces/TokenInfo.html":{},"interfaces/TokenInfoRequest.html":{},"interfaces/VerifyIdTokenOptions.html":{}}}],["per",{"_index":974,"title":{},"body":{"interfaces/FederatedSignonCertsResponse.html":{},"interfaces/GetAccessTokenCallback.html":{},"interfaces/GetAccessTokenResponse.html":{},"interfaces/GetFederatedSignonCertsCallback.html":{},"interfaces/GetTokenCallback.html":{},"interfaces/GetTokenOptions.html":{},"interfaces/GetTokenResponse.html":{},"interfaces/OAuth2ClientOptions.html":{},"interfaces/RefreshAccessTokenCallback.html":{},"interfaces/RefreshAccessTokenResponse.html":{},"interfaces/RefreshOptions.html":{},"interfaces/RequestMetadataCallback.html":{},"interfaces/RequestMetadataResponse.html":{},"interfaces/RevokeCredentialsResult.html":{},"interfaces/TokenInfo.html":{},"interfaces/TokenInfoRequest.html":{},"interfaces/VerifyIdTokenOptions.html":{}}}],["percent",{"_index":1839,"title":{},"body":{"license.html":{}}}],["perform",{"_index":1672,"title":{},"body":{"index.html":{},"license.html":{}}}],["permiss",{"_index":633,"title":{},"body":{"interfaces/ComputeOptions.html":{},"interfaces/Credentials.html":{},"classes/LoginTicket.html":{},"miscellaneous/functions.html":{},"license.html":{}}}],["perpetu",{"_index":1883,"title":{},"body":{"license.html":{}}}],["pertain",{"_index":1922,"title":{},"body":{"license.html":{}}}],["pictur",{"_index":1377,"title":{},"body":{"classes/LoginTicket.html":{},"interfaces/TokenPayload.html":{}}}],["piec",{"_index":1703,"title":{},"body":{"index.html":{}}}],["pifi",{"_index":1596,"title":{},"body":{"changelog.html":{}}}],["pin",{"_index":524,"title":{},"body":{"interfaces/BodyResponseCallback.html":{},"classes/DefaultTransporter.html":{},"interfaces/RequestError.html":{},"interfaces/Transporter.html":{}}}],["pkg",{"_index":507,"title":{},"body":{"interfaces/BodyResponseCallback.html":{},"classes/DefaultTransporter.html":{},"interfaces/RequestError.html":{},"interfaces/Transporter.html":{},"miscellaneous/variables.html":{}}}],["place",{"_index":1546,"title":{},"body":{"changelog.html":{},"index.html":{},"license.html":{}}}],["placehold",{"_index":598,"title":{},"body":{"interfaces/ComputeOptions.html":{},"interfaces/JWTOptions.html":{}}}],["plain",{"_index":696,"title":{},"body":{"interfaces/FederatedSignonCertsResponse.html":{},"interfaces/GetAccessTokenCallback.html":{},"interfaces/GetAccessTokenResponse.html":{},"interfaces/GetFederatedSignonCertsCallback.html":{},"interfaces/GetTokenCallback.html":{},"interfaces/GetTokenOptions.html":{},"interfaces/GetTokenResponse.html":{},"interfaces/OAuth2ClientOptions.html":{},"interfaces/RefreshAccessTokenCallback.html":{},"interfaces/RefreshAccessTokenResponse.html":{},"interfaces/RefreshOptions.html":{},"interfaces/RequestMetadataCallback.html":{},"interfaces/RequestMetadataResponse.html":{},"interfaces/RevokeCredentialsResult.html":{},"interfaces/TokenInfo.html":{},"interfaces/TokenInfoRequest.html":{},"interfaces/VerifyIdTokenOptions.html":{},"miscellaneous/enumerations.html":{}}}],["platform",{"_index":376,"title":{},"body":{"interfaces/ADCCallback.html":{},"interfaces/ADCResponse.html":{},"interfaces/CredentialCallback.html":{},"interfaces/GoogleAuthOptions.html":{},"interfaces/ProjectIdCallback.html":{},"interfaces/SignBlobResponse.html":{},"changelog.html":{},"index.html":{}}}],["pleas",{"_index":133,"title":{},"body":{"interfaces/ADCCallback.html":{},"interfaces/ADCResponse.html":{},"interfaces/CredentialCallback.html":{},"interfaces/GoogleAuthOptions.html":{},"classes/JWTAccess.html":{},"interfaces/ProjectIdCallback.html":{},"interfaces/SignBlobResponse.html":{},"interfaces/Warning.html":{},"changelog.html":{},"index.html":{},"miscellaneous/variables.html":{}}}],["plu",{"_index":1715,"title":{},"body":{"index.html":{}}}],["point",{"_index":215,"title":{},"body":{"interfaces/ADCCallback.html":{},"interfaces/ADCResponse.html":{},"interfaces/CredentialCallback.html":{},"interfaces/FederatedSignonCertsResponse.html":{},"interfaces/GetAccessTokenCallback.html":{},"interfaces/GetAccessTokenResponse.html":{},"interfaces/GetFederatedSignonCertsCallback.html":{},"interfaces/GetTokenCallback.html":{},"interfaces/GetTokenOptions.html":{},"interfaces/GetTokenResponse.html":{},"interfaces/GoogleAuthOptions.html":{},"classes/LoginTicket.html":{},"interfaces/OAuth2ClientOptions.html":{},"interfaces/ProjectIdCallback.html":{},"interfaces/RefreshAccessTokenCallback.html":{},"interfaces/RefreshAccessTokenResponse.html":{},"interfaces/RefreshOptions.html":{},"interfaces/RequestMetadataCallback.html":{},"interfaces/RequestMetadataResponse.html":{},"interfaces/RevokeCredentialsResult.html":{},"interfaces/SignBlobResponse.html":{},"interfaces/TokenInfo.html":{},"interfaces/TokenInfoRequest.html":{},"interfaces/TokenPayload.html":{},"interfaces/VerifyIdTokenOptions.html":{}}}],["possibl",{"_index":806,"title":{},"body":{"interfaces/FederatedSignonCertsResponse.html":{},"interfaces/GetAccessTokenCallback.html":{},"interfaces/GetAccessTokenResponse.html":{},"interfaces/GetFederatedSignonCertsCallback.html":{},"interfaces/GetTokenCallback.html":{},"interfaces/GetTokenOptions.html":{},"interfaces/GetTokenResponse.html":{},"interfaces/OAuth2ClientOptions.html":{},"interfaces/RefreshAccessTokenCallback.html":{},"interfaces/RefreshAccessTokenResponse.html":{},"interfaces/RefreshOptions.html":{},"interfaces/RequestMetadataCallback.html":{},"interfaces/RequestMetadataResponse.html":{},"interfaces/RevokeCredentialsResult.html":{},"interfaces/TokenInfo.html":{},"interfaces/TokenInfoRequest.html":{},"interfaces/VerifyIdTokenOptions.html":{},"license.html":{}}}],["post",{"_index":489,"title":{},"body":{"interfaces/ADCCallback.html":{},"interfaces/ADCResponse.html":{},"interfaces/CredentialCallback.html":{},"interfaces/FederatedSignonCertsResponse.html":{},"interfaces/GetAccessTokenCallback.html":{},"interfaces/GetAccessTokenResponse.html":{},"interfaces/GetFederatedSignonCertsCallback.html":{},"interfaces/GetTokenCallback.html":{},"interfaces/GetTokenOptions.html":{},"interfaces/GetTokenResponse.html":{},"interfaces/GoogleAuthOptions.html":{},"interfaces/OAuth2ClientOptions.html":{},"interfaces/ProjectIdCallback.html":{},"interfaces/RefreshAccessTokenCallback.html":{},"interfaces/RefreshAccessTokenResponse.html":{},"interfaces/RefreshOptions.html":{},"interfaces/RequestMetadataCallback.html":{},"interfaces/RequestMetadataResponse.html":{},"interfaces/RevokeCredentialsResult.html":{},"interfaces/SignBlobResponse.html":{},"interfaces/TokenInfo.html":{},"interfaces/TokenInfoRequest.html":{},"interfaces/VerifyIdTokenOptions.html":{}}}],["power",{"_index":1832,"title":{},"body":{"license.html":{}}}],["pre",{"_index":1713,"title":{},"body":{"index.html":{}}}],["preced",{"_index":162,"title":{},"body":{"interfaces/ADCCallback.html":{},"interfaces/ADCResponse.html":{},"interfaces/CredentialCallback.html":{},"interfaces/GoogleAuthOptions.html":{},"interfaces/ProjectIdCallback.html":{},"interfaces/SignBlobResponse.html":{}}}],["prefer",{"_index":1520,"title":{},"body":{"changelog.html":{},"license.html":{}}}],["prefil",{"_index":860,"title":{},"body":{"interfaces/FederatedSignonCertsResponse.html":{},"interfaces/GetAccessTokenCallback.html":{},"interfaces/GetAccessTokenResponse.html":{},"interfaces/GetFederatedSignonCertsCallback.html":{},"interfaces/GetTokenCallback.html":{},"interfaces/GetTokenOptions.html":{},"interfaces/GetTokenResponse.html":{},"interfaces/OAuth2ClientOptions.html":{},"interfaces/RefreshAccessTokenCallback.html":{},"interfaces/RefreshAccessTokenResponse.html":{},"interfaces/RefreshOptions.html":{},"interfaces/RequestMetadataCallback.html":{},"interfaces/RequestMetadataResponse.html":{},"interfaces/RevokeCredentialsResult.html":{},"interfaces/TokenInfo.html":{},"interfaces/TokenInfoRequest.html":{},"interfaces/VerifyIdTokenOptions.html":{}}}],["preflight",{"_index":522,"title":{},"body":{"interfaces/BodyResponseCallback.html":{},"classes/DefaultTransporter.html":{},"interfaces/RequestError.html":{},"interfaces/Transporter.html":{}}}],["prepar",{"_index":1891,"title":{},"body":{"license.html":{}}}],["present",{"_index":713,"title":{},"body":{"interfaces/FederatedSignonCertsResponse.html":{},"interfaces/GetAccessTokenCallback.html":{},"interfaces/GetAccessTokenResponse.html":{},"interfaces/GetFederatedSignonCertsCallback.html":{},"interfaces/GetTokenCallback.html":{},"interfaces/GetTokenOptions.html":{},"interfaces/GetTokenResponse.html":{},"classes/LoginTicket.html":{},"interfaces/OAuth2ClientOptions.html":{},"interfaces/RefreshAccessTokenCallback.html":{},"interfaces/RefreshAccessTokenResponse.html":{},"interfaces/RefreshOptions.html":{},"interfaces/RequestMetadataCallback.html":{},"interfaces/RequestMetadataResponse.html":{},"interfaces/RevokeCredentialsResult.html":{},"interfaces/TokenInfo.html":{},"interfaces/TokenInfoRequest.html":{},"interfaces/TokenPayload.html":{},"interfaces/VerifyIdTokenOptions.html":{},"index.html":{}}}],["pretti",{"_index":986,"title":{},"body":{"interfaces/FederatedSignonCertsResponse.html":{},"interfaces/GetAccessTokenCallback.html":{},"interfaces/GetAccessTokenResponse.html":{},"interfaces/GetFederatedSignonCertsCallback.html":{},"interfaces/GetTokenCallback.html":{},"interfaces/GetTokenOptions.html":{},"interfaces/GetTokenResponse.html":{},"interfaces/OAuth2ClientOptions.html":{},"interfaces/RefreshAccessTokenCallback.html":{},"interfaces/RefreshAccessTokenResponse.html":{},"interfaces/RefreshOptions.html":{},"interfaces/RequestMetadataCallback.html":{},"interfaces/RequestMetadataResponse.html":{},"interfaces/RevokeCredentialsResult.html":{},"interfaces/TokenInfo.html":{},"interfaces/TokenInfoRequest.html":{},"interfaces/VerifyIdTokenOptions.html":{}}}],["prevent",{"_index":1568,"title":{},"body":{"changelog.html":{}}}],["previous",{"_index":854,"title":{},"body":{"interfaces/FederatedSignonCertsResponse.html":{},"interfaces/GetAccessTokenCallback.html":{},"interfaces/GetAccessTokenResponse.html":{},"interfaces/GetFederatedSignonCertsCallback.html":{},"interfaces/GetTokenCallback.html":{},"interfaces/GetTokenOptions.html":{},"interfaces/GetTokenResponse.html":{},"interfaces/OAuth2ClientOptions.html":{},"interfaces/RefreshAccessTokenCallback.html":{},"interfaces/RefreshAccessTokenResponse.html":{},"interfaces/RefreshOptions.html":{},"interfaces/RequestMetadataCallback.html":{},"interfaces/RequestMetadataResponse.html":{},"interfaces/RevokeCredentialsResult.html":{},"interfaces/TokenInfo.html":{},"interfaces/TokenInfoRequest.html":{},"interfaces/VerifyIdTokenOptions.html":{}}}],["primari",{"_index":1372,"title":{},"body":{"classes/LoginTicket.html":{},"interfaces/TokenPayload.html":{}}}],["print",{"_index":396,"title":{},"body":{"interfaces/ADCCallback.html":{},"interfaces/ADCResponse.html":{},"interfaces/CredentialCallback.html":{},"interfaces/GoogleAuthOptions.html":{},"interfaces/ProjectIdCallback.html":{},"interfaces/SignBlobResponse.html":{},"license.html":{}}}],["privat",{"_index":95,"title":{},"body":{"interfaces/ADCCallback.html":{},"interfaces/ADCResponse.html":{},"interfaces/BodyResponseCallback.html":{},"interfaces/ComputeOptions.html":{},"interfaces/CredentialCallback.html":{},"classes/DefaultTransporter.html":{},"interfaces/FederatedSignonCertsResponse.html":{},"interfaces/GetAccessTokenCallback.html":{},"interfaces/GetAccessTokenResponse.html":{},"interfaces/GetFederatedSignonCertsCallback.html":{},"interfaces/GetTokenCallback.html":{},"interfaces/GetTokenOptions.html":{},"interfaces/GetTokenResponse.html":{},"interfaces/GoogleAuthOptions.html":{},"classes/JWTAccess.html":{},"interfaces/JWTOptions.html":{},"classes/LoginTicket.html":{},"interfaces/OAuth2ClientOptions.html":{},"interfaces/ProjectIdCallback.html":{},"interfaces/RefreshAccessTokenCallback.html":{},"interfaces/RefreshAccessTokenResponse.html":{},"interfaces/RefreshOptions.html":{},"interfaces/RequestError.html":{},"interfaces/RequestMetadataCallback.html":{},"interfaces/RequestMetadataResponse.html":{},"interfaces/RevokeCredentialsResult.html":{},"interfaces/SignBlobResponse.html":{},"interfaces/TokenInfo.html":{},"interfaces/TokenInfoRequest.html":{},"interfaces/TokenPayload.html":{},"interfaces/Transporter.html":{},"interfaces/UserRefreshClientOptions.html":{},"interfaces/VerifyIdTokenOptions.html":{},"index.html":{}}}],["private_key",{"_index":71,"title":{},"body":{"interfaces/ADCCallback.html":{},"interfaces/ADCResponse.html":{},"interfaces/CredentialBody.html":{},"interfaces/CredentialCallback.html":{},"interfaces/CredentialRequest.html":{},"interfaces/Credentials.html":{},"interfaces/GoogleAuthOptions.html":{},"classes/JWTAccess.html":{},"interfaces/JWTInput.html":{},"interfaces/JWTOptions.html":{},"interfaces/ProjectIdCallback.html":{},"interfaces/SignBlobResponse.html":{},"index.html":{}}}],["private_key_id",{"_index":644,"title":{},"body":{"interfaces/CredentialBody.html":{},"interfaces/CredentialRequest.html":{},"interfaces/Credentials.html":{},"interfaces/JWTInput.html":{},"changelog.html":{},"index.html":{}}}],["problem",{"_index":1556,"title":{},"body":{"changelog.html":{}}}],["problemat",{"_index":314,"title":{},"body":{"interfaces/ADCCallback.html":{},"interfaces/ADCResponse.html":{},"interfaces/CredentialCallback.html":{},"interfaces/GoogleAuthOptions.html":{},"interfaces/ProjectIdCallback.html":{},"interfaces/SignBlobResponse.html":{}}}],["problematic_credentials_warn",{"_index":1431,"title":{},"body":{"interfaces/Warning.html":{},"miscellaneous/variables.html":{}}}],["process",{"_index":760,"title":{},"body":{"interfaces/FederatedSignonCertsResponse.html":{},"interfaces/GetAccessTokenCallback.html":{},"interfaces/GetAccessTokenResponse.html":{},"interfaces/GetFederatedSignonCertsCallback.html":{},"interfaces/GetTokenCallback.html":{},"interfaces/GetTokenOptions.html":{},"interfaces/GetTokenResponse.html":{},"interfaces/OAuth2ClientOptions.html":{},"interfaces/RefreshAccessTokenCallback.html":{},"interfaces/RefreshAccessTokenResponse.html":{},"interfaces/RefreshOptions.html":{},"interfaces/RequestMetadataCallback.html":{},"interfaces/RequestMetadataResponse.html":{},"interfaces/RevokeCredentialsResult.html":{},"interfaces/TokenInfo.html":{},"interfaces/TokenInfoRequest.html":{},"interfaces/VerifyIdTokenOptions.html":{}}}],["process.emitwarning(warning.messag",{"_index":1427,"title":{},"body":{"interfaces/Warning.html":{}}}],["process.env.https_proxi",{"_index":549,"title":{},"body":{"interfaces/BodyResponseCallback.html":{},"classes/DefaultTransporter.html":{},"interfaces/RequestError.html":{},"interfaces/Transporter.html":{}}}],["process.env['appdata",{"_index":270,"title":{},"body":{"interfaces/ADCCallback.html":{},"interfaces/ADCResponse.html":{},"interfaces/CredentialCallback.html":{},"interfaces/GoogleAuthOptions.html":{},"interfaces/ProjectIdCallback.html":{},"interfaces/SignBlobResponse.html":{}}}],["process.env['cr",{"_index":1798,"title":{},"body":{"index.html":{}}}],["process.env['gcloud_project",{"_index":405,"title":{},"body":{"interfaces/ADCCallback.html":{},"interfaces/ADCResponse.html":{},"interfaces/CredentialCallback.html":{},"interfaces/GoogleAuthOptions.html":{},"interfaces/ProjectIdCallback.html":{},"interfaces/SignBlobResponse.html":{}}}],["process.env['google_application_credenti",{"_index":254,"title":{},"body":{"interfaces/ADCCallback.html":{},"interfaces/ADCResponse.html":{},"interfaces/CredentialCallback.html":{},"interfaces/GoogleAuthOptions.html":{},"interfaces/ProjectIdCallback.html":{},"interfaces/SignBlobResponse.html":{}}}],["process.env['google_cloud_project",{"_index":406,"title":{},"body":{"interfaces/ADCCallback.html":{},"interfaces/ADCResponse.html":{},"interfaces/CredentialCallback.html":{},"interfaces/GoogleAuthOptions.html":{},"interfaces/ProjectIdCallback.html":{},"interfaces/SignBlobResponse.html":{}}}],["process.env['hom",{"_index":274,"title":{},"body":{"interfaces/ADCCallback.html":{},"interfaces/ADCResponse.html":{},"interfaces/CredentialCallback.html":{},"interfaces/GoogleAuthOptions.html":{},"interfaces/ProjectIdCallback.html":{},"interfaces/SignBlobResponse.html":{}}}],["process.exit",{"_index":1721,"title":{},"body":{"index.html":{}}}],["processerror(",{"_index":558,"title":{},"body":{"interfaces/BodyResponseCallback.html":{},"classes/DefaultTransporter.html":{},"interfaces/RequestError.html":{},"interfaces/Transporter.html":{}}}],["product",{"_index":1945,"title":{},"body":{"license.html":{}}}],["product_nam",{"_index":509,"title":{},"body":{"interfaces/BodyResponseCallback.html":{},"classes/DefaultTransporter.html":{},"interfaces/RequestError.html":{},"interfaces/Transporter.html":{},"miscellaneous/variables.html":{}}}],["product_name}/${pkg.vers",{"_index":534,"title":{},"body":{"interfaces/BodyResponseCallback.html":{},"classes/DefaultTransporter.html":{},"interfaces/RequestError.html":{},"interfaces/Transporter.html":{}}}],["profil",{"_index":712,"title":{},"body":{"interfaces/FederatedSignonCertsResponse.html":{},"interfaces/GetAccessTokenCallback.html":{},"interfaces/GetAccessTokenResponse.html":{},"interfaces/GetFederatedSignonCertsCallback.html":{},"interfaces/GetTokenCallback.html":{},"interfaces/GetTokenOptions.html":{},"interfaces/GetTokenResponse.html":{},"classes/LoginTicket.html":{},"interfaces/OAuth2ClientOptions.html":{},"interfaces/RefreshAccessTokenCallback.html":{},"interfaces/RefreshAccessTokenResponse.html":{},"interfaces/RefreshOptions.html":{},"interfaces/RequestMetadataCallback.html":{},"interfaces/RequestMetadataResponse.html":{},"interfaces/RevokeCredentialsResult.html":{},"interfaces/TokenInfo.html":{},"interfaces/TokenInfoRequest.html":{},"interfaces/TokenPayload.html":{},"interfaces/VerifyIdTokenOptions.html":{}}}],["project",{"_index":78,"title":{},"body":{"interfaces/ADCCallback.html":{},"interfaces/ADCResponse.html":{},"interfaces/CredentialCallback.html":{},"interfaces/FederatedSignonCertsResponse.html":{},"interfaces/GetAccessTokenCallback.html":{},"interfaces/GetAccessTokenResponse.html":{},"interfaces/GetFederatedSignonCertsCallback.html":{},"interfaces/GetTokenCallback.html":{},"interfaces/GetTokenOptions.html":{},"interfaces/GetTokenResponse.html":{},"interfaces/GoogleAuthOptions.html":{},"classes/LoginTicket.html":{},"interfaces/OAuth2ClientOptions.html":{},"interfaces/ProjectIdCallback.html":{},"interfaces/RefreshAccessTokenCallback.html":{},"interfaces/RefreshAccessTokenResponse.html":{},"interfaces/RefreshOptions.html":{},"interfaces/RequestMetadataCallback.html":{},"interfaces/RequestMetadataResponse.html":{},"interfaces/RevokeCredentialsResult.html":{},"interfaces/SignBlobResponse.html":{},"interfaces/TokenInfo.html":{},"interfaces/TokenInfoRequest.html":{},"interfaces/TokenPayload.html":{},"interfaces/VerifyIdTokenOptions.html":{},"index.html":{}}}],["project_id",{"_index":645,"title":{},"body":{"interfaces/CredentialBody.html":{},"interfaces/CredentialRequest.html":{},"interfaces/Credentials.html":{},"interfaces/JWTInput.html":{},"index.html":{}}}],["projectid",{"_index":16,"title":{},"body":{"interfaces/ADCCallback.html":{},"interfaces/ADCResponse.html":{},"interfaces/CredentialCallback.html":{},"interfaces/FederatedSignonCertsResponse.html":{},"interfaces/GetAccessTokenCallback.html":{},"interfaces/GetAccessTokenResponse.html":{},"interfaces/GetFederatedSignonCertsCallback.html":{},"interfaces/GetTokenCallback.html":{},"interfaces/GetTokenOptions.html":{},"interfaces/GetTokenResponse.html":{},"interfaces/GoogleAuthOptions.html":{},"classes/JWTAccess.html":{},"interfaces/OAuth2ClientOptions.html":{},"interfaces/ProjectIdCallback.html":{},"interfaces/RefreshAccessTokenCallback.html":{},"interfaces/RefreshAccessTokenResponse.html":{},"interfaces/RefreshOptions.html":{},"interfaces/RequestMetadataCallback.html":{},"interfaces/RequestMetadataResponse.html":{},"interfaces/RevokeCredentialsResult.html":{},"interfaces/SignBlobResponse.html":{},"interfaces/TokenInfo.html":{},"interfaces/TokenInfoRequest.html":{},"interfaces/VerifyIdTokenOptions.html":{},"index.html":{}}}],["projectidcallback",{"_index":54,"title":{"interfaces/ProjectIdCallback.html":{}},"body":{"interfaces/ADCCallback.html":{},"interfaces/ADCResponse.html":{},"interfaces/CredentialCallback.html":{},"interfaces/GoogleAuthOptions.html":{},"interfaces/ProjectIdCallback.html":{},"interfaces/SignBlobResponse.html":{}}}],["projects/${projectid}/serviceaccounts/${creds.client_email",{"_index":486,"title":{},"body":{"interfaces/ADCCallback.html":{},"interfaces/ADCResponse.html":{},"interfaces/CredentialCallback.html":{},"interfaces/GoogleAuthOptions.html":{},"interfaces/ProjectIdCallback.html":{},"interfaces/SignBlobResponse.html":{}}}],["promin",{"_index":1918,"title":{},"body":{"license.html":{}}}],["promis",{"_index":109,"title":{},"body":{"interfaces/ADCCallback.html":{},"interfaces/ADCResponse.html":{},"interfaces/ComputeOptions.html":{},"interfaces/CredentialCallback.html":{},"interfaces/FederatedSignonCertsResponse.html":{},"interfaces/GetAccessTokenCallback.html":{},"interfaces/GetAccessTokenResponse.html":{},"interfaces/GetFederatedSignonCertsCallback.html":{},"interfaces/GetTokenCallback.html":{},"interfaces/GetTokenOptions.html":{},"interfaces/GetTokenResponse.html":{},"interfaces/GoogleAuthOptions.html":{},"classes/JWTAccess.html":{},"interfaces/JWTOptions.html":{},"interfaces/OAuth2ClientOptions.html":{},"interfaces/ProjectIdCallback.html":{},"interfaces/RefreshAccessTokenCallback.html":{},"interfaces/RefreshAccessTokenResponse.html":{},"interfaces/RefreshOptions.html":{},"interfaces/RequestMetadataCallback.html":{},"interfaces/RequestMetadataResponse.html":{},"interfaces/RevokeCredentialsResult.html":{},"interfaces/SignBlobResponse.html":{},"interfaces/TokenInfo.html":{},"interfaces/TokenInfoRequest.html":{},"interfaces/UserRefreshClientOptions.html":{},"interfaces/VerifyIdTokenOptions.html":{}}}],["promise((resolv",{"_index":345,"title":{},"body":{"interfaces/ADCCallback.html":{},"interfaces/ADCResponse.html":{},"interfaces/CredentialCallback.html":{},"interfaces/GoogleAuthOptions.html":{},"classes/JWTAccess.html":{},"interfaces/JWTOptions.html":{},"interfaces/ProjectIdCallback.html":{},"interfaces/SignBlobResponse.html":{},"interfaces/UserRefreshClientOptions.html":{},"index.html":{}}}],["promise(async",{"_index":177,"title":{},"body":{"interfaces/ADCCallback.html":{},"interfaces/ADCResponse.html":{},"interfaces/CredentialCallback.html":{},"interfaces/GoogleAuthOptions.html":{},"interfaces/ProjectIdCallback.html":{},"interfaces/SignBlobResponse.html":{}}}],["promise(resolv",{"_index":398,"title":{},"body":{"interfaces/ADCCallback.html":{},"interfaces/ADCResponse.html":{},"interfaces/CredentialCallback.html":{},"interfaces/GoogleAuthOptions.html":{},"interfaces/ProjectIdCallback.html":{},"interfaces/SignBlobResponse.html":{}}}],["promise.resolve(this._cachedprojectid",{"_index":155,"title":{},"body":{"interfaces/ADCCallback.html":{},"interfaces/ADCResponse.html":{},"interfaces/CredentialCallback.html":{},"interfaces/GoogleAuthOptions.html":{},"interfaces/ProjectIdCallback.html":{},"interfaces/SignBlobResponse.html":{}}}],["promise|void",{"_index":139,"title":{},"body":{"interfaces/ADCCallback.html":{},"interfaces/ADCResponse.html":{},"interfaces/CredentialCallback.html":{},"interfaces/FederatedSignonCertsResponse.html":{},"interfaces/GetAccessTokenCallback.html":{},"interfaces/GetAccessTokenResponse.html":{},"interfaces/GetFederatedSignonCertsCallback.html":{},"interfaces/GetTokenCallback.html":{},"interfaces/GetTokenOptions.html":{},"interfaces/GetTokenResponse.html":{},"interfaces/GoogleAuthOptions.html":{},"interfaces/JWTOptions.html":{},"interfaces/OAuth2ClientOptions.html":{},"interfaces/ProjectIdCallback.html":{},"interfaces/RefreshAccessTokenCallback.html":{},"interfaces/RefreshAccessTokenResponse.html":{},"interfaces/RefreshOptions.html":{},"interfaces/RequestMetadataCallback.html":{},"interfaces/RequestMetadataResponse.html":{},"interfaces/RevokeCredentialsResult.html":{},"interfaces/SignBlobResponse.html":{},"interfaces/TokenInfo.html":{},"interfaces/TokenInfoRequest.html":{},"interfaces/VerifyIdTokenOptions.html":{}}}],["prompt",{"_index":867,"title":{},"body":{"interfaces/FederatedSignonCertsResponse.html":{},"interfaces/GetAccessTokenCallback.html":{},"interfaces/GetAccessTokenResponse.html":{},"interfaces/GetFederatedSignonCertsCallback.html":{},"interfaces/GetTokenCallback.html":{},"interfaces/GetTokenOptions.html":{},"interfaces/GetTokenResponse.html":{},"interfaces/OAuth2ClientOptions.html":{},"interfaces/RefreshAccessTokenCallback.html":{},"interfaces/RefreshAccessTokenResponse.html":{},"interfaces/RefreshOptions.html":{},"interfaces/RequestMetadataCallback.html":{},"interfaces/RequestMetadataResponse.html":{},"interfaces/RevokeCredentialsResult.html":{},"interfaces/TokenInfo.html":{},"interfaces/TokenInfoRequest.html":{},"interfaces/VerifyIdTokenOptions.html":{},"index.html":{}}}],["properli",{"_index":100,"title":{},"body":{"interfaces/ADCCallback.html":{},"interfaces/ADCResponse.html":{},"interfaces/CredentialCallback.html":{},"interfaces/GoogleAuthOptions.html":{},"interfaces/ProjectIdCallback.html":{},"interfaces/SignBlobResponse.html":{}}}],["properti",{"_index":7,"title":{},"body":{"interfaces/ADCCallback.html":{},"interfaces/ADCResponse.html":{},"interfaces/BodyResponseCallback.html":{},"interfaces/ComputeOptions.html":{},"interfaces/CredentialBody.html":{},"interfaces/CredentialCallback.html":{},"interfaces/CredentialRequest.html":{},"interfaces/Credentials.html":{},"classes/DefaultTransporter.html":{},"interfaces/FederatedSignonCertsResponse.html":{},"interfaces/GetAccessTokenCallback.html":{},"interfaces/GetAccessTokenResponse.html":{},"interfaces/GetFederatedSignonCertsCallback.html":{},"interfaces/GetTokenCallback.html":{},"interfaces/GetTokenOptions.html":{},"interfaces/GetTokenResponse.html":{},"interfaces/GoogleAuthOptions.html":{},"classes/IAMAuth.html":{},"classes/JWTAccess.html":{},"interfaces/JWTInput.html":{},"interfaces/JWTOptions.html":{},"interfaces/OAuth2ClientOptions.html":{},"interfaces/ProjectIdCallback.html":{},"interfaces/RefreshAccessTokenCallback.html":{},"interfaces/RefreshAccessTokenResponse.html":{},"interfaces/RefreshOptions.html":{},"interfaces/RequestError.html":{},"interfaces/RequestMetadata.html":{},"interfaces/RequestMetadataCallback.html":{},"interfaces/RequestMetadataResponse.html":{},"interfaces/RevokeCredentialsResult.html":{},"interfaces/SignBlobResponse.html":{},"interfaces/TokenInfo.html":{},"interfaces/TokenInfoRequest.html":{},"interfaces/TokenPayload.html":{},"interfaces/UserRefreshClientOptions.html":{},"interfaces/VerifyIdTokenOptions.html":{},"interfaces/Warning.html":{},"changelog.html":{},"index.html":{}}}],["protect",{"_index":319,"title":{},"body":{"interfaces/ADCCallback.html":{},"interfaces/ADCResponse.html":{},"interfaces/ComputeOptions.html":{},"interfaces/CredentialCallback.html":{},"interfaces/FederatedSignonCertsResponse.html":{},"interfaces/GetAccessTokenCallback.html":{},"interfaces/GetAccessTokenResponse.html":{},"interfaces/GetFederatedSignonCertsCallback.html":{},"interfaces/GetTokenCallback.html":{},"interfaces/GetTokenOptions.html":{},"interfaces/GetTokenResponse.html":{},"interfaces/GoogleAuthOptions.html":{},"interfaces/JWTOptions.html":{},"classes/LoginTicket.html":{},"interfaces/OAuth2ClientOptions.html":{},"interfaces/ProjectIdCallback.html":{},"interfaces/RefreshAccessTokenCallback.html":{},"interfaces/RefreshAccessTokenResponse.html":{},"interfaces/RefreshOptions.html":{},"interfaces/RequestMetadataCallback.html":{},"interfaces/RequestMetadataResponse.html":{},"interfaces/RevokeCredentialsResult.html":{},"interfaces/SignBlobResponse.html":{},"interfaces/TokenInfo.html":{},"interfaces/TokenInfoRequest.html":{},"interfaces/TokenPayload.html":{},"interfaces/UserRefreshClientOptions.html":{},"interfaces/VerifyIdTokenOptions.html":{}}}],["provid",{"_index":438,"title":{},"body":{"interfaces/ADCCallback.html":{},"interfaces/ADCResponse.html":{},"interfaces/CredentialCallback.html":{},"interfaces/FederatedSignonCertsResponse.html":{},"interfaces/GetAccessTokenCallback.html":{},"interfaces/GetAccessTokenResponse.html":{},"interfaces/GetFederatedSignonCertsCallback.html":{},"interfaces/GetTokenCallback.html":{},"interfaces/GetTokenOptions.html":{},"interfaces/GetTokenResponse.html":{},"interfaces/GoogleAuthOptions.html":{},"classes/JWTAccess.html":{},"interfaces/JWTOptions.html":{},"classes/LoginTicket.html":{},"interfaces/OAuth2ClientOptions.html":{},"interfaces/ProjectIdCallback.html":{},"interfaces/RefreshAccessTokenCallback.html":{},"interfaces/RefreshAccessTokenResponse.html":{},"interfaces/RefreshOptions.html":{},"interfaces/RequestMetadataCallback.html":{},"interfaces/RequestMetadataResponse.html":{},"interfaces/RevokeCredentialsResult.html":{},"interfaces/SignBlobResponse.html":{},"interfaces/TokenInfo.html":{},"interfaces/TokenInfoRequest.html":{},"interfaces/TokenPayload.html":{},"interfaces/VerifyIdTokenOptions.html":{},"index.html":{},"license.html":{}}}],["provis",{"_index":1145,"title":{},"body":{"interfaces/FederatedSignonCertsResponse.html":{},"interfaces/GetAccessTokenCallback.html":{},"interfaces/GetAccessTokenResponse.html":{},"interfaces/GetFederatedSignonCertsCallback.html":{},"interfaces/GetTokenCallback.html":{},"interfaces/GetTokenOptions.html":{},"interfaces/GetTokenResponse.html":{},"interfaces/OAuth2ClientOptions.html":{},"interfaces/RefreshAccessTokenCallback.html":{},"interfaces/RefreshAccessTokenResponse.html":{},"interfaces/RefreshOptions.html":{},"interfaces/RequestMetadataCallback.html":{},"interfaces/RequestMetadataResponse.html":{},"interfaces/RevokeCredentialsResult.html":{},"interfaces/TokenInfo.html":{},"interfaces/TokenInfoRequest.html":{},"interfaces/VerifyIdTokenOptions.html":{},"index.html":{}}}],["proxi",{"_index":504,"title":{},"body":{"interfaces/BodyResponseCallback.html":{},"classes/DefaultTransporter.html":{},"interfaces/RequestError.html":{},"interfaces/Transporter.html":{},"changelog.html":{},"dependencies.html":{},"index.html":{},"miscellaneous/variables.html":{}}}],["pubkey",{"_index":1390,"title":{},"body":{"classes/PemVerifier.html":{}}}],["public",{"_index":101,"title":{},"body":{"interfaces/ADCCallback.html":{},"interfaces/ADCResponse.html":{},"interfaces/CredentialCallback.html":{},"interfaces/GoogleAuthOptions.html":{},"classes/IAMAuth.html":{},"interfaces/ProjectIdCallback.html":{},"interfaces/RequestMetadata.html":{},"interfaces/SignBlobResponse.html":{}}}],["publicli",{"_index":1892,"title":{},"body":{"license.html":{}}}],["publish",{"_index":1515,"title":{},"body":{"changelog.html":{}}}],["purpos",{"_index":825,"title":{},"body":{"interfaces/FederatedSignonCertsResponse.html":{},"interfaces/GetAccessTokenCallback.html":{},"interfaces/GetAccessTokenResponse.html":{},"interfaces/GetFederatedSignonCertsCallback.html":{},"interfaces/GetTokenCallback.html":{},"interfaces/GetTokenOptions.html":{},"interfaces/GetTokenResponse.html":{},"interfaces/OAuth2ClientOptions.html":{},"interfaces/RefreshAccessTokenCallback.html":{},"interfaces/RefreshAccessTokenResponse.html":{},"interfaces/RefreshOptions.html":{},"interfaces/RequestMetadataCallback.html":{},"interfaces/RequestMetadataResponse.html":{},"interfaces/RevokeCredentialsResult.html":{},"interfaces/TokenInfo.html":{},"interfaces/TokenInfoRequest.html":{},"interfaces/VerifyIdTokenOptions.html":{},"index.html":{},"license.html":{}}}],["qs",{"_index":1738,"title":{},"body":{"index.html":{}}}],["qs.code",{"_index":1741,"title":{},"body":{"index.html":{}}}],["querystr",{"_index":430,"title":{},"body":{"interfaces/ADCCallback.html":{},"interfaces/ADCResponse.html":{},"interfaces/CredentialCallback.html":{},"interfaces/FederatedSignonCertsResponse.html":{},"interfaces/GetAccessTokenCallback.html":{},"interfaces/GetAccessTokenResponse.html":{},"interfaces/GetFederatedSignonCertsCallback.html":{},"interfaces/GetTokenCallback.html":{},"interfaces/GetTokenOptions.html":{},"interfaces/GetTokenResponse.html":{},"interfaces/GoogleAuthOptions.html":{},"interfaces/OAuth2ClientOptions.html":{},"interfaces/ProjectIdCallback.html":{},"interfaces/RefreshAccessTokenCallback.html":{},"interfaces/RefreshAccessTokenResponse.html":{},"interfaces/RefreshOptions.html":{},"interfaces/RequestMetadataCallback.html":{},"interfaces/RequestMetadataResponse.html":{},"interfaces/RevokeCredentialsResult.html":{},"interfaces/SignBlobResponse.html":{},"interfaces/TokenInfo.html":{},"interfaces/TokenInfoRequest.html":{},"interfaces/VerifyIdTokenOptions.html":{},"index.html":{}}}],["querystring.parse(url.parse(req.url).queri",{"_index":1739,"title":{},"body":{"index.html":{}}}],["querystring.stringify(data",{"_index":1032,"title":{},"body":{"interfaces/FederatedSignonCertsResponse.html":{},"interfaces/GetAccessTokenCallback.html":{},"interfaces/GetAccessTokenResponse.html":{},"interfaces/GetFederatedSignonCertsCallback.html":{},"interfaces/GetTokenCallback.html":{},"interfaces/GetTokenOptions.html":{},"interfaces/GetTokenResponse.html":{},"interfaces/OAuth2ClientOptions.html":{},"interfaces/RefreshAccessTokenCallback.html":{},"interfaces/RefreshAccessTokenResponse.html":{},"interfaces/RefreshOptions.html":{},"interfaces/RequestMetadataCallback.html":{},"interfaces/RequestMetadataResponse.html":{},"interfaces/RevokeCredentialsResult.html":{},"interfaces/TokenInfo.html":{},"interfaces/TokenInfoRequest.html":{},"interfaces/VerifyIdTokenOptions.html":{}}}],["querystring.stringify(opt",{"_index":968,"title":{},"body":{"interfaces/FederatedSignonCertsResponse.html":{},"interfaces/GetAccessTokenCallback.html":{},"interfaces/GetAccessTokenResponse.html":{},"interfaces/GetFederatedSignonCertsCallback.html":{},"interfaces/GetTokenCallback.html":{},"interfaces/GetTokenOptions.html":{},"interfaces/GetTokenResponse.html":{},"interfaces/OAuth2ClientOptions.html":{},"interfaces/RefreshAccessTokenCallback.html":{},"interfaces/RefreshAccessTokenResponse.html":{},"interfaces/RefreshOptions.html":{},"interfaces/RequestMetadataCallback.html":{},"interfaces/RequestMetadataResponse.html":{},"interfaces/RevokeCredentialsResult.html":{},"interfaces/TokenInfo.html":{},"interfaces/TokenInfoRequest.html":{},"interfaces/VerifyIdTokenOptions.html":{}}}],["querystring.stringify(valu",{"_index":1021,"title":{},"body":{"interfaces/FederatedSignonCertsResponse.html":{},"interfaces/GetAccessTokenCallback.html":{},"interfaces/GetAccessTokenResponse.html":{},"interfaces/GetFederatedSignonCertsCallback.html":{},"interfaces/GetTokenCallback.html":{},"interfaces/GetTokenOptions.html":{},"interfaces/GetTokenResponse.html":{},"interfaces/OAuth2ClientOptions.html":{},"interfaces/RefreshAccessTokenCallback.html":{},"interfaces/RefreshAccessTokenResponse.html":{},"interfaces/RefreshOptions.html":{},"interfaces/RequestMetadataCallback.html":{},"interfaces/RequestMetadataResponse.html":{},"interfaces/RevokeCredentialsResult.html":{},"interfaces/TokenInfo.html":{},"interfaces/TokenInfoRequest.html":{},"interfaces/VerifyIdTokenOptions.html":{}}}],["querystring.stringify({token",{"_index":1084,"title":{},"body":{"interfaces/FederatedSignonCertsResponse.html":{},"interfaces/GetAccessTokenCallback.html":{},"interfaces/GetAccessTokenResponse.html":{},"interfaces/GetFederatedSignonCertsCallback.html":{},"interfaces/GetTokenCallback.html":{},"interfaces/GetTokenOptions.html":{},"interfaces/GetTokenResponse.html":{},"interfaces/OAuth2ClientOptions.html":{},"interfaces/RefreshAccessTokenCallback.html":{},"interfaces/RefreshAccessTokenResponse.html":{},"interfaces/RefreshOptions.html":{},"interfaces/RequestMetadataCallback.html":{},"interfaces/RequestMetadataResponse.html":{},"interfaces/RevokeCredentialsResult.html":{},"interfaces/TokenInfo.html":{},"interfaces/TokenInfoRequest.html":{},"interfaces/VerifyIdTokenOptions.html":{}}}],["question",{"_index":1809,"title":{},"body":{"index.html":{}}}],["quota",{"_index":317,"title":{},"body":{"interfaces/ADCCallback.html":{},"interfaces/ADCResponse.html":{},"interfaces/CredentialCallback.html":{},"interfaces/GoogleAuthOptions.html":{},"interfaces/ProjectIdCallback.html":{},"interfaces/SignBlobResponse.html":{},"interfaces/Warning.html":{},"miscellaneous/variables.html":{}}}],["r",{"_index":144,"title":{},"body":{"interfaces/ADCCallback.html":{},"interfaces/ADCResponse.html":{},"interfaces/BodyResponseCallback.html":{},"interfaces/CredentialCallback.html":{},"classes/DefaultTransporter.html":{},"interfaces/FederatedSignonCertsResponse.html":{},"interfaces/GetAccessTokenCallback.html":{},"interfaces/GetAccessTokenResponse.html":{},"interfaces/GetFederatedSignonCertsCallback.html":{},"interfaces/GetTokenCallback.html":{},"interfaces/GetTokenOptions.html":{},"interfaces/GetTokenResponse.html":{},"interfaces/GoogleAuthOptions.html":{},"interfaces/JWTOptions.html":{},"interfaces/OAuth2ClientOptions.html":{},"interfaces/ProjectIdCallback.html":{},"interfaces/RefreshAccessTokenCallback.html":{},"interfaces/RefreshAccessTokenResponse.html":{},"interfaces/RefreshOptions.html":{},"interfaces/RequestError.html":{},"interfaces/RequestMetadataCallback.html":{},"interfaces/RequestMetadataResponse.html":{},"interfaces/RevokeCredentialsResult.html":{},"interfaces/SignBlobResponse.html":{},"interfaces/TokenInfo.html":{},"interfaces/TokenInfoRequest.html":{},"interfaces/Transporter.html":{},"interfaces/VerifyIdTokenOptions.html":{},"index.html":{}}}],["r.cert",{"_index":1161,"title":{},"body":{"interfaces/FederatedSignonCertsResponse.html":{},"interfaces/GetAccessTokenCallback.html":{},"interfaces/GetAccessTokenResponse.html":{},"interfaces/GetFederatedSignonCertsCallback.html":{},"interfaces/GetTokenCallback.html":{},"interfaces/GetTokenOptions.html":{},"interfaces/GetTokenResponse.html":{},"interfaces/OAuth2ClientOptions.html":{},"interfaces/RefreshAccessTokenCallback.html":{},"interfaces/RefreshAccessTokenResponse.html":{},"interfaces/RefreshOptions.html":{},"interfaces/RequestMetadataCallback.html":{},"interfaces/RequestMetadataResponse.html":{},"interfaces/RevokeCredentialsResult.html":{},"interfaces/TokenInfo.html":{},"interfaces/TokenInfoRequest.html":{},"interfaces/VerifyIdTokenOptions.html":{}}}],["r.credenti",{"_index":203,"title":{},"body":{"interfaces/ADCCallback.html":{},"interfaces/ADCResponse.html":{},"interfaces/CredentialCallback.html":{},"interfaces/FederatedSignonCertsResponse.html":{},"interfaces/GetAccessTokenCallback.html":{},"interfaces/GetAccessTokenResponse.html":{},"interfaces/GetFederatedSignonCertsCallback.html":{},"interfaces/GetTokenCallback.html":{},"interfaces/GetTokenOptions.html":{},"interfaces/GetTokenResponse.html":{},"interfaces/GoogleAuthOptions.html":{},"interfaces/OAuth2ClientOptions.html":{},"interfaces/ProjectIdCallback.html":{},"interfaces/RefreshAccessTokenCallback.html":{},"interfaces/RefreshAccessTokenResponse.html":{},"interfaces/RefreshOptions.html":{},"interfaces/RequestMetadataCallback.html":{},"interfaces/RequestMetadataResponse.html":{},"interfaces/RevokeCredentialsResult.html":{},"interfaces/SignBlobResponse.html":{},"interfaces/TokenInfo.html":{},"interfaces/TokenInfoRequest.html":{},"interfaces/VerifyIdTokenOptions.html":{}}}],["r.credentials.access_token",{"_index":1056,"title":{},"body":{"interfaces/FederatedSignonCertsResponse.html":{},"interfaces/GetAccessTokenCallback.html":{},"interfaces/GetAccessTokenResponse.html":{},"interfaces/GetFederatedSignonCertsCallback.html":{},"interfaces/GetTokenCallback.html":{},"interfaces/GetTokenOptions.html":{},"interfaces/GetTokenResponse.html":{},"interfaces/OAuth2ClientOptions.html":{},"interfaces/RefreshAccessTokenCallback.html":{},"interfaces/RefreshAccessTokenResponse.html":{},"interfaces/RefreshOptions.html":{},"interfaces/RequestMetadataCallback.html":{},"interfaces/RequestMetadataResponse.html":{},"interfaces/RevokeCredentialsResult.html":{},"interfaces/TokenInfo.html":{},"interfaces/TokenInfoRequest.html":{},"interfaces/VerifyIdTokenOptions.html":{}}}],["r.data",{"_index":412,"title":{},"body":{"interfaces/ADCCallback.html":{},"interfaces/ADCResponse.html":{},"interfaces/CredentialCallback.html":{},"interfaces/GoogleAuthOptions.html":{},"interfaces/ProjectIdCallback.html":{},"interfaces/SignBlobResponse.html":{}}}],["r.header",{"_index":1063,"title":{},"body":{"interfaces/FederatedSignonCertsResponse.html":{},"interfaces/GetAccessTokenCallback.html":{},"interfaces/GetAccessTokenResponse.html":{},"interfaces/GetFederatedSignonCertsCallback.html":{},"interfaces/GetTokenCallback.html":{},"interfaces/GetTokenOptions.html":{},"interfaces/GetTokenResponse.html":{},"interfaces/OAuth2ClientOptions.html":{},"interfaces/RefreshAccessTokenCallback.html":{},"interfaces/RefreshAccessTokenResponse.html":{},"interfaces/RefreshOptions.html":{},"interfaces/RequestMetadataCallback.html":{},"interfaces/RequestMetadataResponse.html":{},"interfaces/RevokeCredentialsResult.html":{},"interfaces/TokenInfo.html":{},"interfaces/TokenInfoRequest.html":{},"interfaces/VerifyIdTokenOptions.html":{}}}],["r.headers.author",{"_index":1103,"title":{},"body":{"interfaces/FederatedSignonCertsResponse.html":{},"interfaces/GetAccessTokenCallback.html":{},"interfaces/GetAccessTokenResponse.html":{},"interfaces/GetFederatedSignonCertsCallback.html":{},"interfaces/GetTokenCallback.html":{},"interfaces/GetTokenOptions.html":{},"interfaces/GetTokenResponse.html":{},"interfaces/OAuth2ClientOptions.html":{},"interfaces/RefreshAccessTokenCallback.html":{},"interfaces/RefreshAccessTokenResponse.html":{},"interfaces/RefreshOptions.html":{},"interfaces/RequestMetadataCallback.html":{},"interfaces/RequestMetadataResponse.html":{},"interfaces/RevokeCredentialsResult.html":{},"interfaces/TokenInfo.html":{},"interfaces/TokenInfoRequest.html":{},"interfaces/VerifyIdTokenOptions.html":{}}}],["r.projectid",{"_index":204,"title":{},"body":{"interfaces/ADCCallback.html":{},"interfaces/ADCResponse.html":{},"interfaces/CredentialCallback.html":{},"interfaces/GoogleAuthOptions.html":{},"interfaces/ProjectIdCallback.html":{},"interfaces/SignBlobResponse.html":{}}}],["r.re",{"_index":1010,"title":{},"body":{"interfaces/FederatedSignonCertsResponse.html":{},"interfaces/GetAccessTokenCallback.html":{},"interfaces/GetAccessTokenResponse.html":{},"interfaces/GetFederatedSignonCertsCallback.html":{},"interfaces/GetTokenCallback.html":{},"interfaces/GetTokenOptions.html":{},"interfaces/GetTokenResponse.html":{},"interfaces/OAuth2ClientOptions.html":{},"interfaces/RefreshAccessTokenCallback.html":{},"interfaces/RefreshAccessTokenResponse.html":{},"interfaces/RefreshOptions.html":{},"interfaces/RequestMetadataCallback.html":{},"interfaces/RequestMetadataResponse.html":{},"interfaces/RevokeCredentialsResult.html":{},"interfaces/TokenInfo.html":{},"interfaces/TokenInfoRequest.html":{},"interfaces/VerifyIdTokenOptions.html":{}}}],["r.token",{"_index":1009,"title":{},"body":{"interfaces/FederatedSignonCertsResponse.html":{},"interfaces/GetAccessTokenCallback.html":{},"interfaces/GetAccessTokenResponse.html":{},"interfaces/GetFederatedSignonCertsCallback.html":{},"interfaces/GetTokenCallback.html":{},"interfaces/GetTokenOptions.html":{},"interfaces/GetTokenResponse.html":{},"interfaces/OAuth2ClientOptions.html":{},"interfaces/RefreshAccessTokenCallback.html":{},"interfaces/RefreshAccessTokenResponse.html":{},"interfaces/RefreshOptions.html":{},"interfaces/RequestMetadataCallback.html":{},"interfaces/RequestMetadataResponse.html":{},"interfaces/RevokeCredentialsResult.html":{},"interfaces/TokenInfo.html":{},"interfaces/TokenInfoRequest.html":{},"interfaces/VerifyIdTokenOptions.html":{}}}],["r2",{"_index":1101,"title":{},"body":{"interfaces/FederatedSignonCertsResponse.html":{},"interfaces/GetAccessTokenCallback.html":{},"interfaces/GetAccessTokenResponse.html":{},"interfaces/GetFederatedSignonCertsCallback.html":{},"interfaces/GetTokenCallback.html":{},"interfaces/GetTokenOptions.html":{},"interfaces/GetTokenResponse.html":{},"interfaces/OAuth2ClientOptions.html":{},"interfaces/RefreshAccessTokenCallback.html":{},"interfaces/RefreshAccessTokenResponse.html":{},"interfaces/RefreshOptions.html":{},"interfaces/RequestMetadataCallback.html":{},"interfaces/RequestMetadataResponse.html":{},"interfaces/RevokeCredentialsResult.html":{},"interfaces/TokenInfo.html":{},"interfaces/TokenInfoRequest.html":{},"interfaces/VerifyIdTokenOptions.html":{}}}],["rais",{"_index":1759,"title":{},"body":{"index.html":{}}}],["random",{"_index":839,"title":{},"body":{"interfaces/FederatedSignonCertsResponse.html":{},"interfaces/GetAccessTokenCallback.html":{},"interfaces/GetAccessTokenResponse.html":{},"interfaces/GetFederatedSignonCertsCallback.html":{},"interfaces/GetTokenCallback.html":{},"interfaces/GetTokenOptions.html":{},"interfaces/GetTokenResponse.html":{},"interfaces/OAuth2ClientOptions.html":{},"interfaces/RefreshAccessTokenCallback.html":{},"interfaces/RefreshAccessTokenResponse.html":{},"interfaces/RefreshOptions.html":{},"interfaces/RequestMetadataCallback.html":{},"interfaces/RequestMetadataResponse.html":{},"interfaces/RevokeCredentialsResult.html":{},"interfaces/TokenInfo.html":{},"interfaces/TokenInfoRequest.html":{},"interfaces/VerifyIdTokenOptions.html":{}}}],["randomstr",{"_index":980,"title":{},"body":{"interfaces/FederatedSignonCertsResponse.html":{},"interfaces/GetAccessTokenCallback.html":{},"interfaces/GetAccessTokenResponse.html":{},"interfaces/GetFederatedSignonCertsCallback.html":{},"interfaces/GetTokenCallback.html":{},"interfaces/GetTokenOptions.html":{},"interfaces/GetTokenResponse.html":{},"interfaces/OAuth2ClientOptions.html":{},"interfaces/RefreshAccessTokenCallback.html":{},"interfaces/RefreshAccessTokenResponse.html":{},"interfaces/RefreshOptions.html":{},"interfaces/RequestMetadataCallback.html":{},"interfaces/RequestMetadataResponse.html":{},"interfaces/RevokeCredentialsResult.html":{},"interfaces/TokenInfo.html":{},"interfaces/TokenInfoRequest.html":{},"interfaces/VerifyIdTokenOptions.html":{}}}],["randomstring.replace(/\\+/g",{"_index":991,"title":{},"body":{"interfaces/FederatedSignonCertsResponse.html":{},"interfaces/GetAccessTokenCallback.html":{},"interfaces/GetAccessTokenResponse.html":{},"interfaces/GetFederatedSignonCertsCallback.html":{},"interfaces/GetTokenCallback.html":{},"interfaces/GetTokenOptions.html":{},"interfaces/GetTokenResponse.html":{},"interfaces/OAuth2ClientOptions.html":{},"interfaces/RefreshAccessTokenCallback.html":{},"interfaces/RefreshAccessTokenResponse.html":{},"interfaces/RefreshOptions.html":{},"interfaces/RequestMetadataCallback.html":{},"interfaces/RequestMetadataResponse.html":{},"interfaces/RevokeCredentialsResult.html":{},"interfaces/TokenInfo.html":{},"interfaces/TokenInfoRequest.html":{},"interfaces/VerifyIdTokenOptions.html":{}}}],["re",{"_index":487,"title":{},"body":{"interfaces/ADCCallback.html":{},"interfaces/ADCResponse.html":{},"interfaces/BodyResponseCallback.html":{},"interfaces/ComputeOptions.html":{},"interfaces/CredentialCallback.html":{},"classes/DefaultTransporter.html":{},"interfaces/FederatedSignonCertsResponse.html":{},"interfaces/GetAccessTokenCallback.html":{},"interfaces/GetAccessTokenResponse.html":{},"interfaces/GetFederatedSignonCertsCallback.html":{},"interfaces/GetTokenCallback.html":{},"interfaces/GetTokenOptions.html":{},"interfaces/GetTokenResponse.html":{},"interfaces/GoogleAuthOptions.html":{},"interfaces/JWTOptions.html":{},"interfaces/OAuth2ClientOptions.html":{},"interfaces/ProjectIdCallback.html":{},"interfaces/RefreshAccessTokenCallback.html":{},"interfaces/RefreshAccessTokenResponse.html":{},"interfaces/RefreshOptions.html":{},"interfaces/RequestError.html":{},"interfaces/RequestMetadataCallback.html":{},"interfaces/RequestMetadataResponse.html":{},"interfaces/RevokeCredentialsResult.html":{},"interfaces/SignBlobResponse.html":{},"interfaces/TokenInfo.html":{},"interfaces/TokenInfoRequest.html":{},"interfaces/Transporter.html":{},"interfaces/VerifyIdTokenOptions.html":{},"changelog.html":{},"index.html":{}}}],["read",{"_index":260,"title":{},"body":{"interfaces/ADCCallback.html":{},"interfaces/ADCResponse.html":{},"interfaces/CredentialCallback.html":{},"interfaces/GoogleAuthOptions.html":{},"interfaces/ProjectIdCallback.html":{},"interfaces/SignBlobResponse.html":{},"changelog.html":{}}}],["readabl",{"_index":1924,"title":{},"body":{"license.html":{}}}],["readablestream",{"_index":1114,"title":{},"body":{"interfaces/FederatedSignonCertsResponse.html":{},"interfaces/GetAccessTokenCallback.html":{},"interfaces/GetAccessTokenResponse.html":{},"interfaces/GetFederatedSignonCertsCallback.html":{},"interfaces/GetTokenCallback.html":{},"interfaces/GetTokenOptions.html":{},"interfaces/GetTokenResponse.html":{},"interfaces/OAuth2ClientOptions.html":{},"interfaces/RefreshAccessTokenCallback.html":{},"interfaces/RefreshAccessTokenResponse.html":{},"interfaces/RefreshOptions.html":{},"interfaces/RequestMetadataCallback.html":{},"interfaces/RequestMetadataResponse.html":{},"interfaces/RevokeCredentialsResult.html":{},"interfaces/TokenInfo.html":{},"interfaces/TokenInfoRequest.html":{},"interfaces/VerifyIdTokenOptions.html":{}}}],["readm",{"_index":1485,"title":{},"body":{"changelog.html":{}}}],["readme.md",{"_index":1575,"title":{},"body":{"changelog.html":{}}}],["readonli",{"_index":532,"title":{},"body":{"interfaces/BodyResponseCallback.html":{},"classes/DefaultTransporter.html":{},"interfaces/FederatedSignonCertsResponse.html":{},"interfaces/GetAccessTokenCallback.html":{},"interfaces/GetAccessTokenResponse.html":{},"interfaces/GetFederatedSignonCertsCallback.html":{},"interfaces/GetTokenCallback.html":{},"interfaces/GetTokenOptions.html":{},"interfaces/GetTokenResponse.html":{},"interfaces/OAuth2ClientOptions.html":{},"interfaces/RefreshAccessTokenCallback.html":{},"interfaces/RefreshAccessTokenResponse.html":{},"interfaces/RefreshOptions.html":{},"interfaces/RequestError.html":{},"interfaces/RequestMetadataCallback.html":{},"interfaces/RequestMetadataResponse.html":{},"interfaces/RevokeCredentialsResult.html":{},"interfaces/TokenInfo.html":{},"interfaces/TokenInfoRequest.html":{},"interfaces/Transporter.html":{},"interfaces/VerifyIdTokenOptions.html":{}}}],["readstream",{"_index":308,"title":{},"body":{"interfaces/ADCCallback.html":{},"interfaces/ADCResponse.html":{},"interfaces/CredentialCallback.html":{},"interfaces/GoogleAuthOptions.html":{},"interfaces/ProjectIdCallback.html":{},"interfaces/SignBlobResponse.html":{}}}],["reason",{"_index":606,"title":{},"body":{"interfaces/ComputeOptions.html":{},"license.html":{}}}],["receiv",{"_index":1435,"title":{},"body":{"interfaces/Warning.html":{},"license.html":{},"miscellaneous/variables.html":{}}}],["recent",{"_index":1754,"title":{},"body":{"index.html":{}}}],["recipi",{"_index":1177,"title":{},"body":{"interfaces/FederatedSignonCertsResponse.html":{},"interfaces/GetAccessTokenCallback.html":{},"interfaces/GetAccessTokenResponse.html":{},"interfaces/GetFederatedSignonCertsCallback.html":{},"interfaces/GetTokenCallback.html":{},"interfaces/GetTokenOptions.html":{},"interfaces/GetTokenResponse.html":{},"interfaces/OAuth2ClientOptions.html":{},"interfaces/RefreshAccessTokenCallback.html":{},"interfaces/RefreshAccessTokenResponse.html":{},"interfaces/RefreshOptions.html":{},"interfaces/RequestMetadataCallback.html":{},"interfaces/RequestMetadataResponse.html":{},"interfaces/RevokeCredentialsResult.html":{},"interfaces/TokenInfo.html":{},"interfaces/TokenInfoRequest.html":{},"interfaces/VerifyIdTokenOptions.html":{},"license.html":{}}}],["recogn",{"_index":1224,"title":{},"body":{"classes/JWTAccess.html":{},"interfaces/Warning.html":{}}}],["recommend",{"_index":754,"title":{},"body":{"interfaces/FederatedSignonCertsResponse.html":{},"interfaces/GetAccessTokenCallback.html":{},"interfaces/GetAccessTokenResponse.html":{},"interfaces/GetFederatedSignonCertsCallback.html":{},"interfaces/GetTokenCallback.html":{},"interfaces/GetTokenOptions.html":{},"interfaces/GetTokenResponse.html":{},"interfaces/OAuth2ClientOptions.html":{},"interfaces/RefreshAccessTokenCallback.html":{},"interfaces/RefreshAccessTokenResponse.html":{},"interfaces/RefreshOptions.html":{},"interfaces/RequestMetadataCallback.html":{},"interfaces/RequestMetadataResponse.html":{},"interfaces/RevokeCredentialsResult.html":{},"interfaces/TokenInfo.html":{},"interfaces/TokenInfoRequest.html":{},"interfaces/VerifyIdTokenOptions.html":{},"interfaces/Warning.html":{},"index.html":{},"license.html":{},"miscellaneous/variables.html":{}}}],["record",{"_index":1375,"title":{},"body":{"classes/LoginTicket.html":{},"interfaces/TokenPayload.html":{}}}],["recurs",{"_index":432,"title":{},"body":{"interfaces/ADCCallback.html":{},"interfaces/ADCResponse.html":{},"interfaces/CredentialCallback.html":{},"interfaces/GoogleAuthOptions.html":{},"interfaces/ProjectIdCallback.html":{},"interfaces/SignBlobResponse.html":{}}}],["redirect",{"_index":703,"title":{},"body":{"interfaces/FederatedSignonCertsResponse.html":{},"interfaces/GetAccessTokenCallback.html":{},"interfaces/GetAccessTokenResponse.html":{},"interfaces/GetFederatedSignonCertsCallback.html":{},"interfaces/GetTokenCallback.html":{},"interfaces/GetTokenOptions.html":{},"interfaces/GetTokenResponse.html":{},"interfaces/OAuth2ClientOptions.html":{},"interfaces/RefreshAccessTokenCallback.html":{},"interfaces/RefreshAccessTokenResponse.html":{},"interfaces/RefreshOptions.html":{},"interfaces/RequestMetadataCallback.html":{},"interfaces/RequestMetadataResponse.html":{},"interfaces/RevokeCredentialsResult.html":{},"interfaces/TokenInfo.html":{},"interfaces/TokenInfoRequest.html":{},"interfaces/VerifyIdTokenOptions.html":{}}}],["redirect_uri",{"_index":706,"title":{},"body":{"interfaces/FederatedSignonCertsResponse.html":{},"interfaces/GetAccessTokenCallback.html":{},"interfaces/GetAccessTokenResponse.html":{},"interfaces/GetFederatedSignonCertsCallback.html":{},"interfaces/GetTokenCallback.html":{},"interfaces/GetTokenOptions.html":{},"interfaces/GetTokenResponse.html":{},"interfaces/OAuth2ClientOptions.html":{},"interfaces/RefreshAccessTokenCallback.html":{},"interfaces/RefreshAccessTokenResponse.html":{},"interfaces/RefreshOptions.html":{},"interfaces/RequestMetadataCallback.html":{},"interfaces/RequestMetadataResponse.html":{},"interfaces/RevokeCredentialsResult.html":{},"interfaces/TokenInfo.html":{},"interfaces/TokenInfoRequest.html":{},"interfaces/VerifyIdTokenOptions.html":{}}}],["redirect_url",{"_index":1702,"title":{},"body":{"index.html":{}}}],["redirecturi",{"_index":896,"title":{},"body":{"interfaces/FederatedSignonCertsResponse.html":{},"interfaces/GetAccessTokenCallback.html":{},"interfaces/GetAccessTokenResponse.html":{},"interfaces/GetFederatedSignonCertsCallback.html":{},"interfaces/GetTokenCallback.html":{},"interfaces/GetTokenOptions.html":{},"interfaces/GetTokenResponse.html":{},"interfaces/OAuth2ClientOptions.html":{},"interfaces/RefreshAccessTokenCallback.html":{},"interfaces/RefreshAccessTokenResponse.html":{},"interfaces/RefreshOptions.html":{},"interfaces/RequestMetadataCallback.html":{},"interfaces/RequestMetadataResponse.html":{},"interfaces/RevokeCredentialsResult.html":{},"interfaces/TokenInfo.html":{},"interfaces/TokenInfoRequest.html":{},"interfaces/VerifyIdTokenOptions.html":{},"index.html":{}}}],["redistribut",{"_index":1912,"title":{},"body":{"license.html":{}}}],["refactor",{"_index":911,"title":{},"body":{"interfaces/FederatedSignonCertsResponse.html":{},"interfaces/GetAccessTokenCallback.html":{},"interfaces/GetAccessTokenResponse.html":{},"interfaces/GetFederatedSignonCertsCallback.html":{},"interfaces/GetTokenCallback.html":{},"interfaces/GetTokenOptions.html":{},"interfaces/GetTokenResponse.html":{},"interfaces/OAuth2ClientOptions.html":{},"interfaces/RefreshAccessTokenCallback.html":{},"interfaces/RefreshAccessTokenResponse.html":{},"interfaces/RefreshOptions.html":{},"interfaces/RequestMetadataCallback.html":{},"interfaces/RequestMetadataResponse.html":{},"interfaces/RevokeCredentialsResult.html":{},"interfaces/TokenInfo.html":{},"interfaces/TokenInfoRequest.html":{},"interfaces/UserRefreshClientOptions.html":{},"interfaces/VerifyIdTokenOptions.html":{},"changelog.html":{}}}],["refresh",{"_index":591,"title":{},"body":{"interfaces/ComputeOptions.html":{},"interfaces/FederatedSignonCertsResponse.html":{},"interfaces/GetAccessTokenCallback.html":{},"interfaces/GetAccessTokenResponse.html":{},"interfaces/GetFederatedSignonCertsCallback.html":{},"interfaces/GetTokenCallback.html":{},"interfaces/GetTokenOptions.html":{},"interfaces/GetTokenResponse.html":{},"classes/JWTAccess.html":{},"interfaces/JWTOptions.html":{},"classes/LoginTicket.html":{},"interfaces/OAuth2ClientOptions.html":{},"interfaces/RefreshAccessTokenCallback.html":{},"interfaces/RefreshAccessTokenResponse.html":{},"interfaces/RefreshOptions.html":{},"interfaces/RequestMetadataCallback.html":{},"interfaces/RequestMetadataResponse.html":{},"interfaces/RevokeCredentialsResult.html":{},"interfaces/TokenInfo.html":{},"interfaces/TokenInfoRequest.html":{},"interfaces/TokenPayload.html":{},"interfaces/UserRefreshClientOptions.html":{},"interfaces/VerifyIdTokenOptions.html":{},"changelog.html":{},"index.html":{}}}],["refresh_access_token_deprec",{"_index":1450,"title":{},"body":{"interfaces/Warning.html":{},"miscellaneous/variables.html":{}}}],["refresh_token",{"_index":597,"title":{},"body":{"interfaces/ComputeOptions.html":{},"interfaces/CredentialBody.html":{},"interfaces/CredentialRequest.html":{},"interfaces/Credentials.html":{},"interfaces/FederatedSignonCertsResponse.html":{},"interfaces/GetAccessTokenCallback.html":{},"interfaces/GetAccessTokenResponse.html":{},"interfaces/GetFederatedSignonCertsCallback.html":{},"interfaces/GetTokenCallback.html":{},"interfaces/GetTokenOptions.html":{},"interfaces/GetTokenResponse.html":{},"interfaces/JWTInput.html":{},"interfaces/JWTOptions.html":{},"interfaces/OAuth2ClientOptions.html":{},"interfaces/RefreshAccessTokenCallback.html":{},"interfaces/RefreshAccessTokenResponse.html":{},"interfaces/RefreshOptions.html":{},"interfaces/RequestMetadataCallback.html":{},"interfaces/RequestMetadataResponse.html":{},"interfaces/RevokeCredentialsResult.html":{},"interfaces/TokenInfo.html":{},"interfaces/TokenInfoRequest.html":{},"interfaces/UserRefreshClientOptions.html":{},"interfaces/VerifyIdTokenOptions.html":{},"index.html":{}}}],["refreshaccesstoken",{"_index":1037,"title":{},"body":{"interfaces/FederatedSignonCertsResponse.html":{},"interfaces/GetAccessTokenCallback.html":{},"interfaces/GetAccessTokenResponse.html":{},"interfaces/GetFederatedSignonCertsCallback.html":{},"interfaces/GetTokenCallback.html":{},"interfaces/GetTokenOptions.html":{},"interfaces/GetTokenResponse.html":{},"interfaces/OAuth2ClientOptions.html":{},"interfaces/RefreshAccessTokenCallback.html":{},"interfaces/RefreshAccessTokenResponse.html":{},"interfaces/RefreshOptions.html":{},"interfaces/RequestMetadataCallback.html":{},"interfaces/RequestMetadataResponse.html":{},"interfaces/RevokeCredentialsResult.html":{},"interfaces/TokenInfo.html":{},"interfaces/TokenInfoRequest.html":{},"interfaces/VerifyIdTokenOptions.html":{},"interfaces/Warning.html":{},"changelog.html":{},"index.html":{},"miscellaneous/variables.html":{}}}],["refreshaccesstoken(callback",{"_index":1038,"title":{},"body":{"interfaces/FederatedSignonCertsResponse.html":{},"interfaces/GetAccessTokenCallback.html":{},"interfaces/GetAccessTokenResponse.html":{},"interfaces/GetFederatedSignonCertsCallback.html":{},"interfaces/GetTokenCallback.html":{},"interfaces/GetTokenOptions.html":{},"interfaces/GetTokenResponse.html":{},"interfaces/OAuth2ClientOptions.html":{},"interfaces/RefreshAccessTokenCallback.html":{},"interfaces/RefreshAccessTokenResponse.html":{},"interfaces/RefreshOptions.html":{},"interfaces/RequestMetadataCallback.html":{},"interfaces/RequestMetadataResponse.html":{},"interfaces/RevokeCredentialsResult.html":{},"interfaces/TokenInfo.html":{},"interfaces/TokenInfoRequest.html":{},"interfaces/VerifyIdTokenOptions.html":{}}}],["refreshaccesstokenasync",{"_index":1042,"title":{},"body":{"interfaces/FederatedSignonCertsResponse.html":{},"interfaces/GetAccessTokenCallback.html":{},"interfaces/GetAccessTokenResponse.html":{},"interfaces/GetFederatedSignonCertsCallback.html":{},"interfaces/GetTokenCallback.html":{},"interfaces/GetTokenOptions.html":{},"interfaces/GetTokenResponse.html":{},"interfaces/OAuth2ClientOptions.html":{},"interfaces/RefreshAccessTokenCallback.html":{},"interfaces/RefreshAccessTokenResponse.html":{},"interfaces/RefreshOptions.html":{},"interfaces/RequestMetadataCallback.html":{},"interfaces/RequestMetadataResponse.html":{},"interfaces/RevokeCredentialsResult.html":{},"interfaces/TokenInfo.html":{},"interfaces/TokenInfoRequest.html":{},"interfaces/VerifyIdTokenOptions.html":{}}}],["refreshaccesstokencallback",{"_index":883,"title":{"interfaces/RefreshAccessTokenCallback.html":{}},"body":{"interfaces/FederatedSignonCertsResponse.html":{},"interfaces/GetAccessTokenCallback.html":{},"interfaces/GetAccessTokenResponse.html":{},"interfaces/GetFederatedSignonCertsCallback.html":{},"interfaces/GetTokenCallback.html":{},"interfaces/GetTokenOptions.html":{},"interfaces/GetTokenResponse.html":{},"interfaces/OAuth2ClientOptions.html":{},"interfaces/RefreshAccessTokenCallback.html":{},"interfaces/RefreshAccessTokenResponse.html":{},"interfaces/RefreshOptions.html":{},"interfaces/RequestMetadataCallback.html":{},"interfaces/RequestMetadataResponse.html":{},"interfaces/RevokeCredentialsResult.html":{},"interfaces/TokenInfo.html":{},"interfaces/TokenInfoRequest.html":{},"interfaces/VerifyIdTokenOptions.html":{}}}],["refreshaccesstokenrespons",{"_index":884,"title":{"interfaces/RefreshAccessTokenResponse.html":{}},"body":{"interfaces/FederatedSignonCertsResponse.html":{},"interfaces/GetAccessTokenCallback.html":{},"interfaces/GetAccessTokenResponse.html":{},"interfaces/GetFederatedSignonCertsCallback.html":{},"interfaces/GetTokenCallback.html":{},"interfaces/GetTokenOptions.html":{},"interfaces/GetTokenResponse.html":{},"interfaces/OAuth2ClientOptions.html":{},"interfaces/RefreshAccessTokenCallback.html":{},"interfaces/RefreshAccessTokenResponse.html":{},"interfaces/RefreshOptions.html":{},"interfaces/RequestMetadataCallback.html":{},"interfaces/RequestMetadataResponse.html":{},"interfaces/RevokeCredentialsResult.html":{},"interfaces/TokenInfo.html":{},"interfaces/TokenInfoRequest.html":{},"interfaces/VerifyIdTokenOptions.html":{}}}],["refreshcli",{"_index":52,"title":{},"body":{"interfaces/ADCCallback.html":{},"interfaces/ADCResponse.html":{},"interfaces/CredentialCallback.html":{},"interfaces/GoogleAuthOptions.html":{},"interfaces/ProjectIdCallback.html":{},"interfaces/SignBlobResponse.html":{}}}],["refreshopt",{"_index":50,"title":{"interfaces/RefreshOptions.html":{}},"body":{"interfaces/ADCCallback.html":{},"interfaces/ADCResponse.html":{},"interfaces/ComputeOptions.html":{},"interfaces/CredentialCallback.html":{},"interfaces/FederatedSignonCertsResponse.html":{},"interfaces/GetAccessTokenCallback.html":{},"interfaces/GetAccessTokenResponse.html":{},"interfaces/GetFederatedSignonCertsCallback.html":{},"interfaces/GetTokenCallback.html":{},"interfaces/GetTokenOptions.html":{},"interfaces/GetTokenResponse.html":{},"interfaces/GoogleAuthOptions.html":{},"interfaces/JWTOptions.html":{},"interfaces/OAuth2ClientOptions.html":{},"interfaces/ProjectIdCallback.html":{},"interfaces/RefreshAccessTokenCallback.html":{},"interfaces/RefreshAccessTokenResponse.html":{},"interfaces/RefreshOptions.html":{},"interfaces/RequestMetadataCallback.html":{},"interfaces/RequestMetadataResponse.html":{},"interfaces/RevokeCredentialsResult.html":{},"interfaces/SignBlobResponse.html":{},"interfaces/TokenInfo.html":{},"interfaces/TokenInfoRequest.html":{},"interfaces/UserRefreshClientOptions.html":{},"interfaces/VerifyIdTokenOptions.html":{}}}],["refreshoptions|credentialcallback",{"_index":341,"title":{},"body":{"interfaces/ADCCallback.html":{},"interfaces/ADCResponse.html":{},"interfaces/CredentialCallback.html":{},"interfaces/GoogleAuthOptions.html":{},"interfaces/ProjectIdCallback.html":{},"interfaces/SignBlobResponse.html":{}}}],["refreshoptions|undefin",{"_index":198,"title":{},"body":{"interfaces/ADCCallback.html":{},"interfaces/ADCResponse.html":{},"interfaces/CredentialCallback.html":{},"interfaces/GoogleAuthOptions.html":{},"interfaces/ProjectIdCallback.html":{},"interfaces/SignBlobResponse.html":{}}}],["refreshtoken",{"_index":609,"title":{},"body":{"interfaces/ComputeOptions.html":{},"interfaces/FederatedSignonCertsResponse.html":{},"interfaces/GetAccessTokenCallback.html":{},"interfaces/GetAccessTokenResponse.html":{},"interfaces/GetFederatedSignonCertsCallback.html":{},"interfaces/GetTokenCallback.html":{},"interfaces/GetTokenOptions.html":{},"interfaces/GetTokenResponse.html":{},"interfaces/JWTOptions.html":{},"interfaces/OAuth2ClientOptions.html":{},"interfaces/RefreshAccessTokenCallback.html":{},"interfaces/RefreshAccessTokenResponse.html":{},"interfaces/RefreshOptions.html":{},"interfaces/RequestMetadataCallback.html":{},"interfaces/RequestMetadataResponse.html":{},"interfaces/RevokeCredentialsResult.html":{},"interfaces/TokenInfo.html":{},"interfaces/TokenInfoRequest.html":{},"interfaces/UserRefreshClientOptions.html":{},"interfaces/VerifyIdTokenOptions.html":{}}}],["refreshtoken(refreshtoken",{"_index":1025,"title":{},"body":{"interfaces/FederatedSignonCertsResponse.html":{},"interfaces/GetAccessTokenCallback.html":{},"interfaces/GetAccessTokenResponse.html":{},"interfaces/GetFederatedSignonCertsCallback.html":{},"interfaces/GetTokenCallback.html":{},"interfaces/GetTokenOptions.html":{},"interfaces/GetTokenResponse.html":{},"interfaces/OAuth2ClientOptions.html":{},"interfaces/RefreshAccessTokenCallback.html":{},"interfaces/RefreshAccessTokenResponse.html":{},"interfaces/RefreshOptions.html":{},"interfaces/RequestMetadataCallback.html":{},"interfaces/RequestMetadataResponse.html":{},"interfaces/RevokeCredentialsResult.html":{},"interfaces/TokenInfo.html":{},"interfaces/TokenInfoRequest.html":{},"interfaces/VerifyIdTokenOptions.html":{}}}],["refreshtokennocache(refreshtoken",{"_index":612,"title":{},"body":{"interfaces/ComputeOptions.html":{},"interfaces/FederatedSignonCertsResponse.html":{},"interfaces/GetAccessTokenCallback.html":{},"interfaces/GetAccessTokenResponse.html":{},"interfaces/GetFederatedSignonCertsCallback.html":{},"interfaces/GetTokenCallback.html":{},"interfaces/GetTokenOptions.html":{},"interfaces/GetTokenResponse.html":{},"interfaces/JWTOptions.html":{},"interfaces/OAuth2ClientOptions.html":{},"interfaces/RefreshAccessTokenCallback.html":{},"interfaces/RefreshAccessTokenResponse.html":{},"interfaces/RefreshOptions.html":{},"interfaces/RequestMetadataCallback.html":{},"interfaces/RequestMetadataResponse.html":{},"interfaces/RevokeCredentialsResult.html":{},"interfaces/TokenInfo.html":{},"interfaces/TokenInfoRequest.html":{},"interfaces/UserRefreshClientOptions.html":{},"interfaces/VerifyIdTokenOptions.html":{}}}],["refreshtokenpromis",{"_index":908,"title":{},"body":{"interfaces/FederatedSignonCertsResponse.html":{},"interfaces/GetAccessTokenCallback.html":{},"interfaces/GetAccessTokenResponse.html":{},"interfaces/GetFederatedSignonCertsCallback.html":{},"interfaces/GetTokenCallback.html":{},"interfaces/GetTokenOptions.html":{},"interfaces/GetTokenResponse.html":{},"interfaces/OAuth2ClientOptions.html":{},"interfaces/RefreshAccessTokenCallback.html":{},"interfaces/RefreshAccessTokenResponse.html":{},"interfaces/RefreshOptions.html":{},"interfaces/RequestMetadataCallback.html":{},"interfaces/RequestMetadataResponse.html":{},"interfaces/RevokeCredentialsResult.html":{},"interfaces/TokenInfo.html":{},"interfaces/TokenInfoRequest.html":{},"interfaces/VerifyIdTokenOptions.html":{}}}],["regard",{"_index":1943,"title":{},"body":{"license.html":{}}}],["regardless",{"_index":722,"title":{},"body":{"interfaces/FederatedSignonCertsResponse.html":{},"interfaces/GetAccessTokenCallback.html":{},"interfaces/GetAccessTokenResponse.html":{},"interfaces/GetFederatedSignonCertsCallback.html":{},"interfaces/GetTokenCallback.html":{},"interfaces/GetTokenOptions.html":{},"interfaces/GetTokenResponse.html":{},"interfaces/OAuth2ClientOptions.html":{},"interfaces/RefreshAccessTokenCallback.html":{},"interfaces/RefreshAccessTokenResponse.html":{},"interfaces/RefreshOptions.html":{},"interfaces/RequestMetadataCallback.html":{},"interfaces/RequestMetadataResponse.html":{},"interfaces/RevokeCredentialsResult.html":{},"interfaces/TokenInfo.html":{},"interfaces/TokenInfoRequest.html":{},"interfaces/VerifyIdTokenOptions.html":{}}}],["reject",{"_index":178,"title":{},"body":{"interfaces/ADCCallback.html":{},"interfaces/ADCResponse.html":{},"interfaces/CredentialCallback.html":{},"interfaces/GoogleAuthOptions.html":{},"classes/JWTAccess.html":{},"interfaces/JWTOptions.html":{},"interfaces/ProjectIdCallback.html":{},"interfaces/SignBlobResponse.html":{},"interfaces/UserRefreshClientOptions.html":{},"changelog.html":{},"index.html":{}}}],["reject(",{"_index":188,"title":{},"body":{"interfaces/ADCCallback.html":{},"interfaces/ADCResponse.html":{},"interfaces/CredentialCallback.html":{},"interfaces/GoogleAuthOptions.html":{},"interfaces/JWTOptions.html":{},"interfaces/ProjectIdCallback.html":{},"interfaces/SignBlobResponse.html":{}}}],["reject(err",{"_index":354,"title":{},"body":{"interfaces/ADCCallback.html":{},"interfaces/ADCResponse.html":{},"interfaces/CredentialCallback.html":{},"interfaces/GoogleAuthOptions.html":{},"classes/JWTAccess.html":{},"interfaces/ProjectIdCallback.html":{},"interfaces/SignBlobResponse.html":{},"interfaces/UserRefreshClientOptions.html":{}}}],["reject(new",{"_index":1280,"title":{},"body":{"classes/JWTAccess.html":{},"interfaces/UserRefreshClientOptions.html":{}}}],["relat",{"_index":1808,"title":{},"body":{"index.html":{}}}],["relationship",{"_index":798,"title":{},"body":{"interfaces/FederatedSignonCertsResponse.html":{},"interfaces/GetAccessTokenCallback.html":{},"interfaces/GetAccessTokenResponse.html":{},"interfaces/GetFederatedSignonCertsCallback.html":{},"interfaces/GetTokenCallback.html":{},"interfaces/GetTokenOptions.html":{},"interfaces/GetTokenResponse.html":{},"interfaces/OAuth2ClientOptions.html":{},"interfaces/RefreshAccessTokenCallback.html":{},"interfaces/RefreshAccessTokenResponse.html":{},"interfaces/RefreshOptions.html":{},"interfaces/RequestMetadataCallback.html":{},"interfaces/RequestMetadataResponse.html":{},"interfaces/RevokeCredentialsResult.html":{},"interfaces/TokenInfo.html":{},"interfaces/TokenInfoRequest.html":{},"interfaces/VerifyIdTokenOptions.html":{}}}],["releas",{"_index":1134,"title":{},"body":{"interfaces/FederatedSignonCertsResponse.html":{},"interfaces/GetAccessTokenCallback.html":{},"interfaces/GetAccessTokenResponse.html":{},"interfaces/GetFederatedSignonCertsCallback.html":{},"interfaces/GetTokenCallback.html":{},"interfaces/GetTokenOptions.html":{},"interfaces/GetTokenResponse.html":{},"interfaces/OAuth2ClientOptions.html":{},"interfaces/RefreshAccessTokenCallback.html":{},"interfaces/RefreshAccessTokenResponse.html":{},"interfaces/RefreshOptions.html":{},"interfaces/RequestMetadataCallback.html":{},"interfaces/RequestMetadataResponse.html":{},"interfaces/RevokeCredentialsResult.html":{},"interfaces/TokenInfo.html":{},"interfaces/TokenInfoRequest.html":{},"interfaces/UserRefreshClientOptions.html":{},"interfaces/VerifyIdTokenOptions.html":{},"interfaces/Warning.html":{},"changelog.html":{},"index.html":{},"miscellaneous/variables.html":{}}}],["relev",{"_index":1274,"title":{},"body":{"classes/JWTAccess.html":{},"interfaces/JWTOptions.html":{}}}],["reli",{"_index":772,"title":{},"body":{"interfaces/FederatedSignonCertsResponse.html":{},"interfaces/GetAccessTokenCallback.html":{},"interfaces/GetAccessTokenResponse.html":{},"interfaces/GetFederatedSignonCertsCallback.html":{},"interfaces/GetTokenCallback.html":{},"interfaces/GetTokenOptions.html":{},"interfaces/GetTokenResponse.html":{},"interfaces/OAuth2ClientOptions.html":{},"interfaces/RefreshAccessTokenCallback.html":{},"interfaces/RefreshAccessTokenResponse.html":{},"interfaces/RefreshOptions.html":{},"interfaces/RequestMetadataCallback.html":{},"interfaces/RequestMetadataResponse.html":{},"interfaces/RevokeCredentialsResult.html":{},"interfaces/TokenInfo.html":{},"interfaces/TokenInfoRequest.html":{},"interfaces/VerifyIdTokenOptions.html":{}}}],["remain",{"_index":1861,"title":{},"body":{"license.html":{}}}],["remov",{"_index":131,"title":{},"body":{"interfaces/ADCCallback.html":{},"interfaces/ADCResponse.html":{},"interfaces/CredentialCallback.html":{},"interfaces/FederatedSignonCertsResponse.html":{},"interfaces/GetAccessTokenCallback.html":{},"interfaces/GetAccessTokenResponse.html":{},"interfaces/GetFederatedSignonCertsCallback.html":{},"interfaces/GetTokenCallback.html":{},"interfaces/GetTokenOptions.html":{},"interfaces/GetTokenResponse.html":{},"interfaces/GoogleAuthOptions.html":{},"interfaces/OAuth2ClientOptions.html":{},"interfaces/ProjectIdCallback.html":{},"interfaces/RefreshAccessTokenCallback.html":{},"interfaces/RefreshAccessTokenResponse.html":{},"interfaces/RefreshOptions.html":{},"interfaces/RequestMetadataCallback.html":{},"interfaces/RequestMetadataResponse.html":{},"interfaces/RevokeCredentialsResult.html":{},"interfaces/SignBlobResponse.html":{},"interfaces/TokenInfo.html":{},"interfaces/TokenInfoRequest.html":{},"interfaces/VerifyIdTokenOptions.html":{},"interfaces/Warning.html":{},"changelog.html":{},"miscellaneous/variables.html":{}}}],["renov",{"_index":1605,"title":{},"body":{"changelog.html":{}}}],["replac",{"_index":1482,"title":{},"body":{"changelog.html":{},"license.html":{}}}],["replace(/=/g",{"_index":992,"title":{},"body":{"interfaces/FederatedSignonCertsResponse.html":{},"interfaces/GetAccessTokenCallback.html":{},"interfaces/GetAccessTokenResponse.html":{},"interfaces/GetFederatedSignonCertsCallback.html":{},"interfaces/GetTokenCallback.html":{},"interfaces/GetTokenOptions.html":{},"interfaces/GetTokenResponse.html":{},"interfaces/OAuth2ClientOptions.html":{},"interfaces/RefreshAccessTokenCallback.html":{},"interfaces/RefreshAccessTokenResponse.html":{},"interfaces/RefreshOptions.html":{},"interfaces/RequestMetadataCallback.html":{},"interfaces/RequestMetadataResponse.html":{},"interfaces/RevokeCredentialsResult.html":{},"interfaces/TokenInfo.html":{},"interfaces/TokenInfoRequest.html":{},"interfaces/VerifyIdTokenOptions.html":{}}}],["replace(/\\+/g",{"_index":1000,"title":{},"body":{"interfaces/FederatedSignonCertsResponse.html":{},"interfaces/GetAccessTokenCallback.html":{},"interfaces/GetAccessTokenResponse.html":{},"interfaces/GetFederatedSignonCertsCallback.html":{},"interfaces/GetTokenCallback.html":{},"interfaces/GetTokenOptions.html":{},"interfaces/GetTokenResponse.html":{},"interfaces/OAuth2ClientOptions.html":{},"interfaces/RefreshAccessTokenCallback.html":{},"interfaces/RefreshAccessTokenResponse.html":{},"interfaces/RefreshOptions.html":{},"interfaces/RequestMetadataCallback.html":{},"interfaces/RequestMetadataResponse.html":{},"interfaces/RevokeCredentialsResult.html":{},"interfaces/TokenInfo.html":{},"interfaces/TokenInfoRequest.html":{},"interfaces/VerifyIdTokenOptions.html":{}}}],["replace(/\\//g",{"_index":1001,"title":{},"body":{"interfaces/FederatedSignonCertsResponse.html":{},"interfaces/GetAccessTokenCallback.html":{},"interfaces/GetAccessTokenResponse.html":{},"interfaces/GetFederatedSignonCertsCallback.html":{},"interfaces/GetTokenCallback.html":{},"interfaces/GetTokenOptions.html":{},"interfaces/GetTokenResponse.html":{},"interfaces/OAuth2ClientOptions.html":{},"interfaces/RefreshAccessTokenCallback.html":{},"interfaces/RefreshAccessTokenResponse.html":{},"interfaces/RefreshOptions.html":{},"interfaces/RequestMetadataCallback.html":{},"interfaces/RequestMetadataResponse.html":{},"interfaces/RevokeCredentialsResult.html":{},"interfaces/TokenInfo.html":{},"interfaces/TokenInfoRequest.html":{},"interfaces/VerifyIdTokenOptions.html":{}}}],["replay",{"_index":1097,"title":{},"body":{"interfaces/FederatedSignonCertsResponse.html":{},"interfaces/GetAccessTokenCallback.html":{},"interfaces/GetAccessTokenResponse.html":{},"interfaces/GetFederatedSignonCertsCallback.html":{},"interfaces/GetTokenCallback.html":{},"interfaces/GetTokenOptions.html":{},"interfaces/GetTokenResponse.html":{},"classes/LoginTicket.html":{},"interfaces/OAuth2ClientOptions.html":{},"interfaces/RefreshAccessTokenCallback.html":{},"interfaces/RefreshAccessTokenResponse.html":{},"interfaces/RefreshOptions.html":{},"interfaces/RequestMetadataCallback.html":{},"interfaces/RequestMetadataResponse.html":{},"interfaces/RevokeCredentialsResult.html":{},"interfaces/TokenInfo.html":{},"interfaces/TokenInfoRequest.html":{},"interfaces/TokenPayload.html":{},"interfaces/VerifyIdTokenOptions.html":{}}}],["repres",{"_index":1381,"title":{},"body":{"classes/LoginTicket.html":{},"interfaces/TokenPayload.html":{},"license.html":{}}}],["reproduc",{"_index":1890,"title":{},"body":{"license.html":{}}}],["reproduct",{"_index":1821,"title":{},"body":{"license.html":{}}}],["req",{"_index":1736,"title":{},"body":{"index.html":{}}}],["req.url.indexof('/oauth2callback",{"_index":1737,"title":{},"body":{"index.html":{}}}],["request",{"_index":76,"title":{},"body":{"interfaces/ADCCallback.html":{},"interfaces/ADCResponse.html":{},"interfaces/BodyResponseCallback.html":{},"interfaces/CredentialCallback.html":{},"classes/DefaultTransporter.html":{},"interfaces/FederatedSignonCertsResponse.html":{},"interfaces/GetAccessTokenCallback.html":{},"interfaces/GetAccessTokenResponse.html":{},"interfaces/GetFederatedSignonCertsCallback.html":{},"interfaces/GetTokenCallback.html":{},"interfaces/GetTokenOptions.html":{},"interfaces/GetTokenResponse.html":{},"interfaces/GoogleAuthOptions.html":{},"classes/IAMAuth.html":{},"interfaces/JWTOptions.html":{},"classes/LoginTicket.html":{},"interfaces/OAuth2ClientOptions.html":{},"interfaces/ProjectIdCallback.html":{},"interfaces/RefreshAccessTokenCallback.html":{},"interfaces/RefreshAccessTokenResponse.html":{},"interfaces/RefreshOptions.html":{},"interfaces/RequestError.html":{},"interfaces/RequestMetadata.html":{},"interfaces/RequestMetadataCallback.html":{},"interfaces/RequestMetadataResponse.html":{},"interfaces/RevokeCredentialsResult.html":{},"interfaces/SignBlobResponse.html":{},"interfaces/TokenInfo.html":{},"interfaces/TokenInfoRequest.html":{},"interfaces/TokenPayload.html":{},"interfaces/Transporter.html":{},"interfaces/VerifyIdTokenOptions.html":{},"changelog.html":{},"index.html":{}}}],["request(opt",{"_index":469,"title":{},"body":{"interfaces/ADCCallback.html":{},"interfaces/ADCResponse.html":{},"interfaces/BodyResponseCallback.html":{},"interfaces/CredentialCallback.html":{},"classes/DefaultTransporter.html":{},"interfaces/FederatedSignonCertsResponse.html":{},"interfaces/GetAccessTokenCallback.html":{},"interfaces/GetAccessTokenResponse.html":{},"interfaces/GetFederatedSignonCertsCallback.html":{},"interfaces/GetTokenCallback.html":{},"interfaces/GetTokenOptions.html":{},"interfaces/GetTokenResponse.html":{},"interfaces/GoogleAuthOptions.html":{},"interfaces/OAuth2ClientOptions.html":{},"interfaces/ProjectIdCallback.html":{},"interfaces/RefreshAccessTokenCallback.html":{},"interfaces/RefreshAccessTokenResponse.html":{},"interfaces/RefreshOptions.html":{},"interfaces/RequestError.html":{},"interfaces/RequestMetadataCallback.html":{},"interfaces/RequestMetadataResponse.html":{},"interfaces/RevokeCredentialsResult.html":{},"interfaces/SignBlobResponse.html":{},"interfaces/TokenInfo.html":{},"interfaces/TokenInfoRequest.html":{},"interfaces/Transporter.html":{},"interfaces/VerifyIdTokenOptions.html":{}}}],["requestasync(opt",{"_index":623,"title":{},"body":{"interfaces/ComputeOptions.html":{},"interfaces/FederatedSignonCertsResponse.html":{},"interfaces/GetAccessTokenCallback.html":{},"interfaces/GetAccessTokenResponse.html":{},"interfaces/GetFederatedSignonCertsCallback.html":{},"interfaces/GetTokenCallback.html":{},"interfaces/GetTokenOptions.html":{},"interfaces/GetTokenResponse.html":{},"interfaces/OAuth2ClientOptions.html":{},"interfaces/RefreshAccessTokenCallback.html":{},"interfaces/RefreshAccessTokenResponse.html":{},"interfaces/RefreshOptions.html":{},"interfaces/RequestMetadataCallback.html":{},"interfaces/RequestMetadataResponse.html":{},"interfaces/RevokeCredentialsResult.html":{},"interfaces/TokenInfo.html":{},"interfaces/TokenInfoRequest.html":{},"interfaces/VerifyIdTokenOptions.html":{}}}],["requesterror",{"_index":516,"title":{"interfaces/RequestError.html":{}},"body":{"interfaces/BodyResponseCallback.html":{},"classes/DefaultTransporter.html":{},"interfaces/RequestError.html":{},"interfaces/Transporter.html":{}}}],["requestmetadata",{"_index":1205,"title":{"interfaces/RequestMetadata.html":{}},"body":{"classes/IAMAuth.html":{},"interfaces/RequestMetadata.html":{}}}],["requestmetadatacallback",{"_index":886,"title":{"interfaces/RequestMetadataCallback.html":{}},"body":{"interfaces/FederatedSignonCertsResponse.html":{},"interfaces/GetAccessTokenCallback.html":{},"interfaces/GetAccessTokenResponse.html":{},"interfaces/GetFederatedSignonCertsCallback.html":{},"interfaces/GetTokenCallback.html":{},"interfaces/GetTokenOptions.html":{},"interfaces/GetTokenResponse.html":{},"interfaces/OAuth2ClientOptions.html":{},"interfaces/RefreshAccessTokenCallback.html":{},"interfaces/RefreshAccessTokenResponse.html":{},"interfaces/RefreshOptions.html":{},"interfaces/RequestMetadataCallback.html":{},"interfaces/RequestMetadataResponse.html":{},"interfaces/RevokeCredentialsResult.html":{},"interfaces/TokenInfo.html":{},"interfaces/TokenInfoRequest.html":{},"interfaces/VerifyIdTokenOptions.html":{}}}],["requestmetadatarespons",{"_index":885,"title":{"interfaces/RequestMetadataResponse.html":{}},"body":{"interfaces/FederatedSignonCertsResponse.html":{},"interfaces/GetAccessTokenCallback.html":{},"interfaces/GetAccessTokenResponse.html":{},"interfaces/GetFederatedSignonCertsCallback.html":{},"interfaces/GetTokenCallback.html":{},"interfaces/GetTokenOptions.html":{},"interfaces/GetTokenResponse.html":{},"classes/JWTAccess.html":{},"interfaces/JWTOptions.html":{},"interfaces/OAuth2ClientOptions.html":{},"interfaces/RefreshAccessTokenCallback.html":{},"interfaces/RefreshAccessTokenResponse.html":{},"interfaces/RefreshOptions.html":{},"interfaces/RequestMetadataCallback.html":{},"interfaces/RequestMetadataResponse.html":{},"interfaces/RevokeCredentialsResult.html":{},"interfaces/TokenInfo.html":{},"interfaces/TokenInfoRequest.html":{},"interfaces/VerifyIdTokenOptions.html":{}}}],["requestretriev",{"_index":1760,"title":{},"body":{"index.html":{}}}],["requir",{"_index":72,"title":{},"body":{"interfaces/ADCCallback.html":{},"interfaces/ADCResponse.html":{},"interfaces/BodyResponseCallback.html":{},"interfaces/ComputeOptions.html":{},"interfaces/CredentialCallback.html":{},"interfaces/Credentials.html":{},"classes/DefaultTransporter.html":{},"interfaces/FederatedSignonCertsResponse.html":{},"interfaces/GetAccessTokenCallback.html":{},"interfaces/GetAccessTokenResponse.html":{},"interfaces/GetFederatedSignonCertsCallback.html":{},"interfaces/GetTokenCallback.html":{},"interfaces/GetTokenOptions.html":{},"interfaces/GetTokenResponse.html":{},"interfaces/GoogleAuthOptions.html":{},"classes/IAMAuth.html":{},"classes/JWTAccess.html":{},"interfaces/JWTOptions.html":{},"classes/LoginTicket.html":{},"interfaces/OAuth2ClientOptions.html":{},"interfaces/ProjectIdCallback.html":{},"interfaces/RefreshAccessTokenCallback.html":{},"interfaces/RefreshAccessTokenResponse.html":{},"interfaces/RefreshOptions.html":{},"interfaces/RequestError.html":{},"interfaces/RequestMetadata.html":{},"interfaces/RequestMetadataCallback.html":{},"interfaces/RequestMetadataResponse.html":{},"interfaces/RevokeCredentialsResult.html":{},"interfaces/SignBlobResponse.html":{},"interfaces/TokenInfo.html":{},"interfaces/TokenInfoRequest.html":{},"interfaces/Transporter.html":{},"interfaces/VerifyIdTokenOptions.html":{},"changelog.html":{},"miscellaneous/functions.html":{},"license.html":{}}}],["require('../../package.json",{"_index":508,"title":{},"body":{"interfaces/BodyResponseCallback.html":{},"classes/DefaultTransporter.html":{},"interfaces/RequestError.html":{},"interfaces/Transporter.html":{},"miscellaneous/variables.html":{}}}],["require('./jwt.keys.json",{"_index":1780,"title":{},"body":{"index.html":{}}}],["require('./keys.json",{"_index":1712,"title":{},"body":{"index.html":{}}}],["require('axios/lib/adapters/http",{"_index":531,"title":{},"body":{"interfaces/BodyResponseCallback.html":{},"classes/DefaultTransporter.html":{},"interfaces/RequestError.html":{},"interfaces/Transporter.html":{}}}],["require('googl",{"_index":1691,"title":{},"body":{"index.html":{}}}],["require('http",{"_index":503,"title":{},"body":{"interfaces/BodyResponseCallback.html":{},"classes/DefaultTransporter.html":{},"interfaces/RequestError.html":{},"interfaces/Transporter.html":{},"index.html":{},"miscellaneous/variables.html":{}}}],["require('opn",{"_index":1711,"title":{},"body":{"index.html":{}}}],["require('querystr",{"_index":1709,"title":{},"body":{"index.html":{}}}],["require('url",{"_index":1708,"title":{},"body":{"index.html":{}}}],["requiredaudi",{"_index":1175,"title":{},"body":{"interfaces/FederatedSignonCertsResponse.html":{},"interfaces/GetAccessTokenCallback.html":{},"interfaces/GetAccessTokenResponse.html":{},"interfaces/GetFederatedSignonCertsCallback.html":{},"interfaces/GetTokenCallback.html":{},"interfaces/GetTokenOptions.html":{},"interfaces/GetTokenResponse.html":{},"interfaces/OAuth2ClientOptions.html":{},"interfaces/RefreshAccessTokenCallback.html":{},"interfaces/RefreshAccessTokenResponse.html":{},"interfaces/RefreshOptions.html":{},"interfaces/RequestMetadataCallback.html":{},"interfaces/RequestMetadataResponse.html":{},"interfaces/RevokeCredentialsResult.html":{},"interfaces/TokenInfo.html":{},"interfaces/TokenInfoRequest.html":{},"interfaces/VerifyIdTokenOptions.html":{}}}],["res.config.data",{"_index":1122,"title":{},"body":{"interfaces/FederatedSignonCertsResponse.html":{},"interfaces/GetAccessTokenCallback.html":{},"interfaces/GetAccessTokenResponse.html":{},"interfaces/GetFederatedSignonCertsCallback.html":{},"interfaces/GetTokenCallback.html":{},"interfaces/GetTokenOptions.html":{},"interfaces/GetTokenResponse.html":{},"interfaces/OAuth2ClientOptions.html":{},"interfaces/RefreshAccessTokenCallback.html":{},"interfaces/RefreshAccessTokenResponse.html":{},"interfaces/RefreshOptions.html":{},"interfaces/RequestMetadataCallback.html":{},"interfaces/RequestMetadataResponse.html":{},"interfaces/RevokeCredentialsResult.html":{},"interfaces/TokenInfo.html":{},"interfaces/TokenInfoRequest.html":{},"interfaces/VerifyIdTokenOptions.html":{}}}],["res.data",{"_index":560,"title":{},"body":{"interfaces/BodyResponseCallback.html":{},"interfaces/ComputeOptions.html":{},"classes/DefaultTransporter.html":{},"interfaces/FederatedSignonCertsResponse.html":{},"interfaces/GetAccessTokenCallback.html":{},"interfaces/GetAccessTokenResponse.html":{},"interfaces/GetFederatedSignonCertsCallback.html":{},"interfaces/GetTokenCallback.html":{},"interfaces/GetTokenOptions.html":{},"interfaces/GetTokenResponse.html":{},"interfaces/OAuth2ClientOptions.html":{},"interfaces/RefreshAccessTokenCallback.html":{},"interfaces/RefreshAccessTokenResponse.html":{},"interfaces/RefreshOptions.html":{},"interfaces/RequestError.html":{},"interfaces/RequestMetadataCallback.html":{},"interfaces/RequestMetadataResponse.html":{},"interfaces/RevokeCredentialsResult.html":{},"interfaces/TokenInfo.html":{},"interfaces/TokenInfoRequest.html":{},"interfaces/Transporter.html":{},"interfaces/VerifyIdTokenOptions.html":{}}}],["res.data.expires_in",{"_index":616,"title":{},"body":{"interfaces/ComputeOptions.html":{},"interfaces/FederatedSignonCertsResponse.html":{},"interfaces/GetAccessTokenCallback.html":{},"interfaces/GetAccessTokenResponse.html":{},"interfaces/GetFederatedSignonCertsCallback.html":{},"interfaces/GetTokenCallback.html":{},"interfaces/GetTokenOptions.html":{},"interfaces/GetTokenResponse.html":{},"interfaces/OAuth2ClientOptions.html":{},"interfaces/RefreshAccessTokenCallback.html":{},"interfaces/RefreshAccessTokenResponse.html":{},"interfaces/RefreshOptions.html":{},"interfaces/RequestMetadataCallback.html":{},"interfaces/RequestMetadataResponse.html":{},"interfaces/RevokeCredentialsResult.html":{},"interfaces/TokenInfo.html":{},"interfaces/TokenInfoRequest.html":{},"interfaces/VerifyIdTokenOptions.html":{}}}],["res.data.signatur",{"_index":493,"title":{},"body":{"interfaces/ADCCallback.html":{},"interfaces/ADCResponse.html":{},"interfaces/CredentialCallback.html":{},"interfaces/GoogleAuthOptions.html":{},"interfaces/ProjectIdCallback.html":{},"interfaces/SignBlobResponse.html":{}}}],["res.end('authent",{"_index":1742,"title":{},"body":{"index.html":{}}}],["res.head",{"_index":1068,"title":{},"body":{"interfaces/FederatedSignonCertsResponse.html":{},"interfaces/GetAccessTokenCallback.html":{},"interfaces/GetAccessTokenResponse.html":{},"interfaces/GetFederatedSignonCertsCallback.html":{},"interfaces/GetTokenCallback.html":{},"interfaces/GetTokenOptions.html":{},"interfaces/GetTokenResponse.html":{},"interfaces/OAuth2ClientOptions.html":{},"interfaces/RefreshAccessTokenCallback.html":{},"interfaces/RefreshAccessTokenResponse.html":{},"interfaces/RefreshOptions.html":{},"interfaces/RequestMetadataCallback.html":{},"interfaces/RequestMetadataResponse.html":{},"interfaces/RevokeCredentialsResult.html":{},"interfaces/TokenInfo.html":{},"interfaces/TokenInfoRequest.html":{},"interfaces/VerifyIdTokenOptions.html":{}}}],["res.headers;new",{"_index":1543,"title":{},"body":{"changelog.html":{}}}],["res.statu",{"_index":562,"title":{},"body":{"interfaces/BodyResponseCallback.html":{},"interfaces/ComputeOptions.html":{},"classes/DefaultTransporter.html":{},"interfaces/FederatedSignonCertsResponse.html":{},"interfaces/GetAccessTokenCallback.html":{},"interfaces/GetAccessTokenResponse.html":{},"interfaces/GetFederatedSignonCertsCallback.html":{},"interfaces/GetTokenCallback.html":{},"interfaces/GetTokenOptions.html":{},"interfaces/GetTokenResponse.html":{},"interfaces/OAuth2ClientOptions.html":{},"interfaces/RefreshAccessTokenCallback.html":{},"interfaces/RefreshAccessTokenResponse.html":{},"interfaces/RefreshOptions.html":{},"interfaces/RequestError.html":{},"interfaces/RequestMetadataCallback.html":{},"interfaces/RequestMetadataResponse.html":{},"interfaces/RevokeCredentialsResult.html":{},"interfaces/TokenInfo.html":{},"interfaces/TokenInfoRequest.html":{},"interfaces/Transporter.html":{},"interfaces/VerifyIdTokenOptions.html":{}}}],["res.status.tostr",{"_index":566,"title":{},"body":{"interfaces/BodyResponseCallback.html":{},"interfaces/ComputeOptions.html":{},"classes/DefaultTransporter.html":{},"interfaces/RequestError.html":{},"interfaces/Transporter.html":{}}}],["reserv",{"_index":653,"title":{},"body":{"interfaces/Credentials.html":{},"classes/LoginTicket.html":{},"miscellaneous/functions.html":{}}}],["resolv",{"_index":151,"title":{},"body":{"interfaces/ADCCallback.html":{},"interfaces/ADCResponse.html":{},"interfaces/CredentialCallback.html":{},"interfaces/FederatedSignonCertsResponse.html":{},"interfaces/GetAccessTokenCallback.html":{},"interfaces/GetAccessTokenResponse.html":{},"interfaces/GetFederatedSignonCertsCallback.html":{},"interfaces/GetTokenCallback.html":{},"interfaces/GetTokenOptions.html":{},"interfaces/GetTokenResponse.html":{},"interfaces/GoogleAuthOptions.html":{},"classes/JWTAccess.html":{},"interfaces/JWTOptions.html":{},"interfaces/OAuth2ClientOptions.html":{},"interfaces/ProjectIdCallback.html":{},"interfaces/RefreshAccessTokenCallback.html":{},"interfaces/RefreshAccessTokenResponse.html":{},"interfaces/RefreshOptions.html":{},"interfaces/RequestMetadataCallback.html":{},"interfaces/RequestMetadataResponse.html":{},"interfaces/RevokeCredentialsResult.html":{},"interfaces/SignBlobResponse.html":{},"interfaces/TokenInfo.html":{},"interfaces/TokenInfoRequest.html":{},"interfaces/UserRefreshClientOptions.html":{},"interfaces/VerifyIdTokenOptions.html":{}}}],["resolve(nul",{"_index":403,"title":{},"body":{"interfaces/ADCCallback.html":{},"interfaces/ADCResponse.html":{},"interfaces/CredentialCallback.html":{},"interfaces/GoogleAuthOptions.html":{},"interfaces/ProjectIdCallback.html":{},"interfaces/SignBlobResponse.html":{}}}],["resolve(oauth2cli",{"_index":1747,"title":{},"body":{"index.html":{}}}],["resolve(projectid",{"_index":185,"title":{},"body":{"interfaces/ADCCallback.html":{},"interfaces/ADCResponse.html":{},"interfaces/CredentialCallback.html":{},"interfaces/GoogleAuthOptions.html":{},"interfaces/ProjectIdCallback.html":{},"interfaces/SignBlobResponse.html":{}}}],["resolve(r",{"_index":353,"title":{},"body":{"interfaces/ADCCallback.html":{},"interfaces/ADCResponse.html":{},"interfaces/CredentialCallback.html":{},"interfaces/GoogleAuthOptions.html":{},"interfaces/ProjectIdCallback.html":{},"interfaces/SignBlobResponse.html":{}}}],["resourc",{"_index":789,"title":{},"body":{"interfaces/FederatedSignonCertsResponse.html":{},"interfaces/GetAccessTokenCallback.html":{},"interfaces/GetAccessTokenResponse.html":{},"interfaces/GetFederatedSignonCertsCallback.html":{},"interfaces/GetTokenCallback.html":{},"interfaces/GetTokenOptions.html":{},"interfaces/GetTokenResponse.html":{},"interfaces/OAuth2ClientOptions.html":{},"interfaces/RefreshAccessTokenCallback.html":{},"interfaces/RefreshAccessTokenResponse.html":{},"interfaces/RefreshOptions.html":{},"interfaces/RequestMetadataCallback.html":{},"interfaces/RequestMetadataResponse.html":{},"interfaces/RevokeCredentialsResult.html":{},"interfaces/TokenInfo.html":{},"interfaces/TokenInfoRequest.html":{},"interfaces/VerifyIdTokenOptions.html":{}}}],["respect",{"_index":429,"title":{},"body":{"interfaces/ADCCallback.html":{},"interfaces/ADCResponse.html":{},"interfaces/CredentialCallback.html":{},"interfaces/GoogleAuthOptions.html":{},"interfaces/ProjectIdCallback.html":{},"interfaces/SignBlobResponse.html":{}}}],["respons",{"_index":578,"title":{},"body":{"interfaces/BodyResponseCallback.html":{},"classes/DefaultTransporter.html":{},"interfaces/FederatedSignonCertsResponse.html":{},"interfaces/GetAccessTokenCallback.html":{},"interfaces/GetAccessTokenResponse.html":{},"interfaces/GetFederatedSignonCertsCallback.html":{},"interfaces/GetTokenCallback.html":{},"interfaces/GetTokenOptions.html":{},"interfaces/GetTokenResponse.html":{},"classes/LoginTicket.html":{},"interfaces/OAuth2ClientOptions.html":{},"interfaces/RefreshAccessTokenCallback.html":{},"interfaces/RefreshAccessTokenResponse.html":{},"interfaces/RefreshOptions.html":{},"interfaces/RequestError.html":{},"interfaces/RequestMetadataCallback.html":{},"interfaces/RequestMetadataResponse.html":{},"interfaces/RevokeCredentialsResult.html":{},"interfaces/TokenInfo.html":{},"interfaces/TokenInfoRequest.html":{},"interfaces/TokenPayload.html":{},"interfaces/Transporter.html":{},"interfaces/VerifyIdTokenOptions.html":{},"license.html":{}}}],["response.cert",{"_index":1141,"title":{},"body":{"interfaces/FederatedSignonCertsResponse.html":{},"interfaces/GetAccessTokenCallback.html":{},"interfaces/GetAccessTokenResponse.html":{},"interfaces/GetFederatedSignonCertsCallback.html":{},"interfaces/GetTokenCallback.html":{},"interfaces/GetTokenOptions.html":{},"interfaces/GetTokenResponse.html":{},"interfaces/OAuth2ClientOptions.html":{},"interfaces/RefreshAccessTokenCallback.html":{},"interfaces/RefreshAccessTokenResponse.html":{},"interfaces/RefreshOptions.html":{},"interfaces/RequestMetadataCallback.html":{},"interfaces/RequestMetadataResponse.html":{},"interfaces/RevokeCredentialsResult.html":{},"interfaces/TokenInfo.html":{},"interfaces/TokenInfoRequest.html":{},"interfaces/VerifyIdTokenOptions.html":{}}}],["response_typ",{"_index":781,"title":{},"body":{"interfaces/FederatedSignonCertsResponse.html":{},"interfaces/GetAccessTokenCallback.html":{},"interfaces/GetAccessTokenResponse.html":{},"interfaces/GetFederatedSignonCertsCallback.html":{},"interfaces/GetTokenCallback.html":{},"interfaces/GetTokenOptions.html":{},"interfaces/GetTokenResponse.html":{},"interfaces/OAuth2ClientOptions.html":{},"interfaces/RefreshAccessTokenCallback.html":{},"interfaces/RefreshAccessTokenResponse.html":{},"interfaces/RefreshOptions.html":{},"interfaces/RequestMetadataCallback.html":{},"interfaces/RequestMetadataResponse.html":{},"interfaces/RevokeCredentialsResult.html":{},"interfaces/TokenInfo.html":{},"interfaces/TokenInfoRequest.html":{},"interfaces/VerifyIdTokenOptions.html":{}}}],["rest",{"_index":247,"title":{},"body":{"interfaces/ADCCallback.html":{},"interfaces/ADCResponse.html":{},"interfaces/CredentialCallback.html":{},"interfaces/GoogleAuthOptions.html":{},"interfaces/ProjectIdCallback.html":{},"interfaces/SignBlobResponse.html":{}}}],["restrict",{"_index":1777,"title":{},"body":{"index.html":{}}}],["result",{"_index":58,"title":{},"body":{"interfaces/ADCCallback.html":{},"interfaces/ADCResponse.html":{},"interfaces/BodyResponseCallback.html":{},"interfaces/ComputeOptions.html":{},"interfaces/CredentialBody.html":{},"interfaces/CredentialCallback.html":{},"interfaces/CredentialRequest.html":{},"interfaces/Credentials.html":{},"classes/DefaultTransporter.html":{},"interfaces/FederatedSignonCertsResponse.html":{},"interfaces/GetAccessTokenCallback.html":{},"interfaces/GetAccessTokenResponse.html":{},"interfaces/GetFederatedSignonCertsCallback.html":{},"interfaces/GetTokenCallback.html":{},"interfaces/GetTokenOptions.html":{},"interfaces/GetTokenResponse.html":{},"interfaces/GoogleAuthOptions.html":{},"classes/IAMAuth.html":{},"classes/JWTAccess.html":{},"interfaces/JWTInput.html":{},"interfaces/JWTOptions.html":{},"classes/LoginTicket.html":{},"interfaces/OAuth2ClientOptions.html":{},"classes/PemVerifier.html":{},"interfaces/ProjectIdCallback.html":{},"interfaces/RefreshAccessTokenCallback.html":{},"interfaces/RefreshAccessTokenResponse.html":{},"interfaces/RefreshOptions.html":{},"interfaces/RequestError.html":{},"interfaces/RequestMetadata.html":{},"interfaces/RequestMetadataCallback.html":{},"interfaces/RequestMetadataResponse.html":{},"interfaces/RevokeCredentialsResult.html":{},"interfaces/SignBlobResponse.html":{},"interfaces/TokenInfo.html":{},"interfaces/TokenInfoRequest.html":{},"interfaces/TokenPayload.html":{},"interfaces/Transporter.html":{},"interfaces/UserRefreshClientOptions.html":{},"interfaces/VerifyIdTokenOptions.html":{},"interfaces/Warning.html":{},"changelog.html":{},"dependencies.html":{},"miscellaneous/enumerations.html":{},"miscellaneous/functions.html":{},"index.html":{},"license.html":{},"modules.html":{},"overview.html":{},"miscellaneous/typealiases.html":{},"miscellaneous/variables.html":{}}}],["result.token",{"_index":1325,"title":{},"body":{"interfaces/JWTOptions.html":{}}}],["retain",{"_index":1920,"title":{},"body":{"license.html":{}}}],["retri",{"_index":624,"title":{},"body":{"interfaces/ComputeOptions.html":{},"interfaces/FederatedSignonCertsResponse.html":{},"interfaces/GetAccessTokenCallback.html":{},"interfaces/GetAccessTokenResponse.html":{},"interfaces/GetFederatedSignonCertsCallback.html":{},"interfaces/GetTokenCallback.html":{},"interfaces/GetTokenOptions.html":{},"interfaces/GetTokenResponse.html":{},"interfaces/OAuth2ClientOptions.html":{},"interfaces/RefreshAccessTokenCallback.html":{},"interfaces/RefreshAccessTokenResponse.html":{},"interfaces/RefreshOptions.html":{},"interfaces/RequestMetadataCallback.html":{},"interfaces/RequestMetadataResponse.html":{},"interfaces/RevokeCredentialsResult.html":{},"interfaces/TokenInfo.html":{},"interfaces/TokenInfoRequest.html":{},"interfaces/VerifyIdTokenOptions.html":{},"changelog.html":{},"index.html":{}}}],["retriev",{"_index":586,"title":{},"body":{"interfaces/ComputeOptions.html":{},"interfaces/FederatedSignonCertsResponse.html":{},"interfaces/GetAccessTokenCallback.html":{},"interfaces/GetAccessTokenResponse.html":{},"interfaces/GetFederatedSignonCertsCallback.html":{},"interfaces/GetTokenCallback.html":{},"interfaces/GetTokenOptions.html":{},"interfaces/GetTokenResponse.html":{},"interfaces/JWTOptions.html":{},"interfaces/OAuth2ClientOptions.html":{},"interfaces/RefreshAccessTokenCallback.html":{},"interfaces/RefreshAccessTokenResponse.html":{},"interfaces/RefreshOptions.html":{},"interfaces/RequestMetadataCallback.html":{},"interfaces/RequestMetadataResponse.html":{},"interfaces/RevokeCredentialsResult.html":{},"interfaces/TokenInfo.html":{},"interfaces/TokenInfoRequest.html":{},"interfaces/VerifyIdTokenOptions.html":{},"index.html":{}}}],["retry).catch(",{"_index":626,"title":{},"body":{"interfaces/ComputeOptions.html":{}}}],["return",{"_index":18,"title":{},"body":{"interfaces/ADCCallback.html":{},"interfaces/ADCResponse.html":{},"interfaces/BodyResponseCallback.html":{},"interfaces/ComputeOptions.html":{},"interfaces/CredentialCallback.html":{},"classes/DefaultTransporter.html":{},"interfaces/FederatedSignonCertsResponse.html":{},"interfaces/GetAccessTokenCallback.html":{},"interfaces/GetAccessTokenResponse.html":{},"interfaces/GetFederatedSignonCertsCallback.html":{},"interfaces/GetTokenCallback.html":{},"interfaces/GetTokenOptions.html":{},"interfaces/GetTokenResponse.html":{},"interfaces/GoogleAuthOptions.html":{},"classes/IAMAuth.html":{},"classes/JWTAccess.html":{},"interfaces/JWTOptions.html":{},"classes/LoginTicket.html":{},"interfaces/OAuth2ClientOptions.html":{},"classes/PemVerifier.html":{},"interfaces/ProjectIdCallback.html":{},"interfaces/RefreshAccessTokenCallback.html":{},"interfaces/RefreshAccessTokenResponse.html":{},"interfaces/RefreshOptions.html":{},"interfaces/RequestError.html":{},"interfaces/RequestMetadata.html":{},"interfaces/RequestMetadataCallback.html":{},"interfaces/RequestMetadataResponse.html":{},"interfaces/RevokeCredentialsResult.html":{},"interfaces/SignBlobResponse.html":{},"interfaces/TokenInfo.html":{},"interfaces/TokenInfoRequest.html":{},"interfaces/TokenPayload.html":{},"interfaces/Transporter.html":{},"interfaces/UserRefreshClientOptions.html":{},"interfaces/VerifyIdTokenOptions.html":{},"interfaces/Warning.html":{},"changelog.html":{},"index.html":{}}}],["reus",{"_index":731,"title":{},"body":{"interfaces/FederatedSignonCertsResponse.html":{},"interfaces/GetAccessTokenCallback.html":{},"interfaces/GetAccessTokenResponse.html":{},"interfaces/GetFederatedSignonCertsCallback.html":{},"interfaces/GetTokenCallback.html":{},"interfaces/GetTokenOptions.html":{},"interfaces/GetTokenResponse.html":{},"classes/LoginTicket.html":{},"interfaces/OAuth2ClientOptions.html":{},"interfaces/RefreshAccessTokenCallback.html":{},"interfaces/RefreshAccessTokenResponse.html":{},"interfaces/RefreshOptions.html":{},"interfaces/RequestMetadataCallback.html":{},"interfaces/RequestMetadataResponse.html":{},"interfaces/RevokeCredentialsResult.html":{},"interfaces/TokenInfo.html":{},"interfaces/TokenInfoRequest.html":{},"interfaces/TokenPayload.html":{},"interfaces/VerifyIdTokenOptions.html":{}}}],["revis",{"_index":1857,"title":{},"body":{"license.html":{}}}],["revok",{"_index":937,"title":{},"body":{"interfaces/FederatedSignonCertsResponse.html":{},"interfaces/GetAccessTokenCallback.html":{},"interfaces/GetAccessTokenResponse.html":{},"interfaces/GetFederatedSignonCertsCallback.html":{},"interfaces/GetTokenCallback.html":{},"interfaces/GetTokenOptions.html":{},"interfaces/GetTokenResponse.html":{},"interfaces/OAuth2ClientOptions.html":{},"interfaces/RefreshAccessTokenCallback.html":{},"interfaces/RefreshAccessTokenResponse.html":{},"interfaces/RefreshOptions.html":{},"interfaces/RequestMetadataCallback.html":{},"interfaces/RequestMetadataResponse.html":{},"interfaces/RevokeCredentialsResult.html":{},"interfaces/TokenInfo.html":{},"interfaces/TokenInfoRequest.html":{},"interfaces/VerifyIdTokenOptions.html":{}}}],["revokecredenti",{"_index":1088,"title":{},"body":{"interfaces/FederatedSignonCertsResponse.html":{},"interfaces/GetAccessTokenCallback.html":{},"interfaces/GetAccessTokenResponse.html":{},"interfaces/GetFederatedSignonCertsCallback.html":{},"interfaces/GetTokenCallback.html":{},"interfaces/GetTokenOptions.html":{},"interfaces/GetTokenResponse.html":{},"interfaces/OAuth2ClientOptions.html":{},"interfaces/RefreshAccessTokenCallback.html":{},"interfaces/RefreshAccessTokenResponse.html":{},"interfaces/RefreshOptions.html":{},"interfaces/RequestMetadataCallback.html":{},"interfaces/RequestMetadataResponse.html":{},"interfaces/RevokeCredentialsResult.html":{},"interfaces/TokenInfo.html":{},"interfaces/TokenInfoRequest.html":{},"interfaces/VerifyIdTokenOptions.html":{}}}],["revokecredentials(callback",{"_index":1089,"title":{},"body":{"interfaces/FederatedSignonCertsResponse.html":{},"interfaces/GetAccessTokenCallback.html":{},"interfaces/GetAccessTokenResponse.html":{},"interfaces/GetFederatedSignonCertsCallback.html":{},"interfaces/GetTokenCallback.html":{},"interfaces/GetTokenOptions.html":{},"interfaces/GetTokenResponse.html":{},"interfaces/OAuth2ClientOptions.html":{},"interfaces/RefreshAccessTokenCallback.html":{},"interfaces/RefreshAccessTokenResponse.html":{},"interfaces/RefreshOptions.html":{},"interfaces/RequestMetadataCallback.html":{},"interfaces/RequestMetadataResponse.html":{},"interfaces/RevokeCredentialsResult.html":{},"interfaces/TokenInfo.html":{},"interfaces/TokenInfoRequest.html":{},"interfaces/VerifyIdTokenOptions.html":{}}}],["revokecredentialsasync",{"_index":1092,"title":{},"body":{"interfaces/FederatedSignonCertsResponse.html":{},"interfaces/GetAccessTokenCallback.html":{},"interfaces/GetAccessTokenResponse.html":{},"interfaces/GetFederatedSignonCertsCallback.html":{},"interfaces/GetTokenCallback.html":{},"interfaces/GetTokenOptions.html":{},"interfaces/GetTokenResponse.html":{},"interfaces/OAuth2ClientOptions.html":{},"interfaces/RefreshAccessTokenCallback.html":{},"interfaces/RefreshAccessTokenResponse.html":{},"interfaces/RefreshOptions.html":{},"interfaces/RequestMetadataCallback.html":{},"interfaces/RequestMetadataResponse.html":{},"interfaces/RevokeCredentialsResult.html":{},"interfaces/TokenInfo.html":{},"interfaces/TokenInfoRequest.html":{},"interfaces/VerifyIdTokenOptions.html":{}}}],["revokecredentialsresult",{"_index":888,"title":{"interfaces/RevokeCredentialsResult.html":{}},"body":{"interfaces/FederatedSignonCertsResponse.html":{},"interfaces/GetAccessTokenCallback.html":{},"interfaces/GetAccessTokenResponse.html":{},"interfaces/GetFederatedSignonCertsCallback.html":{},"interfaces/GetTokenCallback.html":{},"interfaces/GetTokenOptions.html":{},"interfaces/GetTokenResponse.html":{},"interfaces/OAuth2ClientOptions.html":{},"interfaces/RefreshAccessTokenCallback.html":{},"interfaces/RefreshAccessTokenResponse.html":{},"interfaces/RefreshOptions.html":{},"interfaces/RequestMetadataCallback.html":{},"interfaces/RequestMetadataResponse.html":{},"interfaces/RevokeCredentialsResult.html":{},"interfaces/TokenInfo.html":{},"interfaces/TokenInfoRequest.html":{},"interfaces/VerifyIdTokenOptions.html":{}}}],["revoketoken",{"_index":1082,"title":{},"body":{"interfaces/FederatedSignonCertsResponse.html":{},"interfaces/GetAccessTokenCallback.html":{},"interfaces/GetAccessTokenResponse.html":{},"interfaces/GetFederatedSignonCertsCallback.html":{},"interfaces/GetTokenCallback.html":{},"interfaces/GetTokenOptions.html":{},"interfaces/GetTokenResponse.html":{},"interfaces/OAuth2ClientOptions.html":{},"interfaces/RefreshAccessTokenCallback.html":{},"interfaces/RefreshAccessTokenResponse.html":{},"interfaces/RefreshOptions.html":{},"interfaces/RequestMetadataCallback.html":{},"interfaces/RequestMetadataResponse.html":{},"interfaces/RevokeCredentialsResult.html":{},"interfaces/TokenInfo.html":{},"interfaces/TokenInfoRequest.html":{},"interfaces/VerifyIdTokenOptions.html":{}}}],["revoketoken(token",{"_index":1081,"title":{},"body":{"interfaces/FederatedSignonCertsResponse.html":{},"interfaces/GetAccessTokenCallback.html":{},"interfaces/GetAccessTokenResponse.html":{},"interfaces/GetFederatedSignonCertsCallback.html":{},"interfaces/GetTokenCallback.html":{},"interfaces/GetTokenOptions.html":{},"interfaces/GetTokenResponse.html":{},"interfaces/OAuth2ClientOptions.html":{},"interfaces/RefreshAccessTokenCallback.html":{},"interfaces/RefreshAccessTokenResponse.html":{},"interfaces/RefreshOptions.html":{},"interfaces/RequestMetadataCallback.html":{},"interfaces/RequestMetadataResponse.html":{},"interfaces/RevokeCredentialsResult.html":{},"interfaces/TokenInfo.html":{},"interfaces/TokenInfoRequest.html":{},"interfaces/VerifyIdTokenOptions.html":{}}}],["right",{"_index":652,"title":{},"body":{"interfaces/Credentials.html":{},"classes/LoginTicket.html":{},"miscellaneous/functions.html":{},"index.html":{},"license.html":{}}}],["risk",{"_index":1953,"title":{},"body":{"license.html":{}}}],["root",{"_index":277,"title":{},"body":{"interfaces/ADCCallback.html":{},"interfaces/ADCResponse.html":{},"interfaces/CredentialCallback.html":{},"interfaces/GoogleAuthOptions.html":{},"interfaces/ProjectIdCallback.html":{},"interfaces/SignBlobResponse.html":{}}}],["rooturl",{"_index":966,"title":{},"body":{"interfaces/FederatedSignonCertsResponse.html":{},"interfaces/GetAccessTokenCallback.html":{},"interfaces/GetAccessTokenResponse.html":{},"interfaces/GetFederatedSignonCertsCallback.html":{},"interfaces/GetTokenCallback.html":{},"interfaces/GetTokenOptions.html":{},"interfaces/GetTokenResponse.html":{},"interfaces/OAuth2ClientOptions.html":{},"interfaces/RefreshAccessTokenCallback.html":{},"interfaces/RefreshAccessTokenResponse.html":{},"interfaces/RefreshOptions.html":{},"interfaces/RequestMetadataCallback.html":{},"interfaces/RequestMetadataResponse.html":{},"interfaces/RevokeCredentialsResult.html":{},"interfaces/TokenInfo.html":{},"interfaces/TokenInfoRequest.html":{},"interfaces/VerifyIdTokenOptions.html":{}}}],["royalti",{"_index":1887,"title":{},"body":{"license.html":{}}}],["rs256",{"_index":1242,"title":{},"body":{"classes/JWTAccess.html":{},"miscellaneous/variables.html":{}}}],["rule",{"_index":1402,"title":{},"body":{"interfaces/UserRefreshClientOptions.html":{}}}],["run",{"_index":92,"title":{},"body":{"interfaces/ADCCallback.html":{},"interfaces/ADCResponse.html":{},"interfaces/CredentialCallback.html":{},"interfaces/GoogleAuthOptions.html":{},"interfaces/ProjectIdCallback.html":{},"interfaces/SignBlobResponse.html":{},"changelog.html":{},"index.html":{}}}],["runtim",{"_index":1690,"title":{},"body":{"index.html":{}}}],["s",{"_index":304,"title":{},"body":{"interfaces/ADCCallback.html":{},"interfaces/ADCResponse.html":{},"interfaces/CredentialCallback.html":{},"interfaces/GoogleAuthOptions.html":{},"classes/JWTAccess.html":{},"interfaces/JWTOptions.html":{},"interfaces/ProjectIdCallback.html":{},"interfaces/SignBlobResponse.html":{},"interfaces/UserRefreshClientOptions.html":{}}}],["s.length",{"_index":393,"title":{},"body":{"interfaces/ADCCallback.html":{},"interfaces/ADCResponse.html":{},"interfaces/CredentialCallback.html":{},"interfaces/GoogleAuthOptions.html":{},"interfaces/ProjectIdCallback.html":{},"interfaces/SignBlobResponse.html":{}}}],["s256",{"_index":697,"title":{},"body":{"interfaces/FederatedSignonCertsResponse.html":{},"interfaces/GetAccessTokenCallback.html":{},"interfaces/GetAccessTokenResponse.html":{},"interfaces/GetFederatedSignonCertsCallback.html":{},"interfaces/GetTokenCallback.html":{},"interfaces/GetTokenOptions.html":{},"interfaces/GetTokenResponse.html":{},"interfaces/OAuth2ClientOptions.html":{},"interfaces/RefreshAccessTokenCallback.html":{},"interfaces/RefreshAccessTokenResponse.html":{},"interfaces/RefreshOptions.html":{},"interfaces/RequestMetadataCallback.html":{},"interfaces/RequestMetadataResponse.html":{},"interfaces/RevokeCredentialsResult.html":{},"interfaces/TokenInfo.html":{},"interfaces/TokenInfoRequest.html":{},"interfaces/VerifyIdTokenOptions.html":{},"miscellaneous/enumerations.html":{}}}],["safe",{"_index":1752,"title":{},"body":{"index.html":{}}}],["same",{"_index":721,"title":{},"body":{"interfaces/FederatedSignonCertsResponse.html":{},"interfaces/GetAccessTokenCallback.html":{},"interfaces/GetAccessTokenResponse.html":{},"interfaces/GetFederatedSignonCertsCallback.html":{},"interfaces/GetTokenCallback.html":{},"interfaces/GetTokenOptions.html":{},"interfaces/GetTokenResponse.html":{},"classes/LoginTicket.html":{},"interfaces/OAuth2ClientOptions.html":{},"interfaces/RefreshAccessTokenCallback.html":{},"interfaces/RefreshAccessTokenResponse.html":{},"interfaces/RefreshOptions.html":{},"interfaces/RequestMetadataCallback.html":{},"interfaces/RequestMetadataResponse.html":{},"interfaces/RevokeCredentialsResult.html":{},"interfaces/TokenInfo.html":{},"interfaces/TokenInfoRequest.html":{},"interfaces/TokenPayload.html":{},"interfaces/VerifyIdTokenOptions.html":{},"index.html":{},"license.html":{}}}],["sampl",{"_index":1487,"title":{},"body":{"changelog.html":{}}}],["samples/jwt.j",{"_index":1786,"title":{},"body":{"index.html":{}}}],["satisifi",{"_index":102,"title":{},"body":{"interfaces/ADCCallback.html":{},"interfaces/ADCResponse.html":{},"interfaces/CredentialCallback.html":{},"interfaces/GoogleAuthOptions.html":{},"interfaces/ProjectIdCallback.html":{},"interfaces/SignBlobResponse.html":{}}}],["save",{"_index":111,"title":{},"body":{"interfaces/ADCCallback.html":{},"interfaces/ADCResponse.html":{},"interfaces/CredentialCallback.html":{},"interfaces/GoogleAuthOptions.html":{},"interfaces/ProjectIdCallback.html":{},"interfaces/SignBlobResponse.html":{},"index.html":{}}}],["scenario",{"_index":219,"title":{},"body":{"interfaces/ADCCallback.html":{},"interfaces/ADCResponse.html":{},"interfaces/CredentialCallback.html":{},"interfaces/GoogleAuthOptions.html":{},"interfaces/ProjectIdCallback.html":{},"interfaces/SignBlobResponse.html":{},"changelog.html":{},"index.html":{}}}],["scheme",{"_index":785,"title":{},"body":{"interfaces/FederatedSignonCertsResponse.html":{},"interfaces/GetAccessTokenCallback.html":{},"interfaces/GetAccessTokenResponse.html":{},"interfaces/GetFederatedSignonCertsCallback.html":{},"interfaces/GetTokenCallback.html":{},"interfaces/GetTokenOptions.html":{},"interfaces/GetTokenResponse.html":{},"interfaces/OAuth2ClientOptions.html":{},"interfaces/RefreshAccessTokenCallback.html":{},"interfaces/RefreshAccessTokenResponse.html":{},"interfaces/RefreshOptions.html":{},"interfaces/RequestMetadataCallback.html":{},"interfaces/RequestMetadataResponse.html":{},"interfaces/RevokeCredentialsResult.html":{},"interfaces/TokenInfo.html":{},"interfaces/TokenInfoRequest.html":{},"interfaces/VerifyIdTokenOptions.html":{}}}],["scope",{"_index":73,"title":{},"body":{"interfaces/ADCCallback.html":{},"interfaces/ADCResponse.html":{},"interfaces/ComputeOptions.html":{},"interfaces/CredentialCallback.html":{},"interfaces/FederatedSignonCertsResponse.html":{},"interfaces/GetAccessTokenCallback.html":{},"interfaces/GetAccessTokenResponse.html":{},"interfaces/GetFederatedSignonCertsCallback.html":{},"interfaces/GetTokenCallback.html":{},"interfaces/GetTokenOptions.html":{},"interfaces/GetTokenResponse.html":{},"interfaces/GoogleAuthOptions.html":{},"classes/IAMAuth.html":{},"classes/JWTAccess.html":{},"interfaces/JWTOptions.html":{},"classes/LoginTicket.html":{},"interfaces/OAuth2ClientOptions.html":{},"interfaces/ProjectIdCallback.html":{},"interfaces/RefreshAccessTokenCallback.html":{},"interfaces/RefreshAccessTokenResponse.html":{},"interfaces/RefreshOptions.html":{},"interfaces/RequestMetadata.html":{},"interfaces/RequestMetadataCallback.html":{},"interfaces/RequestMetadataResponse.html":{},"interfaces/RevokeCredentialsResult.html":{},"interfaces/SignBlobResponse.html":{},"interfaces/TokenInfo.html":{},"interfaces/TokenInfoRequest.html":{},"interfaces/TokenPayload.html":{},"interfaces/VerifyIdTokenOptions.html":{},"changelog.html":{},"index.html":{}}}],["screen",{"_index":793,"title":{},"body":{"interfaces/FederatedSignonCertsResponse.html":{},"interfaces/GetAccessTokenCallback.html":{},"interfaces/GetAccessTokenResponse.html":{},"interfaces/GetFederatedSignonCertsCallback.html":{},"interfaces/GetTokenCallback.html":{},"interfaces/GetTokenOptions.html":{},"interfaces/GetTokenResponse.html":{},"interfaces/OAuth2ClientOptions.html":{},"interfaces/RefreshAccessTokenCallback.html":{},"interfaces/RefreshAccessTokenResponse.html":{},"interfaces/RefreshOptions.html":{},"interfaces/RequestMetadataCallback.html":{},"interfaces/RequestMetadataResponse.html":{},"interfaces/RevokeCredentialsResult.html":{},"interfaces/TokenInfo.html":{},"interfaces/TokenInfoRequest.html":{},"interfaces/VerifyIdTokenOptions.html":{}}}],["sdk",{"_index":168,"title":{},"body":{"interfaces/ADCCallback.html":{},"interfaces/ADCResponse.html":{},"interfaces/CredentialCallback.html":{},"interfaces/GoogleAuthOptions.html":{},"interfaces/ProjectIdCallback.html":{},"interfaces/SignBlobResponse.html":{},"interfaces/Warning.html":{},"changelog.html":{},"miscellaneous/variables.html":{}}}],["sdk'",{"_index":313,"title":{},"body":{"interfaces/ADCCallback.html":{},"interfaces/ADCResponse.html":{},"interfaces/CredentialCallback.html":{},"interfaces/GoogleAuthOptions.html":{},"interfaces/ProjectIdCallback.html":{},"interfaces/SignBlobResponse.html":{}}}],["seamlessli",{"_index":1699,"title":{},"body":{"index.html":{}}}],["second",{"_index":945,"title":{},"body":{"interfaces/FederatedSignonCertsResponse.html":{},"interfaces/GetAccessTokenCallback.html":{},"interfaces/GetAccessTokenResponse.html":{},"interfaces/GetFederatedSignonCertsCallback.html":{},"interfaces/GetTokenCallback.html":{},"interfaces/GetTokenOptions.html":{},"interfaces/GetTokenResponse.html":{},"classes/JWTAccess.html":{},"classes/LoginTicket.html":{},"interfaces/OAuth2ClientOptions.html":{},"interfaces/RefreshAccessTokenCallback.html":{},"interfaces/RefreshAccessTokenResponse.html":{},"interfaces/RefreshOptions.html":{},"interfaces/RequestMetadataCallback.html":{},"interfaces/RequestMetadataResponse.html":{},"interfaces/RevokeCredentialsResult.html":{},"interfaces/TokenInfo.html":{},"interfaces/TokenInfoRequest.html":{},"interfaces/TokenPayload.html":{},"interfaces/VerifyIdTokenOptions.html":{}}}],["secret",{"_index":915,"title":{},"body":{"interfaces/FederatedSignonCertsResponse.html":{},"interfaces/GetAccessTokenCallback.html":{},"interfaces/GetAccessTokenResponse.html":{},"interfaces/GetFederatedSignonCertsCallback.html":{},"interfaces/GetTokenCallback.html":{},"interfaces/GetTokenOptions.html":{},"interfaces/GetTokenResponse.html":{},"classes/JWTAccess.html":{},"interfaces/OAuth2ClientOptions.html":{},"interfaces/RefreshAccessTokenCallback.html":{},"interfaces/RefreshAccessTokenResponse.html":{},"interfaces/RefreshOptions.html":{},"interfaces/RequestMetadataCallback.html":{},"interfaces/RequestMetadataResponse.html":{},"interfaces/RevokeCredentialsResult.html":{},"interfaces/TokenInfo.html":{},"interfaces/TokenInfoRequest.html":{},"interfaces/UserRefreshClientOptions.html":{},"interfaces/VerifyIdTokenOptions.html":{},"index.html":{}}}],["section",{"_index":855,"title":{},"body":{"interfaces/FederatedSignonCertsResponse.html":{},"interfaces/GetAccessTokenCallback.html":{},"interfaces/GetAccessTokenResponse.html":{},"interfaces/GetFederatedSignonCertsCallback.html":{},"interfaces/GetTokenCallback.html":{},"interfaces/GetTokenOptions.html":{},"interfaces/GetTokenResponse.html":{},"interfaces/OAuth2ClientOptions.html":{},"interfaces/RefreshAccessTokenCallback.html":{},"interfaces/RefreshAccessTokenResponse.html":{},"interfaces/RefreshOptions.html":{},"interfaces/RequestMetadataCallback.html":{},"interfaces/RequestMetadataResponse.html":{},"interfaces/RevokeCredentialsResult.html":{},"interfaces/TokenInfo.html":{},"interfaces/TokenInfoRequest.html":{},"interfaces/VerifyIdTokenOptions.html":{},"license.html":{}}}],["secur",{"_index":779,"title":{},"body":{"interfaces/FederatedSignonCertsResponse.html":{},"interfaces/GetAccessTokenCallback.html":{},"interfaces/GetAccessTokenResponse.html":{},"interfaces/GetFederatedSignonCertsCallback.html":{},"interfaces/GetTokenCallback.html":{},"interfaces/GetTokenOptions.html":{},"interfaces/GetTokenResponse.html":{},"interfaces/OAuth2ClientOptions.html":{},"interfaces/RefreshAccessTokenCallback.html":{},"interfaces/RefreshAccessTokenResponse.html":{},"interfaces/RefreshOptions.html":{},"interfaces/RequestMetadataCallback.html":{},"interfaces/RequestMetadataResponse.html":{},"interfaces/RevokeCredentialsResult.html":{},"interfaces/TokenInfo.html":{},"interfaces/TokenInfoRequest.html":{},"interfaces/VerifyIdTokenOptions.html":{},"index.html":{}}}],["see",{"_index":587,"title":{},"body":{"interfaces/ComputeOptions.html":{},"interfaces/Credentials.html":{},"interfaces/FederatedSignonCertsResponse.html":{},"interfaces/GetAccessTokenCallback.html":{},"interfaces/GetAccessTokenResponse.html":{},"interfaces/GetFederatedSignonCertsCallback.html":{},"interfaces/GetTokenCallback.html":{},"interfaces/GetTokenOptions.html":{},"interfaces/GetTokenResponse.html":{},"classes/LoginTicket.html":{},"interfaces/OAuth2ClientOptions.html":{},"interfaces/RefreshAccessTokenCallback.html":{},"interfaces/RefreshAccessTokenResponse.html":{},"interfaces/RefreshOptions.html":{},"interfaces/RequestMetadataCallback.html":{},"interfaces/RequestMetadataResponse.html":{},"interfaces/RevokeCredentialsResult.html":{},"interfaces/TokenInfo.html":{},"interfaces/TokenInfoRequest.html":{},"interfaces/VerifyIdTokenOptions.html":{},"interfaces/Warning.html":{},"miscellaneous/functions.html":{},"index.html":{},"license.html":{},"miscellaneous/variables.html":{}}}],["seem",{"_index":283,"title":{},"body":{"interfaces/ADCCallback.html":{},"interfaces/ADCResponse.html":{},"interfaces/CredentialCallback.html":{},"interfaces/GoogleAuthOptions.html":{},"interfaces/ProjectIdCallback.html":{},"interfaces/SignBlobResponse.html":{}}}],["select",{"_index":765,"title":{},"body":{"interfaces/FederatedSignonCertsResponse.html":{},"interfaces/GetAccessTokenCallback.html":{},"interfaces/GetAccessTokenResponse.html":{},"interfaces/GetFederatedSignonCertsCallback.html":{},"interfaces/GetTokenCallback.html":{},"interfaces/GetTokenOptions.html":{},"interfaces/GetTokenResponse.html":{},"interfaces/OAuth2ClientOptions.html":{},"interfaces/RefreshAccessTokenCallback.html":{},"interfaces/RefreshAccessTokenResponse.html":{},"interfaces/RefreshOptions.html":{},"interfaces/RequestMetadataCallback.html":{},"interfaces/RequestMetadataResponse.html":{},"interfaces/RevokeCredentialsResult.html":{},"interfaces/TokenInfo.html":{},"interfaces/TokenInfoRequest.html":{},"interfaces/VerifyIdTokenOptions.html":{},"index.html":{}}}],["select_account",{"_index":870,"title":{},"body":{"interfaces/FederatedSignonCertsResponse.html":{},"interfaces/GetAccessTokenCallback.html":{},"interfaces/GetAccessTokenResponse.html":{},"interfaces/GetFederatedSignonCertsCallback.html":{},"interfaces/GetTokenCallback.html":{},"interfaces/GetTokenOptions.html":{},"interfaces/GetTokenResponse.html":{},"interfaces/OAuth2ClientOptions.html":{},"interfaces/RefreshAccessTokenCallback.html":{},"interfaces/RefreshAccessTokenResponse.html":{},"interfaces/RefreshOptions.html":{},"interfaces/RequestMetadataCallback.html":{},"interfaces/RequestMetadataResponse.html":{},"interfaces/RevokeCredentialsResult.html":{},"interfaces/TokenInfo.html":{},"interfaces/TokenInfoRequest.html":{},"interfaces/VerifyIdTokenOptions.html":{}}}],["selector",{"_index":1192,"title":{},"body":{"classes/IAMAuth.html":{},"interfaces/RequestMetadata.html":{}}}],["sell",{"_index":1896,"title":{},"body":{"license.html":{}}}],["semver",{"_index":1415,"title":{},"body":{"interfaces/Warning.html":{},"dependencies.html":{}}}],["semver.satisfies(process.vers",{"_index":1420,"title":{},"body":{"interfaces/Warning.html":{}}}],["send",{"_index":817,"title":{},"body":{"interfaces/FederatedSignonCertsResponse.html":{},"interfaces/GetAccessTokenCallback.html":{},"interfaces/GetAccessTokenResponse.html":{},"interfaces/GetFederatedSignonCertsCallback.html":{},"interfaces/GetTokenCallback.html":{},"interfaces/GetTokenOptions.html":{},"interfaces/GetTokenResponse.html":{},"interfaces/OAuth2ClientOptions.html":{},"interfaces/RefreshAccessTokenCallback.html":{},"interfaces/RefreshAccessTokenResponse.html":{},"interfaces/RefreshOptions.html":{},"interfaces/RequestMetadataCallback.html":{},"interfaces/RequestMetadataResponse.html":{},"interfaces/RevokeCredentialsResult.html":{},"interfaces/TokenInfo.html":{},"interfaces/TokenInfoRequest.html":{},"interfaces/VerifyIdTokenOptions.html":{}}}],["sens",{"_index":1111,"title":{},"body":{"interfaces/FederatedSignonCertsResponse.html":{},"interfaces/GetAccessTokenCallback.html":{},"interfaces/GetAccessTokenResponse.html":{},"interfaces/GetFederatedSignonCertsCallback.html":{},"interfaces/GetTokenCallback.html":{},"interfaces/GetTokenOptions.html":{},"interfaces/GetTokenResponse.html":{},"interfaces/OAuth2ClientOptions.html":{},"interfaces/RefreshAccessTokenCallback.html":{},"interfaces/RefreshAccessTokenResponse.html":{},"interfaces/RefreshOptions.html":{},"interfaces/RequestMetadataCallback.html":{},"interfaces/RequestMetadataResponse.html":{},"interfaces/RevokeCredentialsResult.html":{},"interfaces/TokenInfo.html":{},"interfaces/TokenInfoRequest.html":{},"interfaces/VerifyIdTokenOptions.html":{}}}],["sensit",{"_index":866,"title":{},"body":{"interfaces/FederatedSignonCertsResponse.html":{},"interfaces/GetAccessTokenCallback.html":{},"interfaces/GetAccessTokenResponse.html":{},"interfaces/GetFederatedSignonCertsCallback.html":{},"interfaces/GetTokenCallback.html":{},"interfaces/GetTokenOptions.html":{},"interfaces/GetTokenResponse.html":{},"interfaces/OAuth2ClientOptions.html":{},"interfaces/RefreshAccessTokenCallback.html":{},"interfaces/RefreshAccessTokenResponse.html":{},"interfaces/RefreshOptions.html":{},"interfaces/RequestMetadataCallback.html":{},"interfaces/RequestMetadataResponse.html":{},"interfaces/RevokeCredentialsResult.html":{},"interfaces/TokenInfo.html":{},"interfaces/TokenInfoRequest.html":{},"interfaces/VerifyIdTokenOptions.html":{}}}],["sent",{"_index":1303,"title":{},"body":{"interfaces/JWTOptions.html":{},"license.html":{}}}],["separ",{"_index":1862,"title":{},"body":{"license.html":{}}}],["server",{"_index":174,"title":{},"body":{"interfaces/ADCCallback.html":{},"interfaces/ADCResponse.html":{},"interfaces/ComputeOptions.html":{},"interfaces/CredentialCallback.html":{},"interfaces/FederatedSignonCertsResponse.html":{},"interfaces/GetAccessTokenCallback.html":{},"interfaces/GetAccessTokenResponse.html":{},"interfaces/GetFederatedSignonCertsCallback.html":{},"interfaces/GetTokenCallback.html":{},"interfaces/GetTokenOptions.html":{},"interfaces/GetTokenResponse.html":{},"interfaces/GoogleAuthOptions.html":{},"classes/LoginTicket.html":{},"interfaces/OAuth2ClientOptions.html":{},"interfaces/ProjectIdCallback.html":{},"interfaces/RefreshAccessTokenCallback.html":{},"interfaces/RefreshAccessTokenResponse.html":{},"interfaces/RefreshOptions.html":{},"interfaces/RequestMetadataCallback.html":{},"interfaces/RequestMetadataResponse.html":{},"interfaces/RevokeCredentialsResult.html":{},"interfaces/SignBlobResponse.html":{},"interfaces/TokenInfo.html":{},"interfaces/TokenInfoRequest.html":{},"interfaces/TokenPayload.html":{},"interfaces/VerifyIdTokenOptions.html":{},"interfaces/Warning.html":{},"index.html":{},"miscellaneous/variables.html":{}}}],["server'",{"_index":815,"title":{},"body":{"interfaces/FederatedSignonCertsResponse.html":{},"interfaces/GetAccessTokenCallback.html":{},"interfaces/GetAccessTokenResponse.html":{},"interfaces/GetFederatedSignonCertsCallback.html":{},"interfaces/GetTokenCallback.html":{},"interfaces/GetTokenOptions.html":{},"interfaces/GetTokenResponse.html":{},"interfaces/OAuth2ClientOptions.html":{},"interfaces/RefreshAccessTokenCallback.html":{},"interfaces/RefreshAccessTokenResponse.html":{},"interfaces/RefreshOptions.html":{},"interfaces/RequestMetadataCallback.html":{},"interfaces/RequestMetadataResponse.html":{},"interfaces/RevokeCredentialsResult.html":{},"interfaces/TokenInfo.html":{},"interfaces/TokenInfoRequest.html":{},"interfaces/VerifyIdTokenOptions.html":{}}}],["server.clos",{"_index":1743,"title":{},"body":{"index.html":{}}}],["servic",{"_index":189,"title":{},"body":{"interfaces/ADCCallback.html":{},"interfaces/ADCResponse.html":{},"interfaces/ComputeOptions.html":{},"interfaces/CredentialCallback.html":{},"interfaces/GoogleAuthOptions.html":{},"classes/JWTAccess.html":{},"interfaces/JWTOptions.html":{},"interfaces/ProjectIdCallback.html":{},"interfaces/SignBlobResponse.html":{},"interfaces/Warning.html":{},"index.html":{},"license.html":{},"miscellaneous/variables.html":{}}}],["service_account",{"_index":1790,"title":{},"body":{"index.html":{}}}],["serviceaccountemail",{"_index":581,"title":{},"body":{"interfaces/ComputeOptions.html":{},"index.html":{}}}],["session",{"_index":720,"title":{},"body":{"interfaces/FederatedSignonCertsResponse.html":{},"interfaces/GetAccessTokenCallback.html":{},"interfaces/GetAccessTokenResponse.html":{},"interfaces/GetFederatedSignonCertsCallback.html":{},"interfaces/GetTokenCallback.html":{},"interfaces/GetTokenOptions.html":{},"interfaces/GetTokenResponse.html":{},"classes/LoginTicket.html":{},"interfaces/OAuth2ClientOptions.html":{},"interfaces/RefreshAccessTokenCallback.html":{},"interfaces/RefreshAccessTokenResponse.html":{},"interfaces/RefreshOptions.html":{},"interfaces/RequestMetadataCallback.html":{},"interfaces/RequestMetadataResponse.html":{},"interfaces/RevokeCredentialsResult.html":{},"interfaces/TokenInfo.html":{},"interfaces/TokenInfoRequest.html":{},"interfaces/TokenPayload.html":{},"interfaces/VerifyIdTokenOptions.html":{}}}],["set",{"_index":330,"title":{},"body":{"interfaces/ADCCallback.html":{},"interfaces/ADCResponse.html":{},"interfaces/BodyResponseCallback.html":{},"interfaces/CredentialCallback.html":{},"classes/DefaultTransporter.html":{},"interfaces/FederatedSignonCertsResponse.html":{},"interfaces/GetAccessTokenCallback.html":{},"interfaces/GetAccessTokenResponse.html":{},"interfaces/GetFederatedSignonCertsCallback.html":{},"interfaces/GetTokenCallback.html":{},"interfaces/GetTokenOptions.html":{},"interfaces/GetTokenResponse.html":{},"interfaces/GoogleAuthOptions.html":{},"classes/JWTAccess.html":{},"interfaces/JWTOptions.html":{},"interfaces/OAuth2ClientOptions.html":{},"interfaces/ProjectIdCallback.html":{},"interfaces/RefreshAccessTokenCallback.html":{},"interfaces/RefreshAccessTokenResponse.html":{},"interfaces/RefreshOptions.html":{},"interfaces/RequestError.html":{},"interfaces/RequestMetadataCallback.html":{},"interfaces/RequestMetadataResponse.html":{},"interfaces/RevokeCredentialsResult.html":{},"interfaces/SignBlobResponse.html":{},"interfaces/TokenInfo.html":{},"interfaces/TokenInfoRequest.html":{},"interfaces/Transporter.html":{},"interfaces/VerifyIdTokenOptions.html":{},"changelog.html":{},"index.html":{}}}],["sever",{"_index":824,"title":{},"body":{"interfaces/FederatedSignonCertsResponse.html":{},"interfaces/GetAccessTokenCallback.html":{},"interfaces/GetAccessTokenResponse.html":{},"interfaces/GetFederatedSignonCertsCallback.html":{},"interfaces/GetTokenCallback.html":{},"interfaces/GetTokenOptions.html":{},"interfaces/GetTokenResponse.html":{},"interfaces/OAuth2ClientOptions.html":{},"interfaces/RefreshAccessTokenCallback.html":{},"interfaces/RefreshAccessTokenResponse.html":{},"interfaces/RefreshOptions.html":{},"interfaces/RequestMetadataCallback.html":{},"interfaces/RequestMetadataResponse.html":{},"interfaces/RevokeCredentialsResult.html":{},"interfaces/TokenInfo.html":{},"interfaces/TokenInfoRequest.html":{},"interfaces/VerifyIdTokenOptions.html":{}}}],["sha256",{"_index":478,"title":{},"body":{"interfaces/ADCCallback.html":{},"interfaces/ADCResponse.html":{},"interfaces/CredentialCallback.html":{},"interfaces/FederatedSignonCertsResponse.html":{},"interfaces/GetAccessTokenCallback.html":{},"interfaces/GetAccessTokenResponse.html":{},"interfaces/GetFederatedSignonCertsCallback.html":{},"interfaces/GetTokenCallback.html":{},"interfaces/GetTokenOptions.html":{},"interfaces/GetTokenResponse.html":{},"interfaces/GoogleAuthOptions.html":{},"interfaces/OAuth2ClientOptions.html":{},"interfaces/ProjectIdCallback.html":{},"interfaces/RefreshAccessTokenCallback.html":{},"interfaces/RefreshAccessTokenResponse.html":{},"interfaces/RefreshOptions.html":{},"interfaces/RequestMetadataCallback.html":{},"interfaces/RequestMetadataResponse.html":{},"interfaces/RevokeCredentialsResult.html":{},"interfaces/SignBlobResponse.html":{},"interfaces/TokenInfo.html":{},"interfaces/TokenInfoRequest.html":{},"interfaces/VerifyIdTokenOptions.html":{}}}],["shall",{"_index":1823,"title":{},"body":{"license.html":{}}}],["share",{"_index":743,"title":{},"body":{"interfaces/FederatedSignonCertsResponse.html":{},"interfaces/GetAccessTokenCallback.html":{},"interfaces/GetAccessTokenResponse.html":{},"interfaces/GetFederatedSignonCertsCallback.html":{},"interfaces/GetTokenCallback.html":{},"interfaces/GetTokenOptions.html":{},"interfaces/GetTokenResponse.html":{},"classes/LoginTicket.html":{},"interfaces/OAuth2ClientOptions.html":{},"interfaces/RefreshAccessTokenCallback.html":{},"interfaces/RefreshAccessTokenResponse.html":{},"interfaces/RefreshOptions.html":{},"interfaces/RequestMetadataCallback.html":{},"interfaces/RequestMetadataResponse.html":{},"interfaces/RevokeCredentialsResult.html":{},"interfaces/TokenInfo.html":{},"interfaces/TokenInfoRequest.html":{},"interfaces/TokenPayload.html":{},"interfaces/VerifyIdTokenOptions.html":{},"license.html":{}}}],["shouldrefresh",{"_index":1053,"title":{},"body":{"interfaces/FederatedSignonCertsResponse.html":{},"interfaces/GetAccessTokenCallback.html":{},"interfaces/GetAccessTokenResponse.html":{},"interfaces/GetFederatedSignonCertsCallback.html":{},"interfaces/GetTokenCallback.html":{},"interfaces/GetTokenOptions.html":{},"interfaces/GetTokenResponse.html":{},"interfaces/OAuth2ClientOptions.html":{},"interfaces/RefreshAccessTokenCallback.html":{},"interfaces/RefreshAccessTokenResponse.html":{},"interfaces/RefreshOptions.html":{},"interfaces/RequestMetadataCallback.html":{},"interfaces/RequestMetadataResponse.html":{},"interfaces/RevokeCredentialsResult.html":{},"interfaces/TokenInfo.html":{},"interfaces/TokenInfoRequest.html":{},"interfaces/VerifyIdTokenOptions.html":{}}}],["show",{"_index":1418,"title":{},"body":{"interfaces/Warning.html":{},"index.html":{}}}],["shown",{"_index":1761,"title":{},"body":{"index.html":{}}}],["side",{"_index":774,"title":{},"body":{"interfaces/FederatedSignonCertsResponse.html":{},"interfaces/GetAccessTokenCallback.html":{},"interfaces/GetAccessTokenResponse.html":{},"interfaces/GetFederatedSignonCertsCallback.html":{},"interfaces/GetTokenCallback.html":{},"interfaces/GetTokenOptions.html":{},"interfaces/GetTokenResponse.html":{},"interfaces/OAuth2ClientOptions.html":{},"interfaces/RefreshAccessTokenCallback.html":{},"interfaces/RefreshAccessTokenResponse.html":{},"interfaces/RefreshOptions.html":{},"interfaces/RequestMetadataCallback.html":{},"interfaces/RequestMetadataResponse.html":{},"interfaces/RevokeCredentialsResult.html":{},"interfaces/TokenInfo.html":{},"interfaces/TokenInfoRequest.html":{},"interfaces/VerifyIdTokenOptions.html":{}}}],["sign",{"_index":472,"title":{},"body":{"interfaces/ADCCallback.html":{},"interfaces/ADCResponse.html":{},"interfaces/CredentialCallback.html":{},"interfaces/FederatedSignonCertsResponse.html":{},"interfaces/GetAccessTokenCallback.html":{},"interfaces/GetAccessTokenResponse.html":{},"interfaces/GetFederatedSignonCertsCallback.html":{},"interfaces/GetTokenCallback.html":{},"interfaces/GetTokenOptions.html":{},"interfaces/GetTokenResponse.html":{},"interfaces/GoogleAuthOptions.html":{},"classes/JWTAccess.html":{},"interfaces/OAuth2ClientOptions.html":{},"interfaces/ProjectIdCallback.html":{},"interfaces/RefreshAccessTokenCallback.html":{},"interfaces/RefreshAccessTokenResponse.html":{},"interfaces/RefreshOptions.html":{},"interfaces/RequestMetadataCallback.html":{},"interfaces/RequestMetadataResponse.html":{},"interfaces/RevokeCredentialsResult.html":{},"interfaces/SignBlobResponse.html":{},"interfaces/TokenInfo.html":{},"interfaces/TokenInfoRequest.html":{},"interfaces/VerifyIdTokenOptions.html":{}}}],["sign(data",{"_index":475,"title":{},"body":{"interfaces/ADCCallback.html":{},"interfaces/ADCResponse.html":{},"interfaces/CredentialCallback.html":{},"interfaces/GoogleAuthOptions.html":{},"interfaces/ProjectIdCallback.html":{},"interfaces/SignBlobResponse.html":{}}}],["sign.sign(client.key",{"_index":480,"title":{},"body":{"interfaces/ADCCallback.html":{},"interfaces/ADCResponse.html":{},"interfaces/CredentialCallback.html":{},"interfaces/GoogleAuthOptions.html":{},"interfaces/ProjectIdCallback.html":{},"interfaces/SignBlobResponse.html":{}}}],["sign.update(data",{"_index":479,"title":{},"body":{"interfaces/ADCCallback.html":{},"interfaces/ADCResponse.html":{},"interfaces/CredentialCallback.html":{},"interfaces/GoogleAuthOptions.html":{},"interfaces/ProjectIdCallback.html":{},"interfaces/SignBlobResponse.html":{}}}],["signatur",{"_index":9,"title":{},"body":{"interfaces/ADCCallback.html":{},"interfaces/ADCResponse.html":{},"interfaces/BodyResponseCallback.html":{},"interfaces/CredentialCallback.html":{},"interfaces/GetAccessTokenCallback.html":{},"interfaces/GetFederatedSignonCertsCallback.html":{},"interfaces/GetTokenCallback.html":{},"interfaces/GoogleAuthOptions.html":{},"classes/PemVerifier.html":{},"interfaces/ProjectIdCallback.html":{},"interfaces/RefreshAccessTokenCallback.html":{},"interfaces/RequestMetadataCallback.html":{},"interfaces/SignBlobResponse.html":{}}}],["signblobrespons",{"_index":494,"title":{"interfaces/SignBlobResponse.html":{}},"body":{"interfaces/ADCCallback.html":{},"interfaces/ADCResponse.html":{},"interfaces/CredentialCallback.html":{},"interfaces/GoogleAuthOptions.html":{},"interfaces/ProjectIdCallback.html":{},"interfaces/SignBlobResponse.html":{}}}],["signedjwt",{"_index":1268,"title":{},"body":{"classes/JWTAccess.html":{}}}],["simpl",{"_index":1348,"title":{},"body":{"classes/LoginTicket.html":{},"interfaces/TokenPayload.html":{},"index.html":{}}}],["simpli",{"_index":1540,"title":{},"body":{"changelog.html":{}}}],["simplifi",{"_index":859,"title":{},"body":{"interfaces/FederatedSignonCertsResponse.html":{},"interfaces/GetAccessTokenCallback.html":{},"interfaces/GetAccessTokenResponse.html":{},"interfaces/GetFederatedSignonCertsCallback.html":{},"interfaces/GetTokenCallback.html":{},"interfaces/GetTokenOptions.html":{},"interfaces/GetTokenResponse.html":{},"interfaces/OAuth2ClientOptions.html":{},"interfaces/RefreshAccessTokenCallback.html":{},"interfaces/RefreshAccessTokenResponse.html":{},"interfaces/RefreshOptions.html":{},"interfaces/RequestMetadataCallback.html":{},"interfaces/RequestMetadataResponse.html":{},"interfaces/RevokeCredentialsResult.html":{},"interfaces/TokenInfo.html":{},"interfaces/TokenInfoRequest.html":{},"interfaces/VerifyIdTokenOptions.html":{}}}],["singl",{"_index":1286,"title":{},"body":{"interfaces/JWTOptions.html":{},"index.html":{}}}],["sink",{"_index":1511,"title":{},"body":{"changelog.html":{}}}],["sinon",{"_index":1468,"title":{},"body":{"changelog.html":{}}}],["site",{"_index":831,"title":{},"body":{"interfaces/FederatedSignonCertsResponse.html":{},"interfaces/GetAccessTokenCallback.html":{},"interfaces/GetAccessTokenResponse.html":{},"interfaces/GetFederatedSignonCertsCallback.html":{},"interfaces/GetTokenCallback.html":{},"interfaces/GetTokenOptions.html":{},"interfaces/GetTokenResponse.html":{},"classes/LoginTicket.html":{},"interfaces/OAuth2ClientOptions.html":{},"interfaces/RefreshAccessTokenCallback.html":{},"interfaces/RefreshAccessTokenResponse.html":{},"interfaces/RefreshOptions.html":{},"interfaces/RequestMetadataCallback.html":{},"interfaces/RequestMetadataResponse.html":{},"interfaces/RevokeCredentialsResult.html":{},"interfaces/TokenInfo.html":{},"interfaces/TokenInfoRequest.html":{},"interfaces/TokenPayload.html":{},"interfaces/VerifyIdTokenOptions.html":{}}}],["skew",{"_index":943,"title":{},"body":{"interfaces/FederatedSignonCertsResponse.html":{},"interfaces/GetAccessTokenCallback.html":{},"interfaces/GetAccessTokenResponse.html":{},"interfaces/GetFederatedSignonCertsCallback.html":{},"interfaces/GetTokenCallback.html":{},"interfaces/GetTokenOptions.html":{},"interfaces/GetTokenResponse.html":{},"interfaces/OAuth2ClientOptions.html":{},"interfaces/RefreshAccessTokenCallback.html":{},"interfaces/RefreshAccessTokenResponse.html":{},"interfaces/RefreshOptions.html":{},"interfaces/RequestMetadataCallback.html":{},"interfaces/RequestMetadataResponse.html":{},"interfaces/RevokeCredentialsResult.html":{},"interfaces/TokenInfo.html":{},"interfaces/TokenInfoRequest.html":{},"interfaces/VerifyIdTokenOptions.html":{}}}],["slash",{"_index":786,"title":{},"body":{"interfaces/FederatedSignonCertsResponse.html":{},"interfaces/GetAccessTokenCallback.html":{},"interfaces/GetAccessTokenResponse.html":{},"interfaces/GetFederatedSignonCertsCallback.html":{},"interfaces/GetTokenCallback.html":{},"interfaces/GetTokenOptions.html":{},"interfaces/GetTokenResponse.html":{},"interfaces/OAuth2ClientOptions.html":{},"interfaces/RefreshAccessTokenCallback.html":{},"interfaces/RefreshAccessTokenResponse.html":{},"interfaces/RefreshOptions.html":{},"interfaces/RequestMetadataCallback.html":{},"interfaces/RequestMetadataResponse.html":{},"interfaces/RevokeCredentialsResult.html":{},"interfaces/TokenInfo.html":{},"interfaces/TokenInfoRequest.html":{},"interfaces/VerifyIdTokenOptions.html":{}}}],["softwar",{"_index":667,"title":{},"body":{"interfaces/Credentials.html":{},"classes/LoginTicket.html":{},"miscellaneous/functions.html":{},"license.html":{}}}],["sole",{"_index":1952,"title":{},"body":{"license.html":{}}}],["sourc",{"_index":3,"title":{},"body":{"interfaces/ADCCallback.html":{},"interfaces/ADCResponse.html":{},"interfaces/BodyResponseCallback.html":{},"interfaces/ComputeOptions.html":{},"interfaces/CredentialBody.html":{},"interfaces/CredentialCallback.html":{},"interfaces/CredentialRequest.html":{},"interfaces/Credentials.html":{},"classes/DefaultTransporter.html":{},"interfaces/FederatedSignonCertsResponse.html":{},"interfaces/GetAccessTokenCallback.html":{},"interfaces/GetAccessTokenResponse.html":{},"interfaces/GetFederatedSignonCertsCallback.html":{},"interfaces/GetTokenCallback.html":{},"interfaces/GetTokenOptions.html":{},"interfaces/GetTokenResponse.html":{},"interfaces/GoogleAuthOptions.html":{},"classes/IAMAuth.html":{},"classes/JWTAccess.html":{},"interfaces/JWTInput.html":{},"interfaces/JWTOptions.html":{},"classes/LoginTicket.html":{},"interfaces/OAuth2ClientOptions.html":{},"classes/PemVerifier.html":{},"interfaces/ProjectIdCallback.html":{},"interfaces/RefreshAccessTokenCallback.html":{},"interfaces/RefreshAccessTokenResponse.html":{},"interfaces/RefreshOptions.html":{},"interfaces/RequestError.html":{},"interfaces/RequestMetadata.html":{},"interfaces/RequestMetadataCallback.html":{},"interfaces/RequestMetadataResponse.html":{},"interfaces/RevokeCredentialsResult.html":{},"interfaces/SignBlobResponse.html":{},"interfaces/TokenInfo.html":{},"interfaces/TokenInfoRequest.html":{},"interfaces/TokenPayload.html":{},"interfaces/Transporter.html":{},"interfaces/UserRefreshClientOptions.html":{},"interfaces/VerifyIdTokenOptions.html":{},"interfaces/Warning.html":{},"index.html":{},"license.html":{}}}],["sourcemap",{"_index":1516,"title":{},"body":{"changelog.html":{}}}],["space",{"_index":787,"title":{},"body":{"interfaces/FederatedSignonCertsResponse.html":{},"interfaces/GetAccessTokenCallback.html":{},"interfaces/GetAccessTokenResponse.html":{},"interfaces/GetFederatedSignonCertsCallback.html":{},"interfaces/GetTokenCallback.html":{},"interfaces/GetTokenOptions.html":{},"interfaces/GetTokenResponse.html":{},"interfaces/OAuth2ClientOptions.html":{},"interfaces/RefreshAccessTokenCallback.html":{},"interfaces/RefreshAccessTokenResponse.html":{},"interfaces/RefreshOptions.html":{},"interfaces/RequestMetadataCallback.html":{},"interfaces/RequestMetadataResponse.html":{},"interfaces/RevokeCredentialsResult.html":{},"interfaces/TokenInfo.html":{},"interfaces/TokenInfoRequest.html":{},"interfaces/VerifyIdTokenOptions.html":{}}}],["special",{"_index":1962,"title":{},"body":{"license.html":{}}}],["specif",{"_index":675,"title":{},"body":{"interfaces/Credentials.html":{},"classes/LoginTicket.html":{},"miscellaneous/functions.html":{},"index.html":{},"license.html":{}}}],["specifi",{"_index":261,"title":{},"body":{"interfaces/ADCCallback.html":{},"interfaces/ADCResponse.html":{},"interfaces/ComputeOptions.html":{},"interfaces/CredentialCallback.html":{},"interfaces/FederatedSignonCertsResponse.html":{},"interfaces/GetAccessTokenCallback.html":{},"interfaces/GetAccessTokenResponse.html":{},"interfaces/GetFederatedSignonCertsCallback.html":{},"interfaces/GetTokenCallback.html":{},"interfaces/GetTokenOptions.html":{},"interfaces/GetTokenResponse.html":{},"interfaces/GoogleAuthOptions.html":{},"interfaces/JWTOptions.html":{},"interfaces/OAuth2ClientOptions.html":{},"interfaces/ProjectIdCallback.html":{},"interfaces/RefreshAccessTokenCallback.html":{},"interfaces/RefreshAccessTokenResponse.html":{},"interfaces/RefreshOptions.html":{},"interfaces/RequestMetadataCallback.html":{},"interfaces/RequestMetadataResponse.html":{},"interfaces/RevokeCredentialsResult.html":{},"interfaces/SignBlobResponse.html":{},"interfaces/TokenInfo.html":{},"interfaces/TokenInfoRequest.html":{},"interfaces/VerifyIdTokenOptions.html":{},"index.html":{}}}],["sponge.xml",{"_index":1503,"title":{},"body":{"changelog.html":{}}}],["spot",{"_index":1035,"title":{},"body":{"interfaces/FederatedSignonCertsResponse.html":{},"interfaces/GetAccessTokenCallback.html":{},"interfaces/GetAccessTokenResponse.html":{},"interfaces/GetFederatedSignonCertsCallback.html":{},"interfaces/GetTokenCallback.html":{},"interfaces/GetTokenOptions.html":{},"interfaces/GetTokenResponse.html":{},"interfaces/OAuth2ClientOptions.html":{},"interfaces/RefreshAccessTokenCallback.html":{},"interfaces/RefreshAccessTokenResponse.html":{},"interfaces/RefreshOptions.html":{},"interfaces/RequestMetadataCallback.html":{},"interfaces/RequestMetadataResponse.html":{},"interfaces/RevokeCredentialsResult.html":{},"interfaces/TokenInfo.html":{},"interfaces/TokenInfoRequest.html":{},"interfaces/VerifyIdTokenOptions.html":{}}}],["src/.../envdetect.t",{"_index":1650,"title":{},"body":{"miscellaneous/enumerations.html":{},"miscellaneous/functions.html":{},"miscellaneous/variables.html":{}}}],["src/.../googleauth.t",{"_index":2000,"title":{},"body":{"miscellaneous/variables.html":{}}}],["src/.../index.t",{"_index":1999,"title":{},"body":{"miscellaneous/variables.html":{}}}],["src/.../jwtaccess.t",{"_index":1998,"title":{},"body":{"miscellaneous/typealiases.html":{},"miscellaneous/variables.html":{}}}],["src/.../messages.t",{"_index":1651,"title":{},"body":{"miscellaneous/enumerations.html":{},"miscellaneous/functions.html":{},"miscellaneous/variables.html":{}}}],["src/.../oauth2client.t",{"_index":1649,"title":{},"body":{"miscellaneous/enumerations.html":{},"miscellaneous/typealiases.html":{}}}],["src/.../options.t",{"_index":1661,"title":{},"body":{"miscellaneous/functions.html":{}}}],["src/.../transporters.t",{"_index":2001,"title":{},"body":{"miscellaneous/variables.html":{}}}],["src/auth/computeclient.t",{"_index":580,"title":{},"body":{"interfaces/ComputeOptions.html":{}}}],["src/auth/credentials.t",{"_index":637,"title":{},"body":{"interfaces/CredentialBody.html":{},"interfaces/CredentialRequest.html":{},"interfaces/Credentials.html":{},"interfaces/JWTInput.html":{}}}],["src/auth/envdetect.t",{"_index":1652,"title":{},"body":{"miscellaneous/enumerations.html":{},"miscellaneous/functions.html":{},"miscellaneous/variables.html":{}}}],["src/auth/googleauth.t",{"_index":5,"title":{},"body":{"interfaces/ADCCallback.html":{},"interfaces/ADCResponse.html":{},"interfaces/CredentialCallback.html":{},"interfaces/GoogleAuthOptions.html":{},"interfaces/ProjectIdCallback.html":{},"interfaces/SignBlobResponse.html":{},"miscellaneous/variables.html":{}}}],["src/auth/iam.t",{"_index":1191,"title":{},"body":{"classes/IAMAuth.html":{},"interfaces/RequestMetadata.html":{}}}],["src/auth/iam.ts:24",{"_index":1195,"title":{},"body":{"classes/IAMAuth.html":{}}}],["src/auth/iam.ts:32",{"_index":1196,"title":{},"body":{"classes/IAMAuth.html":{}}}],["src/auth/iam.ts:43",{"_index":1197,"title":{},"body":{"classes/IAMAuth.html":{}}}],["src/auth/iam.ts:56",{"_index":1206,"title":{},"body":{"classes/IAMAuth.html":{}}}],["src/auth/iam.ts:66",{"_index":1198,"title":{},"body":{"classes/IAMAuth.html":{}}}],["src/auth/jwtaccess.t",{"_index":1218,"title":{},"body":{"classes/JWTAccess.html":{},"miscellaneous/typealiases.html":{},"miscellaneous/variables.html":{}}}],["src/auth/jwtaccess.ts:134",{"_index":1230,"title":{},"body":{"classes/JWTAccess.html":{}}}],["src/auth/jwtaccess.ts:159",{"_index":1231,"title":{},"body":{"classes/JWTAccess.html":{}}}],["src/auth/jwtaccess.ts:160",{"_index":1232,"title":{},"body":{"classes/JWTAccess.html":{}}}],["src/auth/jwtaccess.ts:162",{"_index":1233,"title":{},"body":{"classes/JWTAccess.html":{}}}],["src/auth/jwtaccess.ts:36",{"_index":1225,"title":{},"body":{"classes/JWTAccess.html":{}}}],["src/auth/jwtaccess.ts:37",{"_index":1226,"title":{},"body":{"classes/JWTAccess.html":{}}}],["src/auth/jwtaccess.ts:38",{"_index":1227,"title":{},"body":{"classes/JWTAccess.html":{}}}],["src/auth/jwtaccess.ts:39",{"_index":1228,"title":{},"body":{"classes/JWTAccess.html":{}}}],["src/auth/jwtaccess.ts:41",{"_index":1222,"title":{},"body":{"classes/JWTAccess.html":{}}}],["src/auth/jwtaccess.ts:65",{"_index":1229,"title":{},"body":{"classes/JWTAccess.html":{}}}],["src/auth/jwtaccess.ts:80",{"_index":1236,"title":{},"body":{"classes/JWTAccess.html":{}}}],["src/auth/jwtaccess.ts:94",{"_index":1235,"title":{},"body":{"classes/JWTAccess.html":{}}}],["src/auth/jwtclient.t",{"_index":1281,"title":{},"body":{"interfaces/JWTOptions.html":{}}}],["src/auth/loginticket.t",{"_index":1340,"title":{},"body":{"classes/LoginTicket.html":{},"interfaces/TokenPayload.html":{}}}],["src/auth/loginticket.ts:19",{"_index":1347,"title":{},"body":{"classes/LoginTicket.html":{}}}],["src/auth/loginticket.ts:33",{"_index":1355,"title":{},"body":{"classes/LoginTicket.html":{}}}],["src/auth/loginticket.ts:37",{"_index":1356,"title":{},"body":{"classes/LoginTicket.html":{}}}],["src/auth/loginticket.ts:46",{"_index":1357,"title":{},"body":{"classes/LoginTicket.html":{}}}],["src/auth/loginticket.ts:60",{"_index":1351,"title":{},"body":{"classes/LoginTicket.html":{}}}],["src/auth/oauth2client.t",{"_index":687,"title":{},"body":{"interfaces/FederatedSignonCertsResponse.html":{},"interfaces/GetAccessTokenCallback.html":{},"interfaces/GetAccessTokenResponse.html":{},"interfaces/GetFederatedSignonCertsCallback.html":{},"interfaces/GetTokenCallback.html":{},"interfaces/GetTokenOptions.html":{},"interfaces/GetTokenResponse.html":{},"interfaces/OAuth2ClientOptions.html":{},"interfaces/RefreshAccessTokenCallback.html":{},"interfaces/RefreshAccessTokenResponse.html":{},"interfaces/RefreshOptions.html":{},"interfaces/RequestMetadataCallback.html":{},"interfaces/RequestMetadataResponse.html":{},"interfaces/RevokeCredentialsResult.html":{},"interfaces/TokenInfo.html":{},"interfaces/TokenInfoRequest.html":{},"interfaces/VerifyIdTokenOptions.html":{},"miscellaneous/enumerations.html":{},"miscellaneous/typealiases.html":{}}}],["src/auth/refreshclient.t",{"_index":1399,"title":{},"body":{"interfaces/UserRefreshClientOptions.html":{}}}],["src/index.t",{"_index":2002,"title":{},"body":{"miscellaneous/variables.html":{}}}],["src/messages.t",{"_index":1413,"title":{},"body":{"interfaces/Warning.html":{},"miscellaneous/enumerations.html":{},"miscellaneous/functions.html":{},"miscellaneous/variables.html":{}}}],["src/options.t",{"_index":1662,"title":{},"body":{"miscellaneous/functions.html":{}}}],["src/pemverifier.t",{"_index":1386,"title":{},"body":{"classes/PemVerifier.html":{}}}],["src/pemverifier.ts:20",{"_index":1389,"title":{},"body":{"classes/PemVerifier.html":{}}}],["src/transporters.t",{"_index":497,"title":{},"body":{"interfaces/BodyResponseCallback.html":{},"classes/DefaultTransporter.html":{},"interfaces/RequestError.html":{},"interfaces/Transporter.html":{},"miscellaneous/variables.html":{}}}],["src/transporters.ts:28",{"_index":1395,"title":{},"body":{"interfaces/Transporter.html":{}}}],["src/transporters.ts:29",{"_index":1396,"title":{},"body":{"interfaces/Transporter.html":{}}}],["src/transporters.ts:31",{"_index":1397,"title":{},"body":{"interfaces/Transporter.html":{}}}],["src/transporters.ts:57",{"_index":679,"title":{},"body":{"classes/DefaultTransporter.html":{}}}],["src/transporters.ts:64",{"_index":680,"title":{},"body":{"classes/DefaultTransporter.html":{}}}],["src/transporters.ts:83",{"_index":681,"title":{},"body":{"classes/DefaultTransporter.html":{}}}],["src/transporters.ts:84",{"_index":683,"title":{},"body":{"classes/DefaultTransporter.html":{}}}],["src/transporters.ts:86",{"_index":685,"title":{},"body":{"classes/DefaultTransporter.html":{}}}],["ssl",{"_index":1803,"title":{},"body":{"index.html":{}}}],["stack",{"_index":1810,"title":{},"body":{"index.html":{}}}],["standard",{"_index":997,"title":{},"body":{"interfaces/FederatedSignonCertsResponse.html":{},"interfaces/GetAccessTokenCallback.html":{},"interfaces/GetAccessTokenResponse.html":{},"interfaces/GetFederatedSignonCertsCallback.html":{},"interfaces/GetTokenCallback.html":{},"interfaces/GetTokenOptions.html":{},"interfaces/GetTokenResponse.html":{},"interfaces/OAuth2ClientOptions.html":{},"interfaces/RefreshAccessTokenCallback.html":{},"interfaces/RefreshAccessTokenResponse.html":{},"interfaces/RefreshOptions.html":{},"interfaces/RequestMetadataCallback.html":{},"interfaces/RequestMetadataResponse.html":{},"interfaces/RevokeCredentialsResult.html":{},"interfaces/TokenInfo.html":{},"interfaces/TokenInfoRequest.html":{},"interfaces/VerifyIdTokenOptions.html":{}}}],["start",{"_index":242,"title":{"changelog.html":{},"index.html":{},"license.html":{}},"body":{"interfaces/ADCCallback.html":{},"interfaces/ADCResponse.html":{},"interfaces/ComputeOptions.html":{},"interfaces/CredentialCallback.html":{},"interfaces/FederatedSignonCertsResponse.html":{},"interfaces/GetAccessTokenCallback.html":{},"interfaces/GetAccessTokenResponse.html":{},"interfaces/GetFederatedSignonCertsCallback.html":{},"interfaces/GetTokenCallback.html":{},"interfaces/GetTokenOptions.html":{},"interfaces/GetTokenResponse.html":{},"interfaces/GoogleAuthOptions.html":{},"interfaces/OAuth2ClientOptions.html":{},"interfaces/ProjectIdCallback.html":{},"interfaces/RefreshAccessTokenCallback.html":{},"interfaces/RefreshAccessTokenResponse.html":{},"interfaces/RefreshOptions.html":{},"interfaces/RequestMetadataCallback.html":{},"interfaces/RequestMetadataResponse.html":{},"interfaces/RevokeCredentialsResult.html":{},"interfaces/SignBlobResponse.html":{},"interfaces/TokenInfo.html":{},"interfaces/TokenInfoRequest.html":{},"interfaces/VerifyIdTokenOptions.html":{},"index.html":{}}}],["stash",{"_index":1117,"title":{},"body":{"interfaces/FederatedSignonCertsResponse.html":{},"interfaces/GetAccessTokenCallback.html":{},"interfaces/GetAccessTokenResponse.html":{},"interfaces/GetFederatedSignonCertsCallback.html":{},"interfaces/GetTokenCallback.html":{},"interfaces/GetTokenOptions.html":{},"interfaces/GetTokenResponse.html":{},"interfaces/OAuth2ClientOptions.html":{},"interfaces/RefreshAccessTokenCallback.html":{},"interfaces/RefreshAccessTokenResponse.html":{},"interfaces/RefreshOptions.html":{},"interfaces/RequestMetadataCallback.html":{},"interfaces/RequestMetadataResponse.html":{},"interfaces/RevokeCredentialsResult.html":{},"interfaces/TokenInfo.html":{},"interfaces/TokenInfoRequest.html":{},"interfaces/VerifyIdTokenOptions.html":{}}}],["state",{"_index":814,"title":{},"body":{"interfaces/FederatedSignonCertsResponse.html":{},"interfaces/GetAccessTokenCallback.html":{},"interfaces/GetAccessTokenResponse.html":{},"interfaces/GetFederatedSignonCertsCallback.html":{},"interfaces/GetTokenCallback.html":{},"interfaces/GetTokenOptions.html":{},"interfaces/GetTokenResponse.html":{},"interfaces/OAuth2ClientOptions.html":{},"interfaces/RefreshAccessTokenCallback.html":{},"interfaces/RefreshAccessTokenResponse.html":{},"interfaces/RefreshOptions.html":{},"interfaces/RequestMetadataCallback.html":{},"interfaces/RequestMetadataResponse.html":{},"interfaces/RevokeCredentialsResult.html":{},"interfaces/TokenInfo.html":{},"interfaces/TokenInfoRequest.html":{},"interfaces/VerifyIdTokenOptions.html":{},"license.html":{}}}],["statement",{"_index":1934,"title":{},"body":{"license.html":{}}}],["static",{"_index":117,"title":{},"body":{"interfaces/ADCCallback.html":{},"interfaces/ADCResponse.html":{},"interfaces/BodyResponseCallback.html":{},"interfaces/CredentialCallback.html":{},"classes/DefaultTransporter.html":{},"interfaces/FederatedSignonCertsResponse.html":{},"interfaces/GetAccessTokenCallback.html":{},"interfaces/GetAccessTokenResponse.html":{},"interfaces/GetFederatedSignonCertsCallback.html":{},"interfaces/GetTokenCallback.html":{},"interfaces/GetTokenOptions.html":{},"interfaces/GetTokenResponse.html":{},"interfaces/GoogleAuthOptions.html":{},"interfaces/OAuth2ClientOptions.html":{},"interfaces/ProjectIdCallback.html":{},"interfaces/RefreshAccessTokenCallback.html":{},"interfaces/RefreshAccessTokenResponse.html":{},"interfaces/RefreshOptions.html":{},"interfaces/RequestError.html":{},"interfaces/RequestMetadataCallback.html":{},"interfaces/RequestMetadataResponse.html":{},"interfaces/RevokeCredentialsResult.html":{},"interfaces/SignBlobResponse.html":{},"interfaces/TokenInfo.html":{},"interfaces/TokenInfoRequest.html":{},"interfaces/Transporter.html":{},"interfaces/VerifyIdTokenOptions.html":{}}}],["statuscod",{"_index":1107,"title":{},"body":{"interfaces/FederatedSignonCertsResponse.html":{},"interfaces/GetAccessTokenCallback.html":{},"interfaces/GetAccessTokenResponse.html":{},"interfaces/GetFederatedSignonCertsCallback.html":{},"interfaces/GetTokenCallback.html":{},"interfaces/GetTokenOptions.html":{},"interfaces/GetTokenResponse.html":{},"interfaces/OAuth2ClientOptions.html":{},"interfaces/RefreshAccessTokenCallback.html":{},"interfaces/RefreshAccessTokenResponse.html":{},"interfaces/RefreshOptions.html":{},"interfaces/RequestMetadataCallback.html":{},"interfaces/RequestMetadataResponse.html":{},"interfaces/RevokeCredentialsResult.html":{},"interfaces/TokenInfo.html":{},"interfaces/TokenInfoRequest.html":{},"interfaces/VerifyIdTokenOptions.html":{}}}],["stderr",{"_index":400,"title":{},"body":{"interfaces/ADCCallback.html":{},"interfaces/ADCResponse.html":{},"interfaces/CredentialCallback.html":{},"interfaces/GoogleAuthOptions.html":{},"interfaces/ProjectIdCallback.html":{},"interfaces/SignBlobResponse.html":{}}}],["stdout",{"_index":399,"title":{},"body":{"interfaces/ADCCallback.html":{},"interfaces/ADCResponse.html":{},"interfaces/CredentialCallback.html":{},"interfaces/GoogleAuthOptions.html":{},"interfaces/ProjectIdCallback.html":{},"interfaces/SignBlobResponse.html":{}}}],["step",{"_index":714,"title":{},"body":{"interfaces/FederatedSignonCertsResponse.html":{},"interfaces/GetAccessTokenCallback.html":{},"interfaces/GetAccessTokenResponse.html":{},"interfaces/GetFederatedSignonCertsCallback.html":{},"interfaces/GetTokenCallback.html":{},"interfaces/GetTokenOptions.html":{},"interfaces/GetTokenResponse.html":{},"classes/LoginTicket.html":{},"interfaces/OAuth2ClientOptions.html":{},"interfaces/RefreshAccessTokenCallback.html":{},"interfaces/RefreshAccessTokenResponse.html":{},"interfaces/RefreshOptions.html":{},"interfaces/RequestMetadataCallback.html":{},"interfaces/RequestMetadataResponse.html":{},"interfaces/RevokeCredentialsResult.html":{},"interfaces/TokenInfo.html":{},"interfaces/TokenInfoRequest.html":{},"interfaces/TokenPayload.html":{},"interfaces/VerifyIdTokenOptions.html":{}}}],["stoppag",{"_index":1969,"title":{},"body":{"license.html":{}}}],["store",{"_index":1683,"title":{},"body":{"index.html":{}}}],["straighten",{"_index":1632,"title":{},"body":{"changelog.html":{}}}],["stream",{"_index":34,"title":{},"body":{"interfaces/ADCCallback.html":{},"interfaces/ADCResponse.html":{},"interfaces/CredentialCallback.html":{},"interfaces/FederatedSignonCertsResponse.html":{},"interfaces/GetAccessTokenCallback.html":{},"interfaces/GetAccessTokenResponse.html":{},"interfaces/GetFederatedSignonCertsCallback.html":{},"interfaces/GetTokenCallback.html":{},"interfaces/GetTokenOptions.html":{},"interfaces/GetTokenResponse.html":{},"interfaces/GoogleAuthOptions.html":{},"classes/JWTAccess.html":{},"interfaces/JWTOptions.html":{},"interfaces/OAuth2ClientOptions.html":{},"interfaces/ProjectIdCallback.html":{},"interfaces/RefreshAccessTokenCallback.html":{},"interfaces/RefreshAccessTokenResponse.html":{},"interfaces/RefreshOptions.html":{},"interfaces/RequestMetadataCallback.html":{},"interfaces/RequestMetadataResponse.html":{},"interfaces/RevokeCredentialsResult.html":{},"interfaces/SignBlobResponse.html":{},"interfaces/TokenInfo.html":{},"interfaces/TokenInfoRequest.html":{},"interfaces/UserRefreshClientOptions.html":{},"interfaces/VerifyIdTokenOptions.html":{},"changelog.html":{}}}],["stream.read",{"_index":339,"title":{},"body":{"interfaces/ADCCallback.html":{},"interfaces/ADCResponse.html":{},"interfaces/CredentialCallback.html":{},"interfaces/FederatedSignonCertsResponse.html":{},"interfaces/GetAccessTokenCallback.html":{},"interfaces/GetAccessTokenResponse.html":{},"interfaces/GetFederatedSignonCertsCallback.html":{},"interfaces/GetTokenCallback.html":{},"interfaces/GetTokenOptions.html":{},"interfaces/GetTokenResponse.html":{},"interfaces/GoogleAuthOptions.html":{},"classes/JWTAccess.html":{},"interfaces/JWTOptions.html":{},"interfaces/OAuth2ClientOptions.html":{},"interfaces/ProjectIdCallback.html":{},"interfaces/RefreshAccessTokenCallback.html":{},"interfaces/RefreshAccessTokenResponse.html":{},"interfaces/RefreshOptions.html":{},"interfaces/RequestMetadataCallback.html":{},"interfaces/RequestMetadataResponse.html":{},"interfaces/RevokeCredentialsResult.html":{},"interfaces/SignBlobResponse.html":{},"interfaces/TokenInfo.html":{},"interfaces/TokenInfoRequest.html":{},"interfaces/UserRefreshClientOptions.html":{},"interfaces/VerifyIdTokenOptions.html":{}}}],["streamlin",{"_index":758,"title":{},"body":{"interfaces/FederatedSignonCertsResponse.html":{},"interfaces/GetAccessTokenCallback.html":{},"interfaces/GetAccessTokenResponse.html":{},"interfaces/GetFederatedSignonCertsCallback.html":{},"interfaces/GetTokenCallback.html":{},"interfaces/GetTokenOptions.html":{},"interfaces/GetTokenResponse.html":{},"interfaces/OAuth2ClientOptions.html":{},"interfaces/RefreshAccessTokenCallback.html":{},"interfaces/RefreshAccessTokenResponse.html":{},"interfaces/RefreshOptions.html":{},"interfaces/RequestMetadataCallback.html":{},"interfaces/RequestMetadataResponse.html":{},"interfaces/RevokeCredentialsResult.html":{},"interfaces/TokenInfo.html":{},"interfaces/TokenInfoRequest.html":{},"interfaces/VerifyIdTokenOptions.html":{}}}],["strictequ",{"_index":1620,"title":{},"body":{"changelog.html":{}}}],["string",{"_index":17,"title":{},"body":{"interfaces/ADCCallback.html":{},"interfaces/ADCResponse.html":{},"interfaces/BodyResponseCallback.html":{},"interfaces/ComputeOptions.html":{},"interfaces/CredentialBody.html":{},"interfaces/CredentialCallback.html":{},"interfaces/CredentialRequest.html":{},"interfaces/Credentials.html":{},"classes/DefaultTransporter.html":{},"interfaces/FederatedSignonCertsResponse.html":{},"interfaces/GetAccessTokenCallback.html":{},"interfaces/GetAccessTokenResponse.html":{},"interfaces/GetFederatedSignonCertsCallback.html":{},"interfaces/GetTokenCallback.html":{},"interfaces/GetTokenOptions.html":{},"interfaces/GetTokenResponse.html":{},"interfaces/GoogleAuthOptions.html":{},"classes/IAMAuth.html":{},"classes/JWTAccess.html":{},"interfaces/JWTInput.html":{},"interfaces/JWTOptions.html":{},"classes/LoginTicket.html":{},"interfaces/OAuth2ClientOptions.html":{},"classes/PemVerifier.html":{},"interfaces/ProjectIdCallback.html":{},"interfaces/RefreshAccessTokenCallback.html":{},"interfaces/RefreshAccessTokenResponse.html":{},"interfaces/RefreshOptions.html":{},"interfaces/RequestError.html":{},"interfaces/RequestMetadata.html":{},"interfaces/RequestMetadataCallback.html":{},"interfaces/RequestMetadataResponse.html":{},"interfaces/RevokeCredentialsResult.html":{},"interfaces/SignBlobResponse.html":{},"interfaces/TokenInfo.html":{},"interfaces/TokenInfoRequest.html":{},"interfaces/TokenPayload.html":{},"interfaces/Transporter.html":{},"interfaces/UserRefreshClientOptions.html":{},"interfaces/VerifyIdTokenOptions.html":{},"interfaces/Warning.html":{},"index.html":{},"miscellaneous/variables.html":{}}}],["string(err",{"_index":391,"title":{},"body":{"interfaces/ADCCallback.html":{},"interfaces/ADCResponse.html":{},"interfaces/CredentialCallback.html":{},"interfaces/GoogleAuthOptions.html":{},"interfaces/ProjectIdCallback.html":{},"interfaces/SignBlobResponse.html":{}}}],["string(this.scopes).length",{"_index":1319,"title":{},"body":{"interfaces/JWTOptions.html":{}}}],["string[]|str",{"_index":812,"title":{},"body":{"interfaces/FederatedSignonCertsResponse.html":{},"interfaces/GetAccessTokenCallback.html":{},"interfaces/GetAccessTokenResponse.html":{},"interfaces/GetFederatedSignonCertsCallback.html":{},"interfaces/GetTokenCallback.html":{},"interfaces/GetTokenOptions.html":{},"interfaces/GetTokenResponse.html":{},"interfaces/OAuth2ClientOptions.html":{},"interfaces/RefreshAccessTokenCallback.html":{},"interfaces/RefreshAccessTokenResponse.html":{},"interfaces/RefreshOptions.html":{},"interfaces/RequestMetadataCallback.html":{},"interfaces/RequestMetadataResponse.html":{},"interfaces/RevokeCredentialsResult.html":{},"interfaces/TokenInfo.html":{},"interfaces/TokenInfoRequest.html":{},"interfaces/VerifyIdTokenOptions.html":{}}}],["string|buff",{"_index":1391,"title":{},"body":{"classes/PemVerifier.html":{}}}],["string|gettokenopt",{"_index":1006,"title":{},"body":{"interfaces/FederatedSignonCertsResponse.html":{},"interfaces/GetAccessTokenCallback.html":{},"interfaces/GetAccessTokenResponse.html":{},"interfaces/GetFederatedSignonCertsCallback.html":{},"interfaces/GetTokenCallback.html":{},"interfaces/GetTokenOptions.html":{},"interfaces/GetTokenResponse.html":{},"interfaces/OAuth2ClientOptions.html":{},"interfaces/RefreshAccessTokenCallback.html":{},"interfaces/RefreshAccessTokenResponse.html":{},"interfaces/RefreshOptions.html":{},"interfaces/RequestMetadataCallback.html":{},"interfaces/RequestMetadataResponse.html":{},"interfaces/RevokeCredentialsResult.html":{},"interfaces/TokenInfo.html":{},"interfaces/TokenInfoRequest.html":{},"interfaces/VerifyIdTokenOptions.html":{}}}],["string|jwtopt",{"_index":1291,"title":{},"body":{"interfaces/JWTOptions.html":{}}}],["string|nul",{"_index":56,"title":{},"body":{"interfaces/ADCCallback.html":{},"interfaces/ADCResponse.html":{},"interfaces/CredentialBody.html":{},"interfaces/CredentialCallback.html":{},"interfaces/CredentialRequest.html":{},"interfaces/Credentials.html":{},"interfaces/FederatedSignonCertsResponse.html":{},"interfaces/GetAccessTokenCallback.html":{},"interfaces/GetAccessTokenResponse.html":{},"interfaces/GetFederatedSignonCertsCallback.html":{},"interfaces/GetTokenCallback.html":{},"interfaces/GetTokenOptions.html":{},"interfaces/GetTokenResponse.html":{},"interfaces/GoogleAuthOptions.html":{},"classes/IAMAuth.html":{},"classes/JWTAccess.html":{},"interfaces/JWTInput.html":{},"interfaces/JWTOptions.html":{},"interfaces/OAuth2ClientOptions.html":{},"interfaces/ProjectIdCallback.html":{},"interfaces/RefreshAccessTokenCallback.html":{},"interfaces/RefreshAccessTokenResponse.html":{},"interfaces/RefreshOptions.html":{},"interfaces/RequestMetadata.html":{},"interfaces/RequestMetadataCallback.html":{},"interfaces/RequestMetadataResponse.html":{},"interfaces/RevokeCredentialsResult.html":{},"interfaces/SignBlobResponse.html":{},"interfaces/TokenInfo.html":{},"interfaces/TokenInfoRequest.html":{},"interfaces/UserRefreshClientOptions.html":{},"interfaces/VerifyIdTokenOptions.html":{}}}],["string|oauth2clientopt",{"_index":919,"title":{},"body":{"interfaces/FederatedSignonCertsResponse.html":{},"interfaces/GetAccessTokenCallback.html":{},"interfaces/GetAccessTokenResponse.html":{},"interfaces/GetFederatedSignonCertsCallback.html":{},"interfaces/GetTokenCallback.html":{},"interfaces/GetTokenOptions.html":{},"interfaces/GetTokenResponse.html":{},"interfaces/OAuth2ClientOptions.html":{},"interfaces/RefreshAccessTokenCallback.html":{},"interfaces/RefreshAccessTokenResponse.html":{},"interfaces/RefreshOptions.html":{},"interfaces/RequestMetadataCallback.html":{},"interfaces/RequestMetadataResponse.html":{},"interfaces/RevokeCredentialsResult.html":{},"interfaces/TokenInfo.html":{},"interfaces/TokenInfoRequest.html":{},"interfaces/VerifyIdTokenOptions.html":{}}}],["string|str",{"_index":77,"title":{},"body":{"interfaces/ADCCallback.html":{},"interfaces/ADCResponse.html":{},"interfaces/CredentialCallback.html":{},"interfaces/FederatedSignonCertsResponse.html":{},"interfaces/GetAccessTokenCallback.html":{},"interfaces/GetAccessTokenResponse.html":{},"interfaces/GetFederatedSignonCertsCallback.html":{},"interfaces/GetTokenCallback.html":{},"interfaces/GetTokenOptions.html":{},"interfaces/GetTokenResponse.html":{},"interfaces/GoogleAuthOptions.html":{},"interfaces/JWTOptions.html":{},"interfaces/OAuth2ClientOptions.html":{},"interfaces/ProjectIdCallback.html":{},"interfaces/RefreshAccessTokenCallback.html":{},"interfaces/RefreshAccessTokenResponse.html":{},"interfaces/RefreshOptions.html":{},"interfaces/RequestMetadataCallback.html":{},"interfaces/RequestMetadataResponse.html":{},"interfaces/RevokeCredentialsResult.html":{},"interfaces/SignBlobResponse.html":{},"interfaces/TokenInfo.html":{},"interfaces/TokenInfoRequest.html":{},"interfaces/VerifyIdTokenOptions.html":{}}}],["string|userrefreshclientopt",{"_index":1406,"title":{},"body":{"interfaces/UserRefreshClientOptions.html":{}}}],["structur",{"_index":1157,"title":{},"body":{"interfaces/FederatedSignonCertsResponse.html":{},"interfaces/GetAccessTokenCallback.html":{},"interfaces/GetAccessTokenResponse.html":{},"interfaces/GetFederatedSignonCertsCallback.html":{},"interfaces/GetTokenCallback.html":{},"interfaces/GetTokenOptions.html":{},"interfaces/GetTokenResponse.html":{},"interfaces/OAuth2ClientOptions.html":{},"interfaces/RefreshAccessTokenCallback.html":{},"interfaces/RefreshAccessTokenResponse.html":{},"interfaces/RefreshOptions.html":{},"interfaces/RequestMetadataCallback.html":{},"interfaces/RequestMetadataResponse.html":{},"interfaces/RevokeCredentialsResult.html":{},"interfaces/TokenInfo.html":{},"interfaces/TokenInfoRequest.html":{},"interfaces/VerifyIdTokenOptions.html":{}}}],["style",{"_index":543,"title":{},"body":{"interfaces/BodyResponseCallback.html":{},"classes/DefaultTransporter.html":{},"interfaces/RequestError.html":{},"interfaces/Transporter.html":{}}}],["sub",{"_index":733,"title":{},"body":{"interfaces/FederatedSignonCertsResponse.html":{},"interfaces/GetAccessTokenCallback.html":{},"interfaces/GetAccessTokenResponse.html":{},"interfaces/GetFederatedSignonCertsCallback.html":{},"interfaces/GetTokenCallback.html":{},"interfaces/GetTokenOptions.html":{},"interfaces/GetTokenResponse.html":{},"classes/JWTAccess.html":{},"interfaces/JWTOptions.html":{},"classes/LoginTicket.html":{},"interfaces/OAuth2ClientOptions.html":{},"interfaces/RefreshAccessTokenCallback.html":{},"interfaces/RefreshAccessTokenResponse.html":{},"interfaces/RefreshOptions.html":{},"interfaces/RequestMetadataCallback.html":{},"interfaces/RequestMetadataResponse.html":{},"interfaces/RevokeCredentialsResult.html":{},"interfaces/TokenInfo.html":{},"interfaces/TokenInfoRequest.html":{},"interfaces/TokenPayload.html":{},"interfaces/VerifyIdTokenOptions.html":{}}}],["subject",{"_index":1282,"title":{},"body":{"interfaces/JWTOptions.html":{},"license.html":{}}}],["sublicens",{"_index":1893,"title":{},"body":{"license.html":{}}}],["submiss",{"_index":1936,"title":{},"body":{"license.html":{}}}],["submit",{"_index":1867,"title":{},"body":{"license.html":{}}}],["subsequ",{"_index":1879,"title":{},"body":{"license.html":{}}}],["subtl",{"_index":1539,"title":{},"body":{"changelog.html":{}}}],["success",{"_index":889,"title":{},"body":{"interfaces/FederatedSignonCertsResponse.html":{},"interfaces/GetAccessTokenCallback.html":{},"interfaces/GetAccessTokenResponse.html":{},"interfaces/GetFederatedSignonCertsCallback.html":{},"interfaces/GetTokenCallback.html":{},"interfaces/GetTokenOptions.html":{},"interfaces/GetTokenResponse.html":{},"interfaces/OAuth2ClientOptions.html":{},"interfaces/RefreshAccessTokenCallback.html":{},"interfaces/RefreshAccessTokenResponse.html":{},"interfaces/RefreshOptions.html":{},"interfaces/RequestMetadataCallback.html":{},"interfaces/RequestMetadataResponse.html":{},"interfaces/RevokeCredentialsResult.html":{},"interfaces/TokenInfo.html":{},"interfaces/TokenInfoRequest.html":{},"interfaces/VerifyIdTokenOptions.html":{},"index.html":{}}}],["such",{"_index":826,"title":{},"body":{"interfaces/FederatedSignonCertsResponse.html":{},"interfaces/GetAccessTokenCallback.html":{},"interfaces/GetAccessTokenResponse.html":{},"interfaces/GetFederatedSignonCertsCallback.html":{},"interfaces/GetTokenCallback.html":{},"interfaces/GetTokenOptions.html":{},"interfaces/GetTokenResponse.html":{},"interfaces/OAuth2ClientOptions.html":{},"interfaces/RefreshAccessTokenCallback.html":{},"interfaces/RefreshAccessTokenResponse.html":{},"interfaces/RefreshOptions.html":{},"interfaces/RequestMetadataCallback.html":{},"interfaces/RequestMetadataResponse.html":{},"interfaces/RevokeCredentialsResult.html":{},"interfaces/TokenInfo.html":{},"interfaces/TokenInfoRequest.html":{},"interfaces/VerifyIdTokenOptions.html":{},"license.html":{}}}],["suit",{"_index":762,"title":{},"body":{"interfaces/FederatedSignonCertsResponse.html":{},"interfaces/GetAccessTokenCallback.html":{},"interfaces/GetAccessTokenResponse.html":{},"interfaces/GetFederatedSignonCertsCallback.html":{},"interfaces/GetTokenCallback.html":{},"interfaces/GetTokenOptions.html":{},"interfaces/GetTokenResponse.html":{},"classes/LoginTicket.html":{},"interfaces/OAuth2ClientOptions.html":{},"interfaces/RefreshAccessTokenCallback.html":{},"interfaces/RefreshAccessTokenResponse.html":{},"interfaces/RefreshOptions.html":{},"interfaces/RequestMetadataCallback.html":{},"interfaces/RequestMetadataResponse.html":{},"interfaces/RevokeCredentialsResult.html":{},"interfaces/TokenInfo.html":{},"interfaces/TokenInfoRequest.html":{},"interfaces/TokenPayload.html":{},"interfaces/VerifyIdTokenOptions.html":{},"index.html":{}}}],["suitabl",{"_index":1371,"title":{},"body":{"classes/LoginTicket.html":{},"interfaces/TokenPayload.html":{}}}],["super",{"_index":920,"title":{},"body":{"interfaces/FederatedSignonCertsResponse.html":{},"interfaces/GetAccessTokenCallback.html":{},"interfaces/GetAccessTokenResponse.html":{},"interfaces/GetFederatedSignonCertsCallback.html":{},"interfaces/GetTokenCallback.html":{},"interfaces/GetTokenOptions.html":{},"interfaces/GetTokenResponse.html":{},"interfaces/OAuth2ClientOptions.html":{},"interfaces/RefreshAccessTokenCallback.html":{},"interfaces/RefreshAccessTokenResponse.html":{},"interfaces/RefreshOptions.html":{},"interfaces/RequestMetadataCallback.html":{},"interfaces/RequestMetadataResponse.html":{},"interfaces/RevokeCredentialsResult.html":{},"interfaces/TokenInfo.html":{},"interfaces/TokenInfoRequest.html":{},"interfaces/UserRefreshClientOptions.html":{},"interfaces/VerifyIdTokenOptions.html":{}}}],["super(opt",{"_index":589,"title":{},"body":{"interfaces/ComputeOptions.html":{}}}],["super({eagerrefreshthresholdmilli",{"_index":1292,"title":{},"body":{"interfaces/JWTOptions.html":{}}}],["super.getrequestmetadataasync(url",{"_index":1311,"title":{},"body":{"interfaces/JWTOptions.html":{}}}],["super.refreshtokennocache(this._refreshtoken",{"_index":1409,"title":{},"body":{"interfaces/UserRefreshClientOptions.html":{}}}],["super.requestasync(opt",{"_index":625,"title":{},"body":{"interfaces/ComputeOptions.html":{}}}],["supersed",{"_index":1941,"title":{},"body":{"license.html":{}}}],["suppli",{"_index":1125,"title":{},"body":{"interfaces/FederatedSignonCertsResponse.html":{},"interfaces/GetAccessTokenCallback.html":{},"interfaces/GetAccessTokenResponse.html":{},"interfaces/GetFederatedSignonCertsCallback.html":{},"interfaces/GetTokenCallback.html":{},"interfaces/GetTokenOptions.html":{},"interfaces/GetTokenResponse.html":{},"classes/LoginTicket.html":{},"interfaces/OAuth2ClientOptions.html":{},"interfaces/RefreshAccessTokenCallback.html":{},"interfaces/RefreshAccessTokenResponse.html":{},"interfaces/RefreshOptions.html":{},"interfaces/RequestMetadataCallback.html":{},"interfaces/RequestMetadataResponse.html":{},"interfaces/RevokeCredentialsResult.html":{},"interfaces/TokenInfo.html":{},"interfaces/TokenInfoRequest.html":{},"interfaces/TokenPayload.html":{},"interfaces/VerifyIdTokenOptions.html":{}}}],["support",{"_index":158,"title":{},"body":{"interfaces/ADCCallback.html":{},"interfaces/ADCResponse.html":{},"interfaces/CredentialCallback.html":{},"interfaces/FederatedSignonCertsResponse.html":{},"interfaces/GetAccessTokenCallback.html":{},"interfaces/GetAccessTokenResponse.html":{},"interfaces/GetFederatedSignonCertsCallback.html":{},"interfaces/GetTokenCallback.html":{},"interfaces/GetTokenOptions.html":{},"interfaces/GetTokenResponse.html":{},"interfaces/GoogleAuthOptions.html":{},"interfaces/OAuth2ClientOptions.html":{},"interfaces/ProjectIdCallback.html":{},"interfaces/RefreshAccessTokenCallback.html":{},"interfaces/RefreshAccessTokenResponse.html":{},"interfaces/RefreshOptions.html":{},"interfaces/RequestMetadataCallback.html":{},"interfaces/RequestMetadataResponse.html":{},"interfaces/RevokeCredentialsResult.html":{},"interfaces/SignBlobResponse.html":{},"interfaces/TokenInfo.html":{},"interfaces/TokenInfoRequest.html":{},"interfaces/VerifyIdTokenOptions.html":{},"interfaces/Warning.html":{},"changelog.html":{},"index.html":{},"license.html":{}}}],["sure",{"_index":291,"title":{},"body":{"interfaces/ADCCallback.html":{},"interfaces/ADCResponse.html":{},"interfaces/CredentialCallback.html":{},"interfaces/FederatedSignonCertsResponse.html":{},"interfaces/GetAccessTokenCallback.html":{},"interfaces/GetAccessTokenResponse.html":{},"interfaces/GetFederatedSignonCertsCallback.html":{},"interfaces/GetTokenCallback.html":{},"interfaces/GetTokenOptions.html":{},"interfaces/GetTokenResponse.html":{},"interfaces/GoogleAuthOptions.html":{},"interfaces/OAuth2ClientOptions.html":{},"interfaces/ProjectIdCallback.html":{},"interfaces/RefreshAccessTokenCallback.html":{},"interfaces/RefreshAccessTokenResponse.html":{},"interfaces/RefreshOptions.html":{},"interfaces/RequestMetadataCallback.html":{},"interfaces/RequestMetadataResponse.html":{},"interfaces/RevokeCredentialsResult.html":{},"interfaces/SignBlobResponse.html":{},"interfaces/TokenInfo.html":{},"interfaces/TokenInfoRequest.html":{},"interfaces/VerifyIdTokenOptions.html":{},"index.html":{}}}],["surfac",{"_index":1566,"title":{},"body":{"changelog.html":{}}}],["swap",{"_index":988,"title":{},"body":{"interfaces/FederatedSignonCertsResponse.html":{},"interfaces/GetAccessTokenCallback.html":{},"interfaces/GetAccessTokenResponse.html":{},"interfaces/GetFederatedSignonCertsCallback.html":{},"interfaces/GetTokenCallback.html":{},"interfaces/GetTokenOptions.html":{},"interfaces/GetTokenResponse.html":{},"interfaces/OAuth2ClientOptions.html":{},"interfaces/RefreshAccessTokenCallback.html":{},"interfaces/RefreshAccessTokenResponse.html":{},"interfaces/RefreshOptions.html":{},"interfaces/RequestMetadataCallback.html":{},"interfaces/RequestMetadataResponse.html":{},"interfaces/RevokeCredentialsResult.html":{},"interfaces/TokenInfo.html":{},"interfaces/TokenInfoRequest.html":{},"interfaces/VerifyIdTokenOptions.html":{}}}],["sy",{"_index":362,"title":{},"body":{"interfaces/ADCCallback.html":{},"interfaces/ADCResponse.html":{},"interfaces/CredentialCallback.html":{},"interfaces/GoogleAuthOptions.html":{},"interfaces/ProjectIdCallback.html":{},"interfaces/SignBlobResponse.html":{}}}],["symlink",{"_index":298,"title":{},"body":{"interfaces/ADCCallback.html":{},"interfaces/ADCResponse.html":{},"interfaces/CredentialCallback.html":{},"interfaces/GoogleAuthOptions.html":{},"interfaces/ProjectIdCallback.html":{},"interfaces/SignBlobResponse.html":{}}}],["syntax",{"_index":1424,"title":{},"body":{"interfaces/Warning.html":{},"license.html":{}}}],["synth",{"_index":1583,"title":{},"body":{"changelog.html":{}}}],["sys.length",{"_index":364,"title":{},"body":{"interfaces/ADCCallback.html":{},"interfaces/ADCResponse.html":{},"interfaces/CredentialCallback.html":{},"interfaces/GoogleAuthOptions.html":{},"interfaces/ProjectIdCallback.html":{},"interfaces/SignBlobResponse.html":{}}}],["sys.substring(0",{"_index":366,"title":{},"body":{"interfaces/ADCCallback.html":{},"interfaces/ADCResponse.html":{},"interfaces/CredentialCallback.html":{},"interfaces/GoogleAuthOptions.html":{},"interfaces/ProjectIdCallback.html":{},"interfaces/SignBlobResponse.html":{}}}],["system",{"_index":360,"title":{},"body":{"interfaces/ADCCallback.html":{},"interfaces/ADCResponse.html":{},"interfaces/CredentialCallback.html":{},"interfaces/GoogleAuthOptions.html":{},"interfaces/ProjectIdCallback.html":{},"interfaces/SignBlobResponse.html":{},"changelog.html":{},"index.html":{},"license.html":{}}}],["t",{"_index":682,"title":{},"body":{"classes/DefaultTransporter.html":{},"interfaces/Transporter.html":{}}}],["take",{"_index":245,"title":{},"body":{"interfaces/ADCCallback.html":{},"interfaces/ADCResponse.html":{},"interfaces/CredentialCallback.html":{},"interfaces/FederatedSignonCertsResponse.html":{},"interfaces/GetAccessTokenCallback.html":{},"interfaces/GetAccessTokenResponse.html":{},"interfaces/GetFederatedSignonCertsCallback.html":{},"interfaces/GetTokenCallback.html":{},"interfaces/GetTokenOptions.html":{},"interfaces/GetTokenResponse.html":{},"interfaces/GoogleAuthOptions.html":{},"interfaces/OAuth2ClientOptions.html":{},"interfaces/ProjectIdCallback.html":{},"interfaces/RefreshAccessTokenCallback.html":{},"interfaces/RefreshAccessTokenResponse.html":{},"interfaces/RefreshOptions.html":{},"interfaces/RequestMetadataCallback.html":{},"interfaces/RequestMetadataResponse.html":{},"interfaces/RevokeCredentialsResult.html":{},"interfaces/SignBlobResponse.html":{},"interfaces/TokenInfo.html":{},"interfaces/TokenInfoRequest.html":{},"interfaces/VerifyIdTokenOptions.html":{},"index.html":{}}}],["target_audi",{"_index":1305,"title":{},"body":{"interfaces/JWTOptions.html":{}}}],["templat",{"_index":1491,"title":{},"body":{"changelog.html":{}}}],["term",{"_index":1820,"title":{},"body":{"license.html":{}}}],["termin",{"_index":1911,"title":{},"body":{"license.html":{}}}],["test",{"_index":104,"title":{},"body":{"interfaces/ADCCallback.html":{},"interfaces/ADCResponse.html":{},"interfaces/CredentialCallback.html":{},"interfaces/FederatedSignonCertsResponse.html":{},"interfaces/GetAccessTokenCallback.html":{},"interfaces/GetAccessTokenResponse.html":{},"interfaces/GetFederatedSignonCertsCallback.html":{},"interfaces/GetTokenCallback.html":{},"interfaces/GetTokenOptions.html":{},"interfaces/GetTokenResponse.html":{},"interfaces/GoogleAuthOptions.html":{},"interfaces/OAuth2ClientOptions.html":{},"interfaces/ProjectIdCallback.html":{},"interfaces/RefreshAccessTokenCallback.html":{},"interfaces/RefreshAccessTokenResponse.html":{},"interfaces/RefreshOptions.html":{},"interfaces/RequestMetadataCallback.html":{},"interfaces/RequestMetadataResponse.html":{},"interfaces/RevokeCredentialsResult.html":{},"interfaces/SignBlobResponse.html":{},"interfaces/TokenInfo.html":{},"interfaces/TokenInfoRequest.html":{},"interfaces/UserRefreshClientOptions.html":{},"interfaces/VerifyIdTokenOptions.html":{},"changelog.html":{}}}],["text",{"_index":1816,"title":{},"body":{"index.html":{},"license.html":{}}}],["that'",{"_index":1223,"title":{},"body":{"classes/JWTAccess.html":{}}}],["then(r",{"_index":343,"title":{},"body":{"interfaces/ADCCallback.html":{},"interfaces/ADCResponse.html":{},"interfaces/CredentialCallback.html":{},"interfaces/GoogleAuthOptions.html":{},"interfaces/ProjectIdCallback.html":{},"interfaces/SignBlobResponse.html":{}}}],["theori",{"_index":1955,"title":{},"body":{"license.html":{}}}],["thereof",{"_index":1865,"title":{},"body":{"license.html":{}}}],["third",{"_index":1927,"title":{},"body":{"license.html":{}}}],["this._cachedprojectid",{"_index":120,"title":{},"body":{"interfaces/ADCCallback.html":{},"interfaces/ADCResponse.html":{},"interfaces/CredentialCallback.html":{},"interfaces/GoogleAuthOptions.html":{},"interfaces/ProjectIdCallback.html":{},"interfaces/SignBlobResponse.html":{}}}],["this._checkisgc",{"_index":230,"title":{},"body":{"interfaces/ADCCallback.html":{},"interfaces/ADCResponse.html":{},"interfaces/CredentialCallback.html":{},"interfaces/GoogleAuthOptions.html":{},"interfaces/ProjectIdCallback.html":{},"interfaces/SignBlobResponse.html":{}}}],["this._clientid",{"_index":921,"title":{},"body":{"interfaces/FederatedSignonCertsResponse.html":{},"interfaces/GetAccessTokenCallback.html":{},"interfaces/GetAccessTokenResponse.html":{},"interfaces/GetFederatedSignonCertsCallback.html":{},"interfaces/GetTokenCallback.html":{},"interfaces/GetTokenOptions.html":{},"interfaces/GetTokenResponse.html":{},"interfaces/OAuth2ClientOptions.html":{},"interfaces/RefreshAccessTokenCallback.html":{},"interfaces/RefreshAccessTokenResponse.html":{},"interfaces/RefreshOptions.html":{},"interfaces/RequestMetadataCallback.html":{},"interfaces/RequestMetadataResponse.html":{},"interfaces/RevokeCredentialsResult.html":{},"interfaces/TokenInfo.html":{},"interfaces/TokenInfoRequest.html":{},"interfaces/UserRefreshClientOptions.html":{},"interfaces/VerifyIdTokenOptions.html":{}}}],["this._clientsecret",{"_index":923,"title":{},"body":{"interfaces/FederatedSignonCertsResponse.html":{},"interfaces/GetAccessTokenCallback.html":{},"interfaces/GetAccessTokenResponse.html":{},"interfaces/GetFederatedSignonCertsCallback.html":{},"interfaces/GetTokenCallback.html":{},"interfaces/GetTokenOptions.html":{},"interfaces/GetTokenResponse.html":{},"interfaces/OAuth2ClientOptions.html":{},"interfaces/RefreshAccessTokenCallback.html":{},"interfaces/RefreshAccessTokenResponse.html":{},"interfaces/RefreshOptions.html":{},"interfaces/RequestMetadataCallback.html":{},"interfaces/RequestMetadataResponse.html":{},"interfaces/RevokeCredentialsResult.html":{},"interfaces/TokenInfo.html":{},"interfaces/TokenInfoRequest.html":{},"interfaces/UserRefreshClientOptions.html":{},"interfaces/VerifyIdTokenOptions.html":{}}}],["this._createreadstream(filepath",{"_index":309,"title":{},"body":{"interfaces/ADCCallback.html":{},"interfaces/ADCResponse.html":{},"interfaces/CredentialCallback.html":{},"interfaces/GoogleAuthOptions.html":{},"interfaces/ProjectIdCallback.html":{},"interfaces/SignBlobResponse.html":{}}}],["this._fileexists(loc",{"_index":282,"title":{},"body":{"interfaces/ADCCallback.html":{},"interfaces/ADCResponse.html":{},"interfaces/CredentialCallback.html":{},"interfaces/GoogleAuthOptions.html":{},"interfaces/ProjectIdCallback.html":{},"interfaces/SignBlobResponse.html":{}}}],["this._getapplicationcredentialsfromfilepath",{"_index":257,"title":{},"body":{"interfaces/ADCCallback.html":{},"interfaces/ADCResponse.html":{},"interfaces/CredentialCallback.html":{},"interfaces/GoogleAuthOptions.html":{},"interfaces/ProjectIdCallback.html":{},"interfaces/SignBlobResponse.html":{}}}],["this._getapplicationcredentialsfromfilepath(loc",{"_index":285,"title":{},"body":{"interfaces/ADCCallback.html":{},"interfaces/ADCResponse.html":{},"interfaces/CredentialCallback.html":{},"interfaces/GoogleAuthOptions.html":{},"interfaces/ProjectIdCallback.html":{},"interfaces/SignBlobResponse.html":{}}}],["this._getdefaultprojectidpromis",{"_index":175,"title":{},"body":{"interfaces/ADCCallback.html":{},"interfaces/ADCResponse.html":{},"interfaces/CredentialCallback.html":{},"interfaces/GoogleAuthOptions.html":{},"interfaces/ProjectIdCallback.html":{},"interfaces/SignBlobResponse.html":{}}}],["this._iswindow",{"_index":268,"title":{},"body":{"interfaces/ADCCallback.html":{},"interfaces/ADCResponse.html":{},"interfaces/CredentialCallback.html":{},"interfaces/GoogleAuthOptions.html":{},"interfaces/ProjectIdCallback.html":{},"interfaces/SignBlobResponse.html":{}}}],["this._mockwellknownfilepath(loc",{"_index":281,"title":{},"body":{"interfaces/ADCCallback.html":{},"interfaces/ADCResponse.html":{},"interfaces/CredentialCallback.html":{},"interfaces/GoogleAuthOptions.html":{},"interfaces/ProjectIdCallback.html":{},"interfaces/SignBlobResponse.html":{}}}],["this._osplatform",{"_index":363,"title":{},"body":{"interfaces/ADCCallback.html":{},"interfaces/ADCResponse.html":{},"interfaces/CredentialCallback.html":{},"interfaces/GoogleAuthOptions.html":{},"interfaces/ProjectIdCallback.html":{},"interfaces/SignBlobResponse.html":{}}}],["this._pathjoin(hom",{"_index":275,"title":{},"body":{"interfaces/ADCCallback.html":{},"interfaces/ADCResponse.html":{},"interfaces/CredentialCallback.html":{},"interfaces/GoogleAuthOptions.html":{},"interfaces/ProjectIdCallback.html":{},"interfaces/SignBlobResponse.html":{}}}],["this._pathjoin(loc",{"_index":279,"title":{},"body":{"interfaces/ADCCallback.html":{},"interfaces/ADCResponse.html":{},"interfaces/CredentialCallback.html":{},"interfaces/GoogleAuthOptions.html":{},"interfaces/ProjectIdCallback.html":{},"interfaces/SignBlobResponse.html":{}}}],["this._refreshtoken",{"_index":1407,"title":{},"body":{"interfaces/UserRefreshClientOptions.html":{}}}],["this._trygetapplicationcredentialsfromenvironmentvari",{"_index":220,"title":{},"body":{"interfaces/ADCCallback.html":{},"interfaces/ADCResponse.html":{},"interfaces/CredentialCallback.html":{},"interfaces/GoogleAuthOptions.html":{},"interfaces/ProjectIdCallback.html":{},"interfaces/SignBlobResponse.html":{}}}],["this._trygetapplicationcredentialsfromwellknownfile(opt",{"_index":227,"title":{},"body":{"interfaces/ADCCallback.html":{},"interfaces/ADCResponse.html":{},"interfaces/CredentialCallback.html":{},"interfaces/GoogleAuthOptions.html":{},"interfaces/ProjectIdCallback.html":{},"interfaces/SignBlobResponse.html":{}}}],["this.access",{"_index":1308,"title":{},"body":{"interfaces/JWTOptions.html":{}}}],["this.access.getrequestheaders(url",{"_index":1310,"title":{},"body":{"interfaces/JWTOptions.html":{}}}],["this.additionalclaim",{"_index":1299,"title":{},"body":{"interfaces/JWTOptions.html":{}}}],["this.apikey",{"_index":1073,"title":{},"body":{"interfaces/FederatedSignonCertsResponse.html":{},"interfaces/GetAccessTokenCallback.html":{},"interfaces/GetAccessTokenResponse.html":{},"interfaces/GetFederatedSignonCertsCallback.html":{},"interfaces/GetTokenCallback.html":{},"interfaces/GetTokenOptions.html":{},"interfaces/GetTokenResponse.html":{},"interfaces/JWTOptions.html":{},"interfaces/OAuth2ClientOptions.html":{},"interfaces/RefreshAccessTokenCallback.html":{},"interfaces/RefreshAccessTokenResponse.html":{},"interfaces/RefreshOptions.html":{},"interfaces/RequestMetadataCallback.html":{},"interfaces/RequestMetadataResponse.html":{},"interfaces/RevokeCredentialsResult.html":{},"interfaces/TokenInfo.html":{},"interfaces/TokenInfoRequest.html":{},"interfaces/VerifyIdTokenOptions.html":{}}}],["this.authorizeasync",{"_index":1323,"title":{},"body":{"interfaces/JWTOptions.html":{}}}],["this.authorizeasync().then(r",{"_index":1322,"title":{},"body":{"interfaces/JWTOptions.html":{}}}],["this.cache.get(url",{"_index":1255,"title":{},"body":{"classes/JWTAccess.html":{}}}],["this.cache.set(url",{"_index":1270,"title":{},"body":{"classes/JWTAccess.html":{}}}],["this.cachedcredenti",{"_index":210,"title":{},"body":{"interfaces/ADCCallback.html":{},"interfaces/ADCResponse.html":{},"interfaces/CredentialCallback.html":{},"interfaces/GoogleAuthOptions.html":{},"interfaces/ProjectIdCallback.html":{},"interfaces/SignBlobResponse.html":{}}}],["this.cachedcredential.projectid",{"_index":408,"title":{},"body":{"interfaces/ADCCallback.html":{},"interfaces/ADCResponse.html":{},"interfaces/CredentialCallback.html":{},"interfaces/GoogleAuthOptions.html":{},"interfaces/ProjectIdCallback.html":{},"interfaces/SignBlobResponse.html":{}}}],["this.certificateexpiri",{"_index":1164,"title":{},"body":{"interfaces/FederatedSignonCertsResponse.html":{},"interfaces/GetAccessTokenCallback.html":{},"interfaces/GetAccessTokenResponse.html":{},"interfaces/GetFederatedSignonCertsCallback.html":{},"interfaces/GetTokenCallback.html":{},"interfaces/GetTokenOptions.html":{},"interfaces/GetTokenResponse.html":{},"interfaces/OAuth2ClientOptions.html":{},"interfaces/RefreshAccessTokenCallback.html":{},"interfaces/RefreshAccessTokenResponse.html":{},"interfaces/RefreshOptions.html":{},"interfaces/RequestMetadataCallback.html":{},"interfaces/RequestMetadataResponse.html":{},"interfaces/RevokeCredentialsResult.html":{},"interfaces/TokenInfo.html":{},"interfaces/TokenInfoRequest.html":{},"interfaces/VerifyIdTokenOptions.html":{}}}],["this.checkisgc",{"_index":107,"title":{},"body":{"interfaces/ADCCallback.html":{},"interfaces/ADCResponse.html":{},"interfaces/CredentialCallback.html":{},"interfaces/GoogleAuthOptions.html":{},"interfaces/ProjectIdCallback.html":{},"interfaces/SignBlobResponse.html":{}}}],["this.configure(opt",{"_index":544,"title":{},"body":{"interfaces/BodyResponseCallback.html":{},"classes/DefaultTransporter.html":{},"interfaces/RequestError.html":{},"interfaces/Transporter.html":{}}}],["this.createerror",{"_index":258,"title":{},"body":{"interfaces/ADCCallback.html":{},"interfaces/ADCResponse.html":{},"interfaces/CredentialCallback.html":{},"interfaces/GoogleAuthOptions.html":{},"interfaces/ProjectIdCallback.html":{},"interfaces/SignBlobResponse.html":{}}}],["this.creategtoken",{"_index":1328,"title":{},"body":{"interfaces/JWTOptions.html":{}}}],["this.credenti",{"_index":594,"title":{},"body":{"interfaces/ComputeOptions.html":{},"interfaces/FederatedSignonCertsResponse.html":{},"interfaces/GetAccessTokenCallback.html":{},"interfaces/GetAccessTokenResponse.html":{},"interfaces/GetFederatedSignonCertsCallback.html":{},"interfaces/GetTokenCallback.html":{},"interfaces/GetTokenOptions.html":{},"interfaces/GetTokenResponse.html":{},"interfaces/JWTOptions.html":{},"interfaces/OAuth2ClientOptions.html":{},"interfaces/RefreshAccessTokenCallback.html":{},"interfaces/RefreshAccessTokenResponse.html":{},"interfaces/RefreshOptions.html":{},"interfaces/RequestMetadataCallback.html":{},"interfaces/RequestMetadataResponse.html":{},"interfaces/RevokeCredentialsResult.html":{},"interfaces/TokenInfo.html":{},"interfaces/TokenInfoRequest.html":{},"interfaces/VerifyIdTokenOptions.html":{}}}],["this.credentials.access_token",{"_index":1054,"title":{},"body":{"interfaces/FederatedSignonCertsResponse.html":{},"interfaces/GetAccessTokenCallback.html":{},"interfaces/GetAccessTokenResponse.html":{},"interfaces/GetFederatedSignonCertsCallback.html":{},"interfaces/GetTokenCallback.html":{},"interfaces/GetTokenOptions.html":{},"interfaces/GetTokenResponse.html":{},"interfaces/OAuth2ClientOptions.html":{},"interfaces/RefreshAccessTokenCallback.html":{},"interfaces/RefreshAccessTokenResponse.html":{},"interfaces/RefreshOptions.html":{},"interfaces/RequestMetadataCallback.html":{},"interfaces/RequestMetadataResponse.html":{},"interfaces/RevokeCredentialsResult.html":{},"interfaces/TokenInfo.html":{},"interfaces/TokenInfoRequest.html":{},"interfaces/VerifyIdTokenOptions.html":{}}}],["this.credentials.expiry_d",{"_index":1120,"title":{},"body":{"interfaces/FederatedSignonCertsResponse.html":{},"interfaces/GetAccessTokenCallback.html":{},"interfaces/GetAccessTokenResponse.html":{},"interfaces/GetFederatedSignonCertsCallback.html":{},"interfaces/GetTokenCallback.html":{},"interfaces/GetTokenOptions.html":{},"interfaces/GetTokenResponse.html":{},"interfaces/OAuth2ClientOptions.html":{},"interfaces/RefreshAccessTokenCallback.html":{},"interfaces/RefreshAccessTokenResponse.html":{},"interfaces/RefreshOptions.html":{},"interfaces/RequestMetadataCallback.html":{},"interfaces/RequestMetadataResponse.html":{},"interfaces/RevokeCredentialsResult.html":{},"interfaces/TokenInfo.html":{},"interfaces/TokenInfoRequest.html":{},"interfaces/VerifyIdTokenOptions.html":{}}}],["this.credentials.refresh_token",{"_index":1043,"title":{},"body":{"interfaces/FederatedSignonCertsResponse.html":{},"interfaces/GetAccessTokenCallback.html":{},"interfaces/GetAccessTokenResponse.html":{},"interfaces/GetFederatedSignonCertsCallback.html":{},"interfaces/GetTokenCallback.html":{},"interfaces/GetTokenOptions.html":{},"interfaces/GetTokenResponse.html":{},"interfaces/JWTOptions.html":{},"interfaces/OAuth2ClientOptions.html":{},"interfaces/RefreshAccessTokenCallback.html":{},"interfaces/RefreshAccessTokenResponse.html":{},"interfaces/RefreshOptions.html":{},"interfaces/RequestMetadataCallback.html":{},"interfaces/RequestMetadataResponse.html":{},"interfaces/RevokeCredentialsResult.html":{},"interfaces/TokenInfo.html":{},"interfaces/TokenInfoRequest.html":{},"interfaces/UserRefreshClientOptions.html":{},"interfaces/VerifyIdTokenOptions.html":{}}}],["this.eagerrefreshthresholdmilli",{"_index":927,"title":{},"body":{"interfaces/FederatedSignonCertsResponse.html":{},"interfaces/GetAccessTokenCallback.html":{},"interfaces/GetAccessTokenResponse.html":{},"interfaces/GetFederatedSignonCertsCallback.html":{},"interfaces/GetTokenCallback.html":{},"interfaces/GetTokenOptions.html":{},"interfaces/GetTokenResponse.html":{},"interfaces/OAuth2ClientOptions.html":{},"interfaces/RefreshAccessTokenCallback.html":{},"interfaces/RefreshAccessTokenResponse.html":{},"interfaces/RefreshOptions.html":{},"interfaces/RequestMetadataCallback.html":{},"interfaces/RequestMetadataResponse.html":{},"interfaces/RevokeCredentialsResult.html":{},"interfaces/TokenInfo.html":{},"interfaces/TokenInfoRequest.html":{},"interfaces/VerifyIdTokenOptions.html":{}}}],["this.email",{"_index":1247,"title":{},"body":{"classes/JWTAccess.html":{},"interfaces/JWTOptions.html":{}}}],["this.emit('token",{"_index":622,"title":{},"body":{"interfaces/ComputeOptions.html":{},"interfaces/FederatedSignonCertsResponse.html":{},"interfaces/GetAccessTokenCallback.html":{},"interfaces/GetAccessTokenResponse.html":{},"interfaces/GetFederatedSignonCertsCallback.html":{},"interfaces/GetTokenCallback.html":{},"interfaces/GetTokenOptions.html":{},"interfaces/GetTokenResponse.html":{},"interfaces/JWTOptions.html":{},"interfaces/OAuth2ClientOptions.html":{},"interfaces/RefreshAccessTokenCallback.html":{},"interfaces/RefreshAccessTokenResponse.html":{},"interfaces/RefreshOptions.html":{},"interfaces/RequestMetadataCallback.html":{},"interfaces/RequestMetadataResponse.html":{},"interfaces/RevokeCredentialsResult.html":{},"interfaces/TokenInfo.html":{},"interfaces/TokenInfoRequest.html":{},"interfaces/VerifyIdTokenOptions.html":{}}}],["this.envelop",{"_index":1358,"title":{},"body":{"classes/LoginTicket.html":{},"interfaces/TokenPayload.html":{}}}],["this.fromjson(data",{"_index":352,"title":{},"body":{"interfaces/ADCCallback.html":{},"interfaces/ADCResponse.html":{},"interfaces/CredentialCallback.html":{},"interfaces/GoogleAuthOptions.html":{},"classes/JWTAccess.html":{},"interfaces/JWTOptions.html":{},"interfaces/ProjectIdCallback.html":{},"interfaces/SignBlobResponse.html":{},"interfaces/UserRefreshClientOptions.html":{}}}],["this.fromjson(this.jsoncont",{"_index":445,"title":{},"body":{"interfaces/ADCCallback.html":{},"interfaces/ADCResponse.html":{},"interfaces/CredentialCallback.html":{},"interfaces/GoogleAuthOptions.html":{},"interfaces/ProjectIdCallback.html":{},"interfaces/SignBlobResponse.html":{}}}],["this.fromstream(readstream",{"_index":310,"title":{},"body":{"interfaces/ADCCallback.html":{},"interfaces/ADCResponse.html":{},"interfaces/CredentialCallback.html":{},"interfaces/GoogleAuthOptions.html":{},"interfaces/ProjectIdCallback.html":{},"interfaces/SignBlobResponse.html":{}}}],["this.fromstreamasync(inputstream",{"_index":342,"title":{},"body":{"interfaces/ADCCallback.html":{},"interfaces/ADCResponse.html":{},"interfaces/CredentialCallback.html":{},"interfaces/GoogleAuthOptions.html":{},"classes/JWTAccess.html":{},"interfaces/JWTOptions.html":{},"interfaces/ProjectIdCallback.html":{},"interfaces/SignBlobResponse.html":{},"interfaces/UserRefreshClientOptions.html":{}}}],["this.fromstreamasync(inputstream).then(r",{"_index":1278,"title":{},"body":{"classes/JWTAccess.html":{},"interfaces/JWTOptions.html":{},"interfaces/UserRefreshClientOptions.html":{}}}],["this.fromstreamasync(stream",{"_index":447,"title":{},"body":{"interfaces/ADCCallback.html":{},"interfaces/ADCResponse.html":{},"interfaces/CredentialCallback.html":{},"interfaces/GoogleAuthOptions.html":{},"interfaces/ProjectIdCallback.html":{},"interfaces/SignBlobResponse.html":{}}}],["this.getaccesstokenasync",{"_index":1051,"title":{},"body":{"interfaces/FederatedSignonCertsResponse.html":{},"interfaces/GetAccessTokenCallback.html":{},"interfaces/GetAccessTokenResponse.html":{},"interfaces/GetFederatedSignonCertsCallback.html":{},"interfaces/GetTokenCallback.html":{},"interfaces/GetTokenOptions.html":{},"interfaces/GetTokenResponse.html":{},"interfaces/OAuth2ClientOptions.html":{},"interfaces/RefreshAccessTokenCallback.html":{},"interfaces/RefreshAccessTokenResponse.html":{},"interfaces/RefreshOptions.html":{},"interfaces/RequestMetadataCallback.html":{},"interfaces/RequestMetadataResponse.html":{},"interfaces/RevokeCredentialsResult.html":{},"interfaces/TokenInfo.html":{},"interfaces/TokenInfoRequest.html":{},"interfaces/VerifyIdTokenOptions.html":{}}}],["this.getaccesstokenasync().then",{"_index":1050,"title":{},"body":{"interfaces/FederatedSignonCertsResponse.html":{},"interfaces/GetAccessTokenCallback.html":{},"interfaces/GetAccessTokenResponse.html":{},"interfaces/GetFederatedSignonCertsCallback.html":{},"interfaces/GetTokenCallback.html":{},"interfaces/GetTokenOptions.html":{},"interfaces/GetTokenResponse.html":{},"interfaces/OAuth2ClientOptions.html":{},"interfaces/RefreshAccessTokenCallback.html":{},"interfaces/RefreshAccessTokenResponse.html":{},"interfaces/RefreshOptions.html":{},"interfaces/RequestMetadataCallback.html":{},"interfaces/RequestMetadataResponse.html":{},"interfaces/RevokeCredentialsResult.html":{},"interfaces/TokenInfo.html":{},"interfaces/TokenInfoRequest.html":{},"interfaces/VerifyIdTokenOptions.html":{}}}],["this.getapplicationdefaultasync",{"_index":448,"title":{},"body":{"interfaces/ADCCallback.html":{},"interfaces/ADCResponse.html":{},"interfaces/CredentialCallback.html":{},"interfaces/GoogleAuthOptions.html":{},"interfaces/ProjectIdCallback.html":{},"interfaces/SignBlobResponse.html":{}}}],["this.getapplicationdefaultasync(opt",{"_index":205,"title":{},"body":{"interfaces/ADCCallback.html":{},"interfaces/ADCResponse.html":{},"interfaces/CredentialCallback.html":{},"interfaces/GoogleAuthOptions.html":{},"interfaces/ProjectIdCallback.html":{},"interfaces/SignBlobResponse.html":{}}}],["this.getapplicationdefaultasync(options).then",{"_index":201,"title":{},"body":{"interfaces/ADCCallback.html":{},"interfaces/ADCResponse.html":{},"interfaces/CredentialCallback.html":{},"interfaces/GoogleAuthOptions.html":{},"interfaces/ProjectIdCallback.html":{},"interfaces/SignBlobResponse.html":{}}}],["this.getcli",{"_index":452,"title":{},"body":{"interfaces/ADCCallback.html":{},"interfaces/ADCResponse.html":{},"interfaces/CredentialCallback.html":{},"interfaces/GoogleAuthOptions.html":{},"interfaces/ProjectIdCallback.html":{},"interfaces/SignBlobResponse.html":{}}}],["this.getcredenti",{"_index":484,"title":{},"body":{"interfaces/ADCCallback.html":{},"interfaces/ADCResponse.html":{},"interfaces/CredentialCallback.html":{},"interfaces/GoogleAuthOptions.html":{},"interfaces/ProjectIdCallback.html":{},"interfaces/SignBlobResponse.html":{}}}],["this.getcredentialsasync",{"_index":418,"title":{},"body":{"interfaces/ADCCallback.html":{},"interfaces/ADCResponse.html":{},"interfaces/CredentialCallback.html":{},"interfaces/GoogleAuthOptions.html":{},"interfaces/ProjectIdCallback.html":{},"interfaces/SignBlobResponse.html":{}}}],["this.getcredentialsasync().then(r",{"_index":417,"title":{},"body":{"interfaces/ADCCallback.html":{},"interfaces/ADCResponse.html":{},"interfaces/CredentialCallback.html":{},"interfaces/GoogleAuthOptions.html":{},"interfaces/ProjectIdCallback.html":{},"interfaces/SignBlobResponse.html":{}}}],["this.getdefaultserviceprojectid",{"_index":183,"title":{},"body":{"interfaces/ADCCallback.html":{},"interfaces/ADCResponse.html":{},"interfaces/CredentialCallback.html":{},"interfaces/GoogleAuthOptions.html":{},"interfaces/ProjectIdCallback.html":{},"interfaces/SignBlobResponse.html":{}}}],["this.getenvelop",{"_index":1362,"title":{},"body":{"classes/LoginTicket.html":{},"interfaces/TokenPayload.html":{}}}],["this.getfederatedsignoncertsasync",{"_index":1139,"title":{},"body":{"interfaces/FederatedSignonCertsResponse.html":{},"interfaces/GetAccessTokenCallback.html":{},"interfaces/GetAccessTokenResponse.html":{},"interfaces/GetFederatedSignonCertsCallback.html":{},"interfaces/GetTokenCallback.html":{},"interfaces/GetTokenOptions.html":{},"interfaces/GetTokenResponse.html":{},"interfaces/OAuth2ClientOptions.html":{},"interfaces/RefreshAccessTokenCallback.html":{},"interfaces/RefreshAccessTokenResponse.html":{},"interfaces/RefreshOptions.html":{},"interfaces/RequestMetadataCallback.html":{},"interfaces/RequestMetadataResponse.html":{},"interfaces/RevokeCredentialsResult.html":{},"interfaces/TokenInfo.html":{},"interfaces/TokenInfoRequest.html":{},"interfaces/VerifyIdTokenOptions.html":{}}}],["this.getfederatedsignoncertsasync().then",{"_index":1160,"title":{},"body":{"interfaces/FederatedSignonCertsResponse.html":{},"interfaces/GetAccessTokenCallback.html":{},"interfaces/GetAccessTokenResponse.html":{},"interfaces/GetFederatedSignonCertsCallback.html":{},"interfaces/GetTokenCallback.html":{},"interfaces/GetTokenOptions.html":{},"interfaces/GetTokenResponse.html":{},"interfaces/OAuth2ClientOptions.html":{},"interfaces/RefreshAccessTokenCallback.html":{},"interfaces/RefreshAccessTokenResponse.html":{},"interfaces/RefreshOptions.html":{},"interfaces/RequestMetadataCallback.html":{},"interfaces/RequestMetadataResponse.html":{},"interfaces/RevokeCredentialsResult.html":{},"interfaces/TokenInfo.html":{},"interfaces/TokenInfoRequest.html":{},"interfaces/VerifyIdTokenOptions.html":{}}}],["this.getfileprojectid",{"_index":182,"title":{},"body":{"interfaces/ADCCallback.html":{},"interfaces/ADCResponse.html":{},"interfaces/CredentialCallback.html":{},"interfaces/GoogleAuthOptions.html":{},"interfaces/ProjectIdCallback.html":{},"interfaces/SignBlobResponse.html":{}}}],["this.getgceprojectid",{"_index":184,"title":{},"body":{"interfaces/ADCCallback.html":{},"interfaces/ADCResponse.html":{},"interfaces/CredentialCallback.html":{},"interfaces/GoogleAuthOptions.html":{},"interfaces/ProjectIdCallback.html":{},"interfaces/SignBlobResponse.html":{}}}],["this.getpayload",{"_index":1360,"title":{},"body":{"classes/LoginTicket.html":{},"interfaces/TokenPayload.html":{}}}],["this.getproductionprojectid",{"_index":180,"title":{},"body":{"interfaces/ADCCallback.html":{},"interfaces/ADCResponse.html":{},"interfaces/CredentialCallback.html":{},"interfaces/GoogleAuthOptions.html":{},"interfaces/ProjectIdCallback.html":{},"interfaces/SignBlobResponse.html":{}}}],["this.getprojectid",{"_index":223,"title":{},"body":{"interfaces/ADCCallback.html":{},"interfaces/ADCResponse.html":{},"interfaces/CredentialCallback.html":{},"interfaces/GoogleAuthOptions.html":{},"interfaces/ProjectIdCallback.html":{},"interfaces/SignBlobResponse.html":{}}}],["this.getprojectidasync",{"_index":145,"title":{},"body":{"interfaces/ADCCallback.html":{},"interfaces/ADCResponse.html":{},"interfaces/CredentialCallback.html":{},"interfaces/GoogleAuthOptions.html":{},"interfaces/ProjectIdCallback.html":{},"interfaces/SignBlobResponse.html":{}}}],["this.getprojectidasync().then(r",{"_index":142,"title":{},"body":{"interfaces/ADCCallback.html":{},"interfaces/ADCResponse.html":{},"interfaces/CredentialCallback.html":{},"interfaces/GoogleAuthOptions.html":{},"interfaces/ProjectIdCallback.html":{},"interfaces/SignBlobResponse.html":{}}}],["this.getrequesthead",{"_index":1216,"title":{},"body":{"classes/IAMAuth.html":{},"interfaces/RequestMetadata.html":{}}}],["this.getrequestheaders(url",{"_index":1253,"title":{},"body":{"classes/JWTAccess.html":{}}}],["this.getrequestmetadataasync",{"_index":1064,"title":{},"body":{"interfaces/FederatedSignonCertsResponse.html":{},"interfaces/GetAccessTokenCallback.html":{},"interfaces/GetAccessTokenResponse.html":{},"interfaces/GetFederatedSignonCertsCallback.html":{},"interfaces/GetTokenCallback.html":{},"interfaces/GetTokenOptions.html":{},"interfaces/GetTokenResponse.html":{},"interfaces/OAuth2ClientOptions.html":{},"interfaces/RefreshAccessTokenCallback.html":{},"interfaces/RefreshAccessTokenResponse.html":{},"interfaces/RefreshOptions.html":{},"interfaces/RequestMetadataCallback.html":{},"interfaces/RequestMetadataResponse.html":{},"interfaces/RevokeCredentialsResult.html":{},"interfaces/TokenInfo.html":{},"interfaces/TokenInfoRequest.html":{},"interfaces/VerifyIdTokenOptions.html":{}}}],["this.getrequestmetadataasync(opts.url",{"_index":1102,"title":{},"body":{"interfaces/FederatedSignonCertsResponse.html":{},"interfaces/GetAccessTokenCallback.html":{},"interfaces/GetAccessTokenResponse.html":{},"interfaces/GetFederatedSignonCertsCallback.html":{},"interfaces/GetTokenCallback.html":{},"interfaces/GetTokenOptions.html":{},"interfaces/GetTokenResponse.html":{},"interfaces/OAuth2ClientOptions.html":{},"interfaces/RefreshAccessTokenCallback.html":{},"interfaces/RefreshAccessTokenResponse.html":{},"interfaces/RefreshOptions.html":{},"interfaces/RequestMetadataCallback.html":{},"interfaces/RequestMetadataResponse.html":{},"interfaces/RevokeCredentialsResult.html":{},"interfaces/TokenInfo.html":{},"interfaces/TokenInfoRequest.html":{},"interfaces/VerifyIdTokenOptions.html":{}}}],["this.getrequestmetadataasync(url",{"_index":1067,"title":{},"body":{"interfaces/FederatedSignonCertsResponse.html":{},"interfaces/GetAccessTokenCallback.html":{},"interfaces/GetAccessTokenResponse.html":{},"interfaces/GetFederatedSignonCertsCallback.html":{},"interfaces/GetTokenCallback.html":{},"interfaces/GetTokenOptions.html":{},"interfaces/GetTokenResponse.html":{},"interfaces/OAuth2ClientOptions.html":{},"interfaces/RefreshAccessTokenCallback.html":{},"interfaces/RefreshAccessTokenResponse.html":{},"interfaces/RefreshOptions.html":{},"interfaces/RequestMetadataCallback.html":{},"interfaces/RequestMetadataResponse.html":{},"interfaces/RevokeCredentialsResult.html":{},"interfaces/TokenInfo.html":{},"interfaces/TokenInfoRequest.html":{},"interfaces/VerifyIdTokenOptions.html":{}}}],["this.getrequestmetadataasync(url).then",{"_index":1062,"title":{},"body":{"interfaces/FederatedSignonCertsResponse.html":{},"interfaces/GetAccessTokenCallback.html":{},"interfaces/GetAccessTokenResponse.html":{},"interfaces/GetFederatedSignonCertsCallback.html":{},"interfaces/GetTokenCallback.html":{},"interfaces/GetTokenOptions.html":{},"interfaces/GetTokenResponse.html":{},"interfaces/OAuth2ClientOptions.html":{},"interfaces/RefreshAccessTokenCallback.html":{},"interfaces/RefreshAccessTokenResponse.html":{},"interfaces/RefreshOptions.html":{},"interfaces/RequestMetadataCallback.html":{},"interfaces/RequestMetadataResponse.html":{},"interfaces/RevokeCredentialsResult.html":{},"interfaces/TokenInfo.html":{},"interfaces/TokenInfoRequest.html":{},"interfaces/VerifyIdTokenOptions.html":{}}}],["this.gettokenasync(opt",{"_index":1011,"title":{},"body":{"interfaces/FederatedSignonCertsResponse.html":{},"interfaces/GetAccessTokenCallback.html":{},"interfaces/GetAccessTokenResponse.html":{},"interfaces/GetFederatedSignonCertsCallback.html":{},"interfaces/GetTokenCallback.html":{},"interfaces/GetTokenOptions.html":{},"interfaces/GetTokenResponse.html":{},"interfaces/OAuth2ClientOptions.html":{},"interfaces/RefreshAccessTokenCallback.html":{},"interfaces/RefreshAccessTokenResponse.html":{},"interfaces/RefreshOptions.html":{},"interfaces/RequestMetadataCallback.html":{},"interfaces/RequestMetadataResponse.html":{},"interfaces/RevokeCredentialsResult.html":{},"interfaces/TokenInfo.html":{},"interfaces/TokenInfoRequest.html":{},"interfaces/VerifyIdTokenOptions.html":{}}}],["this.gettokenasync(options).then",{"_index":1008,"title":{},"body":{"interfaces/FederatedSignonCertsResponse.html":{},"interfaces/GetAccessTokenCallback.html":{},"interfaces/GetAccessTokenResponse.html":{},"interfaces/GetFederatedSignonCertsCallback.html":{},"interfaces/GetTokenCallback.html":{},"interfaces/GetTokenOptions.html":{},"interfaces/GetTokenResponse.html":{},"interfaces/OAuth2ClientOptions.html":{},"interfaces/RefreshAccessTokenCallback.html":{},"interfaces/RefreshAccessTokenResponse.html":{},"interfaces/RefreshOptions.html":{},"interfaces/RequestMetadataCallback.html":{},"interfaces/RequestMetadataResponse.html":{},"interfaces/RevokeCredentialsResult.html":{},"interfaces/TokenInfo.html":{},"interfaces/TokenInfoRequest.html":{},"interfaces/VerifyIdTokenOptions.html":{}}}],["this.gtoken",{"_index":1334,"title":{},"body":{"interfaces/JWTOptions.html":{}}}],["this.gtoken!.iss",{"_index":1327,"title":{},"body":{"interfaces/JWTOptions.html":{}}}],["this.gtoken!.key",{"_index":1326,"title":{},"body":{"interfaces/JWTOptions.html":{}}}],["this.hasscop",{"_index":1304,"title":{},"body":{"interfaces/JWTOptions.html":{}}}],["this.istokenexpir",{"_index":1055,"title":{},"body":{"interfaces/FederatedSignonCertsResponse.html":{},"interfaces/GetAccessTokenCallback.html":{},"interfaces/GetAccessTokenResponse.html":{},"interfaces/GetFederatedSignonCertsCallback.html":{},"interfaces/GetTokenCallback.html":{},"interfaces/GetTokenOptions.html":{},"interfaces/GetTokenResponse.html":{},"interfaces/OAuth2ClientOptions.html":{},"interfaces/RefreshAccessTokenCallback.html":{},"interfaces/RefreshAccessTokenResponse.html":{},"interfaces/RefreshOptions.html":{},"interfaces/RequestMetadataCallback.html":{},"interfaces/RequestMetadataResponse.html":{},"interfaces/RevokeCredentialsResult.html":{},"interfaces/TokenInfo.html":{},"interfaces/TokenInfoRequest.html":{},"interfaces/VerifyIdTokenOptions.html":{}}}],["this.jsoncont",{"_index":127,"title":{},"body":{"interfaces/ADCCallback.html":{},"interfaces/ADCResponse.html":{},"interfaces/CredentialCallback.html":{},"interfaces/GoogleAuthOptions.html":{},"interfaces/ProjectIdCallback.html":{},"interfaces/SignBlobResponse.html":{}}}],["this.jsoncontent.client_email",{"_index":420,"title":{},"body":{"interfaces/ADCCallback.html":{},"interfaces/ADCResponse.html":{},"interfaces/CredentialCallback.html":{},"interfaces/GoogleAuthOptions.html":{},"interfaces/ProjectIdCallback.html":{},"interfaces/SignBlobResponse.html":{}}}],["this.jsoncontent.private_key",{"_index":421,"title":{},"body":{"interfaces/ADCCallback.html":{},"interfaces/ADCResponse.html":{},"interfaces/CredentialCallback.html":{},"interfaces/GoogleAuthOptions.html":{},"interfaces/ProjectIdCallback.html":{},"interfaces/SignBlobResponse.html":{}}}],["this.key",{"_index":1248,"title":{},"body":{"classes/JWTAccess.html":{},"interfaces/JWTOptions.html":{}}}],["this.keyfil",{"_index":1294,"title":{},"body":{"interfaces/JWTOptions.html":{}}}],["this.keyfilenam",{"_index":122,"title":{},"body":{"interfaces/ADCCallback.html":{},"interfaces/ADCResponse.html":{},"interfaces/CredentialCallback.html":{},"interfaces/GoogleAuthOptions.html":{},"interfaces/ProjectIdCallback.html":{},"interfaces/SignBlobResponse.html":{}}}],["this.keyid",{"_index":1249,"title":{},"body":{"classes/JWTAccess.html":{},"interfaces/JWTOptions.html":{}}}],["this.payload",{"_index":1359,"title":{},"body":{"classes/LoginTicket.html":{},"interfaces/TokenPayload.html":{}}}],["this.processerror(",{"_index":556,"title":{},"body":{"interfaces/BodyResponseCallback.html":{},"classes/DefaultTransporter.html":{},"interfaces/RequestError.html":{},"interfaces/Transporter.html":{}}}],["this.projectid",{"_index":1276,"title":{},"body":{"classes/JWTAccess.html":{},"interfaces/JWTOptions.html":{}}}],["this.redirecturi",{"_index":925,"title":{},"body":{"interfaces/FederatedSignonCertsResponse.html":{},"interfaces/GetAccessTokenCallback.html":{},"interfaces/GetAccessTokenResponse.html":{},"interfaces/GetFederatedSignonCertsCallback.html":{},"interfaces/GetTokenCallback.html":{},"interfaces/GetTokenOptions.html":{},"interfaces/GetTokenResponse.html":{},"interfaces/OAuth2ClientOptions.html":{},"interfaces/RefreshAccessTokenCallback.html":{},"interfaces/RefreshAccessTokenResponse.html":{},"interfaces/RefreshOptions.html":{},"interfaces/RequestMetadataCallback.html":{},"interfaces/RequestMetadataResponse.html":{},"interfaces/RevokeCredentialsResult.html":{},"interfaces/TokenInfo.html":{},"interfaces/TokenInfoRequest.html":{},"interfaces/VerifyIdTokenOptions.html":{}}}],["this.refreshaccesstokenasync",{"_index":1041,"title":{},"body":{"interfaces/FederatedSignonCertsResponse.html":{},"interfaces/GetAccessTokenCallback.html":{},"interfaces/GetAccessTokenResponse.html":{},"interfaces/GetFederatedSignonCertsCallback.html":{},"interfaces/GetTokenCallback.html":{},"interfaces/GetTokenOptions.html":{},"interfaces/GetTokenResponse.html":{},"interfaces/OAuth2ClientOptions.html":{},"interfaces/RefreshAccessTokenCallback.html":{},"interfaces/RefreshAccessTokenResponse.html":{},"interfaces/RefreshOptions.html":{},"interfaces/RequestMetadataCallback.html":{},"interfaces/RequestMetadataResponse.html":{},"interfaces/RevokeCredentialsResult.html":{},"interfaces/TokenInfo.html":{},"interfaces/TokenInfoRequest.html":{},"interfaces/VerifyIdTokenOptions.html":{}}}],["this.refreshaccesstokenasync().then",{"_index":1040,"title":{},"body":{"interfaces/FederatedSignonCertsResponse.html":{},"interfaces/GetAccessTokenCallback.html":{},"interfaces/GetAccessTokenResponse.html":{},"interfaces/GetFederatedSignonCertsCallback.html":{},"interfaces/GetTokenCallback.html":{},"interfaces/GetTokenOptions.html":{},"interfaces/GetTokenResponse.html":{},"interfaces/OAuth2ClientOptions.html":{},"interfaces/RefreshAccessTokenCallback.html":{},"interfaces/RefreshAccessTokenResponse.html":{},"interfaces/RefreshOptions.html":{},"interfaces/RequestMetadataCallback.html":{},"interfaces/RequestMetadataResponse.html":{},"interfaces/RevokeCredentialsResult.html":{},"interfaces/TokenInfo.html":{},"interfaces/TokenInfoRequest.html":{},"interfaces/VerifyIdTokenOptions.html":{}}}],["this.refreshtoken",{"_index":1306,"title":{},"body":{"interfaces/JWTOptions.html":{},"interfaces/UserRefreshClientOptions.html":{}}}],["this.refreshtoken(this.credentials.refresh_token",{"_index":1045,"title":{},"body":{"interfaces/FederatedSignonCertsResponse.html":{},"interfaces/GetAccessTokenCallback.html":{},"interfaces/GetAccessTokenResponse.html":{},"interfaces/GetFederatedSignonCertsCallback.html":{},"interfaces/GetTokenCallback.html":{},"interfaces/GetTokenOptions.html":{},"interfaces/GetTokenResponse.html":{},"interfaces/OAuth2ClientOptions.html":{},"interfaces/RefreshAccessTokenCallback.html":{},"interfaces/RefreshAccessTokenResponse.html":{},"interfaces/RefreshOptions.html":{},"interfaces/RequestMetadataCallback.html":{},"interfaces/RequestMetadataResponse.html":{},"interfaces/RevokeCredentialsResult.html":{},"interfaces/TokenInfo.html":{},"interfaces/TokenInfoRequest.html":{},"interfaces/VerifyIdTokenOptions.html":{}}}],["this.refreshtoken(thiscreds.refresh_token",{"_index":1076,"title":{},"body":{"interfaces/FederatedSignonCertsResponse.html":{},"interfaces/GetAccessTokenCallback.html":{},"interfaces/GetAccessTokenResponse.html":{},"interfaces/GetFederatedSignonCertsCallback.html":{},"interfaces/GetTokenCallback.html":{},"interfaces/GetTokenOptions.html":{},"interfaces/GetTokenResponse.html":{},"interfaces/OAuth2ClientOptions.html":{},"interfaces/RefreshAccessTokenCallback.html":{},"interfaces/RefreshAccessTokenResponse.html":{},"interfaces/RefreshOptions.html":{},"interfaces/RequestMetadataCallback.html":{},"interfaces/RequestMetadataResponse.html":{},"interfaces/RevokeCredentialsResult.html":{},"interfaces/TokenInfo.html":{},"interfaces/TokenInfoRequest.html":{},"interfaces/VerifyIdTokenOptions.html":{}}}],["this.refreshtokennocache(refreshtoken",{"_index":1026,"title":{},"body":{"interfaces/FederatedSignonCertsResponse.html":{},"interfaces/GetAccessTokenCallback.html":{},"interfaces/GetAccessTokenResponse.html":{},"interfaces/GetFederatedSignonCertsCallback.html":{},"interfaces/GetTokenCallback.html":{},"interfaces/GetTokenOptions.html":{},"interfaces/GetTokenResponse.html":{},"interfaces/OAuth2ClientOptions.html":{},"interfaces/RefreshAccessTokenCallback.html":{},"interfaces/RefreshAccessTokenResponse.html":{},"interfaces/RefreshOptions.html":{},"interfaces/RequestMetadataCallback.html":{},"interfaces/RequestMetadataResponse.html":{},"interfaces/RevokeCredentialsResult.html":{},"interfaces/TokenInfo.html":{},"interfaces/TokenInfoRequest.html":{},"interfaces/VerifyIdTokenOptions.html":{}}}],["this.refreshtokenpromises.delete(refreshtoken",{"_index":1030,"title":{},"body":{"interfaces/FederatedSignonCertsResponse.html":{},"interfaces/GetAccessTokenCallback.html":{},"interfaces/GetAccessTokenResponse.html":{},"interfaces/GetFederatedSignonCertsCallback.html":{},"interfaces/GetTokenCallback.html":{},"interfaces/GetTokenOptions.html":{},"interfaces/GetTokenResponse.html":{},"interfaces/OAuth2ClientOptions.html":{},"interfaces/RefreshAccessTokenCallback.html":{},"interfaces/RefreshAccessTokenResponse.html":{},"interfaces/RefreshOptions.html":{},"interfaces/RequestMetadataCallback.html":{},"interfaces/RequestMetadataResponse.html":{},"interfaces/RevokeCredentialsResult.html":{},"interfaces/TokenInfo.html":{},"interfaces/TokenInfoRequest.html":{},"interfaces/VerifyIdTokenOptions.html":{}}}],["this.refreshtokenpromises.get(refreshtoken",{"_index":1028,"title":{},"body":{"interfaces/FederatedSignonCertsResponse.html":{},"interfaces/GetAccessTokenCallback.html":{},"interfaces/GetAccessTokenResponse.html":{},"interfaces/GetFederatedSignonCertsCallback.html":{},"interfaces/GetTokenCallback.html":{},"interfaces/GetTokenOptions.html":{},"interfaces/GetTokenResponse.html":{},"interfaces/OAuth2ClientOptions.html":{},"interfaces/RefreshAccessTokenCallback.html":{},"interfaces/RefreshAccessTokenResponse.html":{},"interfaces/RefreshOptions.html":{},"interfaces/RequestMetadataCallback.html":{},"interfaces/RequestMetadataResponse.html":{},"interfaces/RevokeCredentialsResult.html":{},"interfaces/TokenInfo.html":{},"interfaces/TokenInfoRequest.html":{},"interfaces/VerifyIdTokenOptions.html":{}}}],["this.refreshtokenpromises.has(refreshtoken",{"_index":1027,"title":{},"body":{"interfaces/FederatedSignonCertsResponse.html":{},"interfaces/GetAccessTokenCallback.html":{},"interfaces/GetAccessTokenResponse.html":{},"interfaces/GetFederatedSignonCertsCallback.html":{},"interfaces/GetTokenCallback.html":{},"interfaces/GetTokenOptions.html":{},"interfaces/GetTokenResponse.html":{},"interfaces/OAuth2ClientOptions.html":{},"interfaces/RefreshAccessTokenCallback.html":{},"interfaces/RefreshAccessTokenResponse.html":{},"interfaces/RefreshOptions.html":{},"interfaces/RequestMetadataCallback.html":{},"interfaces/RequestMetadataResponse.html":{},"interfaces/RevokeCredentialsResult.html":{},"interfaces/TokenInfo.html":{},"interfaces/TokenInfoRequest.html":{},"interfaces/VerifyIdTokenOptions.html":{}}}],["this.refreshtokenpromises.set(refreshtoken",{"_index":1031,"title":{},"body":{"interfaces/FederatedSignonCertsResponse.html":{},"interfaces/GetAccessTokenCallback.html":{},"interfaces/GetAccessTokenResponse.html":{},"interfaces/GetFederatedSignonCertsCallback.html":{},"interfaces/GetTokenCallback.html":{},"interfaces/GetTokenOptions.html":{},"interfaces/GetTokenResponse.html":{},"interfaces/OAuth2ClientOptions.html":{},"interfaces/RefreshAccessTokenCallback.html":{},"interfaces/RefreshAccessTokenResponse.html":{},"interfaces/RefreshOptions.html":{},"interfaces/RequestMetadataCallback.html":{},"interfaces/RequestMetadataResponse.html":{},"interfaces/RevokeCredentialsResult.html":{},"interfaces/TokenInfo.html":{},"interfaces/TokenInfoRequest.html":{},"interfaces/VerifyIdTokenOptions.html":{}}}],["this.request",{"_index":488,"title":{},"body":{"interfaces/ADCCallback.html":{},"interfaces/ADCResponse.html":{},"interfaces/CredentialCallback.html":{},"interfaces/GoogleAuthOptions.html":{},"interfaces/ProjectIdCallback.html":{},"interfaces/SignBlobResponse.html":{}}}],["this.requestasync(opt",{"_index":1100,"title":{},"body":{"interfaces/FederatedSignonCertsResponse.html":{},"interfaces/GetAccessTokenCallback.html":{},"interfaces/GetAccessTokenResponse.html":{},"interfaces/GetFederatedSignonCertsCallback.html":{},"interfaces/GetTokenCallback.html":{},"interfaces/GetTokenOptions.html":{},"interfaces/GetTokenResponse.html":{},"interfaces/OAuth2ClientOptions.html":{},"interfaces/RefreshAccessTokenCallback.html":{},"interfaces/RefreshAccessTokenResponse.html":{},"interfaces/RefreshOptions.html":{},"interfaces/RequestMetadataCallback.html":{},"interfaces/RequestMetadataResponse.html":{},"interfaces/RevokeCredentialsResult.html":{},"interfaces/TokenInfo.html":{},"interfaces/TokenInfoRequest.html":{},"interfaces/VerifyIdTokenOptions.html":{}}}],["this.requestasync(opts).then(r",{"_index":1099,"title":{},"body":{"interfaces/FederatedSignonCertsResponse.html":{},"interfaces/GetAccessTokenCallback.html":{},"interfaces/GetAccessTokenResponse.html":{},"interfaces/GetFederatedSignonCertsCallback.html":{},"interfaces/GetTokenCallback.html":{},"interfaces/GetTokenOptions.html":{},"interfaces/GetTokenResponse.html":{},"interfaces/OAuth2ClientOptions.html":{},"interfaces/RefreshAccessTokenCallback.html":{},"interfaces/RefreshAccessTokenResponse.html":{},"interfaces/RefreshOptions.html":{},"interfaces/RequestMetadataCallback.html":{},"interfaces/RequestMetadataResponse.html":{},"interfaces/RevokeCredentialsResult.html":{},"interfaces/TokenInfo.html":{},"interfaces/TokenInfoRequest.html":{},"interfaces/VerifyIdTokenOptions.html":{}}}],["this.revokecredentialsasync",{"_index":1091,"title":{},"body":{"interfaces/FederatedSignonCertsResponse.html":{},"interfaces/GetAccessTokenCallback.html":{},"interfaces/GetAccessTokenResponse.html":{},"interfaces/GetFederatedSignonCertsCallback.html":{},"interfaces/GetTokenCallback.html":{},"interfaces/GetTokenOptions.html":{},"interfaces/GetTokenResponse.html":{},"interfaces/OAuth2ClientOptions.html":{},"interfaces/RefreshAccessTokenCallback.html":{},"interfaces/RefreshAccessTokenResponse.html":{},"interfaces/RefreshOptions.html":{},"interfaces/RequestMetadataCallback.html":{},"interfaces/RequestMetadataResponse.html":{},"interfaces/RevokeCredentialsResult.html":{},"interfaces/TokenInfo.html":{},"interfaces/TokenInfoRequest.html":{},"interfaces/VerifyIdTokenOptions.html":{}}}],["this.revokecredentialsasync().then(r",{"_index":1090,"title":{},"body":{"interfaces/FederatedSignonCertsResponse.html":{},"interfaces/GetAccessTokenCallback.html":{},"interfaces/GetAccessTokenResponse.html":{},"interfaces/GetFederatedSignonCertsCallback.html":{},"interfaces/GetTokenCallback.html":{},"interfaces/GetTokenOptions.html":{},"interfaces/GetTokenResponse.html":{},"interfaces/OAuth2ClientOptions.html":{},"interfaces/RefreshAccessTokenCallback.html":{},"interfaces/RefreshAccessTokenResponse.html":{},"interfaces/RefreshOptions.html":{},"interfaces/RequestMetadataCallback.html":{},"interfaces/RequestMetadataResponse.html":{},"interfaces/RevokeCredentialsResult.html":{},"interfaces/TokenInfo.html":{},"interfaces/TokenInfoRequest.html":{},"interfaces/VerifyIdTokenOptions.html":{}}}],["this.revoketoken(token",{"_index":1093,"title":{},"body":{"interfaces/FederatedSignonCertsResponse.html":{},"interfaces/GetAccessTokenCallback.html":{},"interfaces/GetAccessTokenResponse.html":{},"interfaces/GetFederatedSignonCertsCallback.html":{},"interfaces/GetTokenCallback.html":{},"interfaces/GetTokenOptions.html":{},"interfaces/GetTokenResponse.html":{},"interfaces/OAuth2ClientOptions.html":{},"interfaces/RefreshAccessTokenCallback.html":{},"interfaces/RefreshAccessTokenResponse.html":{},"interfaces/RefreshOptions.html":{},"interfaces/RequestMetadataCallback.html":{},"interfaces/RequestMetadataResponse.html":{},"interfaces/RevokeCredentialsResult.html":{},"interfaces/TokenInfo.html":{},"interfaces/TokenInfoRequest.html":{},"interfaces/VerifyIdTokenOptions.html":{}}}],["this.scop",{"_index":125,"title":{},"body":{"interfaces/ADCCallback.html":{},"interfaces/ADCResponse.html":{},"interfaces/CredentialCallback.html":{},"interfaces/GoogleAuthOptions.html":{},"interfaces/JWTOptions.html":{},"interfaces/ProjectIdCallback.html":{},"interfaces/SignBlobResponse.html":{}}}],["this.scopes.length",{"_index":1316,"title":{},"body":{"interfaces/JWTOptions.html":{}}}],["this.selector",{"_index":1210,"title":{},"body":{"classes/IAMAuth.html":{},"interfaces/RequestMetadata.html":{}}}],["this.serviceaccountemail",{"_index":599,"title":{},"body":{"interfaces/ComputeOptions.html":{}}}],["this.subject",{"_index":1297,"title":{},"body":{"interfaces/JWTOptions.html":{}}}],["this.token",{"_index":1211,"title":{},"body":{"classes/IAMAuth.html":{},"interfaces/RequestMetadata.html":{}}}],["this.transporter.request",{"_index":1020,"title":{},"body":{"interfaces/FederatedSignonCertsResponse.html":{},"interfaces/GetAccessTokenCallback.html":{},"interfaces/GetAccessTokenResponse.html":{},"interfaces/GetFederatedSignonCertsCallback.html":{},"interfaces/GetTokenCallback.html":{},"interfaces/GetTokenOptions.html":{},"interfaces/GetTokenResponse.html":{},"interfaces/OAuth2ClientOptions.html":{},"interfaces/RefreshAccessTokenCallback.html":{},"interfaces/RefreshAccessTokenResponse.html":{},"interfaces/RefreshOptions.html":{},"interfaces/RequestMetadataCallback.html":{},"interfaces/RequestMetadataResponse.html":{},"interfaces/RevokeCredentialsResult.html":{},"interfaces/TokenInfo.html":{},"interfaces/TokenInfoRequest.html":{},"interfaces/VerifyIdTokenOptions.html":{}}}],["this.transporter.request(opt",{"_index":1086,"title":{},"body":{"interfaces/FederatedSignonCertsResponse.html":{},"interfaces/GetAccessTokenCallback.html":{},"interfaces/GetAccessTokenResponse.html":{},"interfaces/GetFederatedSignonCertsCallback.html":{},"interfaces/GetTokenCallback.html":{},"interfaces/GetTokenOptions.html":{},"interfaces/GetTokenResponse.html":{},"interfaces/OAuth2ClientOptions.html":{},"interfaces/RefreshAccessTokenCallback.html":{},"interfaces/RefreshAccessTokenResponse.html":{},"interfaces/RefreshOptions.html":{},"interfaces/RequestMetadataCallback.html":{},"interfaces/RequestMetadataResponse.html":{},"interfaces/RevokeCredentialsResult.html":{},"interfaces/TokenInfo.html":{},"interfaces/TokenInfoRequest.html":{},"interfaces/VerifyIdTokenOptions.html":{}}}],["this.transporter.request(opts).then",{"_index":1085,"title":{},"body":{"interfaces/FederatedSignonCertsResponse.html":{},"interfaces/GetAccessTokenCallback.html":{},"interfaces/GetAccessTokenResponse.html":{},"interfaces/GetFederatedSignonCertsCallback.html":{},"interfaces/GetTokenCallback.html":{},"interfaces/GetTokenOptions.html":{},"interfaces/GetTokenResponse.html":{},"interfaces/OAuth2ClientOptions.html":{},"interfaces/RefreshAccessTokenCallback.html":{},"interfaces/RefreshAccessTokenResponse.html":{},"interfaces/RefreshOptions.html":{},"interfaces/RequestMetadataCallback.html":{},"interfaces/RequestMetadataResponse.html":{},"interfaces/RevokeCredentialsResult.html":{},"interfaces/TokenInfo.html":{},"interfaces/TokenInfoRequest.html":{},"interfaces/VerifyIdTokenOptions.html":{}}}],["this.verifyidtokenasync(opt",{"_index":1136,"title":{},"body":{"interfaces/FederatedSignonCertsResponse.html":{},"interfaces/GetAccessTokenCallback.html":{},"interfaces/GetAccessTokenResponse.html":{},"interfaces/GetFederatedSignonCertsCallback.html":{},"interfaces/GetTokenCallback.html":{},"interfaces/GetTokenOptions.html":{},"interfaces/GetTokenResponse.html":{},"interfaces/OAuth2ClientOptions.html":{},"interfaces/RefreshAccessTokenCallback.html":{},"interfaces/RefreshAccessTokenResponse.html":{},"interfaces/RefreshOptions.html":{},"interfaces/RequestMetadataCallback.html":{},"interfaces/RequestMetadataResponse.html":{},"interfaces/RevokeCredentialsResult.html":{},"interfaces/TokenInfo.html":{},"interfaces/TokenInfoRequest.html":{},"interfaces/VerifyIdTokenOptions.html":{}}}],["this.verifyidtokenasync(options).then(r",{"_index":1135,"title":{},"body":{"interfaces/FederatedSignonCertsResponse.html":{},"interfaces/GetAccessTokenCallback.html":{},"interfaces/GetAccessTokenResponse.html":{},"interfaces/GetFederatedSignonCertsCallback.html":{},"interfaces/GetTokenCallback.html":{},"interfaces/GetTokenOptions.html":{},"interfaces/GetTokenResponse.html":{},"interfaces/OAuth2ClientOptions.html":{},"interfaces/RefreshAccessTokenCallback.html":{},"interfaces/RefreshAccessTokenResponse.html":{},"interfaces/RefreshOptions.html":{},"interfaces/RequestMetadataCallback.html":{},"interfaces/RequestMetadataResponse.html":{},"interfaces/RevokeCredentialsResult.html":{},"interfaces/TokenInfo.html":{},"interfaces/TokenInfoRequest.html":{},"interfaces/VerifyIdTokenOptions.html":{}}}],["this.verifysignedjwtwithcert",{"_index":1140,"title":{},"body":{"interfaces/FederatedSignonCertsResponse.html":{},"interfaces/GetAccessTokenCallback.html":{},"interfaces/GetAccessTokenResponse.html":{},"interfaces/GetFederatedSignonCertsCallback.html":{},"interfaces/GetTokenCallback.html":{},"interfaces/GetTokenOptions.html":{},"interfaces/GetTokenResponse.html":{},"interfaces/OAuth2ClientOptions.html":{},"interfaces/RefreshAccessTokenCallback.html":{},"interfaces/RefreshAccessTokenResponse.html":{},"interfaces/RefreshOptions.html":{},"interfaces/RequestMetadataCallback.html":{},"interfaces/RequestMetadataResponse.html":{},"interfaces/RevokeCredentialsResult.html":{},"interfaces/TokenInfo.html":{},"interfaces/TokenInfoRequest.html":{},"interfaces/VerifyIdTokenOptions.html":{}}}],["this.warnonproblematiccredentials(cli",{"_index":286,"title":{},"body":{"interfaces/ADCCallback.html":{},"interfaces/ADCResponse.html":{},"interfaces/CredentialCallback.html":{},"interfaces/GoogleAuthOptions.html":{},"interfaces/ProjectIdCallback.html":{},"interfaces/SignBlobResponse.html":{}}}],["thiscr",{"_index":1070,"title":{},"body":{"interfaces/FederatedSignonCertsResponse.html":{},"interfaces/GetAccessTokenCallback.html":{},"interfaces/GetAccessTokenResponse.html":{},"interfaces/GetFederatedSignonCertsCallback.html":{},"interfaces/GetTokenCallback.html":{},"interfaces/GetTokenOptions.html":{},"interfaces/GetTokenResponse.html":{},"interfaces/OAuth2ClientOptions.html":{},"interfaces/RefreshAccessTokenCallback.html":{},"interfaces/RefreshAccessTokenResponse.html":{},"interfaces/RefreshOptions.html":{},"interfaces/RequestMetadataCallback.html":{},"interfaces/RequestMetadataResponse.html":{},"interfaces/RevokeCredentialsResult.html":{},"interfaces/TokenInfo.html":{},"interfaces/TokenInfoRequest.html":{},"interfaces/VerifyIdTokenOptions.html":{}}}],["thiscreds.access_token",{"_index":1071,"title":{},"body":{"interfaces/FederatedSignonCertsResponse.html":{},"interfaces/GetAccessTokenCallback.html":{},"interfaces/GetAccessTokenResponse.html":{},"interfaces/GetFederatedSignonCertsCallback.html":{},"interfaces/GetTokenCallback.html":{},"interfaces/GetTokenOptions.html":{},"interfaces/GetTokenResponse.html":{},"interfaces/OAuth2ClientOptions.html":{},"interfaces/RefreshAccessTokenCallback.html":{},"interfaces/RefreshAccessTokenResponse.html":{},"interfaces/RefreshOptions.html":{},"interfaces/RequestMetadataCallback.html":{},"interfaces/RequestMetadataResponse.html":{},"interfaces/RevokeCredentialsResult.html":{},"interfaces/TokenInfo.html":{},"interfaces/TokenInfoRequest.html":{},"interfaces/VerifyIdTokenOptions.html":{}}}],["thiscreds.refresh_token",{"_index":1072,"title":{},"body":{"interfaces/FederatedSignonCertsResponse.html":{},"interfaces/GetAccessTokenCallback.html":{},"interfaces/GetAccessTokenResponse.html":{},"interfaces/GetFederatedSignonCertsCallback.html":{},"interfaces/GetTokenCallback.html":{},"interfaces/GetTokenOptions.html":{},"interfaces/GetTokenResponse.html":{},"interfaces/OAuth2ClientOptions.html":{},"interfaces/RefreshAccessTokenCallback.html":{},"interfaces/RefreshAccessTokenResponse.html":{},"interfaces/RefreshOptions.html":{},"interfaces/RequestMetadataCallback.html":{},"interfaces/RequestMetadataResponse.html":{},"interfaces/RevokeCredentialsResult.html":{},"interfaces/TokenInfo.html":{},"interfaces/TokenInfoRequest.html":{},"interfaces/VerifyIdTokenOptions.html":{}}}],["thiscreds.token_typ",{"_index":1074,"title":{},"body":{"interfaces/FederatedSignonCertsResponse.html":{},"interfaces/GetAccessTokenCallback.html":{},"interfaces/GetAccessTokenResponse.html":{},"interfaces/GetFederatedSignonCertsCallback.html":{},"interfaces/GetTokenCallback.html":{},"interfaces/GetTokenOptions.html":{},"interfaces/GetTokenResponse.html":{},"interfaces/OAuth2ClientOptions.html":{},"interfaces/RefreshAccessTokenCallback.html":{},"interfaces/RefreshAccessTokenResponse.html":{},"interfaces/RefreshOptions.html":{},"interfaces/RequestMetadataCallback.html":{},"interfaces/RequestMetadataResponse.html":{},"interfaces/RevokeCredentialsResult.html":{},"interfaces/TokenInfo.html":{},"interfaces/TokenInfoRequest.html":{},"interfaces/VerifyIdTokenOptions.html":{}}}],["those",{"_index":1689,"title":{},"body":{"index.html":{},"license.html":{}}}],["three",{"_index":159,"title":{},"body":{"interfaces/ADCCallback.html":{},"interfaces/ADCResponse.html":{},"interfaces/CredentialCallback.html":{},"interfaces/GoogleAuthOptions.html":{},"interfaces/ProjectIdCallback.html":{},"interfaces/SignBlobResponse.html":{}}}],["through",{"_index":1722,"title":{},"body":{"index.html":{},"license.html":{}}}],["throw",{"_index":231,"title":{},"body":{"interfaces/ADCCallback.html":{},"interfaces/ADCResponse.html":{},"interfaces/BodyResponseCallback.html":{},"interfaces/ComputeOptions.html":{},"interfaces/CredentialCallback.html":{},"classes/DefaultTransporter.html":{},"interfaces/FederatedSignonCertsResponse.html":{},"interfaces/GetAccessTokenCallback.html":{},"interfaces/GetAccessTokenResponse.html":{},"interfaces/GetFederatedSignonCertsCallback.html":{},"interfaces/GetTokenCallback.html":{},"interfaces/GetTokenOptions.html":{},"interfaces/GetTokenResponse.html":{},"interfaces/GoogleAuthOptions.html":{},"classes/JWTAccess.html":{},"interfaces/JWTOptions.html":{},"interfaces/OAuth2ClientOptions.html":{},"interfaces/ProjectIdCallback.html":{},"interfaces/RefreshAccessTokenCallback.html":{},"interfaces/RefreshAccessTokenResponse.html":{},"interfaces/RefreshOptions.html":{},"interfaces/RequestError.html":{},"interfaces/RequestMetadataCallback.html":{},"interfaces/RequestMetadataResponse.html":{},"interfaces/RevokeCredentialsResult.html":{},"interfaces/SignBlobResponse.html":{},"interfaces/TokenInfo.html":{},"interfaces/TokenInfoRequest.html":{},"interfaces/Transporter.html":{},"interfaces/UserRefreshClientOptions.html":{},"interfaces/VerifyIdTokenOptions.html":{},"changelog.html":{},"index.html":{}}}],["thrown",{"_index":300,"title":{},"body":{"interfaces/ADCCallback.html":{},"interfaces/ADCResponse.html":{},"interfaces/CredentialCallback.html":{},"interfaces/GoogleAuthOptions.html":{},"interfaces/ProjectIdCallback.html":{},"interfaces/SignBlobResponse.html":{}}}],["thu",{"_index":796,"title":{},"body":{"interfaces/FederatedSignonCertsResponse.html":{},"interfaces/GetAccessTokenCallback.html":{},"interfaces/GetAccessTokenResponse.html":{},"interfaces/GetFederatedSignonCertsCallback.html":{},"interfaces/GetTokenCallback.html":{},"interfaces/GetTokenOptions.html":{},"interfaces/GetTokenResponse.html":{},"interfaces/OAuth2ClientOptions.html":{},"interfaces/RefreshAccessTokenCallback.html":{},"interfaces/RefreshAccessTokenResponse.html":{},"interfaces/RefreshOptions.html":{},"interfaces/RequestMetadataCallback.html":{},"interfaces/RequestMetadataResponse.html":{},"interfaces/RevokeCredentialsResult.html":{},"interfaces/TokenInfo.html":{},"interfaces/TokenInfoRequest.html":{},"interfaces/VerifyIdTokenOptions.html":{}}}],["ti",{"_index":1363,"title":{},"body":{"classes/LoginTicket.html":{},"interfaces/TokenPayload.html":{}}}],["ticket",{"_index":1353,"title":{},"body":{"classes/LoginTicket.html":{},"interfaces/TokenPayload.html":{}}}],["time",{"_index":605,"title":{},"body":{"interfaces/ComputeOptions.html":{},"interfaces/FederatedSignonCertsResponse.html":{},"interfaces/GetAccessTokenCallback.html":{},"interfaces/GetAccessTokenResponse.html":{},"interfaces/GetFederatedSignonCertsCallback.html":{},"interfaces/GetTokenCallback.html":{},"interfaces/GetTokenOptions.html":{},"interfaces/GetTokenResponse.html":{},"classes/LoginTicket.html":{},"interfaces/OAuth2ClientOptions.html":{},"interfaces/RefreshAccessTokenCallback.html":{},"interfaces/RefreshAccessTokenResponse.html":{},"interfaces/RefreshOptions.html":{},"interfaces/RequestMetadataCallback.html":{},"interfaces/RequestMetadataResponse.html":{},"interfaces/RevokeCredentialsResult.html":{},"interfaces/TokenInfo.html":{},"interfaces/TokenInfoRequest.html":{},"interfaces/TokenPayload.html":{},"interfaces/VerifyIdTokenOptions.html":{},"index.html":{}}}],["titl",{"_index":1948,"title":{},"body":{"license.html":{}}}],["todo",{"_index":910,"title":{},"body":{"interfaces/FederatedSignonCertsResponse.html":{},"interfaces/GetAccessTokenCallback.html":{},"interfaces/GetAccessTokenResponse.html":{},"interfaces/GetFederatedSignonCertsCallback.html":{},"interfaces/GetTokenCallback.html":{},"interfaces/GetTokenOptions.html":{},"interfaces/GetTokenResponse.html":{},"interfaces/OAuth2ClientOptions.html":{},"interfaces/RefreshAccessTokenCallback.html":{},"interfaces/RefreshAccessTokenResponse.html":{},"interfaces/RefreshOptions.html":{},"interfaces/RequestMetadataCallback.html":{},"interfaces/RequestMetadataResponse.html":{},"interfaces/RevokeCredentialsResult.html":{},"interfaces/TokenInfo.html":{},"interfaces/TokenInfoRequest.html":{},"interfaces/UserRefreshClientOptions.html":{},"interfaces/VerifyIdTokenOptions.html":{}}}],["token",{"_index":450,"title":{},"body":{"interfaces/ADCCallback.html":{},"interfaces/ADCResponse.html":{},"interfaces/ComputeOptions.html":{},"interfaces/CredentialCallback.html":{},"interfaces/FederatedSignonCertsResponse.html":{},"interfaces/GetAccessTokenCallback.html":{},"interfaces/GetAccessTokenResponse.html":{},"interfaces/GetFederatedSignonCertsCallback.html":{},"interfaces/GetTokenCallback.html":{},"interfaces/GetTokenOptions.html":{},"interfaces/GetTokenResponse.html":{},"interfaces/GoogleAuthOptions.html":{},"classes/IAMAuth.html":{},"classes/JWTAccess.html":{},"interfaces/JWTOptions.html":{},"classes/LoginTicket.html":{},"interfaces/OAuth2ClientOptions.html":{},"interfaces/ProjectIdCallback.html":{},"interfaces/RefreshAccessTokenCallback.html":{},"interfaces/RefreshAccessTokenResponse.html":{},"interfaces/RefreshOptions.html":{},"interfaces/RequestMetadata.html":{},"interfaces/RequestMetadataCallback.html":{},"interfaces/RequestMetadataResponse.html":{},"interfaces/RevokeCredentialsResult.html":{},"interfaces/SignBlobResponse.html":{},"interfaces/TokenInfo.html":{},"interfaces/TokenInfoRequest.html":{},"interfaces/TokenPayload.html":{},"interfaces/UserRefreshClientOptions.html":{},"interfaces/VerifyIdTokenOptions.html":{},"changelog.html":{},"index.html":{}}}],["token_typ",{"_index":640,"title":{},"body":{"interfaces/CredentialBody.html":{},"interfaces/CredentialRequest.html":{},"interfaces/Credentials.html":{},"interfaces/JWTInput.html":{},"interfaces/JWTOptions.html":{}}}],["token_uri",{"_index":1793,"title":{},"body":{"index.html":{}}}],["tokeninfo",{"_index":707,"title":{"interfaces/TokenInfo.html":{}},"body":{"interfaces/FederatedSignonCertsResponse.html":{},"interfaces/GetAccessTokenCallback.html":{},"interfaces/GetAccessTokenResponse.html":{},"interfaces/GetFederatedSignonCertsCallback.html":{},"interfaces/GetTokenCallback.html":{},"interfaces/GetTokenOptions.html":{},"interfaces/GetTokenResponse.html":{},"interfaces/OAuth2ClientOptions.html":{},"interfaces/RefreshAccessTokenCallback.html":{},"interfaces/RefreshAccessTokenResponse.html":{},"interfaces/RefreshOptions.html":{},"interfaces/RequestMetadataCallback.html":{},"interfaces/RequestMetadataResponse.html":{},"interfaces/RevokeCredentialsResult.html":{},"interfaces/TokenInfo.html":{},"interfaces/TokenInfoRequest.html":{},"interfaces/VerifyIdTokenOptions.html":{},"index.html":{}}}],["tokeninforequest",{"_index":751,"title":{"interfaces/TokenInfoRequest.html":{}},"body":{"interfaces/FederatedSignonCertsResponse.html":{},"interfaces/GetAccessTokenCallback.html":{},"interfaces/GetAccessTokenResponse.html":{},"interfaces/GetFederatedSignonCertsCallback.html":{},"interfaces/GetTokenCallback.html":{},"interfaces/GetTokenOptions.html":{},"interfaces/GetTokenResponse.html":{},"interfaces/OAuth2ClientOptions.html":{},"interfaces/RefreshAccessTokenCallback.html":{},"interfaces/RefreshAccessTokenResponse.html":{},"interfaces/RefreshOptions.html":{},"interfaces/RequestMetadataCallback.html":{},"interfaces/RequestMetadataResponse.html":{},"interfaces/RevokeCredentialsResult.html":{},"interfaces/TokenInfo.html":{},"interfaces/TokenInfoRequest.html":{},"interfaces/VerifyIdTokenOptions.html":{}}}],["tokenpath",{"_index":613,"title":{},"body":{"interfaces/ComputeOptions.html":{}}}],["tokenpayload",{"_index":693,"title":{"interfaces/TokenPayload.html":{}},"body":{"interfaces/FederatedSignonCertsResponse.html":{},"interfaces/GetAccessTokenCallback.html":{},"interfaces/GetAccessTokenResponse.html":{},"interfaces/GetFederatedSignonCertsCallback.html":{},"interfaces/GetTokenCallback.html":{},"interfaces/GetTokenOptions.html":{},"interfaces/GetTokenResponse.html":{},"classes/LoginTicket.html":{},"interfaces/OAuth2ClientOptions.html":{},"interfaces/RefreshAccessTokenCallback.html":{},"interfaces/RefreshAccessTokenResponse.html":{},"interfaces/RefreshOptions.html":{},"interfaces/RequestMetadataCallback.html":{},"interfaces/RequestMetadataResponse.html":{},"interfaces/RevokeCredentialsResult.html":{},"interfaces/TokenInfo.html":{},"interfaces/TokenInfoRequest.html":{},"interfaces/TokenPayload.html":{},"interfaces/VerifyIdTokenOptions.html":{}}}],["tokens.access_token",{"_index":1080,"title":{},"body":{"interfaces/FederatedSignonCertsResponse.html":{},"interfaces/GetAccessTokenCallback.html":{},"interfaces/GetAccessTokenResponse.html":{},"interfaces/GetFederatedSignonCertsCallback.html":{},"interfaces/GetTokenCallback.html":{},"interfaces/GetTokenOptions.html":{},"interfaces/GetTokenResponse.html":{},"interfaces/OAuth2ClientOptions.html":{},"interfaces/RefreshAccessTokenCallback.html":{},"interfaces/RefreshAccessTokenResponse.html":{},"interfaces/RefreshOptions.html":{},"interfaces/RequestMetadataCallback.html":{},"interfaces/RequestMetadataResponse.html":{},"interfaces/RevokeCredentialsResult.html":{},"interfaces/TokenInfo.html":{},"interfaces/TokenInfoRequest.html":{},"interfaces/VerifyIdTokenOptions.html":{}}}],["tokens.expiry_d",{"_index":617,"title":{},"body":{"interfaces/ComputeOptions.html":{},"interfaces/FederatedSignonCertsResponse.html":{},"interfaces/GetAccessTokenCallback.html":{},"interfaces/GetAccessTokenResponse.html":{},"interfaces/GetFederatedSignonCertsCallback.html":{},"interfaces/GetTokenCallback.html":{},"interfaces/GetTokenOptions.html":{},"interfaces/GetTokenResponse.html":{},"interfaces/OAuth2ClientOptions.html":{},"interfaces/RefreshAccessTokenCallback.html":{},"interfaces/RefreshAccessTokenResponse.html":{},"interfaces/RefreshOptions.html":{},"interfaces/RequestMetadataCallback.html":{},"interfaces/RequestMetadataResponse.html":{},"interfaces/RevokeCredentialsResult.html":{},"interfaces/TokenInfo.html":{},"interfaces/TokenInfoRequest.html":{},"interfaces/VerifyIdTokenOptions.html":{}}}],["tokens.id_token",{"_index":1307,"title":{},"body":{"interfaces/JWTOptions.html":{}}}],["tokens.refresh_token",{"_index":1046,"title":{},"body":{"interfaces/FederatedSignonCertsResponse.html":{},"interfaces/GetAccessTokenCallback.html":{},"interfaces/GetAccessTokenResponse.html":{},"interfaces/GetFederatedSignonCertsCallback.html":{},"interfaces/GetTokenCallback.html":{},"interfaces/GetTokenOptions.html":{},"interfaces/GetTokenResponse.html":{},"interfaces/OAuth2ClientOptions.html":{},"interfaces/RefreshAccessTokenCallback.html":{},"interfaces/RefreshAccessTokenResponse.html":{},"interfaces/RefreshOptions.html":{},"interfaces/RequestMetadataCallback.html":{},"interfaces/RequestMetadataResponse.html":{},"interfaces/RevokeCredentialsResult.html":{},"interfaces/TokenInfo.html":{},"interfaces/TokenInfoRequest.html":{},"interfaces/VerifyIdTokenOptions.html":{},"index.html":{}}}],["tool",{"_index":1584,"title":{},"body":{"changelog.html":{}}}],["tort",{"_index":1956,"title":{},"body":{"license.html":{}}}],["track",{"_index":1871,"title":{},"body":{"license.html":{}}}],["trade",{"_index":1944,"title":{},"body":{"license.html":{}}}],["trademark",{"_index":1921,"title":{},"body":{"license.html":{}}}],["trail",{"_index":425,"title":{},"body":{"interfaces/ADCCallback.html":{},"interfaces/ADCResponse.html":{},"interfaces/CredentialCallback.html":{},"interfaces/FederatedSignonCertsResponse.html":{},"interfaces/GetAccessTokenCallback.html":{},"interfaces/GetAccessTokenResponse.html":{},"interfaces/GetFederatedSignonCertsCallback.html":{},"interfaces/GetTokenCallback.html":{},"interfaces/GetTokenOptions.html":{},"interfaces/GetTokenResponse.html":{},"interfaces/GoogleAuthOptions.html":{},"interfaces/OAuth2ClientOptions.html":{},"interfaces/ProjectIdCallback.html":{},"interfaces/RefreshAccessTokenCallback.html":{},"interfaces/RefreshAccessTokenResponse.html":{},"interfaces/RefreshOptions.html":{},"interfaces/RequestMetadataCallback.html":{},"interfaces/RequestMetadataResponse.html":{},"interfaces/RevokeCredentialsResult.html":{},"interfaces/SignBlobResponse.html":{},"interfaces/TokenInfo.html":{},"interfaces/TokenInfoRequest.html":{},"interfaces/VerifyIdTokenOptions.html":{}}}],["transfer",{"_index":1897,"title":{},"body":{"license.html":{}}}],["transform",{"_index":1847,"title":{},"body":{"license.html":{}}}],["translat",{"_index":1848,"title":{},"body":{"license.html":{}}}],["transport",{"_index":38,"title":{"interfaces/Transporter.html":{}},"body":{"interfaces/ADCCallback.html":{},"interfaces/ADCResponse.html":{},"interfaces/BodyResponseCallback.html":{},"interfaces/CredentialCallback.html":{},"classes/DefaultTransporter.html":{},"interfaces/FederatedSignonCertsResponse.html":{},"interfaces/GetAccessTokenCallback.html":{},"interfaces/GetAccessTokenResponse.html":{},"interfaces/GetFederatedSignonCertsCallback.html":{},"interfaces/GetTokenCallback.html":{},"interfaces/GetTokenOptions.html":{},"interfaces/GetTokenResponse.html":{},"interfaces/GoogleAuthOptions.html":{},"interfaces/OAuth2ClientOptions.html":{},"interfaces/ProjectIdCallback.html":{},"interfaces/RefreshAccessTokenCallback.html":{},"interfaces/RefreshAccessTokenResponse.html":{},"interfaces/RefreshOptions.html":{},"interfaces/RequestError.html":{},"interfaces/RequestMetadataCallback.html":{},"interfaces/RequestMetadataResponse.html":{},"interfaces/RevokeCredentialsResult.html":{},"interfaces/SignBlobResponse.html":{},"interfaces/TokenInfo.html":{},"interfaces/TokenInfoRequest.html":{},"interfaces/Transporter.html":{},"interfaces/VerifyIdTokenOptions.html":{}}}],["tri",{"_index":179,"title":{},"body":{"interfaces/ADCCallback.html":{},"interfaces/ADCResponse.html":{},"interfaces/BodyResponseCallback.html":{},"interfaces/ComputeOptions.html":{},"interfaces/CredentialCallback.html":{},"classes/DefaultTransporter.html":{},"interfaces/FederatedSignonCertsResponse.html":{},"interfaces/GetAccessTokenCallback.html":{},"interfaces/GetAccessTokenResponse.html":{},"interfaces/GetFederatedSignonCertsCallback.html":{},"interfaces/GetTokenCallback.html":{},"interfaces/GetTokenOptions.html":{},"interfaces/GetTokenResponse.html":{},"interfaces/GoogleAuthOptions.html":{},"classes/JWTAccess.html":{},"interfaces/JWTOptions.html":{},"interfaces/OAuth2ClientOptions.html":{},"interfaces/ProjectIdCallback.html":{},"interfaces/RefreshAccessTokenCallback.html":{},"interfaces/RefreshAccessTokenResponse.html":{},"interfaces/RefreshOptions.html":{},"interfaces/RequestError.html":{},"interfaces/RequestMetadataCallback.html":{},"interfaces/RequestMetadataResponse.html":{},"interfaces/RevokeCredentialsResult.html":{},"interfaces/SignBlobResponse.html":{},"interfaces/TokenInfo.html":{},"interfaces/TokenInfoRequest.html":{},"interfaces/Transporter.html":{},"interfaces/UserRefreshClientOptions.html":{},"interfaces/VerifyIdTokenOptions.html":{},"changelog.html":{},"index.html":{}}}],["true",{"_index":369,"title":{},"body":{"interfaces/ADCCallback.html":{},"interfaces/ADCResponse.html":{},"interfaces/CredentialCallback.html":{},"interfaces/FederatedSignonCertsResponse.html":{},"interfaces/GetAccessTokenCallback.html":{},"interfaces/GetAccessTokenResponse.html":{},"interfaces/GetFederatedSignonCertsCallback.html":{},"interfaces/GetTokenCallback.html":{},"interfaces/GetTokenOptions.html":{},"interfaces/GetTokenResponse.html":{},"interfaces/GoogleAuthOptions.html":{},"classes/LoginTicket.html":{},"interfaces/OAuth2ClientOptions.html":{},"interfaces/ProjectIdCallback.html":{},"interfaces/RefreshAccessTokenCallback.html":{},"interfaces/RefreshAccessTokenResponse.html":{},"interfaces/RefreshOptions.html":{},"interfaces/RequestMetadataCallback.html":{},"interfaces/RequestMetadataResponse.html":{},"interfaces/RevokeCredentialsResult.html":{},"interfaces/SignBlobResponse.html":{},"interfaces/TokenInfo.html":{},"interfaces/TokenInfoRequest.html":{},"interfaces/TokenPayload.html":{},"interfaces/VerifyIdTokenOptions.html":{},"interfaces/Warning.html":{}}}],["truli",{"_index":513,"title":{},"body":{"interfaces/BodyResponseCallback.html":{},"classes/DefaultTransporter.html":{},"interfaces/RequestError.html":{},"interfaces/Transporter.html":{}}}],["trust",{"_index":780,"title":{},"body":{"interfaces/FederatedSignonCertsResponse.html":{},"interfaces/GetAccessTokenCallback.html":{},"interfaces/GetAccessTokenResponse.html":{},"interfaces/GetFederatedSignonCertsCallback.html":{},"interfaces/GetTokenCallback.html":{},"interfaces/GetTokenOptions.html":{},"interfaces/GetTokenResponse.html":{},"interfaces/OAuth2ClientOptions.html":{},"interfaces/RefreshAccessTokenCallback.html":{},"interfaces/RefreshAccessTokenResponse.html":{},"interfaces/RefreshOptions.html":{},"interfaces/RequestMetadataCallback.html":{},"interfaces/RequestMetadataResponse.html":{},"interfaces/RevokeCredentialsResult.html":{},"interfaces/TokenInfo.html":{},"interfaces/TokenInfoRequest.html":{},"interfaces/VerifyIdTokenOptions.html":{}}}],["tslint:dis",{"_index":466,"title":{},"body":{"interfaces/ADCCallback.html":{},"interfaces/ADCResponse.html":{},"interfaces/BodyResponseCallback.html":{},"interfaces/CredentialCallback.html":{},"classes/DefaultTransporter.html":{},"interfaces/GoogleAuthOptions.html":{},"interfaces/JWTOptions.html":{},"interfaces/ProjectIdCallback.html":{},"interfaces/RequestError.html":{},"interfaces/SignBlobResponse.html":{},"interfaces/Transporter.html":{},"interfaces/Warning.html":{}}}],["two",{"_index":382,"title":{},"body":{"interfaces/ADCCallback.html":{},"interfaces/ADCResponse.html":{},"interfaces/CredentialCallback.html":{},"interfaces/FederatedSignonCertsResponse.html":{},"interfaces/GetAccessTokenCallback.html":{},"interfaces/GetAccessTokenResponse.html":{},"interfaces/GetFederatedSignonCertsCallback.html":{},"interfaces/GetTokenCallback.html":{},"interfaces/GetTokenOptions.html":{},"interfaces/GetTokenResponse.html":{},"interfaces/GoogleAuthOptions.html":{},"interfaces/OAuth2ClientOptions.html":{},"interfaces/ProjectIdCallback.html":{},"interfaces/RefreshAccessTokenCallback.html":{},"interfaces/RefreshAccessTokenResponse.html":{},"interfaces/RefreshOptions.html":{},"interfaces/RequestMetadataCallback.html":{},"interfaces/RequestMetadataResponse.html":{},"interfaces/RevokeCredentialsResult.html":{},"interfaces/SignBlobResponse.html":{},"interfaces/TokenInfo.html":{},"interfaces/TokenInfoRequest.html":{},"interfaces/VerifyIdTokenOptions.html":{}}}],["typ",{"_index":1243,"title":{},"body":{"classes/JWTAccess.html":{},"miscellaneous/variables.html":{}}}],["type",{"_index":267,"title":{},"body":{"interfaces/ADCCallback.html":{},"interfaces/ADCResponse.html":{},"interfaces/BodyResponseCallback.html":{},"interfaces/ComputeOptions.html":{},"interfaces/CredentialBody.html":{},"interfaces/CredentialCallback.html":{},"interfaces/CredentialRequest.html":{},"interfaces/Credentials.html":{},"classes/DefaultTransporter.html":{},"interfaces/FederatedSignonCertsResponse.html":{},"interfaces/GetAccessTokenCallback.html":{},"interfaces/GetAccessTokenResponse.html":{},"interfaces/GetFederatedSignonCertsCallback.html":{},"interfaces/GetTokenCallback.html":{},"interfaces/GetTokenOptions.html":{},"interfaces/GetTokenResponse.html":{},"interfaces/GoogleAuthOptions.html":{},"classes/IAMAuth.html":{},"classes/JWTAccess.html":{},"interfaces/JWTInput.html":{},"interfaces/JWTOptions.html":{},"classes/LoginTicket.html":{},"interfaces/OAuth2ClientOptions.html":{},"classes/PemVerifier.html":{},"interfaces/ProjectIdCallback.html":{},"interfaces/RefreshAccessTokenCallback.html":{},"interfaces/RefreshAccessTokenResponse.html":{},"interfaces/RefreshOptions.html":{},"interfaces/RequestError.html":{},"interfaces/RequestMetadata.html":{},"interfaces/RequestMetadataCallback.html":{},"interfaces/RequestMetadataResponse.html":{},"interfaces/RevokeCredentialsResult.html":{},"interfaces/SignBlobResponse.html":{},"interfaces/TokenInfo.html":{},"interfaces/TokenInfoRequest.html":{},"interfaces/TokenPayload.html":{},"interfaces/Transporter.html":{},"interfaces/UserRefreshClientOptions.html":{},"interfaces/VerifyIdTokenOptions.html":{},"interfaces/Warning.html":{},"changelog.html":{},"miscellaneous/functions.html":{},"index.html":{},"license.html":{},"miscellaneous/typealiases.html":{},"miscellaneous/variables.html":{}}}],["typealias",{"_index":1996,"title":{"miscellaneous/typealiases.html":{}},"body":{}}],["typedoc",{"_index":1477,"title":{},"body":{"changelog.html":{}}}],["typeof",{"_index":199,"title":{},"body":{"interfaces/ADCCallback.html":{},"interfaces/ADCResponse.html":{},"interfaces/BodyResponseCallback.html":{},"interfaces/CredentialCallback.html":{},"classes/DefaultTransporter.html":{},"interfaces/FederatedSignonCertsResponse.html":{},"interfaces/GetAccessTokenCallback.html":{},"interfaces/GetAccessTokenResponse.html":{},"interfaces/GetFederatedSignonCertsCallback.html":{},"interfaces/GetTokenCallback.html":{},"interfaces/GetTokenOptions.html":{},"interfaces/GetTokenResponse.html":{},"interfaces/GoogleAuthOptions.html":{},"interfaces/JWTOptions.html":{},"interfaces/OAuth2ClientOptions.html":{},"interfaces/ProjectIdCallback.html":{},"interfaces/RefreshAccessTokenCallback.html":{},"interfaces/RefreshAccessTokenResponse.html":{},"interfaces/RefreshOptions.html":{},"interfaces/RequestError.html":{},"interfaces/RequestMetadataCallback.html":{},"interfaces/RequestMetadataResponse.html":{},"interfaces/RevokeCredentialsResult.html":{},"interfaces/SignBlobResponse.html":{},"interfaces/TokenInfo.html":{},"interfaces/TokenInfoRequest.html":{},"interfaces/Transporter.html":{},"interfaces/UserRefreshClientOptions.html":{},"interfaces/VerifyIdTokenOptions.html":{}}}],["types/nod",{"_index":1422,"title":{},"body":{"interfaces/Warning.html":{}}}],["typescript",{"_index":1471,"title":{},"body":{"changelog.html":{}}}],["typic",{"_index":217,"title":{},"body":{"interfaces/ADCCallback.html":{},"interfaces/ADCResponse.html":{},"interfaces/CredentialCallback.html":{},"interfaces/GoogleAuthOptions.html":{},"interfaces/ProjectIdCallback.html":{},"interfaces/SignBlobResponse.html":{}}}],["typo",{"_index":1484,"title":{},"body":{"changelog.html":{}}}],["uavalu",{"_index":537,"title":{},"body":{"interfaces/BodyResponseCallback.html":{},"classes/DefaultTransporter.html":{},"interfaces/RequestError.html":{},"interfaces/Transporter.html":{}}}],["uavalue.includes(`${product_nam",{"_index":540,"title":{},"body":{"interfaces/BodyResponseCallback.html":{},"classes/DefaultTransporter.html":{},"interfaces/RequestError.html":{},"interfaces/Transporter.html":{}}}],["ui",{"_index":766,"title":{},"body":{"interfaces/FederatedSignonCertsResponse.html":{},"interfaces/GetAccessTokenCallback.html":{},"interfaces/GetAccessTokenResponse.html":{},"interfaces/GetFederatedSignonCertsCallback.html":{},"interfaces/GetTokenCallback.html":{},"interfaces/GetTokenOptions.html":{},"interfaces/GetTokenResponse.html":{},"interfaces/OAuth2ClientOptions.html":{},"interfaces/RefreshAccessTokenCallback.html":{},"interfaces/RefreshAccessTokenResponse.html":{},"interfaces/RefreshOptions.html":{},"interfaces/RequestMetadataCallback.html":{},"interfaces/RequestMetadataResponse.html":{},"interfaces/RevokeCredentialsResult.html":{},"interfaces/TokenInfo.html":{},"interfaces/TokenInfoRequest.html":{},"interfaces/VerifyIdTokenOptions.html":{}}}],["unabl",{"_index":259,"title":{},"body":{"interfaces/ADCCallback.html":{},"interfaces/ADCResponse.html":{},"interfaces/CredentialCallback.html":{},"interfaces/GoogleAuthOptions.html":{},"interfaces/ProjectIdCallback.html":{},"interfaces/SignBlobResponse.html":{}}}],["unam",{"_index":8,"title":{},"body":{"interfaces/ADCCallback.html":{},"interfaces/BodyResponseCallback.html":{},"interfaces/CredentialCallback.html":{},"interfaces/GetAccessTokenCallback.html":{},"interfaces/GetFederatedSignonCertsCallback.html":{},"interfaces/GetTokenCallback.html":{},"interfaces/ProjectIdCallback.html":{},"interfaces/RefreshAccessTokenCallback.html":{},"interfaces/RequestMetadataCallback.html":{}}}],["undefin",{"_index":98,"title":{},"body":{"interfaces/ADCCallback.html":{},"interfaces/ADCResponse.html":{},"interfaces/CredentialCallback.html":{},"interfaces/GoogleAuthOptions.html":{},"interfaces/ProjectIdCallback.html":{},"interfaces/SignBlobResponse.html":{},"miscellaneous/variables.html":{}}}],["under",{"_index":655,"title":{},"body":{"interfaces/Credentials.html":{},"classes/LoginTicket.html":{},"miscellaneous/functions.html":{},"index.html":{},"license.html":{}}}],["understand",{"_index":811,"title":{},"body":{"interfaces/FederatedSignonCertsResponse.html":{},"interfaces/GetAccessTokenCallback.html":{},"interfaces/GetAccessTokenResponse.html":{},"interfaces/GetFederatedSignonCertsCallback.html":{},"interfaces/GetTokenCallback.html":{},"interfaces/GetTokenOptions.html":{},"interfaces/GetTokenResponse.html":{},"interfaces/OAuth2ClientOptions.html":{},"interfaces/RefreshAccessTokenCallback.html":{},"interfaces/RefreshAccessTokenResponse.html":{},"interfaces/RefreshOptions.html":{},"interfaces/RequestMetadataCallback.html":{},"interfaces/RequestMetadataResponse.html":{},"interfaces/RevokeCredentialsResult.html":{},"interfaces/TokenInfo.html":{},"interfaces/TokenInfoRequest.html":{},"interfaces/VerifyIdTokenOptions.html":{}}}],["unencodedcodechalleng",{"_index":994,"title":{},"body":{"interfaces/FederatedSignonCertsResponse.html":{},"interfaces/GetAccessTokenCallback.html":{},"interfaces/GetAccessTokenResponse.html":{},"interfaces/GetFederatedSignonCertsCallback.html":{},"interfaces/GetTokenCallback.html":{},"interfaces/GetTokenOptions.html":{},"interfaces/GetTokenResponse.html":{},"interfaces/OAuth2ClientOptions.html":{},"interfaces/RefreshAccessTokenCallback.html":{},"interfaces/RefreshAccessTokenResponse.html":{},"interfaces/RefreshOptions.html":{},"interfaces/RequestMetadataCallback.html":{},"interfaces/RequestMetadataResponse.html":{},"interfaces/RevokeCredentialsResult.html":{},"interfaces/TokenInfo.html":{},"interfaces/TokenInfoRequest.html":{},"interfaces/VerifyIdTokenOptions.html":{}}}],["unencodedcodechallenge.split('=')[0",{"_index":999,"title":{},"body":{"interfaces/FederatedSignonCertsResponse.html":{},"interfaces/GetAccessTokenCallback.html":{},"interfaces/GetAccessTokenResponse.html":{},"interfaces/GetFederatedSignonCertsCallback.html":{},"interfaces/GetTokenCallback.html":{},"interfaces/GetTokenOptions.html":{},"interfaces/GetTokenResponse.html":{},"interfaces/OAuth2ClientOptions.html":{},"interfaces/RefreshAccessTokenCallback.html":{},"interfaces/RefreshAccessTokenResponse.html":{},"interfaces/RefreshOptions.html":{},"interfaces/RequestMetadataCallback.html":{},"interfaces/RequestMetadataResponse.html":{},"interfaces/RevokeCredentialsResult.html":{},"interfaces/TokenInfo.html":{},"interfaces/TokenInfoRequest.html":{},"interfaces/VerifyIdTokenOptions.html":{}}}],["unexpect",{"_index":232,"title":{},"body":{"interfaces/ADCCallback.html":{},"interfaces/ADCResponse.html":{},"interfaces/CredentialCallback.html":{},"interfaces/GoogleAuthOptions.html":{},"interfaces/ProjectIdCallback.html":{},"interfaces/SignBlobResponse.html":{}}}],["unexpir",{"_index":898,"title":{},"body":{"interfaces/FederatedSignonCertsResponse.html":{},"interfaces/GetAccessTokenCallback.html":{},"interfaces/GetAccessTokenResponse.html":{},"interfaces/GetFederatedSignonCertsCallback.html":{},"interfaces/GetTokenCallback.html":{},"interfaces/GetTokenOptions.html":{},"interfaces/GetTokenResponse.html":{},"interfaces/OAuth2ClientOptions.html":{},"interfaces/RefreshAccessTokenCallback.html":{},"interfaces/RefreshAccessTokenResponse.html":{},"interfaces/RefreshOptions.html":{},"interfaces/RequestMetadataCallback.html":{},"interfaces/RequestMetadataResponse.html":{},"interfaces/RevokeCredentialsResult.html":{},"interfaces/TokenInfo.html":{},"interfaces/TokenInfoRequest.html":{},"interfaces/VerifyIdTokenOptions.html":{}}}],["unhandl",{"_index":1569,"title":{},"body":{"changelog.html":{}}}],["union",{"_index":1829,"title":{},"body":{"license.html":{}}}],["uniqu",{"_index":729,"title":{},"body":{"interfaces/FederatedSignonCertsResponse.html":{},"interfaces/GetAccessTokenCallback.html":{},"interfaces/GetAccessTokenResponse.html":{},"interfaces/GetFederatedSignonCertsCallback.html":{},"interfaces/GetTokenCallback.html":{},"interfaces/GetTokenOptions.html":{},"interfaces/GetTokenResponse.html":{},"classes/LoginTicket.html":{},"interfaces/OAuth2ClientOptions.html":{},"interfaces/RefreshAccessTokenCallback.html":{},"interfaces/RefreshAccessTokenResponse.html":{},"interfaces/RefreshOptions.html":{},"interfaces/RequestMetadataCallback.html":{},"interfaces/RequestMetadataResponse.html":{},"interfaces/RevokeCredentialsResult.html":{},"interfaces/TokenInfo.html":{},"interfaces/TokenInfoRequest.html":{},"interfaces/TokenPayload.html":{},"interfaces/VerifyIdTokenOptions.html":{}}}],["unit",{"_index":103,"title":{},"body":{"interfaces/ADCCallback.html":{},"interfaces/ADCResponse.html":{},"interfaces/CredentialCallback.html":{},"interfaces/GoogleAuthOptions.html":{},"interfaces/ProjectIdCallback.html":{},"interfaces/SignBlobResponse.html":{}}}],["unix",{"_index":1382,"title":{},"body":{"classes/LoginTicket.html":{},"interfaces/TokenPayload.html":{}}}],["unless",{"_index":1937,"title":{},"body":{"license.html":{}}}],["unlik",{"_index":778,"title":{},"body":{"interfaces/FederatedSignonCertsResponse.html":{},"interfaces/GetAccessTokenCallback.html":{},"interfaces/GetAccessTokenResponse.html":{},"interfaces/GetFederatedSignonCertsCallback.html":{},"interfaces/GetTokenCallback.html":{},"interfaces/GetTokenOptions.html":{},"interfaces/GetTokenResponse.html":{},"interfaces/OAuth2ClientOptions.html":{},"interfaces/RefreshAccessTokenCallback.html":{},"interfaces/RefreshAccessTokenResponse.html":{},"interfaces/RefreshOptions.html":{},"interfaces/RequestMetadataCallback.html":{},"interfaces/RequestMetadataResponse.html":{},"interfaces/RevokeCredentialsResult.html":{},"interfaces/TokenInfo.html":{},"interfaces/TokenInfoRequest.html":{},"interfaces/VerifyIdTokenOptions.html":{}}}],["unsuccess",{"_index":1098,"title":{},"body":{"interfaces/FederatedSignonCertsResponse.html":{},"interfaces/GetAccessTokenCallback.html":{},"interfaces/GetAccessTokenResponse.html":{},"interfaces/GetFederatedSignonCertsCallback.html":{},"interfaces/GetTokenCallback.html":{},"interfaces/GetTokenOptions.html":{},"interfaces/GetTokenResponse.html":{},"interfaces/OAuth2ClientOptions.html":{},"interfaces/RefreshAccessTokenCallback.html":{},"interfaces/RefreshAccessTokenResponse.html":{},"interfaces/RefreshOptions.html":{},"interfaces/RequestMetadataCallback.html":{},"interfaces/RequestMetadataResponse.html":{},"interfaces/RevokeCredentialsResult.html":{},"interfaces/TokenInfo.html":{},"interfaces/TokenInfoRequest.html":{},"interfaces/VerifyIdTokenOptions.html":{}}}],["unus",{"_index":610,"title":{},"body":{"interfaces/ComputeOptions.html":{}}}],["unused_uri",{"_index":1213,"title":{},"body":{"classes/IAMAuth.html":{},"interfaces/RequestMetadata.html":{}}}],["unuseduri",{"_index":1207,"title":{},"body":{"classes/IAMAuth.html":{},"interfaces/RequestMetadata.html":{}}}],["updat",{"_index":1373,"title":{},"body":{"classes/LoginTicket.html":{},"interfaces/TokenPayload.html":{},"changelog.html":{}}}],["upgrad",{"_index":1131,"title":{},"body":{"interfaces/FederatedSignonCertsResponse.html":{},"interfaces/GetAccessTokenCallback.html":{},"interfaces/GetAccessTokenResponse.html":{},"interfaces/GetFederatedSignonCertsCallback.html":{},"interfaces/GetTokenCallback.html":{},"interfaces/GetTokenOptions.html":{},"interfaces/GetTokenResponse.html":{},"interfaces/OAuth2ClientOptions.html":{},"interfaces/RefreshAccessTokenCallback.html":{},"interfaces/RefreshAccessTokenResponse.html":{},"interfaces/RefreshOptions.html":{},"interfaces/RequestMetadataCallback.html":{},"interfaces/RequestMetadataResponse.html":{},"interfaces/RevokeCredentialsResult.html":{},"interfaces/TokenInfo.html":{},"interfaces/TokenInfoRequest.html":{},"interfaces/VerifyIdTokenOptions.html":{},"index.html":{}}}],["upload",{"_index":1507,"title":{},"body":{"changelog.html":{}}}],["upon",{"_index":266,"title":{},"body":{"interfaces/ADCCallback.html":{},"interfaces/ADCResponse.html":{},"interfaces/CredentialCallback.html":{},"interfaces/GoogleAuthOptions.html":{},"interfaces/ProjectIdCallback.html":{},"interfaces/SignBlobResponse.html":{},"index.html":{}}}],["uri",{"_index":461,"title":{},"body":{"interfaces/ADCCallback.html":{},"interfaces/ADCResponse.html":{},"interfaces/CredentialCallback.html":{},"interfaces/FederatedSignonCertsResponse.html":{},"interfaces/GetAccessTokenCallback.html":{},"interfaces/GetAccessTokenResponse.html":{},"interfaces/GetFederatedSignonCertsCallback.html":{},"interfaces/GetTokenCallback.html":{},"interfaces/GetTokenOptions.html":{},"interfaces/GetTokenResponse.html":{},"interfaces/GoogleAuthOptions.html":{},"classes/JWTAccess.html":{},"interfaces/JWTOptions.html":{},"interfaces/OAuth2ClientOptions.html":{},"interfaces/ProjectIdCallback.html":{},"interfaces/RefreshAccessTokenCallback.html":{},"interfaces/RefreshAccessTokenResponse.html":{},"interfaces/RefreshOptions.html":{},"interfaces/RequestMetadataCallback.html":{},"interfaces/RequestMetadataResponse.html":{},"interfaces/RevokeCredentialsResult.html":{},"interfaces/SignBlobResponse.html":{},"interfaces/TokenInfo.html":{},"interfaces/TokenInfoRequest.html":{},"interfaces/VerifyIdTokenOptions.html":{},"changelog.html":{}}}],["url",{"_index":460,"title":{},"body":{"interfaces/ADCCallback.html":{},"interfaces/ADCResponse.html":{},"interfaces/CredentialCallback.html":{},"interfaces/FederatedSignonCertsResponse.html":{},"interfaces/GetAccessTokenCallback.html":{},"interfaces/GetAccessTokenResponse.html":{},"interfaces/GetFederatedSignonCertsCallback.html":{},"interfaces/GetTokenCallback.html":{},"interfaces/GetTokenOptions.html":{},"interfaces/GetTokenResponse.html":{},"interfaces/GoogleAuthOptions.html":{},"classes/JWTAccess.html":{},"interfaces/JWTOptions.html":{},"classes/LoginTicket.html":{},"interfaces/OAuth2ClientOptions.html":{},"interfaces/ProjectIdCallback.html":{},"interfaces/RefreshAccessTokenCallback.html":{},"interfaces/RefreshAccessTokenResponse.html":{},"interfaces/RefreshOptions.html":{},"interfaces/RequestMetadataCallback.html":{},"interfaces/RequestMetadataResponse.html":{},"interfaces/RevokeCredentialsResult.html":{},"interfaces/SignBlobResponse.html":{},"interfaces/TokenInfo.html":{},"interfaces/TokenInfoRequest.html":{},"interfaces/TokenPayload.html":{},"interfaces/VerifyIdTokenOptions.html":{},"changelog.html":{},"index.html":{}}}],["urlencod",{"_index":1024,"title":{},"body":{"interfaces/FederatedSignonCertsResponse.html":{},"interfaces/GetAccessTokenCallback.html":{},"interfaces/GetAccessTokenResponse.html":{},"interfaces/GetFederatedSignonCertsCallback.html":{},"interfaces/GetTokenCallback.html":{},"interfaces/GetTokenOptions.html":{},"interfaces/GetTokenResponse.html":{},"interfaces/OAuth2ClientOptions.html":{},"interfaces/RefreshAccessTokenCallback.html":{},"interfaces/RefreshAccessTokenResponse.html":{},"interfaces/RefreshOptions.html":{},"interfaces/RequestMetadataCallback.html":{},"interfaces/RequestMetadataResponse.html":{},"interfaces/RevokeCredentialsResult.html":{},"interfaces/TokenInfo.html":{},"interfaces/TokenInfoRequest.html":{},"interfaces/VerifyIdTokenOptions.html":{}}}],["us",{"_index":134,"title":{},"body":{"interfaces/ADCCallback.html":{},"interfaces/ADCResponse.html":{},"interfaces/BodyResponseCallback.html":{},"interfaces/ComputeOptions.html":{},"interfaces/CredentialCallback.html":{},"interfaces/Credentials.html":{},"classes/DefaultTransporter.html":{},"interfaces/FederatedSignonCertsResponse.html":{},"interfaces/GetAccessTokenCallback.html":{},"interfaces/GetAccessTokenResponse.html":{},"interfaces/GetFederatedSignonCertsCallback.html":{},"interfaces/GetTokenCallback.html":{},"interfaces/GetTokenOptions.html":{},"interfaces/GetTokenResponse.html":{},"interfaces/GoogleAuthOptions.html":{},"classes/IAMAuth.html":{},"classes/JWTAccess.html":{},"interfaces/JWTOptions.html":{},"classes/LoginTicket.html":{},"interfaces/OAuth2ClientOptions.html":{},"interfaces/ProjectIdCallback.html":{},"interfaces/RefreshAccessTokenCallback.html":{},"interfaces/RefreshAccessTokenResponse.html":{},"interfaces/RefreshOptions.html":{},"interfaces/RequestError.html":{},"interfaces/RequestMetadata.html":{},"interfaces/RequestMetadataCallback.html":{},"interfaces/RequestMetadataResponse.html":{},"interfaces/RevokeCredentialsResult.html":{},"interfaces/SignBlobResponse.html":{},"interfaces/TokenInfo.html":{},"interfaces/TokenInfoRequest.html":{},"interfaces/TokenPayload.html":{},"interfaces/Transporter.html":{},"interfaces/UserRefreshClientOptions.html":{},"interfaces/VerifyIdTokenOptions.html":{},"interfaces/Warning.html":{},"changelog.html":{},"miscellaneous/functions.html":{},"index.html":{},"license.html":{},"miscellaneous/variables.html":{}}}],["user",{"_index":415,"title":{},"body":{"interfaces/ADCCallback.html":{},"interfaces/ADCResponse.html":{},"interfaces/BodyResponseCallback.html":{},"interfaces/CredentialCallback.html":{},"classes/DefaultTransporter.html":{},"interfaces/FederatedSignonCertsResponse.html":{},"interfaces/GetAccessTokenCallback.html":{},"interfaces/GetAccessTokenResponse.html":{},"interfaces/GetFederatedSignonCertsCallback.html":{},"interfaces/GetTokenCallback.html":{},"interfaces/GetTokenOptions.html":{},"interfaces/GetTokenResponse.html":{},"interfaces/GoogleAuthOptions.html":{},"classes/LoginTicket.html":{},"interfaces/OAuth2ClientOptions.html":{},"interfaces/ProjectIdCallback.html":{},"interfaces/RefreshAccessTokenCallback.html":{},"interfaces/RefreshAccessTokenResponse.html":{},"interfaces/RefreshOptions.html":{},"interfaces/RequestError.html":{},"interfaces/RequestMetadataCallback.html":{},"interfaces/RequestMetadataResponse.html":{},"interfaces/RevokeCredentialsResult.html":{},"interfaces/SignBlobResponse.html":{},"interfaces/TokenInfo.html":{},"interfaces/TokenInfoRequest.html":{},"interfaces/TokenPayload.html":{},"interfaces/Transporter.html":{},"interfaces/UserRefreshClientOptions.html":{},"interfaces/VerifyIdTokenOptions.html":{},"interfaces/Warning.html":{},"changelog.html":{},"index.html":{},"miscellaneous/variables.html":{}}}],["user'",{"_index":790,"title":{},"body":{"interfaces/FederatedSignonCertsResponse.html":{},"interfaces/GetAccessTokenCallback.html":{},"interfaces/GetAccessTokenResponse.html":{},"interfaces/GetFederatedSignonCertsCallback.html":{},"interfaces/GetTokenCallback.html":{},"interfaces/GetTokenOptions.html":{},"interfaces/GetTokenResponse.html":{},"classes/LoginTicket.html":{},"interfaces/OAuth2ClientOptions.html":{},"interfaces/RefreshAccessTokenCallback.html":{},"interfaces/RefreshAccessTokenResponse.html":{},"interfaces/RefreshOptions.html":{},"interfaces/RequestMetadataCallback.html":{},"interfaces/RequestMetadataResponse.html":{},"interfaces/RevokeCredentialsResult.html":{},"interfaces/TokenInfo.html":{},"interfaces/TokenInfoRequest.html":{},"interfaces/TokenPayload.html":{},"interfaces/VerifyIdTokenOptions.html":{}}}],["user_ag",{"_index":533,"title":{},"body":{"interfaces/BodyResponseCallback.html":{},"classes/DefaultTransporter.html":{},"interfaces/RequestError.html":{},"interfaces/Transporter.html":{}}}],["user_id",{"_index":724,"title":{},"body":{"interfaces/FederatedSignonCertsResponse.html":{},"interfaces/GetAccessTokenCallback.html":{},"interfaces/GetAccessTokenResponse.html":{},"interfaces/GetFederatedSignonCertsCallback.html":{},"interfaces/GetTokenCallback.html":{},"interfaces/GetTokenOptions.html":{},"interfaces/GetTokenResponse.html":{},"interfaces/OAuth2ClientOptions.html":{},"interfaces/RefreshAccessTokenCallback.html":{},"interfaces/RefreshAccessTokenResponse.html":{},"interfaces/RefreshOptions.html":{},"interfaces/RequestMetadataCallback.html":{},"interfaces/RequestMetadataResponse.html":{},"interfaces/RevokeCredentialsResult.html":{},"interfaces/TokenInfo.html":{},"interfaces/TokenInfoRequest.html":{},"interfaces/VerifyIdTokenOptions.html":{}}}],["userrefresh",{"_index":326,"title":{},"body":{"interfaces/ADCCallback.html":{},"interfaces/ADCResponse.html":{},"interfaces/CredentialCallback.html":{},"interfaces/GoogleAuthOptions.html":{},"interfaces/ProjectIdCallback.html":{},"interfaces/SignBlobResponse.html":{}}}],["userrefreshcli",{"_index":51,"title":{},"body":{"interfaces/ADCCallback.html":{},"interfaces/ADCResponse.html":{},"interfaces/CredentialCallback.html":{},"interfaces/GoogleAuthOptions.html":{},"interfaces/ProjectIdCallback.html":{},"interfaces/SignBlobResponse.html":{},"interfaces/UserRefreshClientOptions.html":{},"index.html":{}}}],["userrefreshclient(opt",{"_index":333,"title":{},"body":{"interfaces/ADCCallback.html":{},"interfaces/ADCResponse.html":{},"interfaces/CredentialCallback.html":{},"interfaces/GoogleAuthOptions.html":{},"interfaces/ProjectIdCallback.html":{},"interfaces/SignBlobResponse.html":{}}}],["userrefreshclientopt",{"_index":1398,"title":{"interfaces/UserRefreshClientOptions.html":{}},"body":{"interfaces/UserRefreshClientOptions.html":{}}}],["userrefreshclient|jwt",{"_index":59,"title":{},"body":{"interfaces/ADCCallback.html":{},"interfaces/ADCResponse.html":{},"interfaces/CredentialCallback.html":{},"interfaces/GoogleAuthOptions.html":{},"interfaces/ProjectIdCallback.html":{},"interfaces/SignBlobResponse.html":{}}}],["util",{"_index":35,"title":{},"body":{"interfaces/ADCCallback.html":{},"interfaces/ADCResponse.html":{},"interfaces/CredentialCallback.html":{},"interfaces/FederatedSignonCertsResponse.html":{},"interfaces/GetAccessTokenCallback.html":{},"interfaces/GetAccessTokenResponse.html":{},"interfaces/GetFederatedSignonCertsCallback.html":{},"interfaces/GetTokenCallback.html":{},"interfaces/GetTokenOptions.html":{},"interfaces/GetTokenResponse.html":{},"interfaces/GoogleAuthOptions.html":{},"interfaces/OAuth2ClientOptions.html":{},"interfaces/ProjectIdCallback.html":{},"interfaces/RefreshAccessTokenCallback.html":{},"interfaces/RefreshAccessTokenResponse.html":{},"interfaces/RefreshOptions.html":{},"interfaces/RequestMetadataCallback.html":{},"interfaces/RequestMetadataResponse.html":{},"interfaces/RevokeCredentialsResult.html":{},"interfaces/SignBlobResponse.html":{},"interfaces/TokenInfo.html":{},"interfaces/TokenInfoRequest.html":{},"interfaces/VerifyIdTokenOptions.html":{}}}],["util.format",{"_index":303,"title":{},"body":{"interfaces/ADCCallback.html":{},"interfaces/ADCResponse.html":{},"interfaces/CredentialCallback.html":{},"interfaces/GoogleAuthOptions.html":{},"interfaces/ProjectIdCallback.html":{},"interfaces/SignBlobResponse.html":{}}}],["util.format('un",{"_index":311,"title":{},"body":{"interfaces/ADCCallback.html":{},"interfaces/ADCResponse.html":{},"interfaces/CredentialCallback.html":{},"interfaces/GoogleAuthOptions.html":{},"interfaces/ProjectIdCallback.html":{},"interfaces/SignBlobResponse.html":{}}}],["v1",{"_index":1600,"title":{},"body":{"changelog.html":{}}}],["v10",{"_index":1466,"title":{},"body":{"changelog.html":{}}}],["v13",{"_index":1594,"title":{},"body":{"changelog.html":{}}}],["v2",{"_index":1475,"title":{},"body":{"changelog.html":{}}}],["v2.0.0",{"_index":1529,"title":{},"body":{"changelog.html":{}}}],["v2.0.1",{"_index":1458,"title":{},"body":{"changelog.html":{}}}],["v3",{"_index":1617,"title":{},"body":{"changelog.html":{}}}],["v3.1.3",{"_index":1472,"title":{},"body":{"changelog.html":{}}}],["v4",{"_index":1597,"title":{},"body":{"changelog.html":{}}}],["v6.x/api/process.html#process_process_emitwarning_warning_name_ctor",{"_index":1429,"title":{},"body":{"interfaces/Warning.html":{}}}],["v7",{"_index":1469,"title":{},"body":{"changelog.html":{}}}],["v8.x/api/process.html#process_process_emitwarning_warning_opt",{"_index":1426,"title":{},"body":{"interfaces/Warning.html":{}}}],["valid",{"_index":500,"title":{},"body":{"interfaces/BodyResponseCallback.html":{},"classes/DefaultTransporter.html":{},"interfaces/FederatedSignonCertsResponse.html":{},"interfaces/GetAccessTokenCallback.html":{},"interfaces/GetAccessTokenResponse.html":{},"interfaces/GetFederatedSignonCertsCallback.html":{},"interfaces/GetTokenCallback.html":{},"interfaces/GetTokenOptions.html":{},"interfaces/GetTokenResponse.html":{},"classes/LoginTicket.html":{},"interfaces/OAuth2ClientOptions.html":{},"interfaces/RefreshAccessTokenCallback.html":{},"interfaces/RefreshAccessTokenResponse.html":{},"interfaces/RefreshOptions.html":{},"interfaces/RequestError.html":{},"interfaces/RequestMetadataCallback.html":{},"interfaces/RequestMetadataResponse.html":{},"interfaces/RevokeCredentialsResult.html":{},"interfaces/TokenInfo.html":{},"interfaces/TokenInfoRequest.html":{},"interfaces/TokenPayload.html":{},"interfaces/Transporter.html":{},"interfaces/VerifyIdTokenOptions.html":{},"miscellaneous/functions.html":{}}}],["validate(opt",{"_index":545,"title":{},"body":{"interfaces/BodyResponseCallback.html":{},"classes/DefaultTransporter.html":{},"interfaces/RequestError.html":{},"interfaces/Transporter.html":{},"miscellaneous/functions.html":{}}}],["valu",{"_index":87,"title":{},"body":{"interfaces/ADCCallback.html":{},"interfaces/ADCResponse.html":{},"interfaces/CredentialCallback.html":{},"classes/DefaultTransporter.html":{},"interfaces/FederatedSignonCertsResponse.html":{},"interfaces/GetAccessTokenCallback.html":{},"interfaces/GetAccessTokenResponse.html":{},"interfaces/GetFederatedSignonCertsCallback.html":{},"interfaces/GetTokenCallback.html":{},"interfaces/GetTokenOptions.html":{},"interfaces/GetTokenResponse.html":{},"interfaces/GoogleAuthOptions.html":{},"interfaces/JWTOptions.html":{},"classes/LoginTicket.html":{},"interfaces/OAuth2ClientOptions.html":{},"interfaces/ProjectIdCallback.html":{},"interfaces/RefreshAccessTokenCallback.html":{},"interfaces/RefreshAccessTokenResponse.html":{},"interfaces/RefreshOptions.html":{},"interfaces/RequestMetadataCallback.html":{},"interfaces/RequestMetadataResponse.html":{},"interfaces/RevokeCredentialsResult.html":{},"interfaces/SignBlobResponse.html":{},"interfaces/TokenInfo.html":{},"interfaces/TokenInfoRequest.html":{},"interfaces/TokenPayload.html":{},"interfaces/VerifyIdTokenOptions.html":{},"miscellaneous/enumerations.html":{},"miscellaneous/variables.html":{}}}],["var",{"_index":506,"title":{},"body":{"interfaces/BodyResponseCallback.html":{},"classes/DefaultTransporter.html":{},"interfaces/RequestError.html":{},"interfaces/Transporter.html":{},"changelog.html":{}}}],["variabl",{"_index":165,"title":{"miscellaneous/variables.html":{}},"body":{"interfaces/ADCCallback.html":{},"interfaces/ADCResponse.html":{},"interfaces/BodyResponseCallback.html":{},"interfaces/CredentialCallback.html":{},"classes/DefaultTransporter.html":{},"interfaces/GoogleAuthOptions.html":{},"interfaces/ProjectIdCallback.html":{},"interfaces/RequestError.html":{},"interfaces/SignBlobResponse.html":{},"interfaces/Transporter.html":{},"index.html":{},"miscellaneous/variables.html":{}}}],["varieti",{"_index":1668,"title":{},"body":{"index.html":{}}}],["variou",{"_index":1354,"title":{},"body":{"classes/LoginTicket.html":{},"interfaces/TokenPayload.html":{}}}],["verbal",{"_index":1869,"title":{},"body":{"license.html":{}}}],["veri",{"_index":427,"title":{},"body":{"interfaces/ADCCallback.html":{},"interfaces/ADCResponse.html":{},"interfaces/CredentialCallback.html":{},"interfaces/GoogleAuthOptions.html":{},"interfaces/ProjectIdCallback.html":{},"interfaces/SignBlobResponse.html":{},"index.html":{}}}],["verifi",{"_index":1124,"title":{},"body":{"interfaces/FederatedSignonCertsResponse.html":{},"interfaces/GetAccessTokenCallback.html":{},"interfaces/GetAccessTokenResponse.html":{},"interfaces/GetFederatedSignonCertsCallback.html":{},"interfaces/GetTokenCallback.html":{},"interfaces/GetTokenOptions.html":{},"interfaces/GetTokenResponse.html":{},"classes/LoginTicket.html":{},"interfaces/OAuth2ClientOptions.html":{},"classes/PemVerifier.html":{},"interfaces/RefreshAccessTokenCallback.html":{},"interfaces/RefreshAccessTokenResponse.html":{},"interfaces/RefreshOptions.html":{},"interfaces/RequestMetadataCallback.html":{},"interfaces/RequestMetadataResponse.html":{},"interfaces/RevokeCredentialsResult.html":{},"interfaces/TokenInfo.html":{},"interfaces/TokenInfoRequest.html":{},"interfaces/TokenPayload.html":{},"interfaces/VerifyIdTokenOptions.html":{}}}],["verifier.update(data",{"_index":1393,"title":{},"body":{"classes/PemVerifier.html":{}}}],["verifier.verify(pubkey",{"_index":1394,"title":{},"body":{"classes/PemVerifier.html":{}}}],["verify(pubkey",{"_index":1387,"title":{},"body":{"classes/PemVerifier.html":{}}}],["verifyidtoken",{"_index":1128,"title":{},"body":{"interfaces/FederatedSignonCertsResponse.html":{},"interfaces/GetAccessTokenCallback.html":{},"interfaces/GetAccessTokenResponse.html":{},"interfaces/GetFederatedSignonCertsCallback.html":{},"interfaces/GetTokenCallback.html":{},"interfaces/GetTokenOptions.html":{},"interfaces/GetTokenResponse.html":{},"interfaces/OAuth2ClientOptions.html":{},"interfaces/RefreshAccessTokenCallback.html":{},"interfaces/RefreshAccessTokenResponse.html":{},"interfaces/RefreshOptions.html":{},"interfaces/RequestMetadataCallback.html":{},"interfaces/RequestMetadataResponse.html":{},"interfaces/RevokeCredentialsResult.html":{},"interfaces/TokenInfo.html":{},"interfaces/TokenInfoRequest.html":{},"interfaces/VerifyIdTokenOptions.html":{},"changelog.html":{}}}],["verifyidtoken(opt",{"_index":1127,"title":{},"body":{"interfaces/FederatedSignonCertsResponse.html":{},"interfaces/GetAccessTokenCallback.html":{},"interfaces/GetAccessTokenResponse.html":{},"interfaces/GetFederatedSignonCertsCallback.html":{},"interfaces/GetTokenCallback.html":{},"interfaces/GetTokenOptions.html":{},"interfaces/GetTokenResponse.html":{},"interfaces/OAuth2ClientOptions.html":{},"interfaces/RefreshAccessTokenCallback.html":{},"interfaces/RefreshAccessTokenResponse.html":{},"interfaces/RefreshOptions.html":{},"interfaces/RequestMetadataCallback.html":{},"interfaces/RequestMetadataResponse.html":{},"interfaces/RevokeCredentialsResult.html":{},"interfaces/TokenInfo.html":{},"interfaces/TokenInfoRequest.html":{},"interfaces/VerifyIdTokenOptions.html":{}}}],["verifyidtokenasync(opt",{"_index":1137,"title":{},"body":{"interfaces/FederatedSignonCertsResponse.html":{},"interfaces/GetAccessTokenCallback.html":{},"interfaces/GetAccessTokenResponse.html":{},"interfaces/GetFederatedSignonCertsCallback.html":{},"interfaces/GetTokenCallback.html":{},"interfaces/GetTokenOptions.html":{},"interfaces/GetTokenResponse.html":{},"interfaces/OAuth2ClientOptions.html":{},"interfaces/RefreshAccessTokenCallback.html":{},"interfaces/RefreshAccessTokenResponse.html":{},"interfaces/RefreshOptions.html":{},"interfaces/RequestMetadataCallback.html":{},"interfaces/RequestMetadataResponse.html":{},"interfaces/RevokeCredentialsResult.html":{},"interfaces/TokenInfo.html":{},"interfaces/TokenInfoRequest.html":{},"interfaces/VerifyIdTokenOptions.html":{}}}],["verifyidtokenopt",{"_index":890,"title":{"interfaces/VerifyIdTokenOptions.html":{}},"body":{"interfaces/FederatedSignonCertsResponse.html":{},"interfaces/GetAccessTokenCallback.html":{},"interfaces/GetAccessTokenResponse.html":{},"interfaces/GetFederatedSignonCertsCallback.html":{},"interfaces/GetTokenCallback.html":{},"interfaces/GetTokenOptions.html":{},"interfaces/GetTokenResponse.html":{},"interfaces/OAuth2ClientOptions.html":{},"interfaces/RefreshAccessTokenCallback.html":{},"interfaces/RefreshAccessTokenResponse.html":{},"interfaces/RefreshOptions.html":{},"interfaces/RequestMetadataCallback.html":{},"interfaces/RequestMetadataResponse.html":{},"interfaces/RevokeCredentialsResult.html":{},"interfaces/TokenInfo.html":{},"interfaces/TokenInfoRequest.html":{},"interfaces/VerifyIdTokenOptions.html":{}}}],["version",{"_index":657,"title":{},"body":{"interfaces/Credentials.html":{},"classes/LoginTicket.html":{},"changelog.html":{},"miscellaneous/functions.html":{},"license.html":{}}}],["via",{"_index":807,"title":{},"body":{"interfaces/FederatedSignonCertsResponse.html":{},"interfaces/GetAccessTokenCallback.html":{},"interfaces/GetAccessTokenResponse.html":{},"interfaces/GetFederatedSignonCertsCallback.html":{},"interfaces/GetTokenCallback.html":{},"interfaces/GetTokenOptions.html":{},"interfaces/GetTokenResponse.html":{},"interfaces/OAuth2ClientOptions.html":{},"interfaces/RefreshAccessTokenCallback.html":{},"interfaces/RefreshAccessTokenResponse.html":{},"interfaces/RefreshOptions.html":{},"interfaces/RequestMetadataCallback.html":{},"interfaces/RequestMetadataResponse.html":{},"interfaces/RevokeCredentialsResult.html":{},"interfaces/TokenInfo.html":{},"interfaces/TokenInfoRequest.html":{},"interfaces/VerifyIdTokenOptions.html":{}}}],["visit",{"_index":1716,"title":{},"body":{"index.html":{}}}],["void",{"_index":19,"title":{},"body":{"interfaces/ADCCallback.html":{},"interfaces/ADCResponse.html":{},"interfaces/BodyResponseCallback.html":{},"interfaces/CredentialCallback.html":{},"classes/DefaultTransporter.html":{},"interfaces/FederatedSignonCertsResponse.html":{},"interfaces/GetAccessTokenCallback.html":{},"interfaces/GetAccessTokenResponse.html":{},"interfaces/GetFederatedSignonCertsCallback.html":{},"interfaces/GetTokenCallback.html":{},"interfaces/GetTokenOptions.html":{},"interfaces/GetTokenResponse.html":{},"interfaces/GoogleAuthOptions.html":{},"classes/IAMAuth.html":{},"classes/JWTAccess.html":{},"interfaces/JWTOptions.html":{},"interfaces/OAuth2ClientOptions.html":{},"interfaces/ProjectIdCallback.html":{},"interfaces/RefreshAccessTokenCallback.html":{},"interfaces/RefreshAccessTokenResponse.html":{},"interfaces/RefreshOptions.html":{},"interfaces/RequestError.html":{},"interfaces/RequestMetadata.html":{},"interfaces/RequestMetadataCallback.html":{},"interfaces/RequestMetadataResponse.html":{},"interfaces/RevokeCredentialsResult.html":{},"interfaces/SignBlobResponse.html":{},"interfaces/TokenInfo.html":{},"interfaces/TokenInfoRequest.html":{},"interfaces/Transporter.html":{},"interfaces/UserRefreshClientOptions.html":{},"interfaces/VerifyIdTokenOptions.html":{}}}],["void|promis",{"_index":197,"title":{},"body":{"interfaces/ADCCallback.html":{},"interfaces/ADCResponse.html":{},"interfaces/CredentialCallback.html":{},"interfaces/FederatedSignonCertsResponse.html":{},"interfaces/GetAccessTokenCallback.html":{},"interfaces/GetAccessTokenResponse.html":{},"interfaces/GetFederatedSignonCertsCallback.html":{},"interfaces/GetTokenCallback.html":{},"interfaces/GetTokenOptions.html":{},"interfaces/GetTokenResponse.html":{},"interfaces/GoogleAuthOptions.html":{},"classes/JWTAccess.html":{},"interfaces/JWTOptions.html":{},"interfaces/OAuth2ClientOptions.html":{},"interfaces/ProjectIdCallback.html":{},"interfaces/RefreshAccessTokenCallback.html":{},"interfaces/RefreshAccessTokenResponse.html":{},"interfaces/RefreshOptions.html":{},"interfaces/RequestMetadataCallback.html":{},"interfaces/RequestMetadataResponse.html":{},"interfaces/RevokeCredentialsResult.html":{},"interfaces/SignBlobResponse.html":{},"interfaces/TokenInfo.html":{},"interfaces/TokenInfoRequest.html":{},"interfaces/UserRefreshClientOptions.html":{},"interfaces/VerifyIdTokenOptions.html":{}}}],["want",{"_index":976,"title":{},"body":{"interfaces/FederatedSignonCertsResponse.html":{},"interfaces/GetAccessTokenCallback.html":{},"interfaces/GetAccessTokenResponse.html":{},"interfaces/GetFederatedSignonCertsCallback.html":{},"interfaces/GetTokenCallback.html":{},"interfaces/GetTokenOptions.html":{},"interfaces/GetTokenResponse.html":{},"interfaces/OAuth2ClientOptions.html":{},"interfaces/RefreshAccessTokenCallback.html":{},"interfaces/RefreshAccessTokenResponse.html":{},"interfaces/RefreshOptions.html":{},"interfaces/RequestMetadataCallback.html":{},"interfaces/RequestMetadataResponse.html":{},"interfaces/RevokeCredentialsResult.html":{},"interfaces/TokenInfo.html":{},"interfaces/TokenInfoRequest.html":{},"interfaces/VerifyIdTokenOptions.html":{},"index.html":{}}}],["warn",{"_index":318,"title":{"interfaces/Warning.html":{}},"body":{"interfaces/ADCCallback.html":{},"interfaces/ADCResponse.html":{},"interfaces/CredentialCallback.html":{},"interfaces/GoogleAuthOptions.html":{},"interfaces/ProjectIdCallback.html":{},"interfaces/SignBlobResponse.html":{},"interfaces/Warning.html":{},"changelog.html":{},"miscellaneous/enumerations.html":{},"miscellaneous/functions.html":{}}}],["warn(warn",{"_index":1417,"title":{},"body":{"interfaces/Warning.html":{},"miscellaneous/functions.html":{}}}],["warning.typ",{"_index":1430,"title":{},"body":{"interfaces/Warning.html":{}}}],["warning.warn",{"_index":1419,"title":{},"body":{"interfaces/Warning.html":{}}}],["warningtyp",{"_index":1414,"title":{},"body":{"interfaces/Warning.html":{},"miscellaneous/enumerations.html":{}}}],["warningtypes.deprec",{"_index":1440,"title":{},"body":{"interfaces/Warning.html":{},"miscellaneous/variables.html":{}}}],["warningtypes.warn",{"_index":1433,"title":{},"body":{"interfaces/Warning.html":{},"miscellaneous/variables.html":{}}}],["warnonproblematiccredentials(cli",{"_index":320,"title":{},"body":{"interfaces/ADCCallback.html":{},"interfaces/ADCResponse.html":{},"interfaces/CredentialCallback.html":{},"interfaces/GoogleAuthOptions.html":{},"interfaces/ProjectIdCallback.html":{},"interfaces/SignBlobResponse.html":{}}}],["warranti",{"_index":670,"title":{},"body":{"interfaces/Credentials.html":{},"classes/LoginTicket.html":{},"miscellaneous/functions.html":{},"license.html":{}}}],["way",{"_index":1670,"title":{},"body":{"index.html":{}}}],["we'r",{"_index":229,"title":{},"body":{"interfaces/ADCCallback.html":{},"interfaces/ADCResponse.html":{},"interfaces/CredentialCallback.html":{},"interfaces/FederatedSignonCertsResponse.html":{},"interfaces/GetAccessTokenCallback.html":{},"interfaces/GetAccessTokenResponse.html":{},"interfaces/GetFederatedSignonCertsCallback.html":{},"interfaces/GetTokenCallback.html":{},"interfaces/GetTokenOptions.html":{},"interfaces/GetTokenResponse.html":{},"interfaces/GoogleAuthOptions.html":{},"interfaces/OAuth2ClientOptions.html":{},"interfaces/ProjectIdCallback.html":{},"interfaces/RefreshAccessTokenCallback.html":{},"interfaces/RefreshAccessTokenResponse.html":{},"interfaces/RefreshOptions.html":{},"interfaces/RequestMetadataCallback.html":{},"interfaces/RequestMetadataResponse.html":{},"interfaces/RevokeCredentialsResult.html":{},"interfaces/SignBlobResponse.html":{},"interfaces/TokenInfo.html":{},"interfaces/TokenInfoRequest.html":{},"interfaces/VerifyIdTokenOptions.html":{}}}],["we'v",{"_index":208,"title":{},"body":{"interfaces/ADCCallback.html":{},"interfaces/ADCResponse.html":{},"interfaces/CredentialCallback.html":{},"interfaces/GoogleAuthOptions.html":{},"interfaces/ProjectIdCallback.html":{},"interfaces/SignBlobResponse.html":{}}}],["web",{"_index":741,"title":{},"body":{"interfaces/FederatedSignonCertsResponse.html":{},"interfaces/GetAccessTokenCallback.html":{},"interfaces/GetAccessTokenResponse.html":{},"interfaces/GetFederatedSignonCertsCallback.html":{},"interfaces/GetTokenCallback.html":{},"interfaces/GetTokenOptions.html":{},"interfaces/GetTokenResponse.html":{},"classes/LoginTicket.html":{},"interfaces/OAuth2ClientOptions.html":{},"interfaces/RefreshAccessTokenCallback.html":{},"interfaces/RefreshAccessTokenResponse.html":{},"interfaces/RefreshOptions.html":{},"interfaces/RequestMetadataCallback.html":{},"interfaces/RequestMetadataResponse.html":{},"interfaces/RevokeCredentialsResult.html":{},"interfaces/TokenInfo.html":{},"interfaces/TokenInfoRequest.html":{},"interfaces/TokenPayload.html":{},"interfaces/VerifyIdTokenOptions.html":{},"index.html":{}}}],["webserv",{"_index":1733,"title":{},"body":{"index.html":{}}}],["well",{"_index":225,"title":{},"body":{"interfaces/ADCCallback.html":{},"interfaces/ADCResponse.html":{},"interfaces/CredentialCallback.html":{},"interfaces/GoogleAuthOptions.html":{},"interfaces/ProjectIdCallback.html":{},"interfaces/SignBlobResponse.html":{},"changelog.html":{}}}],["whenev",{"_index":805,"title":{},"body":{"interfaces/FederatedSignonCertsResponse.html":{},"interfaces/GetAccessTokenCallback.html":{},"interfaces/GetAccessTokenResponse.html":{},"interfaces/GetFederatedSignonCertsCallback.html":{},"interfaces/GetTokenCallback.html":{},"interfaces/GetTokenOptions.html":{},"interfaces/GetTokenResponse.html":{},"interfaces/OAuth2ClientOptions.html":{},"interfaces/RefreshAccessTokenCallback.html":{},"interfaces/RefreshAccessTokenResponse.html":{},"interfaces/RefreshOptions.html":{},"interfaces/RequestMetadataCallback.html":{},"interfaces/RequestMetadataResponse.html":{},"interfaces/RevokeCredentialsResult.html":{},"interfaces/TokenInfo.html":{},"interfaces/TokenInfoRequest.html":{},"interfaces/VerifyIdTokenOptions.html":{}}}],["wherev",{"_index":1926,"title":{},"body":{"license.html":{}}}],["whether",{"_index":89,"title":{},"body":{"interfaces/ADCCallback.html":{},"interfaces/ADCResponse.html":{},"interfaces/ComputeOptions.html":{},"interfaces/CredentialCallback.html":{},"interfaces/FederatedSignonCertsResponse.html":{},"interfaces/GetAccessTokenCallback.html":{},"interfaces/GetAccessTokenResponse.html":{},"interfaces/GetFederatedSignonCertsCallback.html":{},"interfaces/GetTokenCallback.html":{},"interfaces/GetTokenOptions.html":{},"interfaces/GetTokenResponse.html":{},"interfaces/GoogleAuthOptions.html":{},"classes/IAMAuth.html":{},"classes/JWTAccess.html":{},"interfaces/JWTOptions.html":{},"interfaces/OAuth2ClientOptions.html":{},"interfaces/ProjectIdCallback.html":{},"interfaces/RefreshAccessTokenCallback.html":{},"interfaces/RefreshAccessTokenResponse.html":{},"interfaces/RefreshOptions.html":{},"interfaces/RequestMetadata.html":{},"interfaces/RequestMetadataCallback.html":{},"interfaces/RequestMetadataResponse.html":{},"interfaces/RevokeCredentialsResult.html":{},"interfaces/SignBlobResponse.html":{},"interfaces/TokenInfo.html":{},"interfaces/TokenInfoRequest.html":{},"interfaces/VerifyIdTokenOptions.html":{},"license.html":{}}}],["whole",{"_index":1860,"title":{},"body":{"license.html":{}}}],["win",{"_index":368,"title":{},"body":{"interfaces/ADCCallback.html":{},"interfaces/ADCResponse.html":{},"interfaces/CredentialCallback.html":{},"interfaces/GoogleAuthOptions.html":{},"interfaces/ProjectIdCallback.html":{},"interfaces/SignBlobResponse.html":{}}}],["window",{"_index":269,"title":{},"body":{"interfaces/ADCCallback.html":{},"interfaces/ADCResponse.html":{},"interfaces/CredentialCallback.html":{},"interfaces/GoogleAuthOptions.html":{},"interfaces/ProjectIdCallback.html":{},"interfaces/SignBlobResponse.html":{},"changelog.html":{}}}],["within",{"_index":734,"title":{},"body":{"interfaces/FederatedSignonCertsResponse.html":{},"interfaces/GetAccessTokenCallback.html":{},"interfaces/GetAccessTokenResponse.html":{},"interfaces/GetFederatedSignonCertsCallback.html":{},"interfaces/GetTokenCallback.html":{},"interfaces/GetTokenOptions.html":{},"interfaces/GetTokenResponse.html":{},"classes/LoginTicket.html":{},"interfaces/OAuth2ClientOptions.html":{},"interfaces/RefreshAccessTokenCallback.html":{},"interfaces/RefreshAccessTokenResponse.html":{},"interfaces/RefreshOptions.html":{},"interfaces/RequestMetadataCallback.html":{},"interfaces/RequestMetadataResponse.html":{},"interfaces/RevokeCredentialsResult.html":{},"interfaces/TokenInfo.html":{},"interfaces/TokenInfoRequest.html":{},"interfaces/TokenPayload.html":{},"interfaces/VerifyIdTokenOptions.html":{},"license.html":{}}}],["without",{"_index":152,"title":{},"body":{"interfaces/ADCCallback.html":{},"interfaces/ADCResponse.html":{},"interfaces/CredentialCallback.html":{},"interfaces/Credentials.html":{},"interfaces/GoogleAuthOptions.html":{},"classes/LoginTicket.html":{},"interfaces/ProjectIdCallback.html":{},"interfaces/SignBlobResponse.html":{},"miscellaneous/functions.html":{},"license.html":{}}}],["won't",{"_index":1779,"title":{},"body":{"index.html":{}}}],["work",{"_index":1705,"title":{},"body":{"index.html":{},"license.html":{}}}],["workflow",{"_index":1723,"title":{},"body":{"index.html":{}}}],["worldwid",{"_index":1884,"title":{},"body":{"license.html":{}}}],["write",{"_index":666,"title":{},"body":{"interfaces/Credentials.html":{},"classes/LoginTicket.html":{},"miscellaneous/functions.html":{},"license.html":{}}}],["written",{"_index":1870,"title":{},"body":{"license.html":{}}}],["wrong",{"_index":1176,"title":{},"body":{"interfaces/FederatedSignonCertsResponse.html":{},"interfaces/GetAccessTokenCallback.html":{},"interfaces/GetAccessTokenResponse.html":{},"interfaces/GetFederatedSignonCertsCallback.html":{},"interfaces/GetTokenCallback.html":{},"interfaces/GetTokenOptions.html":{},"interfaces/GetTokenResponse.html":{},"interfaces/OAuth2ClientOptions.html":{},"interfaces/RefreshAccessTokenCallback.html":{},"interfaces/RefreshAccessTokenResponse.html":{},"interfaces/RefreshOptions.html":{},"interfaces/RequestMetadataCallback.html":{},"interfaces/RequestMetadataResponse.html":{},"interfaces/RevokeCredentialsResult.html":{},"interfaces/TokenInfo.html":{},"interfaces/TokenInfoRequest.html":{},"interfaces/VerifyIdTokenOptions.html":{}}}],["www",{"_index":1023,"title":{},"body":{"interfaces/FederatedSignonCertsResponse.html":{},"interfaces/GetAccessTokenCallback.html":{},"interfaces/GetAccessTokenResponse.html":{},"interfaces/GetFederatedSignonCertsCallback.html":{},"interfaces/GetTokenCallback.html":{},"interfaces/GetTokenOptions.html":{},"interfaces/GetTokenResponse.html":{},"interfaces/OAuth2ClientOptions.html":{},"interfaces/RefreshAccessTokenCallback.html":{},"interfaces/RefreshAccessTokenResponse.html":{},"interfaces/RefreshOptions.html":{},"interfaces/RequestMetadataCallback.html":{},"interfaces/RequestMetadataResponse.html":{},"interfaces/RevokeCredentialsResult.html":{},"interfaces/TokenInfo.html":{},"interfaces/TokenInfoRequest.html":{},"interfaces/VerifyIdTokenOptions.html":{}}}],["x",{"_index":1200,"title":{},"body":{"classes/IAMAuth.html":{},"interfaces/RequestMetadata.html":{}}}],["x1f389",{"_index":1531,"title":{},"body":{"changelog.html":{}}}],["x1f680",{"_index":1624,"title":{},"body":{"changelog.html":{}}}],["xhr",{"_index":518,"title":{},"body":{"interfaces/BodyResponseCallback.html":{},"classes/DefaultTransporter.html":{},"interfaces/RequestError.html":{},"interfaces/Transporter.html":{}}}],["ye",{"_index":684,"title":{},"body":{"classes/DefaultTransporter.html":{},"classes/JWTAccess.html":{},"classes/LoginTicket.html":{},"interfaces/Transporter.html":{}}}],["you'd",{"_index":1684,"title":{},"body":{"index.html":{}}}],["you'r",{"_index":1679,"title":{},"body":{"index.html":{}}}],["you'v",{"_index":1812,"title":{},"body":{"index.html":{}}}],["yyyi",{"_index":1991,"title":{},"body":{"license.html":{}}}],["z]/[0",{"_index":983,"title":{},"body":{"interfaces/FederatedSignonCertsResponse.html":{},"interfaces/GetAccessTokenCallback.html":{},"interfaces/GetAccessTokenResponse.html":{},"interfaces/GetFederatedSignonCertsCallback.html":{},"interfaces/GetTokenCallback.html":{},"interfaces/GetTokenOptions.html":{},"interfaces/GetTokenResponse.html":{},"interfaces/OAuth2ClientOptions.html":{},"interfaces/RefreshAccessTokenCallback.html":{},"interfaces/RefreshAccessTokenResponse.html":{},"interfaces/RefreshOptions.html":{},"interfaces/RequestMetadataCallback.html":{},"interfaces/RequestMetadataResponse.html":{},"interfaces/RevokeCredentialsResult.html":{},"interfaces/TokenInfo.html":{},"interfaces/TokenInfoRequest.html":{},"interfaces/VerifyIdTokenOptions.html":{}}}],["z]/[a",{"_index":982,"title":{},"body":{"interfaces/FederatedSignonCertsResponse.html":{},"interfaces/GetAccessTokenCallback.html":{},"interfaces/GetAccessTokenResponse.html":{},"interfaces/GetFederatedSignonCertsCallback.html":{},"interfaces/GetTokenCallback.html":{},"interfaces/GetTokenOptions.html":{},"interfaces/GetTokenResponse.html":{},"interfaces/OAuth2ClientOptions.html":{},"interfaces/RefreshAccessTokenCallback.html":{},"interfaces/RefreshAccessTokenResponse.html":{},"interfaces/RefreshOptions.html":{},"interfaces/RequestMetadataCallback.html":{},"interfaces/RequestMetadataResponse.html":{},"interfaces/RevokeCredentialsResult.html":{},"interfaces/TokenInfo.html":{},"interfaces/TokenInfoRequest.html":{},"interfaces/VerifyIdTokenOptions.html":{}}}]],"pipeline":["stemmer"]},
    "store": {"interfaces/ADCCallback.html":{"url":"interfaces/ADCCallback.html","title":"interface - ADCCallback","body":"\n                   \n\n\n\n\n\n\n\n\n\n\n\n\n\n  Interfaces\n  ADCCallback\n\n\n\n        \n            Info\n        \n        \n            Source\n        \n\n\n\n    \n        \n            File\n        \n        \n            src/auth/googleauth.ts\n        \n\n\n\n        \n            Index\n            \n                \n                    \n                        \n                            Properties\n                        \n                    \n                    \n                        \n                            \n                                \n                                            Unamed property\n                                \n                            \n                        \n                    \n                \n            \n        \n\n\n\n            \n                Properties\n                    \n                        \n\n                                    \n                                        \n                                            Signature :\n                                            \n                                            \n                                                \n                                                    [err: Error | null, credential: OAuth2Client, projectId: string | null]\n                                            \n                                        \n                                    \n\n\n                                    \n                                        \n                                            Returns :     void\n\n                                        \n                                    \n\n\n\n\n                        \n                    \n            \n    \n\n\n    \n        import {AxiosRequestConfig, AxiosResponse} from 'axios';\nimport {exec} from 'child_process';\nimport * as crypto from 'crypto';\nimport * as fs from 'fs';\nimport * as gcpMetadata from 'gcp-metadata';\nimport * as http from 'http';\nimport * as os from 'os';\nimport * as path from 'path';\nimport * as stream from 'stream';\nimport * as util from 'util';\n\nimport * as messages from '../messages';\nimport {DefaultTransporter, Transporter} from '../transporters';\n\nimport {Compute} from './computeclient';\nimport {CredentialBody, JWTInput} from './credentials';\nimport {GCPEnv, getEnv} from './envDetect';\nimport {JWT, JWTOptions} from './jwtclient';\nimport {Headers, OAuth2Client, RefreshOptions} from './oauth2client';\nimport {UserRefreshClient} from './refreshclient';\n\nexport interface ProjectIdCallback {\n  (err?: Error|null, projectId?: string|null): void;\n}\n\nexport interface CredentialCallback {\n  (err: Error|null, result?: UserRefreshClient|JWT): void;\n}\n\nexport interface ADCCallback {\n  (err: Error|null, credential?: OAuth2Client, projectId?: string|null): void;\n}\n\nexport interface ADCResponse {\n  credential: OAuth2Client;\n  projectId: string|null;\n}\n\nexport interface GoogleAuthOptions {\n  /**\n   * Path to a .json, .pem, or .p12 key file\n   */\n  keyFilename?: string;\n\n  /**\n   * Path to a .json, .pem, or .p12 key file\n   */\n  keyFile?: string;\n\n  /**\n   * Object containing client_email and private_key properties\n   */\n  credentials?: CredentialBody;\n\n  /**\n   * Required scopes for the desired API request\n   */\n  scopes?: string|string[];\n\n  /**\n   * Your project ID.\n   */\n  projectId?: string;\n}\n\nexport const CLOUD_SDK_CLIENT_ID =\n    '764086051850-6qr4p6gpi6hn506pt8ejuq83di341hur.apps.googleusercontent.com';\n\nexport class GoogleAuth {\n  transporter?: Transporter;\n\n  /**\n   * Caches a value indicating whether the auth layer is running on Google\n   * Compute Engine.\n   * @private\n   */\n  private checkIsGCE?: boolean = undefined;\n\n  // Note:  this properly is only public to satisify unit tests.\n  // https://github.com/Microsoft/TypeScript/issues/5228\n  get isGCE() {\n    return this.checkIsGCE;\n  }\n\n  private _getDefaultProjectIdPromise?: Promise;\n  private _cachedProjectId?: string|null;\n\n  // To save the contents of the JSON credential file\n  jsonContent: JWTInput|null = null;\n\n  cachedCredential: JWT|UserRefreshClient|Compute|null = null;\n\n  private keyFilename?: string;\n  private scopes?: string|string[];\n\n  /**\n   * Export DefaultTransporter as a static property of the class.\n   */\n  static DefaultTransporter = DefaultTransporter;\n\n  constructor(opts?: GoogleAuthOptions) {\n    opts = opts || {};\n    this._cachedProjectId = opts.projectId || null;\n    this.keyFilename = opts.keyFilename || opts.keyFile;\n    this.scopes = opts.scopes;\n    this.jsonContent = opts.credentials || null;\n  }\n\n  /**\n   * THIS METHOD HAS BEEN DEPRECATED.\n   * It will be removed in 3.0.  Please use getProjectId instead.\n   */\n  getDefaultProjectId(): Promise;\n  getDefaultProjectId(callback: ProjectIdCallback): void;\n  getDefaultProjectId(callback?: ProjectIdCallback): Promise|void {\n    messages.warn(messages.DEFAULT_PROJECT_ID_DEPRECATED);\n    if (callback) {\n      this.getProjectIdAsync().then(r => callback(null, r), callback);\n    } else {\n      return this.getProjectIdAsync();\n    }\n  }\n\n  /**\n   * Obtains the default project ID for the application.\n   * @param callback Optional callback\n   * @returns Promise that resolves with project Id (if used without callback)\n   */\n  getProjectId(): Promise;\n  getProjectId(callback: ProjectIdCallback): void;\n  getProjectId(callback?: ProjectIdCallback): Promise|void {\n    if (callback) {\n      this.getProjectIdAsync().then(r => callback(null, r), callback);\n    } else {\n      return this.getProjectIdAsync();\n    }\n  }\n\n  private getProjectIdAsync(): Promise {\n    if (this._cachedProjectId) {\n      return Promise.resolve(this._cachedProjectId);\n    }\n\n    // In implicit case, supports three environments. In order of precedence,\n    // the implicit environments are:\n    // - GCLOUD_PROJECT or GOOGLE_CLOUD_PROJECT environment variable\n    // - GOOGLE_APPLICATION_CREDENTIALS JSON file\n    // - Cloud SDK: `gcloud config config-helper --format json`\n    // - GCE project ID from metadata server)\n    if (!this._getDefaultProjectIdPromise) {\n      this._getDefaultProjectIdPromise =\n          new Promise(async (resolve, reject) => {\n            try {\n              const projectId = this.getProductionProjectId() ||\n                  await this.getFileProjectId() ||\n                  await this.getDefaultServiceProjectId() ||\n                  await this.getGCEProjectId();\n              this._cachedProjectId = projectId;\n              resolve(projectId);\n            } catch (e) {\n              reject(e);\n            }\n          });\n    }\n    return this._getDefaultProjectIdPromise;\n  }\n\n  /**\n   * Obtains the default service-level credentials for the application.\n   * @param callback Optional callback.\n   * @returns Promise that resolves with the ADCResponse (if no callback was\n   * passed).\n   */\n  getApplicationDefault(): Promise;\n  getApplicationDefault(callback: ADCCallback): void;\n  getApplicationDefault(options: RefreshOptions): Promise;\n  getApplicationDefault(options: RefreshOptions, callback: ADCCallback): void;\n  getApplicationDefault(\n      optionsOrCallback: ADCCallback|RefreshOptions = {},\n      callback?: ADCCallback): void|Promise {\n    let options: RefreshOptions|undefined;\n    if (typeof optionsOrCallback === 'function') {\n      callback = optionsOrCallback;\n    } else {\n      options = optionsOrCallback;\n    }\n    if (callback) {\n      this.getApplicationDefaultAsync(options).then(\n          r => callback!(null, r.credential, r.projectId), callback);\n    } else {\n      return this.getApplicationDefaultAsync(options);\n    }\n  }\n\n  private async getApplicationDefaultAsync(options?: RefreshOptions):\n      Promise {\n    // If we've already got a cached credential, just return it.\n    if (this.cachedCredential) {\n      return {\n        credential: this.cachedCredential as JWT | UserRefreshClient,\n        projectId: await this.getProjectIdAsync()\n      };\n    }\n\n    let credential: JWT|UserRefreshClient|null;\n    let projectId: string|null;\n    // Check for the existence of a local environment variable pointing to the\n    // location of the credential file. This is typically used in local\n    // developer scenarios.\n    credential =\n        await this._tryGetApplicationCredentialsFromEnvironmentVariable(\n            options);\n    if (credential) {\n      if (credential instanceof JWT) {\n        credential.scopes = this.scopes;\n      }\n      this.cachedCredential = credential;\n      projectId = await this.getProjectId();\n      return {credential, projectId};\n    }\n\n    // Look in the well-known credential file location.\n    credential =\n        await this._tryGetApplicationCredentialsFromWellKnownFile(options);\n    if (credential) {\n      if (credential instanceof JWT) {\n        credential.scopes = this.scopes;\n      }\n      this.cachedCredential = credential;\n      projectId = await this.getProjectId();\n      return {credential, projectId};\n    }\n\n    // Determine if we're running on GCE.\n    let isGCE;\n    try {\n      isGCE = await this._checkIsGCE();\n    } catch (e) {\n      throw new Error(\n          'Unexpected error determining execution environment: ' + e.message);\n    }\n\n    if (!isGCE) {\n      // We failed to find the default credentials. Bail out with an error.\n      throw new Error(\n          'Could not load the default credentials. Browse to https://cloud.google.com/docs/authentication/getting-started for more information.');\n    }\n\n    // For GCE, just return a default ComputeClient. It will take care of\n    // the rest.\n    this.cachedCredential = new Compute(options);\n    projectId = await this.getProjectId();\n    return {projectId, credential: this.cachedCredential};\n  }\n\n  /**\n   * Determines whether the auth layer is running on Google Compute Engine.\n   * @returns A promise that resolves with the boolean.\n   * @api private\n   */\n  async _checkIsGCE() {\n    if (this.checkIsGCE === undefined) {\n      this.checkIsGCE = await gcpMetadata.isAvailable();\n    }\n    return this.checkIsGCE;\n  }\n\n  /**\n   * Attempts to load default credentials from the environment variable path..\n   * @returns Promise that resolves with the OAuth2Client or null.\n   * @api private\n   */\n  async _tryGetApplicationCredentialsFromEnvironmentVariable(\n      options?: RefreshOptions): Promise {\n    const credentialsPath = process.env['GOOGLE_APPLICATION_CREDENTIALS'];\n    if (!credentialsPath || credentialsPath.length === 0) {\n      return null;\n    }\n    try {\n      return this._getApplicationCredentialsFromFilePath(\n          credentialsPath, options);\n    } catch (e) {\n      throw this.createError(\n          'Unable to read the credential file specified by the GOOGLE_APPLICATION_CREDENTIALS environment variable.',\n          e);\n    }\n  }\n\n  /**\n   * Attempts to load default credentials from a well-known file location\n   * @return Promise that resolves with the OAuth2Client or null.\n   * @api private\n   */\n  async _tryGetApplicationCredentialsFromWellKnownFile(\n      options?: RefreshOptions): Promise {\n    // First, figure out the location of the file, depending upon the OS type.\n    let location = null;\n    if (this._isWindows()) {\n      // Windows\n      location = process.env['APPDATA'];\n    } else {\n      // Linux or Mac\n      const home = process.env['HOME'];\n      if (home) {\n        location = this._pathJoin(home, '.config');\n      }\n    }\n    // If we found the root path, expand it.\n    if (location) {\n      location = this._pathJoin(location, 'gcloud');\n      location =\n          this._pathJoin(location, 'application_default_credentials.json');\n      location = this._mockWellKnownFilePath(location);\n      // Check whether the file exists.\n      if (!this._fileExists(location)) {\n        location = null;\n      }\n    }\n    // The file does not exist.\n    if (!location) {\n      return null;\n    }\n    // The file seems to exist. Try to use it.\n    const client =\n        await this._getApplicationCredentialsFromFilePath(location, options);\n    this.warnOnProblematicCredentials(client as JWT);\n    return client;\n  }\n\n  /**\n   * Attempts to load default credentials from a file at the given path..\n   * @param filePath The path to the file to read.\n   * @returns Promise that resolves with the OAuth2Client\n   * @api private\n   */\n  async _getApplicationCredentialsFromFilePath(\n      filePath: string,\n      options: RefreshOptions = {}): Promise {\n    // Make sure the path looks like a string.\n    if (!filePath || filePath.length === 0) {\n      throw new Error('The file path is invalid.');\n    }\n\n    // Make sure there is a file at the path. lstatSync will throw if there is\n    // nothing there.\n    try {\n      // Resolve path to actual file in case of symlink. Expect a thrown error\n      // if not resolvable.\n      filePath = fs.realpathSync(filePath);\n\n      if (!fs.lstatSync(filePath).isFile()) {\n        throw new Error();\n      }\n    } catch (err) {\n      throw this.createError(\n          util.format(\n              'The file at %s does not exist, or it is not a file.', filePath),\n          err);\n    }\n\n    // Now open a read stream on the file, and parse it.\n    try {\n      const readStream = this._createReadStream(filePath);\n      return this.fromStream(readStream, options);\n    } catch (err) {\n      throw this.createError(\n          util.format('Unable to read the file at %s.', filePath), err);\n    }\n  }\n\n  /**\n   * Credentials from the Cloud SDK that are associated with Cloud SDK's project\n   * are problematic because they may not have APIs enabled and have limited\n   * quota. If this is the case, warn about it.\n   */\n  protected warnOnProblematicCredentials(client: JWT) {\n    if (client.email === CLOUD_SDK_CLIENT_ID) {\n      messages.warn(messages.PROBLEMATIC_CREDENTIALS_WARNING);\n    }\n  }\n\n  /**\n   * Create a credentials instance using the given input options.\n   * @param json The input object.\n   * @returns JWT or UserRefresh Client with data\n   */\n  fromJSON(json: JWTInput, options?: RefreshOptions): JWT|UserRefreshClient {\n    let client: UserRefreshClient|JWT;\n    if (!json) {\n      throw new Error(\n          'Must pass in a JSON object containing the Google auth settings.');\n    }\n    this.jsonContent = json;\n    options = options || {};\n    if (json.type === 'authorized_user') {\n      client = new UserRefreshClient(options);\n    } else {\n      (options as JWTOptions).scopes = this.scopes;\n      client = new JWT(options);\n    }\n    client.fromJSON(json);\n    return client;\n  }\n\n  /**\n   * Create a credentials instance using the given input stream.\n   * @param inputStream The input stream.\n   * @param callback Optional callback.\n   */\n  fromStream(inputStream: stream.Readable): Promise;\n  fromStream(inputStream: stream.Readable, callback: CredentialCallback): void;\n  fromStream(inputStream: stream.Readable, options: RefreshOptions):\n      Promise;\n  fromStream(\n      inputStream: stream.Readable, options: RefreshOptions,\n      callback: CredentialCallback): void;\n  fromStream(\n      inputStream: stream.Readable,\n      optionsOrCallback: RefreshOptions|CredentialCallback = {},\n      callback?: CredentialCallback): Promise|void {\n    let options: RefreshOptions = {};\n    if (typeof optionsOrCallback === 'function') {\n      callback = optionsOrCallback;\n    } else {\n      options = optionsOrCallback;\n    }\n    if (callback) {\n      this.fromStreamAsync(inputStream, options)\n          .then(r => callback!(null, r), callback);\n    } else {\n      return this.fromStreamAsync(inputStream, options);\n    }\n  }\n\n  private fromStreamAsync(\n      inputStream: stream.Readable,\n      options?: RefreshOptions): Promise {\n    return new Promise((resolve, reject) => {\n      if (!inputStream) {\n        throw new Error(\n            'Must pass in a stream containing the Google auth settings.');\n      }\n      let s = '';\n      inputStream.setEncoding('utf8')\n          .on('error', reject)\n          .on('data', (chunk) => s += chunk)\n          .on('end', () => {\n            try {\n              const data = JSON.parse(s);\n              const r = this.fromJSON(data, options);\n              return resolve(r);\n            } catch (err) {\n              return reject(err);\n            }\n          });\n    });\n  }\n\n  /**\n   * Create a credentials instance using the given API key string.\n   * @param apiKey The API key string\n   * @param options An optional options object.\n   * @returns A JWT loaded from the key\n   */\n  fromAPIKey(apiKey: string, options?: RefreshOptions): JWT {\n    options = options || {};\n    const client = new JWT(options);\n    client.fromAPIKey(apiKey);\n    return client;\n  }\n\n  /**\n   * Determines whether the current operating system is Windows.\n   * @api private\n   */\n  private _isWindows() {\n    const sys = this._osPlatform();\n    if (sys && sys.length >= 3) {\n      if (sys.substring(0, 3).toLowerCase() === 'win') {\n        return true;\n      }\n    }\n    return false;\n  }\n\n  /**\n   * Creates a file stream. Allows mocking.\n   * @api private\n   */\n  _createReadStream(filePath: string) {\n    return fs.createReadStream(filePath);\n  }\n\n  /**\n   * Gets the current operating system platform. Allows mocking.\n   * @api private\n   */\n  _osPlatform() {\n    return os.platform();\n  }\n\n  /**\n   * Determines whether a file exists. Allows mocking.\n   * @api private\n   */\n  _fileExists(filePath: string) {\n    return fs.existsSync(filePath);\n  }\n\n  /**\n   * Joins two parts of a path. Allows mocking.\n   * @api private\n   */\n  _pathJoin(item1: string, item2: string) {\n    return path.join(item1, item2);\n  }\n\n  /**\n   * Allows mocking of the path to a well-known file.\n   * @api private\n   */\n  _mockWellKnownFilePath(filePath: string) {\n    return filePath;\n  }\n\n  // Creates an Error containing the given message, and includes the message\n  // from the optional err passed in.\n  private createError(message: string, err: Error) {\n    let s = message || '';\n    if (err) {\n      const errorMessage = String(err);\n      if (errorMessage && errorMessage.length > 0) {\n        if (s.length > 0) {\n          s += ' ';\n        }\n        s += errorMessage;\n      }\n    }\n    return Error(s);\n  }\n\n  /**\n   * Run the Google Cloud SDK command that prints the default project ID\n   */\n  private async getDefaultServiceProjectId(): Promise {\n    return new Promise(resolve => {\n      exec(\n          'gcloud config config-helper --format json',\n          (err, stdout, stderr) => {\n            if (!err && stdout) {\n              try {\n                const projectId =\n                    JSON.parse(stdout).configuration.properties.core.project;\n                resolve(projectId);\n                return;\n              } catch (e) {\n                // ignore errors\n              }\n            }\n            resolve(null);\n          });\n    });\n  }\n\n  /**\n   * Loads the project id from environment variables.\n   * @api private\n   */\n  private getProductionProjectId() {\n    return process.env['GCLOUD_PROJECT'] || process.env['GOOGLE_CLOUD_PROJECT'];\n  }\n\n  /**\n   * Loads the project id from the GOOGLE_APPLICATION_CREDENTIALS json file.\n   * @api private\n   */\n  private async getFileProjectId(): Promise {\n    if (this.cachedCredential) {\n      // Try to read the project ID from the cached credentials file\n      return this.cachedCredential.projectId;\n    }\n\n    // Try to load a credentials file and read its project ID\n    const r = await this._tryGetApplicationCredentialsFromEnvironmentVariable();\n    if (r) {\n      return r.projectId;\n    } else {\n      return null;\n    }\n  }\n\n  /**\n   * Gets the Compute Engine project ID if it can be inferred.\n   */\n  private async getGCEProjectId() {\n    try {\n      const r = await gcpMetadata.project('project-id');\n      return r.data;\n    } catch (e) {\n      // Ignore any errors\n      return null;\n    }\n  }\n\n  /**\n   * The callback function handles a credential object that contains the\n   * client_email and private_key (if exists).\n   * getCredentials checks for these values from the user JSON at first.\n   * If it doesn't exist, and the environment is on GCE, it gets the\n   * client_email from the cloud metadata server.\n   * @param callback Callback that handles the credential object that contains\n   * a client_email and optional private key, or the error.\n   * returned\n   */\n  getCredentials(): Promise;\n  getCredentials(\n      callback: (err: Error|null, credentials?: CredentialBody) => void): void;\n  getCredentials(\n      callback?: (err: Error|null, credentials?: CredentialBody) => void):\n      void|Promise {\n    if (callback) {\n      this.getCredentialsAsync().then(r => callback(null, r), callback);\n    } else {\n      return this.getCredentialsAsync();\n    }\n  }\n\n  private async getCredentialsAsync(): Promise {\n    if (this.jsonContent) {\n      const credential: CredentialBody = {\n        client_email: this.jsonContent.client_email,\n        private_key: this.jsonContent.private_key\n      };\n      return credential;\n    }\n\n    const isGCE = await this._checkIsGCE();\n    if (!isGCE) {\n      throw new Error('Unknown error.');\n    }\n\n    // For GCE, return the service account details from the metadata server\n    // NOTE: The trailing '/' at the end of service-accounts/ is very important!\n    // The GCF metadata server doesn't respect querystring params if this / is\n    // not included.\n    const {data} = await gcpMetadata.instance(\n        {property: 'service-accounts/', params: {recursive: true}});\n\n    if (!data || !data.default || !data.default.email) {\n      throw new Error('Failure from metadata server.');\n    }\n\n    return {client_email: data.default.email};\n  }\n\n  /**\n   * Automatically obtain a client based on the provided configuration.  If no\n   * options were passed, use Application Default Credentials.\n   */\n  async getClient(options?: GoogleAuthOptions) {\n    if (options) {\n      this.keyFilename =\n          options.keyFilename || options.keyFile || this.keyFilename;\n      this.scopes = options.scopes || this.scopes;\n      this.jsonContent = options.credentials || this.jsonContent;\n    }\n    if (!this.cachedCredential) {\n      if (this.jsonContent) {\n        this.cachedCredential = await this.fromJSON(this.jsonContent);\n      } else if (this.keyFilename) {\n        const filePath = path.resolve(this.keyFilename);\n        const stream = fs.createReadStream(filePath);\n        this.cachedCredential = await this.fromStreamAsync(stream);\n      } else {\n        await this.getApplicationDefaultAsync();\n      }\n    }\n    return this.cachedCredential!;\n  }\n\n  /**\n   * Automatically obtain application default credentials, and return\n   * an access token for making requests.\n   */\n  async getAccessToken() {\n    const client = await this.getClient();\n    return (await client.getAccessToken()).token;\n  }\n\n  /**\n   * Obtain the HTTP headers that will provide authorization for a given\n   * request.\n   */\n  async getRequestHeaders(url?: string) {\n    const client = await this.getClient();\n    return client.getRequestHeaders(url);\n  }\n\n  /**\n   * Obtain credentials for a request, then attach the appropriate headers to\n   * the request options.\n   * @param opts Axios or Request options on which to attach the headers\n   */\n  async authorizeRequest(opts:\n                             {url?: string, uri?: string, headers?: Headers}) {\n    opts = opts || {};\n    const url = opts.url || opts.uri;\n    const client = await this.getClient();\n    const headers = await client.getRequestHeaders(url);\n    opts.headers = Object.assign(opts.headers || {}, headers);\n    return opts;\n  }\n\n  /**\n   * Automatically obtain application default credentials, and make an\n   * HTTP request using the given options.\n   * @param opts Axios request options for the HTTP request.\n   */\n  // tslint:disable-next-line no-any\n  async request(opts: AxiosRequestConfig): Promise> {\n    const client = await this.getClient();\n    return client.request(opts);\n  }\n\n  /**\n   * Determine the compute environment in which the code is running.\n   */\n  getEnv(): Promise {\n    return getEnv();\n  }\n\n  /**\n   * Sign the given data with the current private key, or go out\n   * to the IAM API to sign it.\n   * @param data The data to be signed.\n   */\n  async sign(data: string): Promise {\n    const client = await this.getClient();\n    if (client instanceof JWT && client.key) {\n      const sign = crypto.createSign('RSA-SHA256');\n      sign.update(data);\n      return sign.sign(client.key, 'base64');\n    }\n\n    const projectId = await this.getProjectId();\n    if (!projectId) {\n      throw new Error('Cannot sign data without a project ID.');\n    }\n\n    const creds = await this.getCredentials();\n    if (!creds.client_email) {\n      throw new Error('Cannot sign data without `client_email`.');\n    }\n\n    const id = `projects/${projectId}/serviceAccounts/${creds.client_email}`;\n    const res = await this.request({\n      method: 'POST',\n      url: `https://iam.googleapis.com/v1/${id}:signBlob`,\n      data: {bytesToSign: Buffer.from(data).toString('base64')}\n    });\n    return res.data.signature;\n  }\n}\n\nexport interface SignBlobResponse {\n  signature: string;\n}\n\n    \n\n\n\n\n\n\n\n                   \n    \n         result-matching \"\"\n        \n    \n    \n        No results matching \"\"\n    \n\n"},"interfaces/ADCResponse.html":{"url":"interfaces/ADCResponse.html","title":"interface - ADCResponse","body":"\n                   \n\n\n\n\n\n\n\n\n\n\n\n\n\n  Interfaces\n  ADCResponse\n\n\n\n        \n            Info\n        \n        \n            Source\n        \n\n\n\n    \n        \n            File\n        \n        \n            src/auth/googleauth.ts\n        \n\n\n\n        \n            Index\n            \n                \n                    \n                        \n                            Properties\n                        \n                    \n                    \n                        \n                            \n                                \n                                        credential\n                                \n                                \n                                        projectId\n                                \n                            \n                        \n                    \n                \n            \n        \n\n\n\n            \n                Properties\n                    \n                        \n                                \n                                    \n                                        \n                                        credential\n                                    \n                                \n                                \n                                    \n                                        credential:     OAuth2Client\n\n                                    \n                                \n\n\n                                    \n                                        \n                                            Type :     OAuth2Client\n\n                                        \n                                    \n\n\n\n\n\n                        \n                    \n                    \n                        \n                                \n                                    \n                                        \n                                        projectId\n                                    \n                                \n                                \n                                    \n                                        projectId:     string | null\n\n                                    \n                                \n\n\n                                    \n                                        \n                                            Type :     string | null\n\n                                        \n                                    \n\n\n\n\n\n                        \n                    \n            \n    \n\n\n    \n        import {AxiosRequestConfig, AxiosResponse} from 'axios';\nimport {exec} from 'child_process';\nimport * as crypto from 'crypto';\nimport * as fs from 'fs';\nimport * as gcpMetadata from 'gcp-metadata';\nimport * as http from 'http';\nimport * as os from 'os';\nimport * as path from 'path';\nimport * as stream from 'stream';\nimport * as util from 'util';\n\nimport * as messages from '../messages';\nimport {DefaultTransporter, Transporter} from '../transporters';\n\nimport {Compute} from './computeclient';\nimport {CredentialBody, JWTInput} from './credentials';\nimport {GCPEnv, getEnv} from './envDetect';\nimport {JWT, JWTOptions} from './jwtclient';\nimport {Headers, OAuth2Client, RefreshOptions} from './oauth2client';\nimport {UserRefreshClient} from './refreshclient';\n\nexport interface ProjectIdCallback {\n  (err?: Error|null, projectId?: string|null): void;\n}\n\nexport interface CredentialCallback {\n  (err: Error|null, result?: UserRefreshClient|JWT): void;\n}\n\nexport interface ADCCallback {\n  (err: Error|null, credential?: OAuth2Client, projectId?: string|null): void;\n}\n\nexport interface ADCResponse {\n  credential: OAuth2Client;\n  projectId: string|null;\n}\n\nexport interface GoogleAuthOptions {\n  /**\n   * Path to a .json, .pem, or .p12 key file\n   */\n  keyFilename?: string;\n\n  /**\n   * Path to a .json, .pem, or .p12 key file\n   */\n  keyFile?: string;\n\n  /**\n   * Object containing client_email and private_key properties\n   */\n  credentials?: CredentialBody;\n\n  /**\n   * Required scopes for the desired API request\n   */\n  scopes?: string|string[];\n\n  /**\n   * Your project ID.\n   */\n  projectId?: string;\n}\n\nexport const CLOUD_SDK_CLIENT_ID =\n    '764086051850-6qr4p6gpi6hn506pt8ejuq83di341hur.apps.googleusercontent.com';\n\nexport class GoogleAuth {\n  transporter?: Transporter;\n\n  /**\n   * Caches a value indicating whether the auth layer is running on Google\n   * Compute Engine.\n   * @private\n   */\n  private checkIsGCE?: boolean = undefined;\n\n  // Note:  this properly is only public to satisify unit tests.\n  // https://github.com/Microsoft/TypeScript/issues/5228\n  get isGCE() {\n    return this.checkIsGCE;\n  }\n\n  private _getDefaultProjectIdPromise?: Promise;\n  private _cachedProjectId?: string|null;\n\n  // To save the contents of the JSON credential file\n  jsonContent: JWTInput|null = null;\n\n  cachedCredential: JWT|UserRefreshClient|Compute|null = null;\n\n  private keyFilename?: string;\n  private scopes?: string|string[];\n\n  /**\n   * Export DefaultTransporter as a static property of the class.\n   */\n  static DefaultTransporter = DefaultTransporter;\n\n  constructor(opts?: GoogleAuthOptions) {\n    opts = opts || {};\n    this._cachedProjectId = opts.projectId || null;\n    this.keyFilename = opts.keyFilename || opts.keyFile;\n    this.scopes = opts.scopes;\n    this.jsonContent = opts.credentials || null;\n  }\n\n  /**\n   * THIS METHOD HAS BEEN DEPRECATED.\n   * It will be removed in 3.0.  Please use getProjectId instead.\n   */\n  getDefaultProjectId(): Promise;\n  getDefaultProjectId(callback: ProjectIdCallback): void;\n  getDefaultProjectId(callback?: ProjectIdCallback): Promise|void {\n    messages.warn(messages.DEFAULT_PROJECT_ID_DEPRECATED);\n    if (callback) {\n      this.getProjectIdAsync().then(r => callback(null, r), callback);\n    } else {\n      return this.getProjectIdAsync();\n    }\n  }\n\n  /**\n   * Obtains the default project ID for the application.\n   * @param callback Optional callback\n   * @returns Promise that resolves with project Id (if used without callback)\n   */\n  getProjectId(): Promise;\n  getProjectId(callback: ProjectIdCallback): void;\n  getProjectId(callback?: ProjectIdCallback): Promise|void {\n    if (callback) {\n      this.getProjectIdAsync().then(r => callback(null, r), callback);\n    } else {\n      return this.getProjectIdAsync();\n    }\n  }\n\n  private getProjectIdAsync(): Promise {\n    if (this._cachedProjectId) {\n      return Promise.resolve(this._cachedProjectId);\n    }\n\n    // In implicit case, supports three environments. In order of precedence,\n    // the implicit environments are:\n    // - GCLOUD_PROJECT or GOOGLE_CLOUD_PROJECT environment variable\n    // - GOOGLE_APPLICATION_CREDENTIALS JSON file\n    // - Cloud SDK: `gcloud config config-helper --format json`\n    // - GCE project ID from metadata server)\n    if (!this._getDefaultProjectIdPromise) {\n      this._getDefaultProjectIdPromise =\n          new Promise(async (resolve, reject) => {\n            try {\n              const projectId = this.getProductionProjectId() ||\n                  await this.getFileProjectId() ||\n                  await this.getDefaultServiceProjectId() ||\n                  await this.getGCEProjectId();\n              this._cachedProjectId = projectId;\n              resolve(projectId);\n            } catch (e) {\n              reject(e);\n            }\n          });\n    }\n    return this._getDefaultProjectIdPromise;\n  }\n\n  /**\n   * Obtains the default service-level credentials for the application.\n   * @param callback Optional callback.\n   * @returns Promise that resolves with the ADCResponse (if no callback was\n   * passed).\n   */\n  getApplicationDefault(): Promise;\n  getApplicationDefault(callback: ADCCallback): void;\n  getApplicationDefault(options: RefreshOptions): Promise;\n  getApplicationDefault(options: RefreshOptions, callback: ADCCallback): void;\n  getApplicationDefault(\n      optionsOrCallback: ADCCallback|RefreshOptions = {},\n      callback?: ADCCallback): void|Promise {\n    let options: RefreshOptions|undefined;\n    if (typeof optionsOrCallback === 'function') {\n      callback = optionsOrCallback;\n    } else {\n      options = optionsOrCallback;\n    }\n    if (callback) {\n      this.getApplicationDefaultAsync(options).then(\n          r => callback!(null, r.credential, r.projectId), callback);\n    } else {\n      return this.getApplicationDefaultAsync(options);\n    }\n  }\n\n  private async getApplicationDefaultAsync(options?: RefreshOptions):\n      Promise {\n    // If we've already got a cached credential, just return it.\n    if (this.cachedCredential) {\n      return {\n        credential: this.cachedCredential as JWT | UserRefreshClient,\n        projectId: await this.getProjectIdAsync()\n      };\n    }\n\n    let credential: JWT|UserRefreshClient|null;\n    let projectId: string|null;\n    // Check for the existence of a local environment variable pointing to the\n    // location of the credential file. This is typically used in local\n    // developer scenarios.\n    credential =\n        await this._tryGetApplicationCredentialsFromEnvironmentVariable(\n            options);\n    if (credential) {\n      if (credential instanceof JWT) {\n        credential.scopes = this.scopes;\n      }\n      this.cachedCredential = credential;\n      projectId = await this.getProjectId();\n      return {credential, projectId};\n    }\n\n    // Look in the well-known credential file location.\n    credential =\n        await this._tryGetApplicationCredentialsFromWellKnownFile(options);\n    if (credential) {\n      if (credential instanceof JWT) {\n        credential.scopes = this.scopes;\n      }\n      this.cachedCredential = credential;\n      projectId = await this.getProjectId();\n      return {credential, projectId};\n    }\n\n    // Determine if we're running on GCE.\n    let isGCE;\n    try {\n      isGCE = await this._checkIsGCE();\n    } catch (e) {\n      throw new Error(\n          'Unexpected error determining execution environment: ' + e.message);\n    }\n\n    if (!isGCE) {\n      // We failed to find the default credentials. Bail out with an error.\n      throw new Error(\n          'Could not load the default credentials. Browse to https://cloud.google.com/docs/authentication/getting-started for more information.');\n    }\n\n    // For GCE, just return a default ComputeClient. It will take care of\n    // the rest.\n    this.cachedCredential = new Compute(options);\n    projectId = await this.getProjectId();\n    return {projectId, credential: this.cachedCredential};\n  }\n\n  /**\n   * Determines whether the auth layer is running on Google Compute Engine.\n   * @returns A promise that resolves with the boolean.\n   * @api private\n   */\n  async _checkIsGCE() {\n    if (this.checkIsGCE === undefined) {\n      this.checkIsGCE = await gcpMetadata.isAvailable();\n    }\n    return this.checkIsGCE;\n  }\n\n  /**\n   * Attempts to load default credentials from the environment variable path..\n   * @returns Promise that resolves with the OAuth2Client or null.\n   * @api private\n   */\n  async _tryGetApplicationCredentialsFromEnvironmentVariable(\n      options?: RefreshOptions): Promise {\n    const credentialsPath = process.env['GOOGLE_APPLICATION_CREDENTIALS'];\n    if (!credentialsPath || credentialsPath.length === 0) {\n      return null;\n    }\n    try {\n      return this._getApplicationCredentialsFromFilePath(\n          credentialsPath, options);\n    } catch (e) {\n      throw this.createError(\n          'Unable to read the credential file specified by the GOOGLE_APPLICATION_CREDENTIALS environment variable.',\n          e);\n    }\n  }\n\n  /**\n   * Attempts to load default credentials from a well-known file location\n   * @return Promise that resolves with the OAuth2Client or null.\n   * @api private\n   */\n  async _tryGetApplicationCredentialsFromWellKnownFile(\n      options?: RefreshOptions): Promise {\n    // First, figure out the location of the file, depending upon the OS type.\n    let location = null;\n    if (this._isWindows()) {\n      // Windows\n      location = process.env['APPDATA'];\n    } else {\n      // Linux or Mac\n      const home = process.env['HOME'];\n      if (home) {\n        location = this._pathJoin(home, '.config');\n      }\n    }\n    // If we found the root path, expand it.\n    if (location) {\n      location = this._pathJoin(location, 'gcloud');\n      location =\n          this._pathJoin(location, 'application_default_credentials.json');\n      location = this._mockWellKnownFilePath(location);\n      // Check whether the file exists.\n      if (!this._fileExists(location)) {\n        location = null;\n      }\n    }\n    // The file does not exist.\n    if (!location) {\n      return null;\n    }\n    // The file seems to exist. Try to use it.\n    const client =\n        await this._getApplicationCredentialsFromFilePath(location, options);\n    this.warnOnProblematicCredentials(client as JWT);\n    return client;\n  }\n\n  /**\n   * Attempts to load default credentials from a file at the given path..\n   * @param filePath The path to the file to read.\n   * @returns Promise that resolves with the OAuth2Client\n   * @api private\n   */\n  async _getApplicationCredentialsFromFilePath(\n      filePath: string,\n      options: RefreshOptions = {}): Promise {\n    // Make sure the path looks like a string.\n    if (!filePath || filePath.length === 0) {\n      throw new Error('The file path is invalid.');\n    }\n\n    // Make sure there is a file at the path. lstatSync will throw if there is\n    // nothing there.\n    try {\n      // Resolve path to actual file in case of symlink. Expect a thrown error\n      // if not resolvable.\n      filePath = fs.realpathSync(filePath);\n\n      if (!fs.lstatSync(filePath).isFile()) {\n        throw new Error();\n      }\n    } catch (err) {\n      throw this.createError(\n          util.format(\n              'The file at %s does not exist, or it is not a file.', filePath),\n          err);\n    }\n\n    // Now open a read stream on the file, and parse it.\n    try {\n      const readStream = this._createReadStream(filePath);\n      return this.fromStream(readStream, options);\n    } catch (err) {\n      throw this.createError(\n          util.format('Unable to read the file at %s.', filePath), err);\n    }\n  }\n\n  /**\n   * Credentials from the Cloud SDK that are associated with Cloud SDK's project\n   * are problematic because they may not have APIs enabled and have limited\n   * quota. If this is the case, warn about it.\n   */\n  protected warnOnProblematicCredentials(client: JWT) {\n    if (client.email === CLOUD_SDK_CLIENT_ID) {\n      messages.warn(messages.PROBLEMATIC_CREDENTIALS_WARNING);\n    }\n  }\n\n  /**\n   * Create a credentials instance using the given input options.\n   * @param json The input object.\n   * @returns JWT or UserRefresh Client with data\n   */\n  fromJSON(json: JWTInput, options?: RefreshOptions): JWT|UserRefreshClient {\n    let client: UserRefreshClient|JWT;\n    if (!json) {\n      throw new Error(\n          'Must pass in a JSON object containing the Google auth settings.');\n    }\n    this.jsonContent = json;\n    options = options || {};\n    if (json.type === 'authorized_user') {\n      client = new UserRefreshClient(options);\n    } else {\n      (options as JWTOptions).scopes = this.scopes;\n      client = new JWT(options);\n    }\n    client.fromJSON(json);\n    return client;\n  }\n\n  /**\n   * Create a credentials instance using the given input stream.\n   * @param inputStream The input stream.\n   * @param callback Optional callback.\n   */\n  fromStream(inputStream: stream.Readable): Promise;\n  fromStream(inputStream: stream.Readable, callback: CredentialCallback): void;\n  fromStream(inputStream: stream.Readable, options: RefreshOptions):\n      Promise;\n  fromStream(\n      inputStream: stream.Readable, options: RefreshOptions,\n      callback: CredentialCallback): void;\n  fromStream(\n      inputStream: stream.Readable,\n      optionsOrCallback: RefreshOptions|CredentialCallback = {},\n      callback?: CredentialCallback): Promise|void {\n    let options: RefreshOptions = {};\n    if (typeof optionsOrCallback === 'function') {\n      callback = optionsOrCallback;\n    } else {\n      options = optionsOrCallback;\n    }\n    if (callback) {\n      this.fromStreamAsync(inputStream, options)\n          .then(r => callback!(null, r), callback);\n    } else {\n      return this.fromStreamAsync(inputStream, options);\n    }\n  }\n\n  private fromStreamAsync(\n      inputStream: stream.Readable,\n      options?: RefreshOptions): Promise {\n    return new Promise((resolve, reject) => {\n      if (!inputStream) {\n        throw new Error(\n            'Must pass in a stream containing the Google auth settings.');\n      }\n      let s = '';\n      inputStream.setEncoding('utf8')\n          .on('error', reject)\n          .on('data', (chunk) => s += chunk)\n          .on('end', () => {\n            try {\n              const data = JSON.parse(s);\n              const r = this.fromJSON(data, options);\n              return resolve(r);\n            } catch (err) {\n              return reject(err);\n            }\n          });\n    });\n  }\n\n  /**\n   * Create a credentials instance using the given API key string.\n   * @param apiKey The API key string\n   * @param options An optional options object.\n   * @returns A JWT loaded from the key\n   */\n  fromAPIKey(apiKey: string, options?: RefreshOptions): JWT {\n    options = options || {};\n    const client = new JWT(options);\n    client.fromAPIKey(apiKey);\n    return client;\n  }\n\n  /**\n   * Determines whether the current operating system is Windows.\n   * @api private\n   */\n  private _isWindows() {\n    const sys = this._osPlatform();\n    if (sys && sys.length >= 3) {\n      if (sys.substring(0, 3).toLowerCase() === 'win') {\n        return true;\n      }\n    }\n    return false;\n  }\n\n  /**\n   * Creates a file stream. Allows mocking.\n   * @api private\n   */\n  _createReadStream(filePath: string) {\n    return fs.createReadStream(filePath);\n  }\n\n  /**\n   * Gets the current operating system platform. Allows mocking.\n   * @api private\n   */\n  _osPlatform() {\n    return os.platform();\n  }\n\n  /**\n   * Determines whether a file exists. Allows mocking.\n   * @api private\n   */\n  _fileExists(filePath: string) {\n    return fs.existsSync(filePath);\n  }\n\n  /**\n   * Joins two parts of a path. Allows mocking.\n   * @api private\n   */\n  _pathJoin(item1: string, item2: string) {\n    return path.join(item1, item2);\n  }\n\n  /**\n   * Allows mocking of the path to a well-known file.\n   * @api private\n   */\n  _mockWellKnownFilePath(filePath: string) {\n    return filePath;\n  }\n\n  // Creates an Error containing the given message, and includes the message\n  // from the optional err passed in.\n  private createError(message: string, err: Error) {\n    let s = message || '';\n    if (err) {\n      const errorMessage = String(err);\n      if (errorMessage && errorMessage.length > 0) {\n        if (s.length > 0) {\n          s += ' ';\n        }\n        s += errorMessage;\n      }\n    }\n    return Error(s);\n  }\n\n  /**\n   * Run the Google Cloud SDK command that prints the default project ID\n   */\n  private async getDefaultServiceProjectId(): Promise {\n    return new Promise(resolve => {\n      exec(\n          'gcloud config config-helper --format json',\n          (err, stdout, stderr) => {\n            if (!err && stdout) {\n              try {\n                const projectId =\n                    JSON.parse(stdout).configuration.properties.core.project;\n                resolve(projectId);\n                return;\n              } catch (e) {\n                // ignore errors\n              }\n            }\n            resolve(null);\n          });\n    });\n  }\n\n  /**\n   * Loads the project id from environment variables.\n   * @api private\n   */\n  private getProductionProjectId() {\n    return process.env['GCLOUD_PROJECT'] || process.env['GOOGLE_CLOUD_PROJECT'];\n  }\n\n  /**\n   * Loads the project id from the GOOGLE_APPLICATION_CREDENTIALS json file.\n   * @api private\n   */\n  private async getFileProjectId(): Promise {\n    if (this.cachedCredential) {\n      // Try to read the project ID from the cached credentials file\n      return this.cachedCredential.projectId;\n    }\n\n    // Try to load a credentials file and read its project ID\n    const r = await this._tryGetApplicationCredentialsFromEnvironmentVariable();\n    if (r) {\n      return r.projectId;\n    } else {\n      return null;\n    }\n  }\n\n  /**\n   * Gets the Compute Engine project ID if it can be inferred.\n   */\n  private async getGCEProjectId() {\n    try {\n      const r = await gcpMetadata.project('project-id');\n      return r.data;\n    } catch (e) {\n      // Ignore any errors\n      return null;\n    }\n  }\n\n  /**\n   * The callback function handles a credential object that contains the\n   * client_email and private_key (if exists).\n   * getCredentials checks for these values from the user JSON at first.\n   * If it doesn't exist, and the environment is on GCE, it gets the\n   * client_email from the cloud metadata server.\n   * @param callback Callback that handles the credential object that contains\n   * a client_email and optional private key, or the error.\n   * returned\n   */\n  getCredentials(): Promise;\n  getCredentials(\n      callback: (err: Error|null, credentials?: CredentialBody) => void): void;\n  getCredentials(\n      callback?: (err: Error|null, credentials?: CredentialBody) => void):\n      void|Promise {\n    if (callback) {\n      this.getCredentialsAsync().then(r => callback(null, r), callback);\n    } else {\n      return this.getCredentialsAsync();\n    }\n  }\n\n  private async getCredentialsAsync(): Promise {\n    if (this.jsonContent) {\n      const credential: CredentialBody = {\n        client_email: this.jsonContent.client_email,\n        private_key: this.jsonContent.private_key\n      };\n      return credential;\n    }\n\n    const isGCE = await this._checkIsGCE();\n    if (!isGCE) {\n      throw new Error('Unknown error.');\n    }\n\n    // For GCE, return the service account details from the metadata server\n    // NOTE: The trailing '/' at the end of service-accounts/ is very important!\n    // The GCF metadata server doesn't respect querystring params if this / is\n    // not included.\n    const {data} = await gcpMetadata.instance(\n        {property: 'service-accounts/', params: {recursive: true}});\n\n    if (!data || !data.default || !data.default.email) {\n      throw new Error('Failure from metadata server.');\n    }\n\n    return {client_email: data.default.email};\n  }\n\n  /**\n   * Automatically obtain a client based on the provided configuration.  If no\n   * options were passed, use Application Default Credentials.\n   */\n  async getClient(options?: GoogleAuthOptions) {\n    if (options) {\n      this.keyFilename =\n          options.keyFilename || options.keyFile || this.keyFilename;\n      this.scopes = options.scopes || this.scopes;\n      this.jsonContent = options.credentials || this.jsonContent;\n    }\n    if (!this.cachedCredential) {\n      if (this.jsonContent) {\n        this.cachedCredential = await this.fromJSON(this.jsonContent);\n      } else if (this.keyFilename) {\n        const filePath = path.resolve(this.keyFilename);\n        const stream = fs.createReadStream(filePath);\n        this.cachedCredential = await this.fromStreamAsync(stream);\n      } else {\n        await this.getApplicationDefaultAsync();\n      }\n    }\n    return this.cachedCredential!;\n  }\n\n  /**\n   * Automatically obtain application default credentials, and return\n   * an access token for making requests.\n   */\n  async getAccessToken() {\n    const client = await this.getClient();\n    return (await client.getAccessToken()).token;\n  }\n\n  /**\n   * Obtain the HTTP headers that will provide authorization for a given\n   * request.\n   */\n  async getRequestHeaders(url?: string) {\n    const client = await this.getClient();\n    return client.getRequestHeaders(url);\n  }\n\n  /**\n   * Obtain credentials for a request, then attach the appropriate headers to\n   * the request options.\n   * @param opts Axios or Request options on which to attach the headers\n   */\n  async authorizeRequest(opts:\n                             {url?: string, uri?: string, headers?: Headers}) {\n    opts = opts || {};\n    const url = opts.url || opts.uri;\n    const client = await this.getClient();\n    const headers = await client.getRequestHeaders(url);\n    opts.headers = Object.assign(opts.headers || {}, headers);\n    return opts;\n  }\n\n  /**\n   * Automatically obtain application default credentials, and make an\n   * HTTP request using the given options.\n   * @param opts Axios request options for the HTTP request.\n   */\n  // tslint:disable-next-line no-any\n  async request(opts: AxiosRequestConfig): Promise> {\n    const client = await this.getClient();\n    return client.request(opts);\n  }\n\n  /**\n   * Determine the compute environment in which the code is running.\n   */\n  getEnv(): Promise {\n    return getEnv();\n  }\n\n  /**\n   * Sign the given data with the current private key, or go out\n   * to the IAM API to sign it.\n   * @param data The data to be signed.\n   */\n  async sign(data: string): Promise {\n    const client = await this.getClient();\n    if (client instanceof JWT && client.key) {\n      const sign = crypto.createSign('RSA-SHA256');\n      sign.update(data);\n      return sign.sign(client.key, 'base64');\n    }\n\n    const projectId = await this.getProjectId();\n    if (!projectId) {\n      throw new Error('Cannot sign data without a project ID.');\n    }\n\n    const creds = await this.getCredentials();\n    if (!creds.client_email) {\n      throw new Error('Cannot sign data without `client_email`.');\n    }\n\n    const id = `projects/${projectId}/serviceAccounts/${creds.client_email}`;\n    const res = await this.request({\n      method: 'POST',\n      url: `https://iam.googleapis.com/v1/${id}:signBlob`,\n      data: {bytesToSign: Buffer.from(data).toString('base64')}\n    });\n    return res.data.signature;\n  }\n}\n\nexport interface SignBlobResponse {\n  signature: string;\n}\n\n    \n\n\n\n\n\n\n\n                   \n    \n         result-matching \"\"\n        \n    \n    \n        No results matching \"\"\n    \n\n"},"interfaces/BodyResponseCallback.html":{"url":"interfaces/BodyResponseCallback.html","title":"interface - BodyResponseCallback","body":"\n                   \n\n\n\n\n\n\n\n\n\n\n\n\n\n  Interfaces\n  BodyResponseCallback\n\n\n\n        \n            Info\n        \n        \n            Source\n        \n\n\n\n    \n        \n            File\n        \n        \n            src/transporters.ts\n        \n\n\n\n        \n            Index\n            \n                \n                    \n                        \n                            Properties\n                        \n                    \n                    \n                        \n                            \n                                \n                                            Unamed property\n                                \n                            \n                        \n                    \n                \n            \n        \n\n\n\n            \n                Properties\n                    \n                        \n\n                                    \n                                        \n                                            Signature :\n                                            \n                                            \n                                                \n                                                    [err: Error | null, res: AxiosResponse | null]\n                                            \n                                        \n                                    \n\n\n                                    \n                                        \n                                            Returns :     void\n\n                                        \n                                    \n\n\n\n\n                        \n                    \n            \n    \n\n\n    \n        import axios, {AxiosError, AxiosPromise, AxiosRequestConfig, AxiosResponse} from 'axios';\nimport {validate} from './options';\n\n// tslint:disable-next-line variable-name\nconst HttpsProxyAgent = require('https-proxy-agent');\n\n// tslint:disable-next-line no-var-requires\nconst pkg = require('../../package.json');\nconst PRODUCT_NAME = 'google-api-nodejs-client';\n\nexport interface Transporter {\n  request(opts: AxiosRequestConfig): AxiosPromise;\n  request(opts: AxiosRequestConfig, callback?: BodyResponseCallback):\n      void;\n  request(opts: AxiosRequestConfig, callback?: BodyResponseCallback):\n      AxiosPromise|void;\n}\n\nexport interface BodyResponseCallback {\n  // The `body` object is a truly dynamic type.  It must be `any`.\n  (err: Error|null, res?: AxiosResponse|null): void;\n}\n\nexport interface RequestError extends AxiosError {\n  errors: Error[];\n}\n\n/**\n * Axios will use XHR if it is available. In the case of Electron,\n * since XHR is there it will try to use that. This leads to OPTIONS\n * preflight requests which googleapis DOES NOT like. This line of\n * code pins the adapter to ensure it uses node.\n * https://github.com/google/google-api-nodejs-client/issues/1083\n */\naxios.defaults.adapter = require('axios/lib/adapters/http');\n\nexport class DefaultTransporter {\n  /**\n   * Default user agent.\n   */\n  static readonly USER_AGENT = `${PRODUCT_NAME}/${pkg.version}`;\n\n  /**\n   * Configures request options before making a request.\n   * @param opts AxiosRequestConfig options.\n   * @return Configured options.\n   */\n  configure(opts: AxiosRequestConfig = {}): AxiosRequestConfig {\n    // set transporter user agent\n    opts.headers = opts.headers || {};\n    const uaValue: string = opts.headers['User-Agent'];\n    if (!uaValue) {\n      opts.headers['User-Agent'] = DefaultTransporter.USER_AGENT;\n    } else if (!uaValue.includes(`${PRODUCT_NAME}/`)) {\n      opts.headers['User-Agent'] =\n          `${uaValue} ${DefaultTransporter.USER_AGENT}`;\n    }\n    return opts;\n  }\n\n  /**\n   * Makes a request using Axios with given options.\n   * @param opts AxiosRequestConfig options.\n   * @param callback optional callback that contains AxiosResponse object.\n   * @return AxiosPromise, assuming no callback is passed.\n   */\n  request(opts: AxiosRequestConfig): AxiosPromise;\n  request(opts: AxiosRequestConfig, callback?: BodyResponseCallback):\n      void;\n  request(opts: AxiosRequestConfig, callback?: BodyResponseCallback):\n      AxiosPromise|void {\n    // ensure the user isn't passing in request-style options\n    opts = this.configure(opts);\n    try {\n      validate(opts);\n    } catch (e) {\n      if (callback) {\n        return callback(e);\n      } else {\n        throw e;\n      }\n    }\n\n    // If the user configured an `HTTPS_PROXY` environment variable, create\n    // a custom agent to proxy the request.\n    const proxy = process.env.HTTPS_PROXY || process.env.https_proxy;\n    if (proxy) {\n      opts.httpsAgent = new HttpsProxyAgent(proxy);\n      opts.proxy = false;\n    }\n\n    if (callback) {\n      axios(opts).then(\n          r => {\n            callback(null, r);\n          },\n          e => {\n            callback(this.processError(e));\n          });\n    } else {\n      return axios(opts).catch(e => {\n        throw this.processError(e);\n      });\n    }\n  }\n\n  /**\n   * Changes the error to include details from the body.\n   */\n  private processError(e: AxiosError): RequestError {\n    const res = e.response;\n    const err = e as RequestError;\n    const body = res ? res.data : null;\n    if (res && body && body.error && res.status !== 200) {\n      if (typeof body.error === 'string') {\n        err.message = body.error;\n        err.code = res.status.toString();\n      } else if (Array.isArray(body.error.errors)) {\n        err.message =\n            body.error.errors.map((err2: Error) => err2.message).join('\\n');\n        err.code = body.error.code;\n        err.errors = body.error.errors;\n      } else {\n        err.message = body.error.message;\n        err.code = body.error.code || res.status;\n      }\n    } else if (res && res.status >= 400) {\n      // Consider all 4xx and 5xx responses errors.\n      err.message = body;\n      err.code = res.status.toString();\n    }\n    return err;\n  }\n}\n\n    \n\n\n\n\n\n\n\n                   \n    \n         result-matching \"\"\n        \n    \n    \n        No results matching \"\"\n    \n\n"},"interfaces/ComputeOptions.html":{"url":"interfaces/ComputeOptions.html","title":"interface - ComputeOptions","body":"\n                   \n\n\n\n\n\n\n\n\n\n\n\n\n\n  Interfaces\n  ComputeOptions\n\n\n\n        \n            Info\n        \n        \n            Source\n        \n\n\n\n    \n        \n            File\n        \n        \n            src/auth/computeclient.ts\n        \n\n\n            \n                Extends\n            \n            \n                    RefreshOptions\n            \n\n        \n            Index\n            \n                \n                    \n                        \n                            Properties\n                        \n                    \n                    \n                        \n                            \n                                \n                                            Optional\n                                        serviceAccountEmail\n                                \n                            \n                        \n                    \n                \n            \n        \n\n\n\n            \n                Properties\n                    \n                        \n                                \n                                    \n                                        \n                                        serviceAccountEmail\n                                    \n                                \n                                \n                                    \n                                        serviceAccountEmail:     string\n\n                                    \n                                \n\n\n                                    \n                                        \n                                            Type :     string\n\n                                        \n                                    \n\n                                    \n                                        \n                                            Optional\n                                        \n                                    \n\n\n\n\n                            \n                                \n                                    The service account email to use, or 'default'. A Compute Engine instance\nmay have multiple service accounts.\n\n                                \n                            \n                        \n                    \n            \n    \n\n\n    \n        import {AxiosError, AxiosPromise, AxiosRequestConfig, AxiosResponse} from 'axios';\nimport * as gcpMetadata from 'gcp-metadata';\nimport * as messages from '../messages';\nimport {CredentialRequest, Credentials} from './credentials';\nimport {GetTokenResponse, OAuth2Client, RefreshOptions} from './oauth2client';\n\nexport interface ComputeOptions extends RefreshOptions {\n  /**\n   * The service account email to use, or 'default'. A Compute Engine instance\n   * may have multiple service accounts.\n   */\n  serviceAccountEmail?: string;\n}\n\nexport class Compute extends OAuth2Client {\n  private serviceAccountEmail: string;\n\n  /**\n   * Google Compute Engine service account credentials.\n   *\n   * Retrieve access token from the metadata server.\n   * See: https://developers.google.com/compute/docs/authentication\n   */\n  constructor(options: ComputeOptions = {}) {\n    super(options);\n    // Start with an expired refresh token, which will automatically be\n    // refreshed before the first API call is made.\n    this.credentials = {expiry_date: 1, refresh_token: 'compute-placeholder'};\n    this.serviceAccountEmail = options.serviceAccountEmail || 'default';\n  }\n\n  /**\n   * Indicates whether the credential requires scopes to be created by calling\n   * createdScoped before use.\n   * @deprecated\n   * @return Boolean indicating if scope is required.\n   */\n  createScopedRequired() {\n    // On compute engine, scopes are specified at the compute instance's\n    // creation time, and cannot be changed. For this reason, always return\n    // false.\n    messages.warn(messages.COMPUTE_CREATE_SCOPED_DEPRECATED);\n    return false;\n  }\n\n  /**\n   * Refreshes the access token.\n   * @param refreshToken Unused parameter\n   */\n  protected async refreshTokenNoCache(refreshToken?: string|\n                                      null): Promise {\n    const tokenPath = `service-accounts/${this.serviceAccountEmail}/token`;\n    let res: AxiosResponse;\n    try {\n      res = await gcpMetadata.instance(tokenPath);\n    } catch (e) {\n      e.message = 'Could not refresh access token.';\n      throw e;\n    }\n    const tokens = res.data as Credentials;\n    if (res.data && res.data.expires_in) {\n      tokens.expiry_date =\n          ((new Date()).getTime() + (res.data.expires_in * 1000));\n      delete (tokens as CredentialRequest).expires_in;\n    }\n    this.emit('tokens', tokens);\n    return {tokens, res};\n  }\n\n  protected requestAsync(opts: AxiosRequestConfig, retry = false):\n      AxiosPromise {\n    return super.requestAsync(opts, retry).catch(e => {\n      const res = (e as AxiosError).response;\n      if (res && res.status) {\n        let helpfulMessage = null;\n        if (res.status === 403) {\n          helpfulMessage =\n              'A Forbidden error was returned while attempting to retrieve an access ' +\n              'token for the Compute Engine built-in service account. This may be because the Compute ' +\n              'Engine instance does not have the correct permission scopes specified.';\n        } else if (res.status === 404) {\n          helpfulMessage =\n              'A Not Found error was returned while attempting to retrieve an access' +\n              'token for the Compute Engine built-in service account. This may be because the Compute ' +\n              'Engine instance does not have any permission scopes specified.';\n        }\n        if (helpfulMessage) {\n          if (e && e.message && !retry) {\n            helpfulMessage += ' ' + e.message;\n          }\n          if (e) {\n            e.message = helpfulMessage;\n          } else {\n            e = new Error(helpfulMessage);\n            (e as NodeJS.ErrnoException).code = res.status.toString();\n          }\n        }\n      }\n      throw e;\n    });\n  }\n}\n\n    \n\n\n\n\n\n\n\n                   \n    \n         result-matching \"\"\n        \n    \n    \n        No results matching \"\"\n    \n\n"},"interfaces/CredentialBody.html":{"url":"interfaces/CredentialBody.html","title":"interface - CredentialBody","body":"\n                   \n\n\n\n\n\n\n\n\n\n\n\n\n\n  Interfaces\n  CredentialBody\n\n\n\n        \n            Info\n        \n        \n            Source\n        \n\n\n\n    \n        \n            File\n        \n        \n            src/auth/credentials.ts\n        \n\n\n\n        \n            Index\n            \n                \n                    \n                        \n                            Properties\n                        \n                    \n                    \n                        \n                            \n                                \n                                            Optional\n                                        client_email\n                                \n                                \n                                            Optional\n                                        private_key\n                                \n                            \n                        \n                    \n                \n            \n        \n\n\n\n            \n                Properties\n                    \n                        \n                                \n                                    \n                                        \n                                        client_email\n                                    \n                                \n                                \n                                    \n                                        client_email:     string\n\n                                    \n                                \n\n\n                                    \n                                        \n                                            Type :     string\n\n                                        \n                                    \n\n                                    \n                                        \n                                            Optional\n                                        \n                                    \n\n\n\n\n                        \n                    \n                    \n                        \n                                \n                                    \n                                        \n                                        private_key\n                                    \n                                \n                                \n                                    \n                                        private_key:     string\n\n                                    \n                                \n\n\n                                    \n                                        \n                                            Type :     string\n\n                                        \n                                    \n\n                                    \n                                        \n                                            Optional\n                                        \n                                    \n\n\n\n\n                        \n                    \n            \n    \n\n\n    \n        export interface Credentials {\n  refresh_token?: string|null;\n  expiry_date?: number|null;\n  access_token?: string|null;\n  token_type?: string|null;\n  id_token?: string|null;\n}\n\nexport interface CredentialRequest {\n  refresh_token?: string;\n  access_token?: string;\n  token_type?: string;\n  expires_in?: number;\n  id_token?: string;\n}\n\nexport interface JWTInput {\n  type?: string;\n  client_email?: string;\n  private_key?: string;\n  private_key_id?: string;\n  project_id?: string;\n  client_id?: string;\n  client_secret?: string;\n  refresh_token?: string;\n}\n\nexport interface CredentialBody {\n  client_email?: string;\n  private_key?: string;\n}\n\n    \n\n\n\n\n\n\n\n                   \n    \n         result-matching \"\"\n        \n    \n    \n        No results matching \"\"\n    \n\n"},"interfaces/CredentialCallback.html":{"url":"interfaces/CredentialCallback.html","title":"interface - CredentialCallback","body":"\n                   \n\n\n\n\n\n\n\n\n\n\n\n\n\n  Interfaces\n  CredentialCallback\n\n\n\n        \n            Info\n        \n        \n            Source\n        \n\n\n\n    \n        \n            File\n        \n        \n            src/auth/googleauth.ts\n        \n\n\n\n        \n            Index\n            \n                \n                    \n                        \n                            Properties\n                        \n                    \n                    \n                        \n                            \n                                \n                                            Unamed property\n                                \n                            \n                        \n                    \n                \n            \n        \n\n\n\n            \n                Properties\n                    \n                        \n\n                                    \n                                        \n                                            Signature :\n                                            \n                                            \n                                                \n                                                    [err: Error | null, result: UserRefreshClient | JWT]\n                                            \n                                        \n                                    \n\n\n                                    \n                                        \n                                            Returns :     void\n\n                                        \n                                    \n\n\n\n\n                        \n                    \n            \n    \n\n\n    \n        import {AxiosRequestConfig, AxiosResponse} from 'axios';\nimport {exec} from 'child_process';\nimport * as crypto from 'crypto';\nimport * as fs from 'fs';\nimport * as gcpMetadata from 'gcp-metadata';\nimport * as http from 'http';\nimport * as os from 'os';\nimport * as path from 'path';\nimport * as stream from 'stream';\nimport * as util from 'util';\n\nimport * as messages from '../messages';\nimport {DefaultTransporter, Transporter} from '../transporters';\n\nimport {Compute} from './computeclient';\nimport {CredentialBody, JWTInput} from './credentials';\nimport {GCPEnv, getEnv} from './envDetect';\nimport {JWT, JWTOptions} from './jwtclient';\nimport {Headers, OAuth2Client, RefreshOptions} from './oauth2client';\nimport {UserRefreshClient} from './refreshclient';\n\nexport interface ProjectIdCallback {\n  (err?: Error|null, projectId?: string|null): void;\n}\n\nexport interface CredentialCallback {\n  (err: Error|null, result?: UserRefreshClient|JWT): void;\n}\n\nexport interface ADCCallback {\n  (err: Error|null, credential?: OAuth2Client, projectId?: string|null): void;\n}\n\nexport interface ADCResponse {\n  credential: OAuth2Client;\n  projectId: string|null;\n}\n\nexport interface GoogleAuthOptions {\n  /**\n   * Path to a .json, .pem, or .p12 key file\n   */\n  keyFilename?: string;\n\n  /**\n   * Path to a .json, .pem, or .p12 key file\n   */\n  keyFile?: string;\n\n  /**\n   * Object containing client_email and private_key properties\n   */\n  credentials?: CredentialBody;\n\n  /**\n   * Required scopes for the desired API request\n   */\n  scopes?: string|string[];\n\n  /**\n   * Your project ID.\n   */\n  projectId?: string;\n}\n\nexport const CLOUD_SDK_CLIENT_ID =\n    '764086051850-6qr4p6gpi6hn506pt8ejuq83di341hur.apps.googleusercontent.com';\n\nexport class GoogleAuth {\n  transporter?: Transporter;\n\n  /**\n   * Caches a value indicating whether the auth layer is running on Google\n   * Compute Engine.\n   * @private\n   */\n  private checkIsGCE?: boolean = undefined;\n\n  // Note:  this properly is only public to satisify unit tests.\n  // https://github.com/Microsoft/TypeScript/issues/5228\n  get isGCE() {\n    return this.checkIsGCE;\n  }\n\n  private _getDefaultProjectIdPromise?: Promise;\n  private _cachedProjectId?: string|null;\n\n  // To save the contents of the JSON credential file\n  jsonContent: JWTInput|null = null;\n\n  cachedCredential: JWT|UserRefreshClient|Compute|null = null;\n\n  private keyFilename?: string;\n  private scopes?: string|string[];\n\n  /**\n   * Export DefaultTransporter as a static property of the class.\n   */\n  static DefaultTransporter = DefaultTransporter;\n\n  constructor(opts?: GoogleAuthOptions) {\n    opts = opts || {};\n    this._cachedProjectId = opts.projectId || null;\n    this.keyFilename = opts.keyFilename || opts.keyFile;\n    this.scopes = opts.scopes;\n    this.jsonContent = opts.credentials || null;\n  }\n\n  /**\n   * THIS METHOD HAS BEEN DEPRECATED.\n   * It will be removed in 3.0.  Please use getProjectId instead.\n   */\n  getDefaultProjectId(): Promise;\n  getDefaultProjectId(callback: ProjectIdCallback): void;\n  getDefaultProjectId(callback?: ProjectIdCallback): Promise|void {\n    messages.warn(messages.DEFAULT_PROJECT_ID_DEPRECATED);\n    if (callback) {\n      this.getProjectIdAsync().then(r => callback(null, r), callback);\n    } else {\n      return this.getProjectIdAsync();\n    }\n  }\n\n  /**\n   * Obtains the default project ID for the application.\n   * @param callback Optional callback\n   * @returns Promise that resolves with project Id (if used without callback)\n   */\n  getProjectId(): Promise;\n  getProjectId(callback: ProjectIdCallback): void;\n  getProjectId(callback?: ProjectIdCallback): Promise|void {\n    if (callback) {\n      this.getProjectIdAsync().then(r => callback(null, r), callback);\n    } else {\n      return this.getProjectIdAsync();\n    }\n  }\n\n  private getProjectIdAsync(): Promise {\n    if (this._cachedProjectId) {\n      return Promise.resolve(this._cachedProjectId);\n    }\n\n    // In implicit case, supports three environments. In order of precedence,\n    // the implicit environments are:\n    // - GCLOUD_PROJECT or GOOGLE_CLOUD_PROJECT environment variable\n    // - GOOGLE_APPLICATION_CREDENTIALS JSON file\n    // - Cloud SDK: `gcloud config config-helper --format json`\n    // - GCE project ID from metadata server)\n    if (!this._getDefaultProjectIdPromise) {\n      this._getDefaultProjectIdPromise =\n          new Promise(async (resolve, reject) => {\n            try {\n              const projectId = this.getProductionProjectId() ||\n                  await this.getFileProjectId() ||\n                  await this.getDefaultServiceProjectId() ||\n                  await this.getGCEProjectId();\n              this._cachedProjectId = projectId;\n              resolve(projectId);\n            } catch (e) {\n              reject(e);\n            }\n          });\n    }\n    return this._getDefaultProjectIdPromise;\n  }\n\n  /**\n   * Obtains the default service-level credentials for the application.\n   * @param callback Optional callback.\n   * @returns Promise that resolves with the ADCResponse (if no callback was\n   * passed).\n   */\n  getApplicationDefault(): Promise;\n  getApplicationDefault(callback: ADCCallback): void;\n  getApplicationDefault(options: RefreshOptions): Promise;\n  getApplicationDefault(options: RefreshOptions, callback: ADCCallback): void;\n  getApplicationDefault(\n      optionsOrCallback: ADCCallback|RefreshOptions = {},\n      callback?: ADCCallback): void|Promise {\n    let options: RefreshOptions|undefined;\n    if (typeof optionsOrCallback === 'function') {\n      callback = optionsOrCallback;\n    } else {\n      options = optionsOrCallback;\n    }\n    if (callback) {\n      this.getApplicationDefaultAsync(options).then(\n          r => callback!(null, r.credential, r.projectId), callback);\n    } else {\n      return this.getApplicationDefaultAsync(options);\n    }\n  }\n\n  private async getApplicationDefaultAsync(options?: RefreshOptions):\n      Promise {\n    // If we've already got a cached credential, just return it.\n    if (this.cachedCredential) {\n      return {\n        credential: this.cachedCredential as JWT | UserRefreshClient,\n        projectId: await this.getProjectIdAsync()\n      };\n    }\n\n    let credential: JWT|UserRefreshClient|null;\n    let projectId: string|null;\n    // Check for the existence of a local environment variable pointing to the\n    // location of the credential file. This is typically used in local\n    // developer scenarios.\n    credential =\n        await this._tryGetApplicationCredentialsFromEnvironmentVariable(\n            options);\n    if (credential) {\n      if (credential instanceof JWT) {\n        credential.scopes = this.scopes;\n      }\n      this.cachedCredential = credential;\n      projectId = await this.getProjectId();\n      return {credential, projectId};\n    }\n\n    // Look in the well-known credential file location.\n    credential =\n        await this._tryGetApplicationCredentialsFromWellKnownFile(options);\n    if (credential) {\n      if (credential instanceof JWT) {\n        credential.scopes = this.scopes;\n      }\n      this.cachedCredential = credential;\n      projectId = await this.getProjectId();\n      return {credential, projectId};\n    }\n\n    // Determine if we're running on GCE.\n    let isGCE;\n    try {\n      isGCE = await this._checkIsGCE();\n    } catch (e) {\n      throw new Error(\n          'Unexpected error determining execution environment: ' + e.message);\n    }\n\n    if (!isGCE) {\n      // We failed to find the default credentials. Bail out with an error.\n      throw new Error(\n          'Could not load the default credentials. Browse to https://cloud.google.com/docs/authentication/getting-started for more information.');\n    }\n\n    // For GCE, just return a default ComputeClient. It will take care of\n    // the rest.\n    this.cachedCredential = new Compute(options);\n    projectId = await this.getProjectId();\n    return {projectId, credential: this.cachedCredential};\n  }\n\n  /**\n   * Determines whether the auth layer is running on Google Compute Engine.\n   * @returns A promise that resolves with the boolean.\n   * @api private\n   */\n  async _checkIsGCE() {\n    if (this.checkIsGCE === undefined) {\n      this.checkIsGCE = await gcpMetadata.isAvailable();\n    }\n    return this.checkIsGCE;\n  }\n\n  /**\n   * Attempts to load default credentials from the environment variable path..\n   * @returns Promise that resolves with the OAuth2Client or null.\n   * @api private\n   */\n  async _tryGetApplicationCredentialsFromEnvironmentVariable(\n      options?: RefreshOptions): Promise {\n    const credentialsPath = process.env['GOOGLE_APPLICATION_CREDENTIALS'];\n    if (!credentialsPath || credentialsPath.length === 0) {\n      return null;\n    }\n    try {\n      return this._getApplicationCredentialsFromFilePath(\n          credentialsPath, options);\n    } catch (e) {\n      throw this.createError(\n          'Unable to read the credential file specified by the GOOGLE_APPLICATION_CREDENTIALS environment variable.',\n          e);\n    }\n  }\n\n  /**\n   * Attempts to load default credentials from a well-known file location\n   * @return Promise that resolves with the OAuth2Client or null.\n   * @api private\n   */\n  async _tryGetApplicationCredentialsFromWellKnownFile(\n      options?: RefreshOptions): Promise {\n    // First, figure out the location of the file, depending upon the OS type.\n    let location = null;\n    if (this._isWindows()) {\n      // Windows\n      location = process.env['APPDATA'];\n    } else {\n      // Linux or Mac\n      const home = process.env['HOME'];\n      if (home) {\n        location = this._pathJoin(home, '.config');\n      }\n    }\n    // If we found the root path, expand it.\n    if (location) {\n      location = this._pathJoin(location, 'gcloud');\n      location =\n          this._pathJoin(location, 'application_default_credentials.json');\n      location = this._mockWellKnownFilePath(location);\n      // Check whether the file exists.\n      if (!this._fileExists(location)) {\n        location = null;\n      }\n    }\n    // The file does not exist.\n    if (!location) {\n      return null;\n    }\n    // The file seems to exist. Try to use it.\n    const client =\n        await this._getApplicationCredentialsFromFilePath(location, options);\n    this.warnOnProblematicCredentials(client as JWT);\n    return client;\n  }\n\n  /**\n   * Attempts to load default credentials from a file at the given path..\n   * @param filePath The path to the file to read.\n   * @returns Promise that resolves with the OAuth2Client\n   * @api private\n   */\n  async _getApplicationCredentialsFromFilePath(\n      filePath: string,\n      options: RefreshOptions = {}): Promise {\n    // Make sure the path looks like a string.\n    if (!filePath || filePath.length === 0) {\n      throw new Error('The file path is invalid.');\n    }\n\n    // Make sure there is a file at the path. lstatSync will throw if there is\n    // nothing there.\n    try {\n      // Resolve path to actual file in case of symlink. Expect a thrown error\n      // if not resolvable.\n      filePath = fs.realpathSync(filePath);\n\n      if (!fs.lstatSync(filePath).isFile()) {\n        throw new Error();\n      }\n    } catch (err) {\n      throw this.createError(\n          util.format(\n              'The file at %s does not exist, or it is not a file.', filePath),\n          err);\n    }\n\n    // Now open a read stream on the file, and parse it.\n    try {\n      const readStream = this._createReadStream(filePath);\n      return this.fromStream(readStream, options);\n    } catch (err) {\n      throw this.createError(\n          util.format('Unable to read the file at %s.', filePath), err);\n    }\n  }\n\n  /**\n   * Credentials from the Cloud SDK that are associated with Cloud SDK's project\n   * are problematic because they may not have APIs enabled and have limited\n   * quota. If this is the case, warn about it.\n   */\n  protected warnOnProblematicCredentials(client: JWT) {\n    if (client.email === CLOUD_SDK_CLIENT_ID) {\n      messages.warn(messages.PROBLEMATIC_CREDENTIALS_WARNING);\n    }\n  }\n\n  /**\n   * Create a credentials instance using the given input options.\n   * @param json The input object.\n   * @returns JWT or UserRefresh Client with data\n   */\n  fromJSON(json: JWTInput, options?: RefreshOptions): JWT|UserRefreshClient {\n    let client: UserRefreshClient|JWT;\n    if (!json) {\n      throw new Error(\n          'Must pass in a JSON object containing the Google auth settings.');\n    }\n    this.jsonContent = json;\n    options = options || {};\n    if (json.type === 'authorized_user') {\n      client = new UserRefreshClient(options);\n    } else {\n      (options as JWTOptions).scopes = this.scopes;\n      client = new JWT(options);\n    }\n    client.fromJSON(json);\n    return client;\n  }\n\n  /**\n   * Create a credentials instance using the given input stream.\n   * @param inputStream The input stream.\n   * @param callback Optional callback.\n   */\n  fromStream(inputStream: stream.Readable): Promise;\n  fromStream(inputStream: stream.Readable, callback: CredentialCallback): void;\n  fromStream(inputStream: stream.Readable, options: RefreshOptions):\n      Promise;\n  fromStream(\n      inputStream: stream.Readable, options: RefreshOptions,\n      callback: CredentialCallback): void;\n  fromStream(\n      inputStream: stream.Readable,\n      optionsOrCallback: RefreshOptions|CredentialCallback = {},\n      callback?: CredentialCallback): Promise|void {\n    let options: RefreshOptions = {};\n    if (typeof optionsOrCallback === 'function') {\n      callback = optionsOrCallback;\n    } else {\n      options = optionsOrCallback;\n    }\n    if (callback) {\n      this.fromStreamAsync(inputStream, options)\n          .then(r => callback!(null, r), callback);\n    } else {\n      return this.fromStreamAsync(inputStream, options);\n    }\n  }\n\n  private fromStreamAsync(\n      inputStream: stream.Readable,\n      options?: RefreshOptions): Promise {\n    return new Promise((resolve, reject) => {\n      if (!inputStream) {\n        throw new Error(\n            'Must pass in a stream containing the Google auth settings.');\n      }\n      let s = '';\n      inputStream.setEncoding('utf8')\n          .on('error', reject)\n          .on('data', (chunk) => s += chunk)\n          .on('end', () => {\n            try {\n              const data = JSON.parse(s);\n              const r = this.fromJSON(data, options);\n              return resolve(r);\n            } catch (err) {\n              return reject(err);\n            }\n          });\n    });\n  }\n\n  /**\n   * Create a credentials instance using the given API key string.\n   * @param apiKey The API key string\n   * @param options An optional options object.\n   * @returns A JWT loaded from the key\n   */\n  fromAPIKey(apiKey: string, options?: RefreshOptions): JWT {\n    options = options || {};\n    const client = new JWT(options);\n    client.fromAPIKey(apiKey);\n    return client;\n  }\n\n  /**\n   * Determines whether the current operating system is Windows.\n   * @api private\n   */\n  private _isWindows() {\n    const sys = this._osPlatform();\n    if (sys && sys.length >= 3) {\n      if (sys.substring(0, 3).toLowerCase() === 'win') {\n        return true;\n      }\n    }\n    return false;\n  }\n\n  /**\n   * Creates a file stream. Allows mocking.\n   * @api private\n   */\n  _createReadStream(filePath: string) {\n    return fs.createReadStream(filePath);\n  }\n\n  /**\n   * Gets the current operating system platform. Allows mocking.\n   * @api private\n   */\n  _osPlatform() {\n    return os.platform();\n  }\n\n  /**\n   * Determines whether a file exists. Allows mocking.\n   * @api private\n   */\n  _fileExists(filePath: string) {\n    return fs.existsSync(filePath);\n  }\n\n  /**\n   * Joins two parts of a path. Allows mocking.\n   * @api private\n   */\n  _pathJoin(item1: string, item2: string) {\n    return path.join(item1, item2);\n  }\n\n  /**\n   * Allows mocking of the path to a well-known file.\n   * @api private\n   */\n  _mockWellKnownFilePath(filePath: string) {\n    return filePath;\n  }\n\n  // Creates an Error containing the given message, and includes the message\n  // from the optional err passed in.\n  private createError(message: string, err: Error) {\n    let s = message || '';\n    if (err) {\n      const errorMessage = String(err);\n      if (errorMessage && errorMessage.length > 0) {\n        if (s.length > 0) {\n          s += ' ';\n        }\n        s += errorMessage;\n      }\n    }\n    return Error(s);\n  }\n\n  /**\n   * Run the Google Cloud SDK command that prints the default project ID\n   */\n  private async getDefaultServiceProjectId(): Promise {\n    return new Promise(resolve => {\n      exec(\n          'gcloud config config-helper --format json',\n          (err, stdout, stderr) => {\n            if (!err && stdout) {\n              try {\n                const projectId =\n                    JSON.parse(stdout).configuration.properties.core.project;\n                resolve(projectId);\n                return;\n              } catch (e) {\n                // ignore errors\n              }\n            }\n            resolve(null);\n          });\n    });\n  }\n\n  /**\n   * Loads the project id from environment variables.\n   * @api private\n   */\n  private getProductionProjectId() {\n    return process.env['GCLOUD_PROJECT'] || process.env['GOOGLE_CLOUD_PROJECT'];\n  }\n\n  /**\n   * Loads the project id from the GOOGLE_APPLICATION_CREDENTIALS json file.\n   * @api private\n   */\n  private async getFileProjectId(): Promise {\n    if (this.cachedCredential) {\n      // Try to read the project ID from the cached credentials file\n      return this.cachedCredential.projectId;\n    }\n\n    // Try to load a credentials file and read its project ID\n    const r = await this._tryGetApplicationCredentialsFromEnvironmentVariable();\n    if (r) {\n      return r.projectId;\n    } else {\n      return null;\n    }\n  }\n\n  /**\n   * Gets the Compute Engine project ID if it can be inferred.\n   */\n  private async getGCEProjectId() {\n    try {\n      const r = await gcpMetadata.project('project-id');\n      return r.data;\n    } catch (e) {\n      // Ignore any errors\n      return null;\n    }\n  }\n\n  /**\n   * The callback function handles a credential object that contains the\n   * client_email and private_key (if exists).\n   * getCredentials checks for these values from the user JSON at first.\n   * If it doesn't exist, and the environment is on GCE, it gets the\n   * client_email from the cloud metadata server.\n   * @param callback Callback that handles the credential object that contains\n   * a client_email and optional private key, or the error.\n   * returned\n   */\n  getCredentials(): Promise;\n  getCredentials(\n      callback: (err: Error|null, credentials?: CredentialBody) => void): void;\n  getCredentials(\n      callback?: (err: Error|null, credentials?: CredentialBody) => void):\n      void|Promise {\n    if (callback) {\n      this.getCredentialsAsync().then(r => callback(null, r), callback);\n    } else {\n      return this.getCredentialsAsync();\n    }\n  }\n\n  private async getCredentialsAsync(): Promise {\n    if (this.jsonContent) {\n      const credential: CredentialBody = {\n        client_email: this.jsonContent.client_email,\n        private_key: this.jsonContent.private_key\n      };\n      return credential;\n    }\n\n    const isGCE = await this._checkIsGCE();\n    if (!isGCE) {\n      throw new Error('Unknown error.');\n    }\n\n    // For GCE, return the service account details from the metadata server\n    // NOTE: The trailing '/' at the end of service-accounts/ is very important!\n    // The GCF metadata server doesn't respect querystring params if this / is\n    // not included.\n    const {data} = await gcpMetadata.instance(\n        {property: 'service-accounts/', params: {recursive: true}});\n\n    if (!data || !data.default || !data.default.email) {\n      throw new Error('Failure from metadata server.');\n    }\n\n    return {client_email: data.default.email};\n  }\n\n  /**\n   * Automatically obtain a client based on the provided configuration.  If no\n   * options were passed, use Application Default Credentials.\n   */\n  async getClient(options?: GoogleAuthOptions) {\n    if (options) {\n      this.keyFilename =\n          options.keyFilename || options.keyFile || this.keyFilename;\n      this.scopes = options.scopes || this.scopes;\n      this.jsonContent = options.credentials || this.jsonContent;\n    }\n    if (!this.cachedCredential) {\n      if (this.jsonContent) {\n        this.cachedCredential = await this.fromJSON(this.jsonContent);\n      } else if (this.keyFilename) {\n        const filePath = path.resolve(this.keyFilename);\n        const stream = fs.createReadStream(filePath);\n        this.cachedCredential = await this.fromStreamAsync(stream);\n      } else {\n        await this.getApplicationDefaultAsync();\n      }\n    }\n    return this.cachedCredential!;\n  }\n\n  /**\n   * Automatically obtain application default credentials, and return\n   * an access token for making requests.\n   */\n  async getAccessToken() {\n    const client = await this.getClient();\n    return (await client.getAccessToken()).token;\n  }\n\n  /**\n   * Obtain the HTTP headers that will provide authorization for a given\n   * request.\n   */\n  async getRequestHeaders(url?: string) {\n    const client = await this.getClient();\n    return client.getRequestHeaders(url);\n  }\n\n  /**\n   * Obtain credentials for a request, then attach the appropriate headers to\n   * the request options.\n   * @param opts Axios or Request options on which to attach the headers\n   */\n  async authorizeRequest(opts:\n                             {url?: string, uri?: string, headers?: Headers}) {\n    opts = opts || {};\n    const url = opts.url || opts.uri;\n    const client = await this.getClient();\n    const headers = await client.getRequestHeaders(url);\n    opts.headers = Object.assign(opts.headers || {}, headers);\n    return opts;\n  }\n\n  /**\n   * Automatically obtain application default credentials, and make an\n   * HTTP request using the given options.\n   * @param opts Axios request options for the HTTP request.\n   */\n  // tslint:disable-next-line no-any\n  async request(opts: AxiosRequestConfig): Promise> {\n    const client = await this.getClient();\n    return client.request(opts);\n  }\n\n  /**\n   * Determine the compute environment in which the code is running.\n   */\n  getEnv(): Promise {\n    return getEnv();\n  }\n\n  /**\n   * Sign the given data with the current private key, or go out\n   * to the IAM API to sign it.\n   * @param data The data to be signed.\n   */\n  async sign(data: string): Promise {\n    const client = await this.getClient();\n    if (client instanceof JWT && client.key) {\n      const sign = crypto.createSign('RSA-SHA256');\n      sign.update(data);\n      return sign.sign(client.key, 'base64');\n    }\n\n    const projectId = await this.getProjectId();\n    if (!projectId) {\n      throw new Error('Cannot sign data without a project ID.');\n    }\n\n    const creds = await this.getCredentials();\n    if (!creds.client_email) {\n      throw new Error('Cannot sign data without `client_email`.');\n    }\n\n    const id = `projects/${projectId}/serviceAccounts/${creds.client_email}`;\n    const res = await this.request({\n      method: 'POST',\n      url: `https://iam.googleapis.com/v1/${id}:signBlob`,\n      data: {bytesToSign: Buffer.from(data).toString('base64')}\n    });\n    return res.data.signature;\n  }\n}\n\nexport interface SignBlobResponse {\n  signature: string;\n}\n\n    \n\n\n\n\n\n\n\n                   \n    \n         result-matching \"\"\n        \n    \n    \n        No results matching \"\"\n    \n\n"},"interfaces/CredentialRequest.html":{"url":"interfaces/CredentialRequest.html","title":"interface - CredentialRequest","body":"\n                   \n\n\n\n\n\n\n\n\n\n\n\n\n\n  Interfaces\n  CredentialRequest\n\n\n\n        \n            Info\n        \n        \n            Source\n        \n\n\n\n    \n        \n            File\n        \n        \n            src/auth/credentials.ts\n        \n\n\n\n        \n            Index\n            \n                \n                    \n                        \n                            Properties\n                        \n                    \n                    \n                        \n                            \n                                \n                                            Optional\n                                        access_token\n                                \n                                \n                                            Optional\n                                        expires_in\n                                \n                                \n                                            Optional\n                                        id_token\n                                \n                                \n                                            Optional\n                                        refresh_token\n                                \n                                \n                                            Optional\n                                        token_type\n                                \n                            \n                        \n                    \n                \n            \n        \n\n\n\n            \n                Properties\n                    \n                        \n                                \n                                    \n                                        \n                                        access_token\n                                    \n                                \n                                \n                                    \n                                        access_token:     string\n\n                                    \n                                \n\n\n                                    \n                                        \n                                            Type :     string\n\n                                        \n                                    \n\n                                    \n                                        \n                                            Optional\n                                        \n                                    \n\n\n\n\n                        \n                    \n                    \n                        \n                                \n                                    \n                                        \n                                        expires_in\n                                    \n                                \n                                \n                                    \n                                        expires_in:     number\n\n                                    \n                                \n\n\n                                    \n                                        \n                                            Type :     number\n\n                                        \n                                    \n\n                                    \n                                        \n                                            Optional\n                                        \n                                    \n\n\n\n\n                        \n                    \n                    \n                        \n                                \n                                    \n                                        \n                                        id_token\n                                    \n                                \n                                \n                                    \n                                        id_token:     string\n\n                                    \n                                \n\n\n                                    \n                                        \n                                            Type :     string\n\n                                        \n                                    \n\n                                    \n                                        \n                                            Optional\n                                        \n                                    \n\n\n\n\n                        \n                    \n                    \n                        \n                                \n                                    \n                                        \n                                        refresh_token\n                                    \n                                \n                                \n                                    \n                                        refresh_token:     string\n\n                                    \n                                \n\n\n                                    \n                                        \n                                            Type :     string\n\n                                        \n                                    \n\n                                    \n                                        \n                                            Optional\n                                        \n                                    \n\n\n\n\n                        \n                    \n                    \n                        \n                                \n                                    \n                                        \n                                        token_type\n                                    \n                                \n                                \n                                    \n                                        token_type:     string\n\n                                    \n                                \n\n\n                                    \n                                        \n                                            Type :     string\n\n                                        \n                                    \n\n                                    \n                                        \n                                            Optional\n                                        \n                                    \n\n\n\n\n                        \n                    \n            \n    \n\n\n    \n        export interface Credentials {\n  refresh_token?: string|null;\n  expiry_date?: number|null;\n  access_token?: string|null;\n  token_type?: string|null;\n  id_token?: string|null;\n}\n\nexport interface CredentialRequest {\n  refresh_token?: string;\n  access_token?: string;\n  token_type?: string;\n  expires_in?: number;\n  id_token?: string;\n}\n\nexport interface JWTInput {\n  type?: string;\n  client_email?: string;\n  private_key?: string;\n  private_key_id?: string;\n  project_id?: string;\n  client_id?: string;\n  client_secret?: string;\n  refresh_token?: string;\n}\n\nexport interface CredentialBody {\n  client_email?: string;\n  private_key?: string;\n}\n\n    \n\n\n\n\n\n\n\n                   \n    \n         result-matching \"\"\n        \n    \n    \n        No results matching \"\"\n    \n\n"},"interfaces/Credentials.html":{"url":"interfaces/Credentials.html","title":"interface - Credentials","body":"\n                   \n\n\n\n\n\n\n\n\n\n\n\n\n\n  Interfaces\n  Credentials\n\n\n\n        \n            Info\n        \n        \n            Source\n        \n\n\n\n    \n        \n            File\n        \n        \n            src/auth/credentials.ts\n        \n\n            \n                Description\n            \n            \n                Copyright 2014 Google Inc. All Rights Reserved.\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n  http://www.apache.org/licenses/LICENSE-2.0Unless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n\n            \n\n\n        \n            Index\n            \n                \n                    \n                        \n                            Properties\n                        \n                    \n                    \n                        \n                            \n                                \n                                            Optional\n                                        access_token\n                                \n                                \n                                            Optional\n                                        expiry_date\n                                \n                                \n                                            Optional\n                                        id_token\n                                \n                                \n                                            Optional\n                                        refresh_token\n                                \n                                \n                                            Optional\n                                        token_type\n                                \n                            \n                        \n                    \n                \n            \n        \n\n\n\n            \n                Properties\n                    \n                        \n                                \n                                    \n                                        \n                                        access_token\n                                    \n                                \n                                \n                                    \n                                        access_token:     string | null\n\n                                    \n                                \n\n\n                                    \n                                        \n                                            Type :     string | null\n\n                                        \n                                    \n\n                                    \n                                        \n                                            Optional\n                                        \n                                    \n\n\n\n\n                        \n                    \n                    \n                        \n                                \n                                    \n                                        \n                                        expiry_date\n                                    \n                                \n                                \n                                    \n                                        expiry_date:     number | null\n\n                                    \n                                \n\n\n                                    \n                                        \n                                            Type :     number | null\n\n                                        \n                                    \n\n                                    \n                                        \n                                            Optional\n                                        \n                                    \n\n\n\n\n                        \n                    \n                    \n                        \n                                \n                                    \n                                        \n                                        id_token\n                                    \n                                \n                                \n                                    \n                                        id_token:     string | null\n\n                                    \n                                \n\n\n                                    \n                                        \n                                            Type :     string | null\n\n                                        \n                                    \n\n                                    \n                                        \n                                            Optional\n                                        \n                                    \n\n\n\n\n                        \n                    \n                    \n                        \n                                \n                                    \n                                        \n                                        refresh_token\n                                    \n                                \n                                \n                                    \n                                        refresh_token:     string | null\n\n                                    \n                                \n\n\n                                    \n                                        \n                                            Type :     string | null\n\n                                        \n                                    \n\n                                    \n                                        \n                                            Optional\n                                        \n                                    \n\n\n\n\n                        \n                    \n                    \n                        \n                                \n                                    \n                                        \n                                        token_type\n                                    \n                                \n                                \n                                    \n                                        token_type:     string | null\n\n                                    \n                                \n\n\n                                    \n                                        \n                                            Type :     string | null\n\n                                        \n                                    \n\n                                    \n                                        \n                                            Optional\n                                        \n                                    \n\n\n\n\n                        \n                    \n            \n    \n\n\n    \n        export interface Credentials {\n  refresh_token?: string|null;\n  expiry_date?: number|null;\n  access_token?: string|null;\n  token_type?: string|null;\n  id_token?: string|null;\n}\n\nexport interface CredentialRequest {\n  refresh_token?: string;\n  access_token?: string;\n  token_type?: string;\n  expires_in?: number;\n  id_token?: string;\n}\n\nexport interface JWTInput {\n  type?: string;\n  client_email?: string;\n  private_key?: string;\n  private_key_id?: string;\n  project_id?: string;\n  client_id?: string;\n  client_secret?: string;\n  refresh_token?: string;\n}\n\nexport interface CredentialBody {\n  client_email?: string;\n  private_key?: string;\n}\n\n    \n\n\n\n\n\n\n\n                   \n    \n         result-matching \"\"\n        \n    \n    \n        No results matching \"\"\n    \n\n"},"classes/DefaultTransporter.html":{"url":"classes/DefaultTransporter.html","title":"class - DefaultTransporter","body":"\n                   \n\n\n\n\n\n\n\n\n\n\n\n\n  Classes\n  DefaultTransporter\n\n\n\n        \n            Info\n        \n        \n            Source\n        \n\n\n\n    \n        \n            File\n        \n        \n            src/transporters.ts\n        \n\n\n\n\n\n            \n    Index\n    \n        \n                \n                    \n                        Properties\n                    \n                \n                \n                    \n                        \n                            \n                                    Static\n                                    Readonly\n                                USER_AGENT\n                            \n                        \n                    \n                \n\n                \n                    \n                        Methods\n                    \n                \n                \n                    \n                        \n                            \n                                configure\n                            \n                            \n                                request\n                            \n                            \n                                request\n                            \n                            \n                                request\n                            \n                        \n                    \n                \n\n\n\n\n\n        \n    \n\n\n\n            \n    \n        \n            Properties\n        \n        \n            \n                \n                    \n                        \n                        \n                            \n                                Static\n                                Readonly\n                            USER_AGENT\n                            \n                            \n                        \n                    \n                \n                \n                    \n                        USER_AGENT:     \n\n                    \n                \n                    \n                        \n                            Default value : `${PRODUCT_NAME}/${pkg.version}`\n                        \n                    \n                        \n                            \n                                    Defined in src/transporters.ts:57\n                            \n                        \n\n                \n                    \n                        Default user agent.\n\n                    \n                \n\n            \n        \n\n\n            \n    \n        \n            Methods\n        \n        \n            \n                \n                    \n                        \n                        \n                            \n                            configure\n                            \n                            \n                        \n                    \n                \n                \n                    \nconfigure(opts: AxiosRequestConfig)\n                    \n                \n\n\n                        \n                            \n                                    Defined in src/transporters.ts:64\n                            \n                        \n\n\n                \n                    \n                            Configures request options before making a request.\n\n\n                            \n                                    Parameters :\n                                    \n                                        \n                                            \n                                                Name\n                                                    Type\n                                                Optional\n                                                    Default value\n                                                    Description\n                                            \n                                        \n                                        \n                                                \n                                                        opts\n                                                        \n                                                                    AxiosRequestConfig\n                                                        \n                                                    \n                                                    \n                                                            No\n                                                    \n                                                    \n                                                        \n                                                                {}\n                                                        \n\n                                                        \n                                                                AxiosRequestConfig options.\n\n                                                        \n                                                \n                                        \n                                    \n                            \n                            \n                            \n                            \n                                Returns :     AxiosRequestConfig\n\n                            \n                                \n                                    Configured options.\n\n                                \n                    \n                \n            \n        \n        \n            \n                \n                    \n                        \n                        \n                            \n                            request\n                            \n                            \n                        \n                    \n                \n                \n                    \nrequest(opts: AxiosRequestConfig)\n                    \n                \n\n\n                        \n                            \n                                    Defined in src/transporters.ts:83\n                            \n                        \n\n                        \n                            \n                                Type parameters :\n                                \n                                        T\n                                \n                            \n                        \n\n                \n                    \n                            Makes a request using Axios with given options.\n\n\n                            \n                                    Parameters :\n                                    \n                                        \n                                            \n                                                Name\n                                                    Type\n                                                Optional\n                                                    Description\n                                            \n                                        \n                                        \n                                                \n                                                        opts\n                                                        \n                                                                    AxiosRequestConfig\n                                                        \n                                                    \n                                                    \n                                                            No\n                                                    \n                                                    \n\n                                                        \n                                                                AxiosRequestConfig options.\n\n                                                        \n                                                \n                                        \n                                    \n                            \n                            \n                            \n                            \n                                Returns :     AxiosPromise\n\n                            \n                                \n                                    AxiosPromise, assuming no callback is passed.\n\n                                \n                    \n                \n            \n        \n        \n            \n                \n                    \n                        \n                        \n                            \n                            request\n                            \n                            \n                        \n                    \n                \n                \n                    \nrequest(opts: AxiosRequestConfig, callback?: BodyResponseCallback)\n                    \n                \n\n\n                        \n                            \n                                    Defined in src/transporters.ts:84\n                            \n                        \n\n                        \n                            \n                                Type parameters :\n                                \n                                        T\n                                \n                            \n                        \n\n                \n                    \n\n                            \n                                    Parameters :\n                                    \n                                        \n                                            \n                                                Name\n                                                    Type\n                                                Optional\n                                            \n                                        \n                                        \n                                                \n                                                        opts\n                                                        \n                                                                    AxiosRequestConfig\n                                                        \n                                                    \n                                                    \n                                                            No\n                                                    \n                                                    \n\n                                                \n                                                \n                                                        callback\n                                                        \n                                                                    BodyResponseCallback\n                                                        \n                                                    \n                                                    \n                                                            Yes\n                                                    \n                                                    \n\n                                                \n                                        \n                                    \n                            \n                            \n                            \n                            \n                                Returns :     void\n\n                            \n                                \n                                    \n                                \n                    \n                \n            \n        \n        \n            \n                \n                    \n                        \n                        \n                            \n                            request\n                            \n                            \n                        \n                    \n                \n                \n                    \nrequest(opts: AxiosRequestConfig, callback?: BodyResponseCallback)\n                    \n                \n\n\n                        \n                            \n                                    Defined in src/transporters.ts:86\n                            \n                        \n\n                        \n                            \n                                Type parameters :\n                                \n                                        T\n                                \n                            \n                        \n\n                \n                    \n\n                            \n                                    Parameters :\n                                    \n                                        \n                                            \n                                                Name\n                                                    Type\n                                                Optional\n                                            \n                                        \n                                        \n                                                \n                                                        opts\n                                                        \n                                                                    AxiosRequestConfig\n                                                        \n                                                    \n                                                    \n                                                            No\n                                                    \n                                                    \n\n                                                \n                                                \n                                                        callback\n                                                        \n                                                                    BodyResponseCallback\n                                                        \n                                                    \n                                                    \n                                                            Yes\n                                                    \n                                                    \n\n                                                \n                                        \n                                    \n                            \n                            \n                            \n                            \n                                Returns :     AxiosPromise | void\n\n                            \n                                \n                                    \n                                \n                    \n                \n            \n        \n\n\n\n\n\n\n\n    \n\n\n    \n        import axios, {AxiosError, AxiosPromise, AxiosRequestConfig, AxiosResponse} from 'axios';\nimport {validate} from './options';\n\n// tslint:disable-next-line variable-name\nconst HttpsProxyAgent = require('https-proxy-agent');\n\n// tslint:disable-next-line no-var-requires\nconst pkg = require('../../package.json');\nconst PRODUCT_NAME = 'google-api-nodejs-client';\n\nexport interface Transporter {\n  request(opts: AxiosRequestConfig): AxiosPromise;\n  request(opts: AxiosRequestConfig, callback?: BodyResponseCallback):\n      void;\n  request(opts: AxiosRequestConfig, callback?: BodyResponseCallback):\n      AxiosPromise|void;\n}\n\nexport interface BodyResponseCallback {\n  // The `body` object is a truly dynamic type.  It must be `any`.\n  (err: Error|null, res?: AxiosResponse|null): void;\n}\n\nexport interface RequestError extends AxiosError {\n  errors: Error[];\n}\n\n/**\n * Axios will use XHR if it is available. In the case of Electron,\n * since XHR is there it will try to use that. This leads to OPTIONS\n * preflight requests which googleapis DOES NOT like. This line of\n * code pins the adapter to ensure it uses node.\n * https://github.com/google/google-api-nodejs-client/issues/1083\n */\naxios.defaults.adapter = require('axios/lib/adapters/http');\n\nexport class DefaultTransporter {\n  /**\n   * Default user agent.\n   */\n  static readonly USER_AGENT = `${PRODUCT_NAME}/${pkg.version}`;\n\n  /**\n   * Configures request options before making a request.\n   * @param opts AxiosRequestConfig options.\n   * @return Configured options.\n   */\n  configure(opts: AxiosRequestConfig = {}): AxiosRequestConfig {\n    // set transporter user agent\n    opts.headers = opts.headers || {};\n    const uaValue: string = opts.headers['User-Agent'];\n    if (!uaValue) {\n      opts.headers['User-Agent'] = DefaultTransporter.USER_AGENT;\n    } else if (!uaValue.includes(`${PRODUCT_NAME}/`)) {\n      opts.headers['User-Agent'] =\n          `${uaValue} ${DefaultTransporter.USER_AGENT}`;\n    }\n    return opts;\n  }\n\n  /**\n   * Makes a request using Axios with given options.\n   * @param opts AxiosRequestConfig options.\n   * @param callback optional callback that contains AxiosResponse object.\n   * @return AxiosPromise, assuming no callback is passed.\n   */\n  request(opts: AxiosRequestConfig): AxiosPromise;\n  request(opts: AxiosRequestConfig, callback?: BodyResponseCallback):\n      void;\n  request(opts: AxiosRequestConfig, callback?: BodyResponseCallback):\n      AxiosPromise|void {\n    // ensure the user isn't passing in request-style options\n    opts = this.configure(opts);\n    try {\n      validate(opts);\n    } catch (e) {\n      if (callback) {\n        return callback(e);\n      } else {\n        throw e;\n      }\n    }\n\n    // If the user configured an `HTTPS_PROXY` environment variable, create\n    // a custom agent to proxy the request.\n    const proxy = process.env.HTTPS_PROXY || process.env.https_proxy;\n    if (proxy) {\n      opts.httpsAgent = new HttpsProxyAgent(proxy);\n      opts.proxy = false;\n    }\n\n    if (callback) {\n      axios(opts).then(\n          r => {\n            callback(null, r);\n          },\n          e => {\n            callback(this.processError(e));\n          });\n    } else {\n      return axios(opts).catch(e => {\n        throw this.processError(e);\n      });\n    }\n  }\n\n  /**\n   * Changes the error to include details from the body.\n   */\n  private processError(e: AxiosError): RequestError {\n    const res = e.response;\n    const err = e as RequestError;\n    const body = res ? res.data : null;\n    if (res && body && body.error && res.status !== 200) {\n      if (typeof body.error === 'string') {\n        err.message = body.error;\n        err.code = res.status.toString();\n      } else if (Array.isArray(body.error.errors)) {\n        err.message =\n            body.error.errors.map((err2: Error) => err2.message).join('\\n');\n        err.code = body.error.code;\n        err.errors = body.error.errors;\n      } else {\n        err.message = body.error.message;\n        err.code = body.error.code || res.status;\n      }\n    } else if (res && res.status >= 400) {\n      // Consider all 4xx and 5xx responses errors.\n      err.message = body;\n      err.code = res.status.toString();\n    }\n    return err;\n  }\n}\n\n    \n\n\n\n\n\n\n\n\n                   \n    \n         result-matching \"\"\n        \n    \n    \n        No results matching \"\"\n    \n\n"},"interfaces/FederatedSignonCertsResponse.html":{"url":"interfaces/FederatedSignonCertsResponse.html","title":"interface - FederatedSignonCertsResponse","body":"\n                   \n\n\n\n\n\n\n\n\n\n\n\n\n\n  Interfaces\n  FederatedSignonCertsResponse\n\n\n\n        \n            Info\n        \n        \n            Source\n        \n\n\n\n    \n        \n            File\n        \n        \n            src/auth/oauth2client.ts\n        \n\n\n\n        \n            Index\n            \n                \n                    \n                        \n                            Properties\n                        \n                    \n                    \n                        \n                            \n                                \n                                        certs\n                                \n                                \n                                            Optional\n                                        res\n                                \n                            \n                        \n                    \n                \n            \n        \n\n\n\n            \n                Properties\n                    \n                        \n                                \n                                    \n                                        \n                                        certs\n                                    \n                                \n                                \n                                    \n                                        certs:     Certificates\n\n                                    \n                                \n\n\n                                    \n                                        \n                                            Type :     Certificates\n\n                                        \n                                    \n\n\n\n\n\n                        \n                    \n                    \n                        \n                                \n                                    \n                                        \n                                        res\n                                    \n                                \n                                \n                                    \n                                        res:     AxiosResponse | null\n\n                                    \n                                \n\n\n                                    \n                                        \n                                            Type :     AxiosResponse | null\n\n                                        \n                                    \n\n                                    \n                                        \n                                            Optional\n                                        \n                                    \n\n\n\n\n                        \n                    \n            \n    \n\n\n    \n        import {AxiosError, AxiosPromise, AxiosRequestConfig, AxiosResponse} from 'axios';\nimport * as crypto from 'crypto';\nimport * as querystring from 'querystring';\nimport * as stream from 'stream';\nimport * as messages from '../messages';\nimport {PemVerifier} from './../pemverifier';\nimport {BodyResponseCallback} from './../transporters';\nimport {AuthClient} from './authclient';\nimport {CredentialRequest, Credentials} from './credentials';\nimport {LoginTicket, TokenPayload} from './loginticket';\n\nexport type Certificates = {\n  [index: string]: string\n};\n\nexport type Headers = {\n  [index: string]: string\n};\n\nexport enum CodeChallengeMethod {\n  Plain = 'plain',\n  S256 = 'S256'\n}\n\nexport interface GetTokenOptions {\n  code: string;\n  codeVerifier?: string;\n  /**\n   * The client ID for your application. The value passed into the constructor\n   * will be used if not provided. Must match any client_id option passed to\n   * a corresponding call to generateAuthUrl.\n   */\n  client_id?: string;\n  /**\n   * Determines where the API server redirects the user after the user\n   * completes the authorization flow. The value passed into the constructor\n   * will be used if not provided. Must match any redirect_uri option passed to\n   * a corresponding call to generateAuthUrl.\n   */\n  redirect_uri?: string;\n}\n\nexport interface TokenInfo {\n  /**\n   * The application that is the intended user of the access token.\n   */\n  aud: string;\n\n  /**\n   * This value lets you correlate profile information from multiple Google\n   * APIs. It is only present in the response if you included the profile scope\n   * in your request in step 1. The field value is an immutable identifier for\n   * the logged-in user that can be used to create and manage user sessions in\n   * your application. The identifier is the same regardless of which client ID\n   * is used to retrieve it. This enables multiple applications in the same\n   * organization to correlate profile information.\n   */\n  user_id?: string;\n\n  /**\n   * An array of scopes that the user granted access to.\n   */\n  scopes: string[];\n\n  /**\n   * The datetime when the token becomes invalid.\n   */\n  expiry_date: number;\n\n  /**\n   * An identifier for the user, unique among all Google accounts and never\n   * reused. A Google account can have multiple emails at different points in\n   * time, but the sub value is never changed. Use sub within your application\n   * as the unique-identifier key for the user.\n   */\n  sub?: string;\n\n  /**\n   * The client_id of the authorized presenter. This claim is only needed when\n   * the party requesting the ID token is not the same as the audience of the ID\n   * token. This may be the case at Google for hybrid apps where a web\n   * application and Android app have a different client_id but share the same\n   * project.\n   */\n  azp?: string;\n\n  /**\n   * Indicates whether your application can refresh access tokens\n   * when the user is not present at the browser. Valid parameter values are\n   * 'online', which is the default value, and 'offline'. Set the value to\n   * 'offline' if your application needs to refresh access tokens when the user\n   * is not present at the browser. This value instructs the Google\n   * authorization server to return a refresh token and an access token the\n   * first time that your application exchanges an authorization code for\n   * tokens.\n   */\n  access_type?: string;\n}\n\ninterface TokenInfoRequest {\n  aud: string;\n  user_id?: string;\n  scope: string;\n  expires_in: number;\n  azp?: string;\n  sub?: string;\n  exp?: number;\n  access_type?: string;\n}\n\nexport interface GenerateAuthUrlOpts {\n  /**\n   * Recommended. Indicates whether your application can refresh access tokens\n   * when the user is not present at the browser. Valid parameter values are\n   * 'online', which is the default value, and 'offline'. Set the value to\n   * 'offline' if your application needs to refresh access tokens when the user\n   * is not present at the browser. This value instructs the Google\n   * authorization server to return a refresh token and an access token the\n   * first time that your application exchanges an authorization code for\n   * tokens.\n   */\n  access_type?: string;\n\n  /**\n   * The hd (hosted domain) parameter streamlines the login process for G Suite\n   * hosted accounts. By including the domain of the G Suite user (for example,\n   * mycollege.edu), you can indicate that the account selection UI should be\n   * optimized for accounts at that domain. To optimize for G Suite accounts\n   * generally instead of just one domain, use an asterisk: hd=*.\n   * Don't rely on this UI optimization to control who can access your app,\n   * as client-side requests can be modified. Be sure to validate that the\n   * returned ID token has an hd claim value that matches what you expect\n   * (e.g. mycolledge.edu). Unlike the request parameter, the ID token claim is\n   * contained within a security token from Google, so the value can be trusted.\n   */\n  hd?: string;\n\n  /**\n   * The 'response_type' will always be set to 'CODE'.\n   */\n  response_type?: string;\n\n  /**\n   * The client ID for your application. The value passed into the constructor\n   * will be used if not provided. You can find this value in the API Console.\n   */\n  client_id?: string;\n\n  /**\n   * Determines where the API server redirects the user after the user\n   * completes the authorization flow. The value must exactly match one of the\n   * 'redirect_uri' values listed for your project in the API Console. Note that\n   * the http or https scheme, case, and trailing slash ('/') must all match.\n   * The value passed into the constructor will be used if not provided.\n   */\n  redirect_uri?: string;\n\n  /**\n   * Required. A space-delimited list of scopes that identify the resources that\n   * your application could access on the user's behalf. These values inform the\n   * consent screen that Google displays to the user. Scopes enable your\n   * application to only request access to the resources that it needs while\n   * also enabling users to control the amount of access that they grant to your\n   * application. Thus, there is an inverse relationship between the number of\n   * scopes requested and the likelihood of obtaining user consent. The\n   * OAuth 2.0 API Scopes document provides a full list of scopes that you might\n   * use to access Google APIs. We recommend that your application request\n   * access to authorization scopes in context whenever possible. By requesting\n   * access to user data in context, via incremental authorization, you help\n   * users to more easily understand why your application needs the access it is\n   * requesting.\n   */\n  scope?: string[]|string;\n\n  /**\n   * Recommended. Specifies any string value that your application uses to\n   * maintain state between your authorization request and the authorization\n   * server's response. The server returns the exact value that you send as a\n   * name=value pair in the hash (#) fragment of the 'redirect_uri' after the\n   * user consents to or denies your application's access request. You can use\n   * this parameter for several purposes, such as directing the user to the\n   * correct resource in your application, sending nonces, and mitigating\n   * cross-site request forgery. Since your redirect_uri can be guessed, using a\n   * state value can increase your assurance that an incoming connection is the\n   * result of an authentication request. If you generate a random string or\n   * encode the hash of a cookie or another value that captures the client's\n   * state, you can validate the response to additionally ensure that the\n   * request and response originated in the same browser, providing protection\n   * against attacks such as cross-site request forgery. See the OpenID Connect\n   * documentation for an example of how to create and confirm a state token.\n   */\n  state?: string;\n\n  /**\n   * Optional. Enables applications to use incremental authorization to request\n   * access to additional scopes in context. If you set this parameter's value\n   * to true and the authorization request is granted, then the new access token\n   * will also cover any scopes to which the user previously granted the\n   * application access. See the incremental authorization section for examples.\n   */\n  include_granted_scopes?: boolean;\n\n  /**\n   * Optional. If your application knows which user is trying to authenticate,\n   * it can use this parameter to provide a hint to the Google Authentication\n   * Server. The server uses the hint to simplify the login flow either by\n   * prefilling the email field in the sign-in form or by selecting the\n   * appropriate multi-login session. Set the parameter value to an email\n   * address or sub identifier, which is equivalent to the user's Google ID.\n   */\n  login_hint?: string;\n\n  /**\n   * Optional. A space-delimited, case-sensitive list of prompts to present the\n   * user. If you don't specify this parameter, the user will be prompted only\n   * the first time your app requests access.  Possible values are:\n   *\n   * 'none' - Donot display any authentication or consent screens. Must not be\n   *        specified with other values.\n   * 'consent' - \tPrompt the user for consent.\n   * 'select_account' - Prompt the user to select an account.\n   */\n  prompt?: string;\n\n  /**\n   * Recommended. Specifies what method was used to encode a 'code_verifier'\n   * that will be used during authorization code exchange. This parameter must\n   * be used with the 'code_challenge' parameter. The value of the\n   * 'code_challenge_method' defaults to \"plain\" if not present in the request\n   * that includes a 'code_challenge'. The only supported values for this\n   * parameter are \"S256\" or \"plain\".\n   */\n  code_challenge_method?: CodeChallengeMethod;\n\n  /**\n   * Recommended. Specifies an encoded 'code_verifier' that will be used as a\n   * server-side challenge during authorization code exchange. This parameter\n   * must be used with the 'code_challenge' parameter described above.\n   */\n  code_challenge?: string;\n}\n\nexport interface GetTokenCallback {\n  (err: AxiosError|null, token?: Credentials|null,\n   res?: AxiosResponse|null): void;\n}\n\nexport interface GetTokenResponse {\n  tokens: Credentials;\n  res: AxiosResponse|null;\n}\n\nexport interface GetAccessTokenCallback {\n  (err: AxiosError|null, token?: string|null, res?: AxiosResponse|null): void;\n}\n\nexport interface GetAccessTokenResponse {\n  token?: string|null;\n  res?: AxiosResponse|null;\n}\n\nexport interface RefreshAccessTokenCallback {\n  (err: AxiosError|null, credentials?: Credentials|null,\n   res?: AxiosResponse|null): void;\n}\n\nexport interface RefreshAccessTokenResponse {\n  credentials: Credentials;\n  res: AxiosResponse|null;\n}\n\nexport interface RequestMetadataResponse {\n  headers: Headers;\n  res?: AxiosResponse|null;\n}\n\nexport interface RequestMetadataCallback {\n  (err: AxiosError|null, headers?: Headers,\n   res?: AxiosResponse|null): void;\n}\n\nexport interface GetFederatedSignonCertsCallback {\n  (err: AxiosError|null, certs?: Certificates,\n   response?: AxiosResponse|null): void;\n}\n\nexport interface FederatedSignonCertsResponse {\n  certs: Certificates;\n  res?: AxiosResponse|null;\n}\n\nexport interface RevokeCredentialsResult {\n  success: boolean;\n}\n\nexport interface VerifyIdTokenOptions {\n  idToken: string;\n  audience: string|string[];\n  maxExpiry?: number;\n}\n\nexport interface OAuth2ClientOptions extends RefreshOptions {\n  clientId?: string;\n  clientSecret?: string;\n  redirectUri?: string;\n}\n\nexport interface RefreshOptions {\n  // Eagerly refresh unexpired tokens when they are within this many\n  // milliseconds from expiring\".\n  // Defaults to a value of 300000 (5 minutes).\n  eagerRefreshThresholdMillis?: number;\n}\n\nexport class OAuth2Client extends AuthClient {\n  private redirectUri?: string;\n  private certificateCache?: Certificates;\n  private certificateExpiry: Date|null = null;\n  protected refreshTokenPromises = new Map>();\n\n  // TODO: refactor tests to make this private\n  _clientId?: string;\n\n  // TODO: refactor tests to make this private\n  _clientSecret?: string;\n\n  apiKey?: string;\n\n  projectId?: string;\n\n  eagerRefreshThresholdMillis: number;\n\n  /**\n   * Handles OAuth2 flow for Google APIs.\n   *\n   * @param clientId The authentication client ID.\n   * @param clientSecret The authentication client secret.\n   * @param redirectUri The URI to redirect to after completing the auth\n   * request.\n   * @param opts optional options for overriding the given parameters.\n   * @constructor\n   */\n  constructor(options?: OAuth2ClientOptions);\n  constructor(clientId?: string, clientSecret?: string, redirectUri?: string);\n  constructor(\n      optionsOrClientId?: string|OAuth2ClientOptions, clientSecret?: string,\n      redirectUri?: string) {\n    super();\n    const opts = (optionsOrClientId && typeof optionsOrClientId === 'object') ?\n        optionsOrClientId :\n        {clientId: optionsOrClientId, clientSecret, redirectUri};\n    this._clientId = opts.clientId;\n    this._clientSecret = opts.clientSecret;\n    this.redirectUri = opts.redirectUri;\n    this.eagerRefreshThresholdMillis =\n        opts.eagerRefreshThresholdMillis || 5 * 60 * 1000;\n  }\n\n  protected static readonly GOOGLE_TOKEN_INFO_URL =\n      'https://oauth2.googleapis.com/tokeninfo';\n\n  /**\n   * The base URL for auth endpoints.\n   */\n  private static readonly GOOGLE_OAUTH2_AUTH_BASE_URL_ =\n      'https://accounts.google.com/o/oauth2/v2/auth';\n\n  /**\n   * The base endpoint for token retrieval.\n   */\n  private static readonly GOOGLE_OAUTH2_TOKEN_URL_ =\n      'https://oauth2.googleapis.com/token';\n\n  /**\n   * The base endpoint to revoke tokens.\n   */\n  private static readonly GOOGLE_OAUTH2_REVOKE_URL_ =\n      'https://oauth2.googleapis.com/revoke';\n\n  /**\n   * Google Sign on certificates.\n   */\n  private static readonly GOOGLE_OAUTH2_FEDERATED_SIGNON_CERTS_URL_ =\n      'https://www.googleapis.com/oauth2/v1/certs';\n\n  /**\n   * Clock skew - five minutes in seconds\n   */\n  private static readonly CLOCK_SKEW_SECS_ = 300;\n\n  /**\n   * Max Token Lifetime is one day in seconds\n   */\n  private static readonly MAX_TOKEN_LIFETIME_SECS_ = 86400;\n\n  /**\n   * The allowed oauth token issuers.\n   */\n  private static readonly ISSUERS_ =\n      ['accounts.google.com', 'https://accounts.google.com'];\n\n  /**\n   * Generates URL for consent page landing.\n   * @param opts Options.\n   * @return URL to consent page.\n   */\n  generateAuthUrl(opts: GenerateAuthUrlOpts = {}) {\n    if (opts.code_challenge_method && !opts.code_challenge) {\n      throw new Error(\n          'If a code_challenge_method is provided, code_challenge must be included.');\n    }\n    opts.response_type = opts.response_type || 'code';\n    opts.client_id = opts.client_id || this._clientId;\n    opts.redirect_uri = opts.redirect_uri || this.redirectUri;\n    // Allow scopes to be passed either as array or a string\n    if (opts.scope instanceof Array) {\n      opts.scope = opts.scope.join(' ');\n    }\n    const rootUrl = OAuth2Client.GOOGLE_OAUTH2_AUTH_BASE_URL_;\n    return rootUrl + '?' + querystring.stringify(opts);\n  }\n\n  /**\n   * Convenience method to automatically generate a code_verifier, and it's\n   * resulting SHA256. If used, this must be paired with a S256\n   * code_challenge_method.\n   */\n  generateCodeVerifier() {\n    // base64 encoding uses 6 bits per character, and we want to generate128\n    // characters. 6*128/8 = 96.\n    const randomString = crypto.randomBytes(96).toString('base64');\n    // The valid characters in the code_verifier are [A-Z]/[a-z]/[0-9]/\n    // \"-\"/\".\"/\"_\"/\"~\". Base64 encoded strings are pretty close, so we're just\n    // swapping out a few chars.\n    const codeVerifier =\n        randomString.replace(/\\+/g, '~').replace(/=/g, '_').replace(/\\//g, '-');\n    // Generate the base64 encoded SHA256\n    const unencodedCodeChallenge =\n        crypto.createHash('sha256').update(codeVerifier).digest('base64');\n    // We need to use base64UrlEncoding instead of standard base64\n    const codeChallenge = unencodedCodeChallenge.split('=')[0]\n                              .replace(/\\+/g, '-')\n                              .replace(/\\//g, '_');\n    return {codeVerifier, codeChallenge};\n  }\n\n  /**\n   * Gets the access token for the given code.\n   * @param code The authorization code.\n   * @param callback Optional callback fn.\n   */\n  getToken(code: string): Promise;\n  getToken(options: GetTokenOptions): Promise;\n  getToken(code: string, callback: GetTokenCallback): void;\n  getToken(options: GetTokenOptions, callback: GetTokenCallback): void;\n  getToken(codeOrOptions: string|GetTokenOptions, callback?: GetTokenCallback):\n      Promise|void {\n    const options = (typeof codeOrOptions === 'string') ?\n        {code: codeOrOptions} :\n        codeOrOptions;\n    if (callback) {\n      this.getTokenAsync(options).then(\n          r => callback(null, r.tokens, r.res),\n          e => callback(e, null, e.response));\n    } else {\n      return this.getTokenAsync(options);\n    }\n  }\n\n  private async getTokenAsync(options: GetTokenOptions):\n      Promise {\n    const url = OAuth2Client.GOOGLE_OAUTH2_TOKEN_URL_;\n    const values = {\n      code: options.code,\n      client_id: options.client_id || this._clientId,\n      client_secret: this._clientSecret,\n      redirect_uri: options.redirect_uri || this.redirectUri,\n      grant_type: 'authorization_code',\n      code_verifier: options.codeVerifier\n    };\n    const res = await this.transporter.request({\n      method: 'POST',\n      url,\n      data: querystring.stringify(values),\n      headers: {'Content-Type': 'application/x-www-form-urlencoded'}\n    });\n    const tokens = res.data as Credentials;\n    if (res.data && res.data.expires_in) {\n      tokens.expiry_date =\n          ((new Date()).getTime() + (res.data.expires_in * 1000));\n      delete (tokens as CredentialRequest).expires_in;\n    }\n    this.emit('tokens', tokens);\n    return {tokens, res};\n  }\n\n  /**\n   * Refreshes the access token.\n   * @param refresh_token Existing refresh token.\n   * @private\n   */\n  protected async refreshToken(refreshToken?: string|\n                               null): Promise {\n    if (!refreshToken) {\n      return this.refreshTokenNoCache(refreshToken);\n    }\n    // If a request to refresh using the same token has started,\n    // return the same promise.\n    if (this.refreshTokenPromises.has(refreshToken)) {\n      return this.refreshTokenPromises.get(refreshToken)!;\n    }\n\n    const p = this.refreshTokenNoCache(refreshToken)\n                  .then(\n                      r => {\n                        this.refreshTokenPromises.delete(refreshToken);\n                        return r;\n                      },\n                      e => {\n                        this.refreshTokenPromises.delete(refreshToken);\n                        throw e;\n                      });\n    this.refreshTokenPromises.set(refreshToken, p);\n    return p;\n  }\n\n  protected async refreshTokenNoCache(refreshToken?: string|\n                                      null): Promise {\n    const url = OAuth2Client.GOOGLE_OAUTH2_TOKEN_URL_;\n    const data = {\n      refresh_token: refreshToken,\n      client_id: this._clientId,\n      client_secret: this._clientSecret,\n      grant_type: 'refresh_token'\n    };\n\n    // request for new token\n    const res = await this.transporter.request({\n      method: 'POST',\n      url,\n      data: querystring.stringify(data),\n      headers: {'Content-Type': 'application/x-www-form-urlencoded'}\n    });\n\n    const tokens = res.data as Credentials;\n    // TODO: de-duplicate this code from a few spots\n    if (res.data && res.data.expires_in) {\n      tokens.expiry_date =\n          ((new Date()).getTime() + (res.data.expires_in * 1000));\n      delete (tokens as CredentialRequest).expires_in;\n    }\n    this.emit('tokens', tokens);\n    return {tokens, res};\n  }\n\n  /**\n   * Retrieves the access token using refresh token\n   *\n   * @deprecated use getRequestHeaders instead.\n   * @param callback callback\n   */\n  refreshAccessToken(): Promise;\n  refreshAccessToken(callback: RefreshAccessTokenCallback): void;\n  refreshAccessToken(callback?: RefreshAccessTokenCallback):\n      Promise|void {\n    messages.warn(messages.REFRESH_ACCESS_TOKEN_DEPRECATED);\n    if (callback) {\n      this.refreshAccessTokenAsync().then(\n          r => callback(null, r.credentials, r.res), callback);\n    } else {\n      return this.refreshAccessTokenAsync();\n    }\n  }\n\n  private async refreshAccessTokenAsync() {\n    if (!this.credentials.refresh_token) {\n      throw new Error('No refresh token is set.');\n    }\n    const r = await this.refreshToken(this.credentials.refresh_token);\n    const tokens = r.tokens as Credentials;\n    tokens.refresh_token = this.credentials.refresh_token;\n    this.credentials = tokens;\n    return {credentials: this.credentials, res: r.res};\n  }\n\n  /**\n   * Get a non-expired access token, after refreshing if necessary\n   *\n   * @param callback Callback to call with the access token\n   */\n  getAccessToken(): Promise;\n  getAccessToken(callback: GetAccessTokenCallback): void;\n  getAccessToken(callback?: GetAccessTokenCallback):\n      Promise|void {\n    if (callback) {\n      this.getAccessTokenAsync().then(\n          r => callback(null, r.token, r.res), callback);\n    } else {\n      return this.getAccessTokenAsync();\n    }\n  }\n\n  private async getAccessTokenAsync(): Promise {\n    const shouldRefresh =\n        !this.credentials.access_token || this.isTokenExpiring();\n    if (shouldRefresh && this.credentials.refresh_token) {\n      if (!this.credentials.refresh_token) {\n        throw new Error('No refresh token is set.');\n      }\n\n      const r = await this.refreshAccessTokenAsync();\n      if (!r.credentials || (r.credentials && !r.credentials.access_token)) {\n        throw new Error('Could not refresh access token.');\n      }\n      return {token: r.credentials.access_token, res: r.res};\n    } else {\n      return {token: this.credentials.access_token};\n    }\n  }\n\n  /**\n   * Obtain the set of headers required to authenticate a request.\n   *\n   * @deprecated Use getRequestHeaders instead.\n   * @param url the Uri being authorized\n   * @param callback the func described above\n   */\n  getRequestMetadata(url?: string|null): Promise;\n  getRequestMetadata(url: string|null, callback: RequestMetadataCallback): void;\n  getRequestMetadata(url: string|null, callback?: RequestMetadataCallback):\n      Promise|void {\n    messages.warn(messages.OAUTH_GET_REQUEST_METADATA_DEPRECATED);\n    if (callback) {\n      this.getRequestMetadataAsync(url).then(\n          r => callback(null, r.headers, r.res), callback);\n    } else {\n      return this.getRequestMetadataAsync();\n    }\n  }\n\n  /**\n   * The main authentication interface.  It takes an optional url which when\n   * present is the endpoint being accessed, and returns a Promise which\n   * resolves with authorization header fields.\n   *\n   * In OAuth2Client, the result has the form:\n   * { Authorization: 'Bearer ' }\n   * @param url The optional url being authorized\n   */\n  async getRequestHeaders(url?: string): Promise {\n    const res = await this.getRequestMetadataAsync(url);\n    return res.headers;\n  }\n\n  protected async getRequestMetadataAsync(url?: string|null):\n      Promise {\n    const thisCreds = this.credentials;\n    if (!thisCreds.access_token && !thisCreds.refresh_token && !this.apiKey) {\n      throw new Error('No access, refresh token or API key is set.');\n    }\n\n    if (thisCreds.access_token && !this.isTokenExpiring()) {\n      thisCreds.token_type = thisCreds.token_type || 'Bearer';\n      const headers = {\n        Authorization: thisCreds.token_type + ' ' + thisCreds.access_token\n      };\n      return {headers};\n    }\n\n    if (this.apiKey) {\n      return {headers: {}};\n    }\n    let r: GetTokenResponse|null = null;\n    let tokens: Credentials|null = null;\n    try {\n      r = await this.refreshToken(thisCreds.refresh_token);\n      tokens = r.tokens;\n    } catch (err) {\n      const e = err as AxiosError;\n      if (e.response &&\n          (e.response.status === 403 || e.response.status === 404)) {\n        e.message = 'Could not refresh access token.';\n      }\n      throw e;\n    }\n\n    const credentials = this.credentials;\n    credentials.token_type = credentials.token_type || 'Bearer';\n    tokens.refresh_token = credentials.refresh_token;\n    this.credentials = tokens;\n    const headers = {\n      Authorization: credentials.token_type + ' ' + tokens.access_token\n    };\n    return {headers, res: r.res};\n  }\n\n  /**\n   * Revokes the access given to token.\n   * @param token The existing token to be revoked.\n   * @param callback Optional callback fn.\n   */\n  revokeToken(token: string): AxiosPromise;\n  revokeToken(\n      token: string,\n      callback: BodyResponseCallback): void;\n  revokeToken(\n      token: string, callback?: BodyResponseCallback):\n      AxiosPromise|void {\n    const opts = {\n      url: OAuth2Client.GOOGLE_OAUTH2_REVOKE_URL_ + '?' +\n          querystring.stringify({token}),\n      method: 'POST'\n    };\n    if (callback) {\n      this.transporter.request(opts).then(\n          r => callback(null, r), callback);\n    } else {\n      return this.transporter.request(opts);\n    }\n  }\n\n\n  /**\n   * Revokes access token and clears the credentials object\n   * @param callback callback\n   */\n  revokeCredentials(): AxiosPromise;\n  revokeCredentials(callback: BodyResponseCallback):\n      void;\n  revokeCredentials(callback?: BodyResponseCallback):\n      AxiosPromise|void {\n    if (callback) {\n      this.revokeCredentialsAsync().then(res => callback(null, res), callback);\n    } else {\n      return this.revokeCredentialsAsync();\n    }\n  }\n\n  private async revokeCredentialsAsync() {\n    const token = this.credentials.access_token;\n    this.credentials = {};\n    if (token) {\n      return this.revokeToken(token);\n    } else {\n      throw new Error('No access token to revoke.');\n    }\n  }\n\n  /**\n   * Provides a request implementation with OAuth 2.0 flow. If credentials have\n   * a refresh_token, in cases of HTTP 401 and 403 responses, it automatically\n   * asks for a new access token and replays the unsuccessful request.\n   * @param opts Request options.\n   * @param callback callback.\n   * @return Request object\n   */\n  request(opts: AxiosRequestConfig): AxiosPromise;\n  request(opts: AxiosRequestConfig, callback: BodyResponseCallback): void;\n  request(opts: AxiosRequestConfig, callback?: BodyResponseCallback):\n      AxiosPromise|void {\n    if (callback) {\n      this.requestAsync(opts).then(r => callback(null, r), e => {\n        return callback(e, e.response);\n      });\n    } else {\n      return this.requestAsync(opts);\n    }\n  }\n\n  protected async requestAsync(opts: AxiosRequestConfig, retry = false):\n      Promise> {\n    let r2: AxiosResponse;\n    try {\n      const r = await this.getRequestMetadataAsync(opts.url);\n      if (r.headers && r.headers.Authorization) {\n        opts.headers = opts.headers || {};\n        opts.headers.Authorization = r.headers.Authorization;\n      }\n\n      if (this.apiKey) {\n        opts.params = Object.assign(opts.params || {}, {key: this.apiKey});\n      }\n      r2 = await this.transporter.request(opts);\n    } catch (e) {\n      const res = (e as AxiosError).response;\n      if (res) {\n        const statusCode = res.status;\n        // Retry the request for metadata if the following criteria are true:\n        // - We haven't already retried.  It only makes sense to retry once.\n        // - The response was a 401 or a 403\n        // - The request didn't send a readableStream\n        // - An access_token and refresh_token were available, but no\n        //   expiry_date was availabe. This can happen when developers stash\n        //   the access_token and refresh_token for later use, but the\n        //   access_token fails on the first try because it's expired.\n        const mayRequireRefresh = this.credentials &&\n            this.credentials.access_token && this.credentials.refresh_token &&\n            !this.credentials.expiry_date;\n        const isReadableStream = res.config.data instanceof stream.Readable;\n        const isAuthErr = statusCode === 401 || statusCode === 403;\n        if (!retry && isAuthErr && !isReadableStream && mayRequireRefresh) {\n          await this.refreshAccessTokenAsync();\n          return this.requestAsync(opts, true);\n        }\n      }\n      throw e;\n    }\n    return r2;\n  }\n\n  /**\n   * Verify id token is token by checking the certs and audience\n   * @param options that contains all options.\n   * @param callback Callback supplying GoogleLogin if successful\n   */\n  verifyIdToken(options: VerifyIdTokenOptions): Promise;\n  verifyIdToken(\n      options: VerifyIdTokenOptions,\n      callback: (err: Error|null, login?: LoginTicket) => void): void;\n  verifyIdToken(\n      options: VerifyIdTokenOptions,\n      callback?: (err: Error|null, login?: LoginTicket) => void):\n      void|Promise {\n    // This function used to accept two arguments instead of an options object.\n    // Check the types to help users upgrade with less pain.\n    // This check can be removed after a 2.0 release.\n    if (callback && typeof callback !== 'function') {\n      throw new Error(\n          'This method accepts an options object as the first parameter, which includes the idToken, audience, and maxExpiry.');\n    }\n\n    if (callback) {\n      this.verifyIdTokenAsync(options).then(r => callback(null, r), callback);\n    } else {\n      return this.verifyIdTokenAsync(options);\n    }\n  }\n\n  private async verifyIdTokenAsync(options: VerifyIdTokenOptions):\n      Promise {\n    if (!options.idToken) {\n      throw new Error('The verifyIdToken method requires an ID Token');\n    }\n\n    const response = await this.getFederatedSignonCertsAsync();\n    const login = this.verifySignedJwtWithCerts(\n        options.idToken, response.certs, options.audience,\n        OAuth2Client.ISSUERS_, options.maxExpiry);\n\n    return login;\n  }\n\n  /**\n   * Obtains information about the provisioned access token.  Especially useful\n   * if you want to check the scopes that were provisioned to a given token.\n   *\n   * @param accessToken Required.  The Access Token for which you want to get\n   * user info.\n   */\n  async getTokenInfo(accessToken: string): Promise {\n    const {data} = await this.transporter.request({\n      method: 'GET',\n      url: OAuth2Client.GOOGLE_TOKEN_INFO_URL,\n      params: {access_token: accessToken}\n    });\n    const info = Object.assign(\n        {\n          expiry_date: ((new Date()).getTime() + (data.expires_in * 1000)),\n          scopes: data.scope.split(' ')\n        },\n        data);\n    delete info.expires_in;\n    delete info.scope;\n    return info;\n  }\n\n  /**\n   * Gets federated sign-on certificates to use for verifying identity tokens.\n   * Returns certs as array structure, where keys are key ids, and values\n   * are PEM encoded certificates.\n   * @param callback Callback supplying the certificates\n   */\n  getFederatedSignonCerts(): Promise;\n  getFederatedSignonCerts(callback: GetFederatedSignonCertsCallback): void;\n  getFederatedSignonCerts(callback?: GetFederatedSignonCertsCallback):\n      Promise|void {\n    if (callback) {\n      this.getFederatedSignonCertsAsync().then(\n          r => callback(null, r.certs, r.res), callback);\n    } else {\n      return this.getFederatedSignonCertsAsync();\n    }\n  }\n\n  async getFederatedSignonCertsAsync(): Promise {\n    const nowTime = (new Date()).getTime();\n    if (this.certificateExpiry &&\n        (nowTime = now + maxExpiry) {\n      throw new Error(\n          'Expiration time too far in future: ' + JSON.stringify(payload));\n    }\n\n    const earliest = iat - OAuth2Client.CLOCK_SKEW_SECS_;\n    const latest = exp + OAuth2Client.CLOCK_SKEW_SECS_;\n\n    if (now  latest) {\n      throw new Error(\n          'Token used too late, ' + now + ' > ' + latest + ': ' +\n          JSON.stringify(payload));\n    }\n\n    if (issuers && issuers.indexOf(payload.iss)  -1);\n      } else {\n        audVerified = (aud === requiredAudience);\n      }\n      if (!audVerified) {\n        throw new Error(\n            'Wrong recipient, payload audience != requiredAudience');\n      }\n    }\n    return new LoginTicket(envelope, payload);\n  }\n\n  /**\n   * This is a utils method to decode a base64 string\n   * @param b64String The string to base64 decode\n   * @return The decoded string\n   */\n  decodeBase64(b64String: string) {\n    const buffer = Buffer.from(b64String, 'base64');\n    return buffer.toString('utf8');\n  }\n\n  /**\n   * Returns true if a token is expired or will expire within\n   * eagerRefreshThresholdMillismilliseconds.\n   * If there is no expiry time, assumes the token is not expired or expiring.\n   */\n  protected isTokenExpiring(): boolean {\n    const expiryDate = this.credentials.expiry_date;\n    return expiryDate ? expiryDate \n    \n\n\n\n\n\n\n\n                   \n    \n         result-matching \"\"\n        \n    \n    \n        No results matching \"\"\n    \n\n"},"interfaces/GetAccessTokenCallback.html":{"url":"interfaces/GetAccessTokenCallback.html","title":"interface - GetAccessTokenCallback","body":"\n                   \n\n\n\n\n\n\n\n\n\n\n\n\n\n  Interfaces\n  GetAccessTokenCallback\n\n\n\n        \n            Info\n        \n        \n            Source\n        \n\n\n\n    \n        \n            File\n        \n        \n            src/auth/oauth2client.ts\n        \n\n\n\n        \n            Index\n            \n                \n                    \n                        \n                            Properties\n                        \n                    \n                    \n                        \n                            \n                                \n                                            Unamed property\n                                \n                            \n                        \n                    \n                \n            \n        \n\n\n\n            \n                Properties\n                    \n                        \n\n                                    \n                                        \n                                            Signature :\n                                            \n                                            \n                                                \n                                                    [err: AxiosError | null, token: string | null, res: AxiosResponse | null]\n                                            \n                                        \n                                    \n\n\n                                    \n                                        \n                                            Returns :     void\n\n                                        \n                                    \n\n\n\n\n                        \n                    \n            \n    \n\n\n    \n        import {AxiosError, AxiosPromise, AxiosRequestConfig, AxiosResponse} from 'axios';\nimport * as crypto from 'crypto';\nimport * as querystring from 'querystring';\nimport * as stream from 'stream';\nimport * as messages from '../messages';\nimport {PemVerifier} from './../pemverifier';\nimport {BodyResponseCallback} from './../transporters';\nimport {AuthClient} from './authclient';\nimport {CredentialRequest, Credentials} from './credentials';\nimport {LoginTicket, TokenPayload} from './loginticket';\n\nexport type Certificates = {\n  [index: string]: string\n};\n\nexport type Headers = {\n  [index: string]: string\n};\n\nexport enum CodeChallengeMethod {\n  Plain = 'plain',\n  S256 = 'S256'\n}\n\nexport interface GetTokenOptions {\n  code: string;\n  codeVerifier?: string;\n  /**\n   * The client ID for your application. The value passed into the constructor\n   * will be used if not provided. Must match any client_id option passed to\n   * a corresponding call to generateAuthUrl.\n   */\n  client_id?: string;\n  /**\n   * Determines where the API server redirects the user after the user\n   * completes the authorization flow. The value passed into the constructor\n   * will be used if not provided. Must match any redirect_uri option passed to\n   * a corresponding call to generateAuthUrl.\n   */\n  redirect_uri?: string;\n}\n\nexport interface TokenInfo {\n  /**\n   * The application that is the intended user of the access token.\n   */\n  aud: string;\n\n  /**\n   * This value lets you correlate profile information from multiple Google\n   * APIs. It is only present in the response if you included the profile scope\n   * in your request in step 1. The field value is an immutable identifier for\n   * the logged-in user that can be used to create and manage user sessions in\n   * your application. The identifier is the same regardless of which client ID\n   * is used to retrieve it. This enables multiple applications in the same\n   * organization to correlate profile information.\n   */\n  user_id?: string;\n\n  /**\n   * An array of scopes that the user granted access to.\n   */\n  scopes: string[];\n\n  /**\n   * The datetime when the token becomes invalid.\n   */\n  expiry_date: number;\n\n  /**\n   * An identifier for the user, unique among all Google accounts and never\n   * reused. A Google account can have multiple emails at different points in\n   * time, but the sub value is never changed. Use sub within your application\n   * as the unique-identifier key for the user.\n   */\n  sub?: string;\n\n  /**\n   * The client_id of the authorized presenter. This claim is only needed when\n   * the party requesting the ID token is not the same as the audience of the ID\n   * token. This may be the case at Google for hybrid apps where a web\n   * application and Android app have a different client_id but share the same\n   * project.\n   */\n  azp?: string;\n\n  /**\n   * Indicates whether your application can refresh access tokens\n   * when the user is not present at the browser. Valid parameter values are\n   * 'online', which is the default value, and 'offline'. Set the value to\n   * 'offline' if your application needs to refresh access tokens when the user\n   * is not present at the browser. This value instructs the Google\n   * authorization server to return a refresh token and an access token the\n   * first time that your application exchanges an authorization code for\n   * tokens.\n   */\n  access_type?: string;\n}\n\ninterface TokenInfoRequest {\n  aud: string;\n  user_id?: string;\n  scope: string;\n  expires_in: number;\n  azp?: string;\n  sub?: string;\n  exp?: number;\n  access_type?: string;\n}\n\nexport interface GenerateAuthUrlOpts {\n  /**\n   * Recommended. Indicates whether your application can refresh access tokens\n   * when the user is not present at the browser. Valid parameter values are\n   * 'online', which is the default value, and 'offline'. Set the value to\n   * 'offline' if your application needs to refresh access tokens when the user\n   * is not present at the browser. This value instructs the Google\n   * authorization server to return a refresh token and an access token the\n   * first time that your application exchanges an authorization code for\n   * tokens.\n   */\n  access_type?: string;\n\n  /**\n   * The hd (hosted domain) parameter streamlines the login process for G Suite\n   * hosted accounts. By including the domain of the G Suite user (for example,\n   * mycollege.edu), you can indicate that the account selection UI should be\n   * optimized for accounts at that domain. To optimize for G Suite accounts\n   * generally instead of just one domain, use an asterisk: hd=*.\n   * Don't rely on this UI optimization to control who can access your app,\n   * as client-side requests can be modified. Be sure to validate that the\n   * returned ID token has an hd claim value that matches what you expect\n   * (e.g. mycolledge.edu). Unlike the request parameter, the ID token claim is\n   * contained within a security token from Google, so the value can be trusted.\n   */\n  hd?: string;\n\n  /**\n   * The 'response_type' will always be set to 'CODE'.\n   */\n  response_type?: string;\n\n  /**\n   * The client ID for your application. The value passed into the constructor\n   * will be used if not provided. You can find this value in the API Console.\n   */\n  client_id?: string;\n\n  /**\n   * Determines where the API server redirects the user after the user\n   * completes the authorization flow. The value must exactly match one of the\n   * 'redirect_uri' values listed for your project in the API Console. Note that\n   * the http or https scheme, case, and trailing slash ('/') must all match.\n   * The value passed into the constructor will be used if not provided.\n   */\n  redirect_uri?: string;\n\n  /**\n   * Required. A space-delimited list of scopes that identify the resources that\n   * your application could access on the user's behalf. These values inform the\n   * consent screen that Google displays to the user. Scopes enable your\n   * application to only request access to the resources that it needs while\n   * also enabling users to control the amount of access that they grant to your\n   * application. Thus, there is an inverse relationship between the number of\n   * scopes requested and the likelihood of obtaining user consent. The\n   * OAuth 2.0 API Scopes document provides a full list of scopes that you might\n   * use to access Google APIs. We recommend that your application request\n   * access to authorization scopes in context whenever possible. By requesting\n   * access to user data in context, via incremental authorization, you help\n   * users to more easily understand why your application needs the access it is\n   * requesting.\n   */\n  scope?: string[]|string;\n\n  /**\n   * Recommended. Specifies any string value that your application uses to\n   * maintain state between your authorization request and the authorization\n   * server's response. The server returns the exact value that you send as a\n   * name=value pair in the hash (#) fragment of the 'redirect_uri' after the\n   * user consents to or denies your application's access request. You can use\n   * this parameter for several purposes, such as directing the user to the\n   * correct resource in your application, sending nonces, and mitigating\n   * cross-site request forgery. Since your redirect_uri can be guessed, using a\n   * state value can increase your assurance that an incoming connection is the\n   * result of an authentication request. If you generate a random string or\n   * encode the hash of a cookie or another value that captures the client's\n   * state, you can validate the response to additionally ensure that the\n   * request and response originated in the same browser, providing protection\n   * against attacks such as cross-site request forgery. See the OpenID Connect\n   * documentation for an example of how to create and confirm a state token.\n   */\n  state?: string;\n\n  /**\n   * Optional. Enables applications to use incremental authorization to request\n   * access to additional scopes in context. If you set this parameter's value\n   * to true and the authorization request is granted, then the new access token\n   * will also cover any scopes to which the user previously granted the\n   * application access. See the incremental authorization section for examples.\n   */\n  include_granted_scopes?: boolean;\n\n  /**\n   * Optional. If your application knows which user is trying to authenticate,\n   * it can use this parameter to provide a hint to the Google Authentication\n   * Server. The server uses the hint to simplify the login flow either by\n   * prefilling the email field in the sign-in form or by selecting the\n   * appropriate multi-login session. Set the parameter value to an email\n   * address or sub identifier, which is equivalent to the user's Google ID.\n   */\n  login_hint?: string;\n\n  /**\n   * Optional. A space-delimited, case-sensitive list of prompts to present the\n   * user. If you don't specify this parameter, the user will be prompted only\n   * the first time your app requests access.  Possible values are:\n   *\n   * 'none' - Donot display any authentication or consent screens. Must not be\n   *        specified with other values.\n   * 'consent' - \tPrompt the user for consent.\n   * 'select_account' - Prompt the user to select an account.\n   */\n  prompt?: string;\n\n  /**\n   * Recommended. Specifies what method was used to encode a 'code_verifier'\n   * that will be used during authorization code exchange. This parameter must\n   * be used with the 'code_challenge' parameter. The value of the\n   * 'code_challenge_method' defaults to \"plain\" if not present in the request\n   * that includes a 'code_challenge'. The only supported values for this\n   * parameter are \"S256\" or \"plain\".\n   */\n  code_challenge_method?: CodeChallengeMethod;\n\n  /**\n   * Recommended. Specifies an encoded 'code_verifier' that will be used as a\n   * server-side challenge during authorization code exchange. This parameter\n   * must be used with the 'code_challenge' parameter described above.\n   */\n  code_challenge?: string;\n}\n\nexport interface GetTokenCallback {\n  (err: AxiosError|null, token?: Credentials|null,\n   res?: AxiosResponse|null): void;\n}\n\nexport interface GetTokenResponse {\n  tokens: Credentials;\n  res: AxiosResponse|null;\n}\n\nexport interface GetAccessTokenCallback {\n  (err: AxiosError|null, token?: string|null, res?: AxiosResponse|null): void;\n}\n\nexport interface GetAccessTokenResponse {\n  token?: string|null;\n  res?: AxiosResponse|null;\n}\n\nexport interface RefreshAccessTokenCallback {\n  (err: AxiosError|null, credentials?: Credentials|null,\n   res?: AxiosResponse|null): void;\n}\n\nexport interface RefreshAccessTokenResponse {\n  credentials: Credentials;\n  res: AxiosResponse|null;\n}\n\nexport interface RequestMetadataResponse {\n  headers: Headers;\n  res?: AxiosResponse|null;\n}\n\nexport interface RequestMetadataCallback {\n  (err: AxiosError|null, headers?: Headers,\n   res?: AxiosResponse|null): void;\n}\n\nexport interface GetFederatedSignonCertsCallback {\n  (err: AxiosError|null, certs?: Certificates,\n   response?: AxiosResponse|null): void;\n}\n\nexport interface FederatedSignonCertsResponse {\n  certs: Certificates;\n  res?: AxiosResponse|null;\n}\n\nexport interface RevokeCredentialsResult {\n  success: boolean;\n}\n\nexport interface VerifyIdTokenOptions {\n  idToken: string;\n  audience: string|string[];\n  maxExpiry?: number;\n}\n\nexport interface OAuth2ClientOptions extends RefreshOptions {\n  clientId?: string;\n  clientSecret?: string;\n  redirectUri?: string;\n}\n\nexport interface RefreshOptions {\n  // Eagerly refresh unexpired tokens when they are within this many\n  // milliseconds from expiring\".\n  // Defaults to a value of 300000 (5 minutes).\n  eagerRefreshThresholdMillis?: number;\n}\n\nexport class OAuth2Client extends AuthClient {\n  private redirectUri?: string;\n  private certificateCache?: Certificates;\n  private certificateExpiry: Date|null = null;\n  protected refreshTokenPromises = new Map>();\n\n  // TODO: refactor tests to make this private\n  _clientId?: string;\n\n  // TODO: refactor tests to make this private\n  _clientSecret?: string;\n\n  apiKey?: string;\n\n  projectId?: string;\n\n  eagerRefreshThresholdMillis: number;\n\n  /**\n   * Handles OAuth2 flow for Google APIs.\n   *\n   * @param clientId The authentication client ID.\n   * @param clientSecret The authentication client secret.\n   * @param redirectUri The URI to redirect to after completing the auth\n   * request.\n   * @param opts optional options for overriding the given parameters.\n   * @constructor\n   */\n  constructor(options?: OAuth2ClientOptions);\n  constructor(clientId?: string, clientSecret?: string, redirectUri?: string);\n  constructor(\n      optionsOrClientId?: string|OAuth2ClientOptions, clientSecret?: string,\n      redirectUri?: string) {\n    super();\n    const opts = (optionsOrClientId && typeof optionsOrClientId === 'object') ?\n        optionsOrClientId :\n        {clientId: optionsOrClientId, clientSecret, redirectUri};\n    this._clientId = opts.clientId;\n    this._clientSecret = opts.clientSecret;\n    this.redirectUri = opts.redirectUri;\n    this.eagerRefreshThresholdMillis =\n        opts.eagerRefreshThresholdMillis || 5 * 60 * 1000;\n  }\n\n  protected static readonly GOOGLE_TOKEN_INFO_URL =\n      'https://oauth2.googleapis.com/tokeninfo';\n\n  /**\n   * The base URL for auth endpoints.\n   */\n  private static readonly GOOGLE_OAUTH2_AUTH_BASE_URL_ =\n      'https://accounts.google.com/o/oauth2/v2/auth';\n\n  /**\n   * The base endpoint for token retrieval.\n   */\n  private static readonly GOOGLE_OAUTH2_TOKEN_URL_ =\n      'https://oauth2.googleapis.com/token';\n\n  /**\n   * The base endpoint to revoke tokens.\n   */\n  private static readonly GOOGLE_OAUTH2_REVOKE_URL_ =\n      'https://oauth2.googleapis.com/revoke';\n\n  /**\n   * Google Sign on certificates.\n   */\n  private static readonly GOOGLE_OAUTH2_FEDERATED_SIGNON_CERTS_URL_ =\n      'https://www.googleapis.com/oauth2/v1/certs';\n\n  /**\n   * Clock skew - five minutes in seconds\n   */\n  private static readonly CLOCK_SKEW_SECS_ = 300;\n\n  /**\n   * Max Token Lifetime is one day in seconds\n   */\n  private static readonly MAX_TOKEN_LIFETIME_SECS_ = 86400;\n\n  /**\n   * The allowed oauth token issuers.\n   */\n  private static readonly ISSUERS_ =\n      ['accounts.google.com', 'https://accounts.google.com'];\n\n  /**\n   * Generates URL for consent page landing.\n   * @param opts Options.\n   * @return URL to consent page.\n   */\n  generateAuthUrl(opts: GenerateAuthUrlOpts = {}) {\n    if (opts.code_challenge_method && !opts.code_challenge) {\n      throw new Error(\n          'If a code_challenge_method is provided, code_challenge must be included.');\n    }\n    opts.response_type = opts.response_type || 'code';\n    opts.client_id = opts.client_id || this._clientId;\n    opts.redirect_uri = opts.redirect_uri || this.redirectUri;\n    // Allow scopes to be passed either as array or a string\n    if (opts.scope instanceof Array) {\n      opts.scope = opts.scope.join(' ');\n    }\n    const rootUrl = OAuth2Client.GOOGLE_OAUTH2_AUTH_BASE_URL_;\n    return rootUrl + '?' + querystring.stringify(opts);\n  }\n\n  /**\n   * Convenience method to automatically generate a code_verifier, and it's\n   * resulting SHA256. If used, this must be paired with a S256\n   * code_challenge_method.\n   */\n  generateCodeVerifier() {\n    // base64 encoding uses 6 bits per character, and we want to generate128\n    // characters. 6*128/8 = 96.\n    const randomString = crypto.randomBytes(96).toString('base64');\n    // The valid characters in the code_verifier are [A-Z]/[a-z]/[0-9]/\n    // \"-\"/\".\"/\"_\"/\"~\". Base64 encoded strings are pretty close, so we're just\n    // swapping out a few chars.\n    const codeVerifier =\n        randomString.replace(/\\+/g, '~').replace(/=/g, '_').replace(/\\//g, '-');\n    // Generate the base64 encoded SHA256\n    const unencodedCodeChallenge =\n        crypto.createHash('sha256').update(codeVerifier).digest('base64');\n    // We need to use base64UrlEncoding instead of standard base64\n    const codeChallenge = unencodedCodeChallenge.split('=')[0]\n                              .replace(/\\+/g, '-')\n                              .replace(/\\//g, '_');\n    return {codeVerifier, codeChallenge};\n  }\n\n  /**\n   * Gets the access token for the given code.\n   * @param code The authorization code.\n   * @param callback Optional callback fn.\n   */\n  getToken(code: string): Promise;\n  getToken(options: GetTokenOptions): Promise;\n  getToken(code: string, callback: GetTokenCallback): void;\n  getToken(options: GetTokenOptions, callback: GetTokenCallback): void;\n  getToken(codeOrOptions: string|GetTokenOptions, callback?: GetTokenCallback):\n      Promise|void {\n    const options = (typeof codeOrOptions === 'string') ?\n        {code: codeOrOptions} :\n        codeOrOptions;\n    if (callback) {\n      this.getTokenAsync(options).then(\n          r => callback(null, r.tokens, r.res),\n          e => callback(e, null, e.response));\n    } else {\n      return this.getTokenAsync(options);\n    }\n  }\n\n  private async getTokenAsync(options: GetTokenOptions):\n      Promise {\n    const url = OAuth2Client.GOOGLE_OAUTH2_TOKEN_URL_;\n    const values = {\n      code: options.code,\n      client_id: options.client_id || this._clientId,\n      client_secret: this._clientSecret,\n      redirect_uri: options.redirect_uri || this.redirectUri,\n      grant_type: 'authorization_code',\n      code_verifier: options.codeVerifier\n    };\n    const res = await this.transporter.request({\n      method: 'POST',\n      url,\n      data: querystring.stringify(values),\n      headers: {'Content-Type': 'application/x-www-form-urlencoded'}\n    });\n    const tokens = res.data as Credentials;\n    if (res.data && res.data.expires_in) {\n      tokens.expiry_date =\n          ((new Date()).getTime() + (res.data.expires_in * 1000));\n      delete (tokens as CredentialRequest).expires_in;\n    }\n    this.emit('tokens', tokens);\n    return {tokens, res};\n  }\n\n  /**\n   * Refreshes the access token.\n   * @param refresh_token Existing refresh token.\n   * @private\n   */\n  protected async refreshToken(refreshToken?: string|\n                               null): Promise {\n    if (!refreshToken) {\n      return this.refreshTokenNoCache(refreshToken);\n    }\n    // If a request to refresh using the same token has started,\n    // return the same promise.\n    if (this.refreshTokenPromises.has(refreshToken)) {\n      return this.refreshTokenPromises.get(refreshToken)!;\n    }\n\n    const p = this.refreshTokenNoCache(refreshToken)\n                  .then(\n                      r => {\n                        this.refreshTokenPromises.delete(refreshToken);\n                        return r;\n                      },\n                      e => {\n                        this.refreshTokenPromises.delete(refreshToken);\n                        throw e;\n                      });\n    this.refreshTokenPromises.set(refreshToken, p);\n    return p;\n  }\n\n  protected async refreshTokenNoCache(refreshToken?: string|\n                                      null): Promise {\n    const url = OAuth2Client.GOOGLE_OAUTH2_TOKEN_URL_;\n    const data = {\n      refresh_token: refreshToken,\n      client_id: this._clientId,\n      client_secret: this._clientSecret,\n      grant_type: 'refresh_token'\n    };\n\n    // request for new token\n    const res = await this.transporter.request({\n      method: 'POST',\n      url,\n      data: querystring.stringify(data),\n      headers: {'Content-Type': 'application/x-www-form-urlencoded'}\n    });\n\n    const tokens = res.data as Credentials;\n    // TODO: de-duplicate this code from a few spots\n    if (res.data && res.data.expires_in) {\n      tokens.expiry_date =\n          ((new Date()).getTime() + (res.data.expires_in * 1000));\n      delete (tokens as CredentialRequest).expires_in;\n    }\n    this.emit('tokens', tokens);\n    return {tokens, res};\n  }\n\n  /**\n   * Retrieves the access token using refresh token\n   *\n   * @deprecated use getRequestHeaders instead.\n   * @param callback callback\n   */\n  refreshAccessToken(): Promise;\n  refreshAccessToken(callback: RefreshAccessTokenCallback): void;\n  refreshAccessToken(callback?: RefreshAccessTokenCallback):\n      Promise|void {\n    messages.warn(messages.REFRESH_ACCESS_TOKEN_DEPRECATED);\n    if (callback) {\n      this.refreshAccessTokenAsync().then(\n          r => callback(null, r.credentials, r.res), callback);\n    } else {\n      return this.refreshAccessTokenAsync();\n    }\n  }\n\n  private async refreshAccessTokenAsync() {\n    if (!this.credentials.refresh_token) {\n      throw new Error('No refresh token is set.');\n    }\n    const r = await this.refreshToken(this.credentials.refresh_token);\n    const tokens = r.tokens as Credentials;\n    tokens.refresh_token = this.credentials.refresh_token;\n    this.credentials = tokens;\n    return {credentials: this.credentials, res: r.res};\n  }\n\n  /**\n   * Get a non-expired access token, after refreshing if necessary\n   *\n   * @param callback Callback to call with the access token\n   */\n  getAccessToken(): Promise;\n  getAccessToken(callback: GetAccessTokenCallback): void;\n  getAccessToken(callback?: GetAccessTokenCallback):\n      Promise|void {\n    if (callback) {\n      this.getAccessTokenAsync().then(\n          r => callback(null, r.token, r.res), callback);\n    } else {\n      return this.getAccessTokenAsync();\n    }\n  }\n\n  private async getAccessTokenAsync(): Promise {\n    const shouldRefresh =\n        !this.credentials.access_token || this.isTokenExpiring();\n    if (shouldRefresh && this.credentials.refresh_token) {\n      if (!this.credentials.refresh_token) {\n        throw new Error('No refresh token is set.');\n      }\n\n      const r = await this.refreshAccessTokenAsync();\n      if (!r.credentials || (r.credentials && !r.credentials.access_token)) {\n        throw new Error('Could not refresh access token.');\n      }\n      return {token: r.credentials.access_token, res: r.res};\n    } else {\n      return {token: this.credentials.access_token};\n    }\n  }\n\n  /**\n   * Obtain the set of headers required to authenticate a request.\n   *\n   * @deprecated Use getRequestHeaders instead.\n   * @param url the Uri being authorized\n   * @param callback the func described above\n   */\n  getRequestMetadata(url?: string|null): Promise;\n  getRequestMetadata(url: string|null, callback: RequestMetadataCallback): void;\n  getRequestMetadata(url: string|null, callback?: RequestMetadataCallback):\n      Promise|void {\n    messages.warn(messages.OAUTH_GET_REQUEST_METADATA_DEPRECATED);\n    if (callback) {\n      this.getRequestMetadataAsync(url).then(\n          r => callback(null, r.headers, r.res), callback);\n    } else {\n      return this.getRequestMetadataAsync();\n    }\n  }\n\n  /**\n   * The main authentication interface.  It takes an optional url which when\n   * present is the endpoint being accessed, and returns a Promise which\n   * resolves with authorization header fields.\n   *\n   * In OAuth2Client, the result has the form:\n   * { Authorization: 'Bearer ' }\n   * @param url The optional url being authorized\n   */\n  async getRequestHeaders(url?: string): Promise {\n    const res = await this.getRequestMetadataAsync(url);\n    return res.headers;\n  }\n\n  protected async getRequestMetadataAsync(url?: string|null):\n      Promise {\n    const thisCreds = this.credentials;\n    if (!thisCreds.access_token && !thisCreds.refresh_token && !this.apiKey) {\n      throw new Error('No access, refresh token or API key is set.');\n    }\n\n    if (thisCreds.access_token && !this.isTokenExpiring()) {\n      thisCreds.token_type = thisCreds.token_type || 'Bearer';\n      const headers = {\n        Authorization: thisCreds.token_type + ' ' + thisCreds.access_token\n      };\n      return {headers};\n    }\n\n    if (this.apiKey) {\n      return {headers: {}};\n    }\n    let r: GetTokenResponse|null = null;\n    let tokens: Credentials|null = null;\n    try {\n      r = await this.refreshToken(thisCreds.refresh_token);\n      tokens = r.tokens;\n    } catch (err) {\n      const e = err as AxiosError;\n      if (e.response &&\n          (e.response.status === 403 || e.response.status === 404)) {\n        e.message = 'Could not refresh access token.';\n      }\n      throw e;\n    }\n\n    const credentials = this.credentials;\n    credentials.token_type = credentials.token_type || 'Bearer';\n    tokens.refresh_token = credentials.refresh_token;\n    this.credentials = tokens;\n    const headers = {\n      Authorization: credentials.token_type + ' ' + tokens.access_token\n    };\n    return {headers, res: r.res};\n  }\n\n  /**\n   * Revokes the access given to token.\n   * @param token The existing token to be revoked.\n   * @param callback Optional callback fn.\n   */\n  revokeToken(token: string): AxiosPromise;\n  revokeToken(\n      token: string,\n      callback: BodyResponseCallback): void;\n  revokeToken(\n      token: string, callback?: BodyResponseCallback):\n      AxiosPromise|void {\n    const opts = {\n      url: OAuth2Client.GOOGLE_OAUTH2_REVOKE_URL_ + '?' +\n          querystring.stringify({token}),\n      method: 'POST'\n    };\n    if (callback) {\n      this.transporter.request(opts).then(\n          r => callback(null, r), callback);\n    } else {\n      return this.transporter.request(opts);\n    }\n  }\n\n\n  /**\n   * Revokes access token and clears the credentials object\n   * @param callback callback\n   */\n  revokeCredentials(): AxiosPromise;\n  revokeCredentials(callback: BodyResponseCallback):\n      void;\n  revokeCredentials(callback?: BodyResponseCallback):\n      AxiosPromise|void {\n    if (callback) {\n      this.revokeCredentialsAsync().then(res => callback(null, res), callback);\n    } else {\n      return this.revokeCredentialsAsync();\n    }\n  }\n\n  private async revokeCredentialsAsync() {\n    const token = this.credentials.access_token;\n    this.credentials = {};\n    if (token) {\n      return this.revokeToken(token);\n    } else {\n      throw new Error('No access token to revoke.');\n    }\n  }\n\n  /**\n   * Provides a request implementation with OAuth 2.0 flow. If credentials have\n   * a refresh_token, in cases of HTTP 401 and 403 responses, it automatically\n   * asks for a new access token and replays the unsuccessful request.\n   * @param opts Request options.\n   * @param callback callback.\n   * @return Request object\n   */\n  request(opts: AxiosRequestConfig): AxiosPromise;\n  request(opts: AxiosRequestConfig, callback: BodyResponseCallback): void;\n  request(opts: AxiosRequestConfig, callback?: BodyResponseCallback):\n      AxiosPromise|void {\n    if (callback) {\n      this.requestAsync(opts).then(r => callback(null, r), e => {\n        return callback(e, e.response);\n      });\n    } else {\n      return this.requestAsync(opts);\n    }\n  }\n\n  protected async requestAsync(opts: AxiosRequestConfig, retry = false):\n      Promise> {\n    let r2: AxiosResponse;\n    try {\n      const r = await this.getRequestMetadataAsync(opts.url);\n      if (r.headers && r.headers.Authorization) {\n        opts.headers = opts.headers || {};\n        opts.headers.Authorization = r.headers.Authorization;\n      }\n\n      if (this.apiKey) {\n        opts.params = Object.assign(opts.params || {}, {key: this.apiKey});\n      }\n      r2 = await this.transporter.request(opts);\n    } catch (e) {\n      const res = (e as AxiosError).response;\n      if (res) {\n        const statusCode = res.status;\n        // Retry the request for metadata if the following criteria are true:\n        // - We haven't already retried.  It only makes sense to retry once.\n        // - The response was a 401 or a 403\n        // - The request didn't send a readableStream\n        // - An access_token and refresh_token were available, but no\n        //   expiry_date was availabe. This can happen when developers stash\n        //   the access_token and refresh_token for later use, but the\n        //   access_token fails on the first try because it's expired.\n        const mayRequireRefresh = this.credentials &&\n            this.credentials.access_token && this.credentials.refresh_token &&\n            !this.credentials.expiry_date;\n        const isReadableStream = res.config.data instanceof stream.Readable;\n        const isAuthErr = statusCode === 401 || statusCode === 403;\n        if (!retry && isAuthErr && !isReadableStream && mayRequireRefresh) {\n          await this.refreshAccessTokenAsync();\n          return this.requestAsync(opts, true);\n        }\n      }\n      throw e;\n    }\n    return r2;\n  }\n\n  /**\n   * Verify id token is token by checking the certs and audience\n   * @param options that contains all options.\n   * @param callback Callback supplying GoogleLogin if successful\n   */\n  verifyIdToken(options: VerifyIdTokenOptions): Promise;\n  verifyIdToken(\n      options: VerifyIdTokenOptions,\n      callback: (err: Error|null, login?: LoginTicket) => void): void;\n  verifyIdToken(\n      options: VerifyIdTokenOptions,\n      callback?: (err: Error|null, login?: LoginTicket) => void):\n      void|Promise {\n    // This function used to accept two arguments instead of an options object.\n    // Check the types to help users upgrade with less pain.\n    // This check can be removed after a 2.0 release.\n    if (callback && typeof callback !== 'function') {\n      throw new Error(\n          'This method accepts an options object as the first parameter, which includes the idToken, audience, and maxExpiry.');\n    }\n\n    if (callback) {\n      this.verifyIdTokenAsync(options).then(r => callback(null, r), callback);\n    } else {\n      return this.verifyIdTokenAsync(options);\n    }\n  }\n\n  private async verifyIdTokenAsync(options: VerifyIdTokenOptions):\n      Promise {\n    if (!options.idToken) {\n      throw new Error('The verifyIdToken method requires an ID Token');\n    }\n\n    const response = await this.getFederatedSignonCertsAsync();\n    const login = this.verifySignedJwtWithCerts(\n        options.idToken, response.certs, options.audience,\n        OAuth2Client.ISSUERS_, options.maxExpiry);\n\n    return login;\n  }\n\n  /**\n   * Obtains information about the provisioned access token.  Especially useful\n   * if you want to check the scopes that were provisioned to a given token.\n   *\n   * @param accessToken Required.  The Access Token for which you want to get\n   * user info.\n   */\n  async getTokenInfo(accessToken: string): Promise {\n    const {data} = await this.transporter.request({\n      method: 'GET',\n      url: OAuth2Client.GOOGLE_TOKEN_INFO_URL,\n      params: {access_token: accessToken}\n    });\n    const info = Object.assign(\n        {\n          expiry_date: ((new Date()).getTime() + (data.expires_in * 1000)),\n          scopes: data.scope.split(' ')\n        },\n        data);\n    delete info.expires_in;\n    delete info.scope;\n    return info;\n  }\n\n  /**\n   * Gets federated sign-on certificates to use for verifying identity tokens.\n   * Returns certs as array structure, where keys are key ids, and values\n   * are PEM encoded certificates.\n   * @param callback Callback supplying the certificates\n   */\n  getFederatedSignonCerts(): Promise;\n  getFederatedSignonCerts(callback: GetFederatedSignonCertsCallback): void;\n  getFederatedSignonCerts(callback?: GetFederatedSignonCertsCallback):\n      Promise|void {\n    if (callback) {\n      this.getFederatedSignonCertsAsync().then(\n          r => callback(null, r.certs, r.res), callback);\n    } else {\n      return this.getFederatedSignonCertsAsync();\n    }\n  }\n\n  async getFederatedSignonCertsAsync(): Promise {\n    const nowTime = (new Date()).getTime();\n    if (this.certificateExpiry &&\n        (nowTime = now + maxExpiry) {\n      throw new Error(\n          'Expiration time too far in future: ' + JSON.stringify(payload));\n    }\n\n    const earliest = iat - OAuth2Client.CLOCK_SKEW_SECS_;\n    const latest = exp + OAuth2Client.CLOCK_SKEW_SECS_;\n\n    if (now  latest) {\n      throw new Error(\n          'Token used too late, ' + now + ' > ' + latest + ': ' +\n          JSON.stringify(payload));\n    }\n\n    if (issuers && issuers.indexOf(payload.iss)  -1);\n      } else {\n        audVerified = (aud === requiredAudience);\n      }\n      if (!audVerified) {\n        throw new Error(\n            'Wrong recipient, payload audience != requiredAudience');\n      }\n    }\n    return new LoginTicket(envelope, payload);\n  }\n\n  /**\n   * This is a utils method to decode a base64 string\n   * @param b64String The string to base64 decode\n   * @return The decoded string\n   */\n  decodeBase64(b64String: string) {\n    const buffer = Buffer.from(b64String, 'base64');\n    return buffer.toString('utf8');\n  }\n\n  /**\n   * Returns true if a token is expired or will expire within\n   * eagerRefreshThresholdMillismilliseconds.\n   * If there is no expiry time, assumes the token is not expired or expiring.\n   */\n  protected isTokenExpiring(): boolean {\n    const expiryDate = this.credentials.expiry_date;\n    return expiryDate ? expiryDate \n    \n\n\n\n\n\n\n\n                   \n    \n         result-matching \"\"\n        \n    \n    \n        No results matching \"\"\n    \n\n"},"interfaces/GetAccessTokenResponse.html":{"url":"interfaces/GetAccessTokenResponse.html","title":"interface - GetAccessTokenResponse","body":"\n                   \n\n\n\n\n\n\n\n\n\n\n\n\n\n  Interfaces\n  GetAccessTokenResponse\n\n\n\n        \n            Info\n        \n        \n            Source\n        \n\n\n\n    \n        \n            File\n        \n        \n            src/auth/oauth2client.ts\n        \n\n\n\n        \n            Index\n            \n                \n                    \n                        \n                            Properties\n                        \n                    \n                    \n                        \n                            \n                                \n                                            Optional\n                                        res\n                                \n                                \n                                            Optional\n                                        token\n                                \n                            \n                        \n                    \n                \n            \n        \n\n\n\n            \n                Properties\n                    \n                        \n                                \n                                    \n                                        \n                                        res\n                                    \n                                \n                                \n                                    \n                                        res:     AxiosResponse | null\n\n                                    \n                                \n\n\n                                    \n                                        \n                                            Type :     AxiosResponse | null\n\n                                        \n                                    \n\n                                    \n                                        \n                                            Optional\n                                        \n                                    \n\n\n\n\n                        \n                    \n                    \n                        \n                                \n                                    \n                                        \n                                        token\n                                    \n                                \n                                \n                                    \n                                        token:     string | null\n\n                                    \n                                \n\n\n                                    \n                                        \n                                            Type :     string | null\n\n                                        \n                                    \n\n                                    \n                                        \n                                            Optional\n                                        \n                                    \n\n\n\n\n                        \n                    \n            \n    \n\n\n    \n        import {AxiosError, AxiosPromise, AxiosRequestConfig, AxiosResponse} from 'axios';\nimport * as crypto from 'crypto';\nimport * as querystring from 'querystring';\nimport * as stream from 'stream';\nimport * as messages from '../messages';\nimport {PemVerifier} from './../pemverifier';\nimport {BodyResponseCallback} from './../transporters';\nimport {AuthClient} from './authclient';\nimport {CredentialRequest, Credentials} from './credentials';\nimport {LoginTicket, TokenPayload} from './loginticket';\n\nexport type Certificates = {\n  [index: string]: string\n};\n\nexport type Headers = {\n  [index: string]: string\n};\n\nexport enum CodeChallengeMethod {\n  Plain = 'plain',\n  S256 = 'S256'\n}\n\nexport interface GetTokenOptions {\n  code: string;\n  codeVerifier?: string;\n  /**\n   * The client ID for your application. The value passed into the constructor\n   * will be used if not provided. Must match any client_id option passed to\n   * a corresponding call to generateAuthUrl.\n   */\n  client_id?: string;\n  /**\n   * Determines where the API server redirects the user after the user\n   * completes the authorization flow. The value passed into the constructor\n   * will be used if not provided. Must match any redirect_uri option passed to\n   * a corresponding call to generateAuthUrl.\n   */\n  redirect_uri?: string;\n}\n\nexport interface TokenInfo {\n  /**\n   * The application that is the intended user of the access token.\n   */\n  aud: string;\n\n  /**\n   * This value lets you correlate profile information from multiple Google\n   * APIs. It is only present in the response if you included the profile scope\n   * in your request in step 1. The field value is an immutable identifier for\n   * the logged-in user that can be used to create and manage user sessions in\n   * your application. The identifier is the same regardless of which client ID\n   * is used to retrieve it. This enables multiple applications in the same\n   * organization to correlate profile information.\n   */\n  user_id?: string;\n\n  /**\n   * An array of scopes that the user granted access to.\n   */\n  scopes: string[];\n\n  /**\n   * The datetime when the token becomes invalid.\n   */\n  expiry_date: number;\n\n  /**\n   * An identifier for the user, unique among all Google accounts and never\n   * reused. A Google account can have multiple emails at different points in\n   * time, but the sub value is never changed. Use sub within your application\n   * as the unique-identifier key for the user.\n   */\n  sub?: string;\n\n  /**\n   * The client_id of the authorized presenter. This claim is only needed when\n   * the party requesting the ID token is not the same as the audience of the ID\n   * token. This may be the case at Google for hybrid apps where a web\n   * application and Android app have a different client_id but share the same\n   * project.\n   */\n  azp?: string;\n\n  /**\n   * Indicates whether your application can refresh access tokens\n   * when the user is not present at the browser. Valid parameter values are\n   * 'online', which is the default value, and 'offline'. Set the value to\n   * 'offline' if your application needs to refresh access tokens when the user\n   * is not present at the browser. This value instructs the Google\n   * authorization server to return a refresh token and an access token the\n   * first time that your application exchanges an authorization code for\n   * tokens.\n   */\n  access_type?: string;\n}\n\ninterface TokenInfoRequest {\n  aud: string;\n  user_id?: string;\n  scope: string;\n  expires_in: number;\n  azp?: string;\n  sub?: string;\n  exp?: number;\n  access_type?: string;\n}\n\nexport interface GenerateAuthUrlOpts {\n  /**\n   * Recommended. Indicates whether your application can refresh access tokens\n   * when the user is not present at the browser. Valid parameter values are\n   * 'online', which is the default value, and 'offline'. Set the value to\n   * 'offline' if your application needs to refresh access tokens when the user\n   * is not present at the browser. This value instructs the Google\n   * authorization server to return a refresh token and an access token the\n   * first time that your application exchanges an authorization code for\n   * tokens.\n   */\n  access_type?: string;\n\n  /**\n   * The hd (hosted domain) parameter streamlines the login process for G Suite\n   * hosted accounts. By including the domain of the G Suite user (for example,\n   * mycollege.edu), you can indicate that the account selection UI should be\n   * optimized for accounts at that domain. To optimize for G Suite accounts\n   * generally instead of just one domain, use an asterisk: hd=*.\n   * Don't rely on this UI optimization to control who can access your app,\n   * as client-side requests can be modified. Be sure to validate that the\n   * returned ID token has an hd claim value that matches what you expect\n   * (e.g. mycolledge.edu). Unlike the request parameter, the ID token claim is\n   * contained within a security token from Google, so the value can be trusted.\n   */\n  hd?: string;\n\n  /**\n   * The 'response_type' will always be set to 'CODE'.\n   */\n  response_type?: string;\n\n  /**\n   * The client ID for your application. The value passed into the constructor\n   * will be used if not provided. You can find this value in the API Console.\n   */\n  client_id?: string;\n\n  /**\n   * Determines where the API server redirects the user after the user\n   * completes the authorization flow. The value must exactly match one of the\n   * 'redirect_uri' values listed for your project in the API Console. Note that\n   * the http or https scheme, case, and trailing slash ('/') must all match.\n   * The value passed into the constructor will be used if not provided.\n   */\n  redirect_uri?: string;\n\n  /**\n   * Required. A space-delimited list of scopes that identify the resources that\n   * your application could access on the user's behalf. These values inform the\n   * consent screen that Google displays to the user. Scopes enable your\n   * application to only request access to the resources that it needs while\n   * also enabling users to control the amount of access that they grant to your\n   * application. Thus, there is an inverse relationship between the number of\n   * scopes requested and the likelihood of obtaining user consent. The\n   * OAuth 2.0 API Scopes document provides a full list of scopes that you might\n   * use to access Google APIs. We recommend that your application request\n   * access to authorization scopes in context whenever possible. By requesting\n   * access to user data in context, via incremental authorization, you help\n   * users to more easily understand why your application needs the access it is\n   * requesting.\n   */\n  scope?: string[]|string;\n\n  /**\n   * Recommended. Specifies any string value that your application uses to\n   * maintain state between your authorization request and the authorization\n   * server's response. The server returns the exact value that you send as a\n   * name=value pair in the hash (#) fragment of the 'redirect_uri' after the\n   * user consents to or denies your application's access request. You can use\n   * this parameter for several purposes, such as directing the user to the\n   * correct resource in your application, sending nonces, and mitigating\n   * cross-site request forgery. Since your redirect_uri can be guessed, using a\n   * state value can increase your assurance that an incoming connection is the\n   * result of an authentication request. If you generate a random string or\n   * encode the hash of a cookie or another value that captures the client's\n   * state, you can validate the response to additionally ensure that the\n   * request and response originated in the same browser, providing protection\n   * against attacks such as cross-site request forgery. See the OpenID Connect\n   * documentation for an example of how to create and confirm a state token.\n   */\n  state?: string;\n\n  /**\n   * Optional. Enables applications to use incremental authorization to request\n   * access to additional scopes in context. If you set this parameter's value\n   * to true and the authorization request is granted, then the new access token\n   * will also cover any scopes to which the user previously granted the\n   * application access. See the incremental authorization section for examples.\n   */\n  include_granted_scopes?: boolean;\n\n  /**\n   * Optional. If your application knows which user is trying to authenticate,\n   * it can use this parameter to provide a hint to the Google Authentication\n   * Server. The server uses the hint to simplify the login flow either by\n   * prefilling the email field in the sign-in form or by selecting the\n   * appropriate multi-login session. Set the parameter value to an email\n   * address or sub identifier, which is equivalent to the user's Google ID.\n   */\n  login_hint?: string;\n\n  /**\n   * Optional. A space-delimited, case-sensitive list of prompts to present the\n   * user. If you don't specify this parameter, the user will be prompted only\n   * the first time your app requests access.  Possible values are:\n   *\n   * 'none' - Donot display any authentication or consent screens. Must not be\n   *        specified with other values.\n   * 'consent' - \tPrompt the user for consent.\n   * 'select_account' - Prompt the user to select an account.\n   */\n  prompt?: string;\n\n  /**\n   * Recommended. Specifies what method was used to encode a 'code_verifier'\n   * that will be used during authorization code exchange. This parameter must\n   * be used with the 'code_challenge' parameter. The value of the\n   * 'code_challenge_method' defaults to \"plain\" if not present in the request\n   * that includes a 'code_challenge'. The only supported values for this\n   * parameter are \"S256\" or \"plain\".\n   */\n  code_challenge_method?: CodeChallengeMethod;\n\n  /**\n   * Recommended. Specifies an encoded 'code_verifier' that will be used as a\n   * server-side challenge during authorization code exchange. This parameter\n   * must be used with the 'code_challenge' parameter described above.\n   */\n  code_challenge?: string;\n}\n\nexport interface GetTokenCallback {\n  (err: AxiosError|null, token?: Credentials|null,\n   res?: AxiosResponse|null): void;\n}\n\nexport interface GetTokenResponse {\n  tokens: Credentials;\n  res: AxiosResponse|null;\n}\n\nexport interface GetAccessTokenCallback {\n  (err: AxiosError|null, token?: string|null, res?: AxiosResponse|null): void;\n}\n\nexport interface GetAccessTokenResponse {\n  token?: string|null;\n  res?: AxiosResponse|null;\n}\n\nexport interface RefreshAccessTokenCallback {\n  (err: AxiosError|null, credentials?: Credentials|null,\n   res?: AxiosResponse|null): void;\n}\n\nexport interface RefreshAccessTokenResponse {\n  credentials: Credentials;\n  res: AxiosResponse|null;\n}\n\nexport interface RequestMetadataResponse {\n  headers: Headers;\n  res?: AxiosResponse|null;\n}\n\nexport interface RequestMetadataCallback {\n  (err: AxiosError|null, headers?: Headers,\n   res?: AxiosResponse|null): void;\n}\n\nexport interface GetFederatedSignonCertsCallback {\n  (err: AxiosError|null, certs?: Certificates,\n   response?: AxiosResponse|null): void;\n}\n\nexport interface FederatedSignonCertsResponse {\n  certs: Certificates;\n  res?: AxiosResponse|null;\n}\n\nexport interface RevokeCredentialsResult {\n  success: boolean;\n}\n\nexport interface VerifyIdTokenOptions {\n  idToken: string;\n  audience: string|string[];\n  maxExpiry?: number;\n}\n\nexport interface OAuth2ClientOptions extends RefreshOptions {\n  clientId?: string;\n  clientSecret?: string;\n  redirectUri?: string;\n}\n\nexport interface RefreshOptions {\n  // Eagerly refresh unexpired tokens when they are within this many\n  // milliseconds from expiring\".\n  // Defaults to a value of 300000 (5 minutes).\n  eagerRefreshThresholdMillis?: number;\n}\n\nexport class OAuth2Client extends AuthClient {\n  private redirectUri?: string;\n  private certificateCache?: Certificates;\n  private certificateExpiry: Date|null = null;\n  protected refreshTokenPromises = new Map>();\n\n  // TODO: refactor tests to make this private\n  _clientId?: string;\n\n  // TODO: refactor tests to make this private\n  _clientSecret?: string;\n\n  apiKey?: string;\n\n  projectId?: string;\n\n  eagerRefreshThresholdMillis: number;\n\n  /**\n   * Handles OAuth2 flow for Google APIs.\n   *\n   * @param clientId The authentication client ID.\n   * @param clientSecret The authentication client secret.\n   * @param redirectUri The URI to redirect to after completing the auth\n   * request.\n   * @param opts optional options for overriding the given parameters.\n   * @constructor\n   */\n  constructor(options?: OAuth2ClientOptions);\n  constructor(clientId?: string, clientSecret?: string, redirectUri?: string);\n  constructor(\n      optionsOrClientId?: string|OAuth2ClientOptions, clientSecret?: string,\n      redirectUri?: string) {\n    super();\n    const opts = (optionsOrClientId && typeof optionsOrClientId === 'object') ?\n        optionsOrClientId :\n        {clientId: optionsOrClientId, clientSecret, redirectUri};\n    this._clientId = opts.clientId;\n    this._clientSecret = opts.clientSecret;\n    this.redirectUri = opts.redirectUri;\n    this.eagerRefreshThresholdMillis =\n        opts.eagerRefreshThresholdMillis || 5 * 60 * 1000;\n  }\n\n  protected static readonly GOOGLE_TOKEN_INFO_URL =\n      'https://oauth2.googleapis.com/tokeninfo';\n\n  /**\n   * The base URL for auth endpoints.\n   */\n  private static readonly GOOGLE_OAUTH2_AUTH_BASE_URL_ =\n      'https://accounts.google.com/o/oauth2/v2/auth';\n\n  /**\n   * The base endpoint for token retrieval.\n   */\n  private static readonly GOOGLE_OAUTH2_TOKEN_URL_ =\n      'https://oauth2.googleapis.com/token';\n\n  /**\n   * The base endpoint to revoke tokens.\n   */\n  private static readonly GOOGLE_OAUTH2_REVOKE_URL_ =\n      'https://oauth2.googleapis.com/revoke';\n\n  /**\n   * Google Sign on certificates.\n   */\n  private static readonly GOOGLE_OAUTH2_FEDERATED_SIGNON_CERTS_URL_ =\n      'https://www.googleapis.com/oauth2/v1/certs';\n\n  /**\n   * Clock skew - five minutes in seconds\n   */\n  private static readonly CLOCK_SKEW_SECS_ = 300;\n\n  /**\n   * Max Token Lifetime is one day in seconds\n   */\n  private static readonly MAX_TOKEN_LIFETIME_SECS_ = 86400;\n\n  /**\n   * The allowed oauth token issuers.\n   */\n  private static readonly ISSUERS_ =\n      ['accounts.google.com', 'https://accounts.google.com'];\n\n  /**\n   * Generates URL for consent page landing.\n   * @param opts Options.\n   * @return URL to consent page.\n   */\n  generateAuthUrl(opts: GenerateAuthUrlOpts = {}) {\n    if (opts.code_challenge_method && !opts.code_challenge) {\n      throw new Error(\n          'If a code_challenge_method is provided, code_challenge must be included.');\n    }\n    opts.response_type = opts.response_type || 'code';\n    opts.client_id = opts.client_id || this._clientId;\n    opts.redirect_uri = opts.redirect_uri || this.redirectUri;\n    // Allow scopes to be passed either as array or a string\n    if (opts.scope instanceof Array) {\n      opts.scope = opts.scope.join(' ');\n    }\n    const rootUrl = OAuth2Client.GOOGLE_OAUTH2_AUTH_BASE_URL_;\n    return rootUrl + '?' + querystring.stringify(opts);\n  }\n\n  /**\n   * Convenience method to automatically generate a code_verifier, and it's\n   * resulting SHA256. If used, this must be paired with a S256\n   * code_challenge_method.\n   */\n  generateCodeVerifier() {\n    // base64 encoding uses 6 bits per character, and we want to generate128\n    // characters. 6*128/8 = 96.\n    const randomString = crypto.randomBytes(96).toString('base64');\n    // The valid characters in the code_verifier are [A-Z]/[a-z]/[0-9]/\n    // \"-\"/\".\"/\"_\"/\"~\". Base64 encoded strings are pretty close, so we're just\n    // swapping out a few chars.\n    const codeVerifier =\n        randomString.replace(/\\+/g, '~').replace(/=/g, '_').replace(/\\//g, '-');\n    // Generate the base64 encoded SHA256\n    const unencodedCodeChallenge =\n        crypto.createHash('sha256').update(codeVerifier).digest('base64');\n    // We need to use base64UrlEncoding instead of standard base64\n    const codeChallenge = unencodedCodeChallenge.split('=')[0]\n                              .replace(/\\+/g, '-')\n                              .replace(/\\//g, '_');\n    return {codeVerifier, codeChallenge};\n  }\n\n  /**\n   * Gets the access token for the given code.\n   * @param code The authorization code.\n   * @param callback Optional callback fn.\n   */\n  getToken(code: string): Promise;\n  getToken(options: GetTokenOptions): Promise;\n  getToken(code: string, callback: GetTokenCallback): void;\n  getToken(options: GetTokenOptions, callback: GetTokenCallback): void;\n  getToken(codeOrOptions: string|GetTokenOptions, callback?: GetTokenCallback):\n      Promise|void {\n    const options = (typeof codeOrOptions === 'string') ?\n        {code: codeOrOptions} :\n        codeOrOptions;\n    if (callback) {\n      this.getTokenAsync(options).then(\n          r => callback(null, r.tokens, r.res),\n          e => callback(e, null, e.response));\n    } else {\n      return this.getTokenAsync(options);\n    }\n  }\n\n  private async getTokenAsync(options: GetTokenOptions):\n      Promise {\n    const url = OAuth2Client.GOOGLE_OAUTH2_TOKEN_URL_;\n    const values = {\n      code: options.code,\n      client_id: options.client_id || this._clientId,\n      client_secret: this._clientSecret,\n      redirect_uri: options.redirect_uri || this.redirectUri,\n      grant_type: 'authorization_code',\n      code_verifier: options.codeVerifier\n    };\n    const res = await this.transporter.request({\n      method: 'POST',\n      url,\n      data: querystring.stringify(values),\n      headers: {'Content-Type': 'application/x-www-form-urlencoded'}\n    });\n    const tokens = res.data as Credentials;\n    if (res.data && res.data.expires_in) {\n      tokens.expiry_date =\n          ((new Date()).getTime() + (res.data.expires_in * 1000));\n      delete (tokens as CredentialRequest).expires_in;\n    }\n    this.emit('tokens', tokens);\n    return {tokens, res};\n  }\n\n  /**\n   * Refreshes the access token.\n   * @param refresh_token Existing refresh token.\n   * @private\n   */\n  protected async refreshToken(refreshToken?: string|\n                               null): Promise {\n    if (!refreshToken) {\n      return this.refreshTokenNoCache(refreshToken);\n    }\n    // If a request to refresh using the same token has started,\n    // return the same promise.\n    if (this.refreshTokenPromises.has(refreshToken)) {\n      return this.refreshTokenPromises.get(refreshToken)!;\n    }\n\n    const p = this.refreshTokenNoCache(refreshToken)\n                  .then(\n                      r => {\n                        this.refreshTokenPromises.delete(refreshToken);\n                        return r;\n                      },\n                      e => {\n                        this.refreshTokenPromises.delete(refreshToken);\n                        throw e;\n                      });\n    this.refreshTokenPromises.set(refreshToken, p);\n    return p;\n  }\n\n  protected async refreshTokenNoCache(refreshToken?: string|\n                                      null): Promise {\n    const url = OAuth2Client.GOOGLE_OAUTH2_TOKEN_URL_;\n    const data = {\n      refresh_token: refreshToken,\n      client_id: this._clientId,\n      client_secret: this._clientSecret,\n      grant_type: 'refresh_token'\n    };\n\n    // request for new token\n    const res = await this.transporter.request({\n      method: 'POST',\n      url,\n      data: querystring.stringify(data),\n      headers: {'Content-Type': 'application/x-www-form-urlencoded'}\n    });\n\n    const tokens = res.data as Credentials;\n    // TODO: de-duplicate this code from a few spots\n    if (res.data && res.data.expires_in) {\n      tokens.expiry_date =\n          ((new Date()).getTime() + (res.data.expires_in * 1000));\n      delete (tokens as CredentialRequest).expires_in;\n    }\n    this.emit('tokens', tokens);\n    return {tokens, res};\n  }\n\n  /**\n   * Retrieves the access token using refresh token\n   *\n   * @deprecated use getRequestHeaders instead.\n   * @param callback callback\n   */\n  refreshAccessToken(): Promise;\n  refreshAccessToken(callback: RefreshAccessTokenCallback): void;\n  refreshAccessToken(callback?: RefreshAccessTokenCallback):\n      Promise|void {\n    messages.warn(messages.REFRESH_ACCESS_TOKEN_DEPRECATED);\n    if (callback) {\n      this.refreshAccessTokenAsync().then(\n          r => callback(null, r.credentials, r.res), callback);\n    } else {\n      return this.refreshAccessTokenAsync();\n    }\n  }\n\n  private async refreshAccessTokenAsync() {\n    if (!this.credentials.refresh_token) {\n      throw new Error('No refresh token is set.');\n    }\n    const r = await this.refreshToken(this.credentials.refresh_token);\n    const tokens = r.tokens as Credentials;\n    tokens.refresh_token = this.credentials.refresh_token;\n    this.credentials = tokens;\n    return {credentials: this.credentials, res: r.res};\n  }\n\n  /**\n   * Get a non-expired access token, after refreshing if necessary\n   *\n   * @param callback Callback to call with the access token\n   */\n  getAccessToken(): Promise;\n  getAccessToken(callback: GetAccessTokenCallback): void;\n  getAccessToken(callback?: GetAccessTokenCallback):\n      Promise|void {\n    if (callback) {\n      this.getAccessTokenAsync().then(\n          r => callback(null, r.token, r.res), callback);\n    } else {\n      return this.getAccessTokenAsync();\n    }\n  }\n\n  private async getAccessTokenAsync(): Promise {\n    const shouldRefresh =\n        !this.credentials.access_token || this.isTokenExpiring();\n    if (shouldRefresh && this.credentials.refresh_token) {\n      if (!this.credentials.refresh_token) {\n        throw new Error('No refresh token is set.');\n      }\n\n      const r = await this.refreshAccessTokenAsync();\n      if (!r.credentials || (r.credentials && !r.credentials.access_token)) {\n        throw new Error('Could not refresh access token.');\n      }\n      return {token: r.credentials.access_token, res: r.res};\n    } else {\n      return {token: this.credentials.access_token};\n    }\n  }\n\n  /**\n   * Obtain the set of headers required to authenticate a request.\n   *\n   * @deprecated Use getRequestHeaders instead.\n   * @param url the Uri being authorized\n   * @param callback the func described above\n   */\n  getRequestMetadata(url?: string|null): Promise;\n  getRequestMetadata(url: string|null, callback: RequestMetadataCallback): void;\n  getRequestMetadata(url: string|null, callback?: RequestMetadataCallback):\n      Promise|void {\n    messages.warn(messages.OAUTH_GET_REQUEST_METADATA_DEPRECATED);\n    if (callback) {\n      this.getRequestMetadataAsync(url).then(\n          r => callback(null, r.headers, r.res), callback);\n    } else {\n      return this.getRequestMetadataAsync();\n    }\n  }\n\n  /**\n   * The main authentication interface.  It takes an optional url which when\n   * present is the endpoint being accessed, and returns a Promise which\n   * resolves with authorization header fields.\n   *\n   * In OAuth2Client, the result has the form:\n   * { Authorization: 'Bearer ' }\n   * @param url The optional url being authorized\n   */\n  async getRequestHeaders(url?: string): Promise {\n    const res = await this.getRequestMetadataAsync(url);\n    return res.headers;\n  }\n\n  protected async getRequestMetadataAsync(url?: string|null):\n      Promise {\n    const thisCreds = this.credentials;\n    if (!thisCreds.access_token && !thisCreds.refresh_token && !this.apiKey) {\n      throw new Error('No access, refresh token or API key is set.');\n    }\n\n    if (thisCreds.access_token && !this.isTokenExpiring()) {\n      thisCreds.token_type = thisCreds.token_type || 'Bearer';\n      const headers = {\n        Authorization: thisCreds.token_type + ' ' + thisCreds.access_token\n      };\n      return {headers};\n    }\n\n    if (this.apiKey) {\n      return {headers: {}};\n    }\n    let r: GetTokenResponse|null = null;\n    let tokens: Credentials|null = null;\n    try {\n      r = await this.refreshToken(thisCreds.refresh_token);\n      tokens = r.tokens;\n    } catch (err) {\n      const e = err as AxiosError;\n      if (e.response &&\n          (e.response.status === 403 || e.response.status === 404)) {\n        e.message = 'Could not refresh access token.';\n      }\n      throw e;\n    }\n\n    const credentials = this.credentials;\n    credentials.token_type = credentials.token_type || 'Bearer';\n    tokens.refresh_token = credentials.refresh_token;\n    this.credentials = tokens;\n    const headers = {\n      Authorization: credentials.token_type + ' ' + tokens.access_token\n    };\n    return {headers, res: r.res};\n  }\n\n  /**\n   * Revokes the access given to token.\n   * @param token The existing token to be revoked.\n   * @param callback Optional callback fn.\n   */\n  revokeToken(token: string): AxiosPromise;\n  revokeToken(\n      token: string,\n      callback: BodyResponseCallback): void;\n  revokeToken(\n      token: string, callback?: BodyResponseCallback):\n      AxiosPromise|void {\n    const opts = {\n      url: OAuth2Client.GOOGLE_OAUTH2_REVOKE_URL_ + '?' +\n          querystring.stringify({token}),\n      method: 'POST'\n    };\n    if (callback) {\n      this.transporter.request(opts).then(\n          r => callback(null, r), callback);\n    } else {\n      return this.transporter.request(opts);\n    }\n  }\n\n\n  /**\n   * Revokes access token and clears the credentials object\n   * @param callback callback\n   */\n  revokeCredentials(): AxiosPromise;\n  revokeCredentials(callback: BodyResponseCallback):\n      void;\n  revokeCredentials(callback?: BodyResponseCallback):\n      AxiosPromise|void {\n    if (callback) {\n      this.revokeCredentialsAsync().then(res => callback(null, res), callback);\n    } else {\n      return this.revokeCredentialsAsync();\n    }\n  }\n\n  private async revokeCredentialsAsync() {\n    const token = this.credentials.access_token;\n    this.credentials = {};\n    if (token) {\n      return this.revokeToken(token);\n    } else {\n      throw new Error('No access token to revoke.');\n    }\n  }\n\n  /**\n   * Provides a request implementation with OAuth 2.0 flow. If credentials have\n   * a refresh_token, in cases of HTTP 401 and 403 responses, it automatically\n   * asks for a new access token and replays the unsuccessful request.\n   * @param opts Request options.\n   * @param callback callback.\n   * @return Request object\n   */\n  request(opts: AxiosRequestConfig): AxiosPromise;\n  request(opts: AxiosRequestConfig, callback: BodyResponseCallback): void;\n  request(opts: AxiosRequestConfig, callback?: BodyResponseCallback):\n      AxiosPromise|void {\n    if (callback) {\n      this.requestAsync(opts).then(r => callback(null, r), e => {\n        return callback(e, e.response);\n      });\n    } else {\n      return this.requestAsync(opts);\n    }\n  }\n\n  protected async requestAsync(opts: AxiosRequestConfig, retry = false):\n      Promise> {\n    let r2: AxiosResponse;\n    try {\n      const r = await this.getRequestMetadataAsync(opts.url);\n      if (r.headers && r.headers.Authorization) {\n        opts.headers = opts.headers || {};\n        opts.headers.Authorization = r.headers.Authorization;\n      }\n\n      if (this.apiKey) {\n        opts.params = Object.assign(opts.params || {}, {key: this.apiKey});\n      }\n      r2 = await this.transporter.request(opts);\n    } catch (e) {\n      const res = (e as AxiosError).response;\n      if (res) {\n        const statusCode = res.status;\n        // Retry the request for metadata if the following criteria are true:\n        // - We haven't already retried.  It only makes sense to retry once.\n        // - The response was a 401 or a 403\n        // - The request didn't send a readableStream\n        // - An access_token and refresh_token were available, but no\n        //   expiry_date was availabe. This can happen when developers stash\n        //   the access_token and refresh_token for later use, but the\n        //   access_token fails on the first try because it's expired.\n        const mayRequireRefresh = this.credentials &&\n            this.credentials.access_token && this.credentials.refresh_token &&\n            !this.credentials.expiry_date;\n        const isReadableStream = res.config.data instanceof stream.Readable;\n        const isAuthErr = statusCode === 401 || statusCode === 403;\n        if (!retry && isAuthErr && !isReadableStream && mayRequireRefresh) {\n          await this.refreshAccessTokenAsync();\n          return this.requestAsync(opts, true);\n        }\n      }\n      throw e;\n    }\n    return r2;\n  }\n\n  /**\n   * Verify id token is token by checking the certs and audience\n   * @param options that contains all options.\n   * @param callback Callback supplying GoogleLogin if successful\n   */\n  verifyIdToken(options: VerifyIdTokenOptions): Promise;\n  verifyIdToken(\n      options: VerifyIdTokenOptions,\n      callback: (err: Error|null, login?: LoginTicket) => void): void;\n  verifyIdToken(\n      options: VerifyIdTokenOptions,\n      callback?: (err: Error|null, login?: LoginTicket) => void):\n      void|Promise {\n    // This function used to accept two arguments instead of an options object.\n    // Check the types to help users upgrade with less pain.\n    // This check can be removed after a 2.0 release.\n    if (callback && typeof callback !== 'function') {\n      throw new Error(\n          'This method accepts an options object as the first parameter, which includes the idToken, audience, and maxExpiry.');\n    }\n\n    if (callback) {\n      this.verifyIdTokenAsync(options).then(r => callback(null, r), callback);\n    } else {\n      return this.verifyIdTokenAsync(options);\n    }\n  }\n\n  private async verifyIdTokenAsync(options: VerifyIdTokenOptions):\n      Promise {\n    if (!options.idToken) {\n      throw new Error('The verifyIdToken method requires an ID Token');\n    }\n\n    const response = await this.getFederatedSignonCertsAsync();\n    const login = this.verifySignedJwtWithCerts(\n        options.idToken, response.certs, options.audience,\n        OAuth2Client.ISSUERS_, options.maxExpiry);\n\n    return login;\n  }\n\n  /**\n   * Obtains information about the provisioned access token.  Especially useful\n   * if you want to check the scopes that were provisioned to a given token.\n   *\n   * @param accessToken Required.  The Access Token for which you want to get\n   * user info.\n   */\n  async getTokenInfo(accessToken: string): Promise {\n    const {data} = await this.transporter.request({\n      method: 'GET',\n      url: OAuth2Client.GOOGLE_TOKEN_INFO_URL,\n      params: {access_token: accessToken}\n    });\n    const info = Object.assign(\n        {\n          expiry_date: ((new Date()).getTime() + (data.expires_in * 1000)),\n          scopes: data.scope.split(' ')\n        },\n        data);\n    delete info.expires_in;\n    delete info.scope;\n    return info;\n  }\n\n  /**\n   * Gets federated sign-on certificates to use for verifying identity tokens.\n   * Returns certs as array structure, where keys are key ids, and values\n   * are PEM encoded certificates.\n   * @param callback Callback supplying the certificates\n   */\n  getFederatedSignonCerts(): Promise;\n  getFederatedSignonCerts(callback: GetFederatedSignonCertsCallback): void;\n  getFederatedSignonCerts(callback?: GetFederatedSignonCertsCallback):\n      Promise|void {\n    if (callback) {\n      this.getFederatedSignonCertsAsync().then(\n          r => callback(null, r.certs, r.res), callback);\n    } else {\n      return this.getFederatedSignonCertsAsync();\n    }\n  }\n\n  async getFederatedSignonCertsAsync(): Promise {\n    const nowTime = (new Date()).getTime();\n    if (this.certificateExpiry &&\n        (nowTime = now + maxExpiry) {\n      throw new Error(\n          'Expiration time too far in future: ' + JSON.stringify(payload));\n    }\n\n    const earliest = iat - OAuth2Client.CLOCK_SKEW_SECS_;\n    const latest = exp + OAuth2Client.CLOCK_SKEW_SECS_;\n\n    if (now  latest) {\n      throw new Error(\n          'Token used too late, ' + now + ' > ' + latest + ': ' +\n          JSON.stringify(payload));\n    }\n\n    if (issuers && issuers.indexOf(payload.iss)  -1);\n      } else {\n        audVerified = (aud === requiredAudience);\n      }\n      if (!audVerified) {\n        throw new Error(\n            'Wrong recipient, payload audience != requiredAudience');\n      }\n    }\n    return new LoginTicket(envelope, payload);\n  }\n\n  /**\n   * This is a utils method to decode a base64 string\n   * @param b64String The string to base64 decode\n   * @return The decoded string\n   */\n  decodeBase64(b64String: string) {\n    const buffer = Buffer.from(b64String, 'base64');\n    return buffer.toString('utf8');\n  }\n\n  /**\n   * Returns true if a token is expired or will expire within\n   * eagerRefreshThresholdMillismilliseconds.\n   * If there is no expiry time, assumes the token is not expired or expiring.\n   */\n  protected isTokenExpiring(): boolean {\n    const expiryDate = this.credentials.expiry_date;\n    return expiryDate ? expiryDate \n    \n\n\n\n\n\n\n\n                   \n    \n         result-matching \"\"\n        \n    \n    \n        No results matching \"\"\n    \n\n"},"interfaces/GetFederatedSignonCertsCallback.html":{"url":"interfaces/GetFederatedSignonCertsCallback.html","title":"interface - GetFederatedSignonCertsCallback","body":"\n                   \n\n\n\n\n\n\n\n\n\n\n\n\n\n  Interfaces\n  GetFederatedSignonCertsCallback\n\n\n\n        \n            Info\n        \n        \n            Source\n        \n\n\n\n    \n        \n            File\n        \n        \n            src/auth/oauth2client.ts\n        \n\n\n\n        \n            Index\n            \n                \n                    \n                        \n                            Properties\n                        \n                    \n                    \n                        \n                            \n                                \n                                            Unamed property\n                                \n                            \n                        \n                    \n                \n            \n        \n\n\n\n            \n                Properties\n                    \n                        \n\n                                    \n                                        \n                                            Signature :\n                                            \n                                            \n                                                \n                                                    [err: AxiosError | null, certs: Certificates, response: AxiosResponse | null]\n                                            \n                                        \n                                    \n\n\n                                    \n                                        \n                                            Returns :     void\n\n                                        \n                                    \n\n\n\n\n                        \n                    \n            \n    \n\n\n    \n        import {AxiosError, AxiosPromise, AxiosRequestConfig, AxiosResponse} from 'axios';\nimport * as crypto from 'crypto';\nimport * as querystring from 'querystring';\nimport * as stream from 'stream';\nimport * as messages from '../messages';\nimport {PemVerifier} from './../pemverifier';\nimport {BodyResponseCallback} from './../transporters';\nimport {AuthClient} from './authclient';\nimport {CredentialRequest, Credentials} from './credentials';\nimport {LoginTicket, TokenPayload} from './loginticket';\n\nexport type Certificates = {\n  [index: string]: string\n};\n\nexport type Headers = {\n  [index: string]: string\n};\n\nexport enum CodeChallengeMethod {\n  Plain = 'plain',\n  S256 = 'S256'\n}\n\nexport interface GetTokenOptions {\n  code: string;\n  codeVerifier?: string;\n  /**\n   * The client ID for your application. The value passed into the constructor\n   * will be used if not provided. Must match any client_id option passed to\n   * a corresponding call to generateAuthUrl.\n   */\n  client_id?: string;\n  /**\n   * Determines where the API server redirects the user after the user\n   * completes the authorization flow. The value passed into the constructor\n   * will be used if not provided. Must match any redirect_uri option passed to\n   * a corresponding call to generateAuthUrl.\n   */\n  redirect_uri?: string;\n}\n\nexport interface TokenInfo {\n  /**\n   * The application that is the intended user of the access token.\n   */\n  aud: string;\n\n  /**\n   * This value lets you correlate profile information from multiple Google\n   * APIs. It is only present in the response if you included the profile scope\n   * in your request in step 1. The field value is an immutable identifier for\n   * the logged-in user that can be used to create and manage user sessions in\n   * your application. The identifier is the same regardless of which client ID\n   * is used to retrieve it. This enables multiple applications in the same\n   * organization to correlate profile information.\n   */\n  user_id?: string;\n\n  /**\n   * An array of scopes that the user granted access to.\n   */\n  scopes: string[];\n\n  /**\n   * The datetime when the token becomes invalid.\n   */\n  expiry_date: number;\n\n  /**\n   * An identifier for the user, unique among all Google accounts and never\n   * reused. A Google account can have multiple emails at different points in\n   * time, but the sub value is never changed. Use sub within your application\n   * as the unique-identifier key for the user.\n   */\n  sub?: string;\n\n  /**\n   * The client_id of the authorized presenter. This claim is only needed when\n   * the party requesting the ID token is not the same as the audience of the ID\n   * token. This may be the case at Google for hybrid apps where a web\n   * application and Android app have a different client_id but share the same\n   * project.\n   */\n  azp?: string;\n\n  /**\n   * Indicates whether your application can refresh access tokens\n   * when the user is not present at the browser. Valid parameter values are\n   * 'online', which is the default value, and 'offline'. Set the value to\n   * 'offline' if your application needs to refresh access tokens when the user\n   * is not present at the browser. This value instructs the Google\n   * authorization server to return a refresh token and an access token the\n   * first time that your application exchanges an authorization code for\n   * tokens.\n   */\n  access_type?: string;\n}\n\ninterface TokenInfoRequest {\n  aud: string;\n  user_id?: string;\n  scope: string;\n  expires_in: number;\n  azp?: string;\n  sub?: string;\n  exp?: number;\n  access_type?: string;\n}\n\nexport interface GenerateAuthUrlOpts {\n  /**\n   * Recommended. Indicates whether your application can refresh access tokens\n   * when the user is not present at the browser. Valid parameter values are\n   * 'online', which is the default value, and 'offline'. Set the value to\n   * 'offline' if your application needs to refresh access tokens when the user\n   * is not present at the browser. This value instructs the Google\n   * authorization server to return a refresh token and an access token the\n   * first time that your application exchanges an authorization code for\n   * tokens.\n   */\n  access_type?: string;\n\n  /**\n   * The hd (hosted domain) parameter streamlines the login process for G Suite\n   * hosted accounts. By including the domain of the G Suite user (for example,\n   * mycollege.edu), you can indicate that the account selection UI should be\n   * optimized for accounts at that domain. To optimize for G Suite accounts\n   * generally instead of just one domain, use an asterisk: hd=*.\n   * Don't rely on this UI optimization to control who can access your app,\n   * as client-side requests can be modified. Be sure to validate that the\n   * returned ID token has an hd claim value that matches what you expect\n   * (e.g. mycolledge.edu). Unlike the request parameter, the ID token claim is\n   * contained within a security token from Google, so the value can be trusted.\n   */\n  hd?: string;\n\n  /**\n   * The 'response_type' will always be set to 'CODE'.\n   */\n  response_type?: string;\n\n  /**\n   * The client ID for your application. The value passed into the constructor\n   * will be used if not provided. You can find this value in the API Console.\n   */\n  client_id?: string;\n\n  /**\n   * Determines where the API server redirects the user after the user\n   * completes the authorization flow. The value must exactly match one of the\n   * 'redirect_uri' values listed for your project in the API Console. Note that\n   * the http or https scheme, case, and trailing slash ('/') must all match.\n   * The value passed into the constructor will be used if not provided.\n   */\n  redirect_uri?: string;\n\n  /**\n   * Required. A space-delimited list of scopes that identify the resources that\n   * your application could access on the user's behalf. These values inform the\n   * consent screen that Google displays to the user. Scopes enable your\n   * application to only request access to the resources that it needs while\n   * also enabling users to control the amount of access that they grant to your\n   * application. Thus, there is an inverse relationship between the number of\n   * scopes requested and the likelihood of obtaining user consent. The\n   * OAuth 2.0 API Scopes document provides a full list of scopes that you might\n   * use to access Google APIs. We recommend that your application request\n   * access to authorization scopes in context whenever possible. By requesting\n   * access to user data in context, via incremental authorization, you help\n   * users to more easily understand why your application needs the access it is\n   * requesting.\n   */\n  scope?: string[]|string;\n\n  /**\n   * Recommended. Specifies any string value that your application uses to\n   * maintain state between your authorization request and the authorization\n   * server's response. The server returns the exact value that you send as a\n   * name=value pair in the hash (#) fragment of the 'redirect_uri' after the\n   * user consents to or denies your application's access request. You can use\n   * this parameter for several purposes, such as directing the user to the\n   * correct resource in your application, sending nonces, and mitigating\n   * cross-site request forgery. Since your redirect_uri can be guessed, using a\n   * state value can increase your assurance that an incoming connection is the\n   * result of an authentication request. If you generate a random string or\n   * encode the hash of a cookie or another value that captures the client's\n   * state, you can validate the response to additionally ensure that the\n   * request and response originated in the same browser, providing protection\n   * against attacks such as cross-site request forgery. See the OpenID Connect\n   * documentation for an example of how to create and confirm a state token.\n   */\n  state?: string;\n\n  /**\n   * Optional. Enables applications to use incremental authorization to request\n   * access to additional scopes in context. If you set this parameter's value\n   * to true and the authorization request is granted, then the new access token\n   * will also cover any scopes to which the user previously granted the\n   * application access. See the incremental authorization section for examples.\n   */\n  include_granted_scopes?: boolean;\n\n  /**\n   * Optional. If your application knows which user is trying to authenticate,\n   * it can use this parameter to provide a hint to the Google Authentication\n   * Server. The server uses the hint to simplify the login flow either by\n   * prefilling the email field in the sign-in form or by selecting the\n   * appropriate multi-login session. Set the parameter value to an email\n   * address or sub identifier, which is equivalent to the user's Google ID.\n   */\n  login_hint?: string;\n\n  /**\n   * Optional. A space-delimited, case-sensitive list of prompts to present the\n   * user. If you don't specify this parameter, the user will be prompted only\n   * the first time your app requests access.  Possible values are:\n   *\n   * 'none' - Donot display any authentication or consent screens. Must not be\n   *        specified with other values.\n   * 'consent' - \tPrompt the user for consent.\n   * 'select_account' - Prompt the user to select an account.\n   */\n  prompt?: string;\n\n  /**\n   * Recommended. Specifies what method was used to encode a 'code_verifier'\n   * that will be used during authorization code exchange. This parameter must\n   * be used with the 'code_challenge' parameter. The value of the\n   * 'code_challenge_method' defaults to \"plain\" if not present in the request\n   * that includes a 'code_challenge'. The only supported values for this\n   * parameter are \"S256\" or \"plain\".\n   */\n  code_challenge_method?: CodeChallengeMethod;\n\n  /**\n   * Recommended. Specifies an encoded 'code_verifier' that will be used as a\n   * server-side challenge during authorization code exchange. This parameter\n   * must be used with the 'code_challenge' parameter described above.\n   */\n  code_challenge?: string;\n}\n\nexport interface GetTokenCallback {\n  (err: AxiosError|null, token?: Credentials|null,\n   res?: AxiosResponse|null): void;\n}\n\nexport interface GetTokenResponse {\n  tokens: Credentials;\n  res: AxiosResponse|null;\n}\n\nexport interface GetAccessTokenCallback {\n  (err: AxiosError|null, token?: string|null, res?: AxiosResponse|null): void;\n}\n\nexport interface GetAccessTokenResponse {\n  token?: string|null;\n  res?: AxiosResponse|null;\n}\n\nexport interface RefreshAccessTokenCallback {\n  (err: AxiosError|null, credentials?: Credentials|null,\n   res?: AxiosResponse|null): void;\n}\n\nexport interface RefreshAccessTokenResponse {\n  credentials: Credentials;\n  res: AxiosResponse|null;\n}\n\nexport interface RequestMetadataResponse {\n  headers: Headers;\n  res?: AxiosResponse|null;\n}\n\nexport interface RequestMetadataCallback {\n  (err: AxiosError|null, headers?: Headers,\n   res?: AxiosResponse|null): void;\n}\n\nexport interface GetFederatedSignonCertsCallback {\n  (err: AxiosError|null, certs?: Certificates,\n   response?: AxiosResponse|null): void;\n}\n\nexport interface FederatedSignonCertsResponse {\n  certs: Certificates;\n  res?: AxiosResponse|null;\n}\n\nexport interface RevokeCredentialsResult {\n  success: boolean;\n}\n\nexport interface VerifyIdTokenOptions {\n  idToken: string;\n  audience: string|string[];\n  maxExpiry?: number;\n}\n\nexport interface OAuth2ClientOptions extends RefreshOptions {\n  clientId?: string;\n  clientSecret?: string;\n  redirectUri?: string;\n}\n\nexport interface RefreshOptions {\n  // Eagerly refresh unexpired tokens when they are within this many\n  // milliseconds from expiring\".\n  // Defaults to a value of 300000 (5 minutes).\n  eagerRefreshThresholdMillis?: number;\n}\n\nexport class OAuth2Client extends AuthClient {\n  private redirectUri?: string;\n  private certificateCache?: Certificates;\n  private certificateExpiry: Date|null = null;\n  protected refreshTokenPromises = new Map>();\n\n  // TODO: refactor tests to make this private\n  _clientId?: string;\n\n  // TODO: refactor tests to make this private\n  _clientSecret?: string;\n\n  apiKey?: string;\n\n  projectId?: string;\n\n  eagerRefreshThresholdMillis: number;\n\n  /**\n   * Handles OAuth2 flow for Google APIs.\n   *\n   * @param clientId The authentication client ID.\n   * @param clientSecret The authentication client secret.\n   * @param redirectUri The URI to redirect to after completing the auth\n   * request.\n   * @param opts optional options for overriding the given parameters.\n   * @constructor\n   */\n  constructor(options?: OAuth2ClientOptions);\n  constructor(clientId?: string, clientSecret?: string, redirectUri?: string);\n  constructor(\n      optionsOrClientId?: string|OAuth2ClientOptions, clientSecret?: string,\n      redirectUri?: string) {\n    super();\n    const opts = (optionsOrClientId && typeof optionsOrClientId === 'object') ?\n        optionsOrClientId :\n        {clientId: optionsOrClientId, clientSecret, redirectUri};\n    this._clientId = opts.clientId;\n    this._clientSecret = opts.clientSecret;\n    this.redirectUri = opts.redirectUri;\n    this.eagerRefreshThresholdMillis =\n        opts.eagerRefreshThresholdMillis || 5 * 60 * 1000;\n  }\n\n  protected static readonly GOOGLE_TOKEN_INFO_URL =\n      'https://oauth2.googleapis.com/tokeninfo';\n\n  /**\n   * The base URL for auth endpoints.\n   */\n  private static readonly GOOGLE_OAUTH2_AUTH_BASE_URL_ =\n      'https://accounts.google.com/o/oauth2/v2/auth';\n\n  /**\n   * The base endpoint for token retrieval.\n   */\n  private static readonly GOOGLE_OAUTH2_TOKEN_URL_ =\n      'https://oauth2.googleapis.com/token';\n\n  /**\n   * The base endpoint to revoke tokens.\n   */\n  private static readonly GOOGLE_OAUTH2_REVOKE_URL_ =\n      'https://oauth2.googleapis.com/revoke';\n\n  /**\n   * Google Sign on certificates.\n   */\n  private static readonly GOOGLE_OAUTH2_FEDERATED_SIGNON_CERTS_URL_ =\n      'https://www.googleapis.com/oauth2/v1/certs';\n\n  /**\n   * Clock skew - five minutes in seconds\n   */\n  private static readonly CLOCK_SKEW_SECS_ = 300;\n\n  /**\n   * Max Token Lifetime is one day in seconds\n   */\n  private static readonly MAX_TOKEN_LIFETIME_SECS_ = 86400;\n\n  /**\n   * The allowed oauth token issuers.\n   */\n  private static readonly ISSUERS_ =\n      ['accounts.google.com', 'https://accounts.google.com'];\n\n  /**\n   * Generates URL for consent page landing.\n   * @param opts Options.\n   * @return URL to consent page.\n   */\n  generateAuthUrl(opts: GenerateAuthUrlOpts = {}) {\n    if (opts.code_challenge_method && !opts.code_challenge) {\n      throw new Error(\n          'If a code_challenge_method is provided, code_challenge must be included.');\n    }\n    opts.response_type = opts.response_type || 'code';\n    opts.client_id = opts.client_id || this._clientId;\n    opts.redirect_uri = opts.redirect_uri || this.redirectUri;\n    // Allow scopes to be passed either as array or a string\n    if (opts.scope instanceof Array) {\n      opts.scope = opts.scope.join(' ');\n    }\n    const rootUrl = OAuth2Client.GOOGLE_OAUTH2_AUTH_BASE_URL_;\n    return rootUrl + '?' + querystring.stringify(opts);\n  }\n\n  /**\n   * Convenience method to automatically generate a code_verifier, and it's\n   * resulting SHA256. If used, this must be paired with a S256\n   * code_challenge_method.\n   */\n  generateCodeVerifier() {\n    // base64 encoding uses 6 bits per character, and we want to generate128\n    // characters. 6*128/8 = 96.\n    const randomString = crypto.randomBytes(96).toString('base64');\n    // The valid characters in the code_verifier are [A-Z]/[a-z]/[0-9]/\n    // \"-\"/\".\"/\"_\"/\"~\". Base64 encoded strings are pretty close, so we're just\n    // swapping out a few chars.\n    const codeVerifier =\n        randomString.replace(/\\+/g, '~').replace(/=/g, '_').replace(/\\//g, '-');\n    // Generate the base64 encoded SHA256\n    const unencodedCodeChallenge =\n        crypto.createHash('sha256').update(codeVerifier).digest('base64');\n    // We need to use base64UrlEncoding instead of standard base64\n    const codeChallenge = unencodedCodeChallenge.split('=')[0]\n                              .replace(/\\+/g, '-')\n                              .replace(/\\//g, '_');\n    return {codeVerifier, codeChallenge};\n  }\n\n  /**\n   * Gets the access token for the given code.\n   * @param code The authorization code.\n   * @param callback Optional callback fn.\n   */\n  getToken(code: string): Promise;\n  getToken(options: GetTokenOptions): Promise;\n  getToken(code: string, callback: GetTokenCallback): void;\n  getToken(options: GetTokenOptions, callback: GetTokenCallback): void;\n  getToken(codeOrOptions: string|GetTokenOptions, callback?: GetTokenCallback):\n      Promise|void {\n    const options = (typeof codeOrOptions === 'string') ?\n        {code: codeOrOptions} :\n        codeOrOptions;\n    if (callback) {\n      this.getTokenAsync(options).then(\n          r => callback(null, r.tokens, r.res),\n          e => callback(e, null, e.response));\n    } else {\n      return this.getTokenAsync(options);\n    }\n  }\n\n  private async getTokenAsync(options: GetTokenOptions):\n      Promise {\n    const url = OAuth2Client.GOOGLE_OAUTH2_TOKEN_URL_;\n    const values = {\n      code: options.code,\n      client_id: options.client_id || this._clientId,\n      client_secret: this._clientSecret,\n      redirect_uri: options.redirect_uri || this.redirectUri,\n      grant_type: 'authorization_code',\n      code_verifier: options.codeVerifier\n    };\n    const res = await this.transporter.request({\n      method: 'POST',\n      url,\n      data: querystring.stringify(values),\n      headers: {'Content-Type': 'application/x-www-form-urlencoded'}\n    });\n    const tokens = res.data as Credentials;\n    if (res.data && res.data.expires_in) {\n      tokens.expiry_date =\n          ((new Date()).getTime() + (res.data.expires_in * 1000));\n      delete (tokens as CredentialRequest).expires_in;\n    }\n    this.emit('tokens', tokens);\n    return {tokens, res};\n  }\n\n  /**\n   * Refreshes the access token.\n   * @param refresh_token Existing refresh token.\n   * @private\n   */\n  protected async refreshToken(refreshToken?: string|\n                               null): Promise {\n    if (!refreshToken) {\n      return this.refreshTokenNoCache(refreshToken);\n    }\n    // If a request to refresh using the same token has started,\n    // return the same promise.\n    if (this.refreshTokenPromises.has(refreshToken)) {\n      return this.refreshTokenPromises.get(refreshToken)!;\n    }\n\n    const p = this.refreshTokenNoCache(refreshToken)\n                  .then(\n                      r => {\n                        this.refreshTokenPromises.delete(refreshToken);\n                        return r;\n                      },\n                      e => {\n                        this.refreshTokenPromises.delete(refreshToken);\n                        throw e;\n                      });\n    this.refreshTokenPromises.set(refreshToken, p);\n    return p;\n  }\n\n  protected async refreshTokenNoCache(refreshToken?: string|\n                                      null): Promise {\n    const url = OAuth2Client.GOOGLE_OAUTH2_TOKEN_URL_;\n    const data = {\n      refresh_token: refreshToken,\n      client_id: this._clientId,\n      client_secret: this._clientSecret,\n      grant_type: 'refresh_token'\n    };\n\n    // request for new token\n    const res = await this.transporter.request({\n      method: 'POST',\n      url,\n      data: querystring.stringify(data),\n      headers: {'Content-Type': 'application/x-www-form-urlencoded'}\n    });\n\n    const tokens = res.data as Credentials;\n    // TODO: de-duplicate this code from a few spots\n    if (res.data && res.data.expires_in) {\n      tokens.expiry_date =\n          ((new Date()).getTime() + (res.data.expires_in * 1000));\n      delete (tokens as CredentialRequest).expires_in;\n    }\n    this.emit('tokens', tokens);\n    return {tokens, res};\n  }\n\n  /**\n   * Retrieves the access token using refresh token\n   *\n   * @deprecated use getRequestHeaders instead.\n   * @param callback callback\n   */\n  refreshAccessToken(): Promise;\n  refreshAccessToken(callback: RefreshAccessTokenCallback): void;\n  refreshAccessToken(callback?: RefreshAccessTokenCallback):\n      Promise|void {\n    messages.warn(messages.REFRESH_ACCESS_TOKEN_DEPRECATED);\n    if (callback) {\n      this.refreshAccessTokenAsync().then(\n          r => callback(null, r.credentials, r.res), callback);\n    } else {\n      return this.refreshAccessTokenAsync();\n    }\n  }\n\n  private async refreshAccessTokenAsync() {\n    if (!this.credentials.refresh_token) {\n      throw new Error('No refresh token is set.');\n    }\n    const r = await this.refreshToken(this.credentials.refresh_token);\n    const tokens = r.tokens as Credentials;\n    tokens.refresh_token = this.credentials.refresh_token;\n    this.credentials = tokens;\n    return {credentials: this.credentials, res: r.res};\n  }\n\n  /**\n   * Get a non-expired access token, after refreshing if necessary\n   *\n   * @param callback Callback to call with the access token\n   */\n  getAccessToken(): Promise;\n  getAccessToken(callback: GetAccessTokenCallback): void;\n  getAccessToken(callback?: GetAccessTokenCallback):\n      Promise|void {\n    if (callback) {\n      this.getAccessTokenAsync().then(\n          r => callback(null, r.token, r.res), callback);\n    } else {\n      return this.getAccessTokenAsync();\n    }\n  }\n\n  private async getAccessTokenAsync(): Promise {\n    const shouldRefresh =\n        !this.credentials.access_token || this.isTokenExpiring();\n    if (shouldRefresh && this.credentials.refresh_token) {\n      if (!this.credentials.refresh_token) {\n        throw new Error('No refresh token is set.');\n      }\n\n      const r = await this.refreshAccessTokenAsync();\n      if (!r.credentials || (r.credentials && !r.credentials.access_token)) {\n        throw new Error('Could not refresh access token.');\n      }\n      return {token: r.credentials.access_token, res: r.res};\n    } else {\n      return {token: this.credentials.access_token};\n    }\n  }\n\n  /**\n   * Obtain the set of headers required to authenticate a request.\n   *\n   * @deprecated Use getRequestHeaders instead.\n   * @param url the Uri being authorized\n   * @param callback the func described above\n   */\n  getRequestMetadata(url?: string|null): Promise;\n  getRequestMetadata(url: string|null, callback: RequestMetadataCallback): void;\n  getRequestMetadata(url: string|null, callback?: RequestMetadataCallback):\n      Promise|void {\n    messages.warn(messages.OAUTH_GET_REQUEST_METADATA_DEPRECATED);\n    if (callback) {\n      this.getRequestMetadataAsync(url).then(\n          r => callback(null, r.headers, r.res), callback);\n    } else {\n      return this.getRequestMetadataAsync();\n    }\n  }\n\n  /**\n   * The main authentication interface.  It takes an optional url which when\n   * present is the endpoint being accessed, and returns a Promise which\n   * resolves with authorization header fields.\n   *\n   * In OAuth2Client, the result has the form:\n   * { Authorization: 'Bearer ' }\n   * @param url The optional url being authorized\n   */\n  async getRequestHeaders(url?: string): Promise {\n    const res = await this.getRequestMetadataAsync(url);\n    return res.headers;\n  }\n\n  protected async getRequestMetadataAsync(url?: string|null):\n      Promise {\n    const thisCreds = this.credentials;\n    if (!thisCreds.access_token && !thisCreds.refresh_token && !this.apiKey) {\n      throw new Error('No access, refresh token or API key is set.');\n    }\n\n    if (thisCreds.access_token && !this.isTokenExpiring()) {\n      thisCreds.token_type = thisCreds.token_type || 'Bearer';\n      const headers = {\n        Authorization: thisCreds.token_type + ' ' + thisCreds.access_token\n      };\n      return {headers};\n    }\n\n    if (this.apiKey) {\n      return {headers: {}};\n    }\n    let r: GetTokenResponse|null = null;\n    let tokens: Credentials|null = null;\n    try {\n      r = await this.refreshToken(thisCreds.refresh_token);\n      tokens = r.tokens;\n    } catch (err) {\n      const e = err as AxiosError;\n      if (e.response &&\n          (e.response.status === 403 || e.response.status === 404)) {\n        e.message = 'Could not refresh access token.';\n      }\n      throw e;\n    }\n\n    const credentials = this.credentials;\n    credentials.token_type = credentials.token_type || 'Bearer';\n    tokens.refresh_token = credentials.refresh_token;\n    this.credentials = tokens;\n    const headers = {\n      Authorization: credentials.token_type + ' ' + tokens.access_token\n    };\n    return {headers, res: r.res};\n  }\n\n  /**\n   * Revokes the access given to token.\n   * @param token The existing token to be revoked.\n   * @param callback Optional callback fn.\n   */\n  revokeToken(token: string): AxiosPromise;\n  revokeToken(\n      token: string,\n      callback: BodyResponseCallback): void;\n  revokeToken(\n      token: string, callback?: BodyResponseCallback):\n      AxiosPromise|void {\n    const opts = {\n      url: OAuth2Client.GOOGLE_OAUTH2_REVOKE_URL_ + '?' +\n          querystring.stringify({token}),\n      method: 'POST'\n    };\n    if (callback) {\n      this.transporter.request(opts).then(\n          r => callback(null, r), callback);\n    } else {\n      return this.transporter.request(opts);\n    }\n  }\n\n\n  /**\n   * Revokes access token and clears the credentials object\n   * @param callback callback\n   */\n  revokeCredentials(): AxiosPromise;\n  revokeCredentials(callback: BodyResponseCallback):\n      void;\n  revokeCredentials(callback?: BodyResponseCallback):\n      AxiosPromise|void {\n    if (callback) {\n      this.revokeCredentialsAsync().then(res => callback(null, res), callback);\n    } else {\n      return this.revokeCredentialsAsync();\n    }\n  }\n\n  private async revokeCredentialsAsync() {\n    const token = this.credentials.access_token;\n    this.credentials = {};\n    if (token) {\n      return this.revokeToken(token);\n    } else {\n      throw new Error('No access token to revoke.');\n    }\n  }\n\n  /**\n   * Provides a request implementation with OAuth 2.0 flow. If credentials have\n   * a refresh_token, in cases of HTTP 401 and 403 responses, it automatically\n   * asks for a new access token and replays the unsuccessful request.\n   * @param opts Request options.\n   * @param callback callback.\n   * @return Request object\n   */\n  request(opts: AxiosRequestConfig): AxiosPromise;\n  request(opts: AxiosRequestConfig, callback: BodyResponseCallback): void;\n  request(opts: AxiosRequestConfig, callback?: BodyResponseCallback):\n      AxiosPromise|void {\n    if (callback) {\n      this.requestAsync(opts).then(r => callback(null, r), e => {\n        return callback(e, e.response);\n      });\n    } else {\n      return this.requestAsync(opts);\n    }\n  }\n\n  protected async requestAsync(opts: AxiosRequestConfig, retry = false):\n      Promise> {\n    let r2: AxiosResponse;\n    try {\n      const r = await this.getRequestMetadataAsync(opts.url);\n      if (r.headers && r.headers.Authorization) {\n        opts.headers = opts.headers || {};\n        opts.headers.Authorization = r.headers.Authorization;\n      }\n\n      if (this.apiKey) {\n        opts.params = Object.assign(opts.params || {}, {key: this.apiKey});\n      }\n      r2 = await this.transporter.request(opts);\n    } catch (e) {\n      const res = (e as AxiosError).response;\n      if (res) {\n        const statusCode = res.status;\n        // Retry the request for metadata if the following criteria are true:\n        // - We haven't already retried.  It only makes sense to retry once.\n        // - The response was a 401 or a 403\n        // - The request didn't send a readableStream\n        // - An access_token and refresh_token were available, but no\n        //   expiry_date was availabe. This can happen when developers stash\n        //   the access_token and refresh_token for later use, but the\n        //   access_token fails on the first try because it's expired.\n        const mayRequireRefresh = this.credentials &&\n            this.credentials.access_token && this.credentials.refresh_token &&\n            !this.credentials.expiry_date;\n        const isReadableStream = res.config.data instanceof stream.Readable;\n        const isAuthErr = statusCode === 401 || statusCode === 403;\n        if (!retry && isAuthErr && !isReadableStream && mayRequireRefresh) {\n          await this.refreshAccessTokenAsync();\n          return this.requestAsync(opts, true);\n        }\n      }\n      throw e;\n    }\n    return r2;\n  }\n\n  /**\n   * Verify id token is token by checking the certs and audience\n   * @param options that contains all options.\n   * @param callback Callback supplying GoogleLogin if successful\n   */\n  verifyIdToken(options: VerifyIdTokenOptions): Promise;\n  verifyIdToken(\n      options: VerifyIdTokenOptions,\n      callback: (err: Error|null, login?: LoginTicket) => void): void;\n  verifyIdToken(\n      options: VerifyIdTokenOptions,\n      callback?: (err: Error|null, login?: LoginTicket) => void):\n      void|Promise {\n    // This function used to accept two arguments instead of an options object.\n    // Check the types to help users upgrade with less pain.\n    // This check can be removed after a 2.0 release.\n    if (callback && typeof callback !== 'function') {\n      throw new Error(\n          'This method accepts an options object as the first parameter, which includes the idToken, audience, and maxExpiry.');\n    }\n\n    if (callback) {\n      this.verifyIdTokenAsync(options).then(r => callback(null, r), callback);\n    } else {\n      return this.verifyIdTokenAsync(options);\n    }\n  }\n\n  private async verifyIdTokenAsync(options: VerifyIdTokenOptions):\n      Promise {\n    if (!options.idToken) {\n      throw new Error('The verifyIdToken method requires an ID Token');\n    }\n\n    const response = await this.getFederatedSignonCertsAsync();\n    const login = this.verifySignedJwtWithCerts(\n        options.idToken, response.certs, options.audience,\n        OAuth2Client.ISSUERS_, options.maxExpiry);\n\n    return login;\n  }\n\n  /**\n   * Obtains information about the provisioned access token.  Especially useful\n   * if you want to check the scopes that were provisioned to a given token.\n   *\n   * @param accessToken Required.  The Access Token for which you want to get\n   * user info.\n   */\n  async getTokenInfo(accessToken: string): Promise {\n    const {data} = await this.transporter.request({\n      method: 'GET',\n      url: OAuth2Client.GOOGLE_TOKEN_INFO_URL,\n      params: {access_token: accessToken}\n    });\n    const info = Object.assign(\n        {\n          expiry_date: ((new Date()).getTime() + (data.expires_in * 1000)),\n          scopes: data.scope.split(' ')\n        },\n        data);\n    delete info.expires_in;\n    delete info.scope;\n    return info;\n  }\n\n  /**\n   * Gets federated sign-on certificates to use for verifying identity tokens.\n   * Returns certs as array structure, where keys are key ids, and values\n   * are PEM encoded certificates.\n   * @param callback Callback supplying the certificates\n   */\n  getFederatedSignonCerts(): Promise;\n  getFederatedSignonCerts(callback: GetFederatedSignonCertsCallback): void;\n  getFederatedSignonCerts(callback?: GetFederatedSignonCertsCallback):\n      Promise|void {\n    if (callback) {\n      this.getFederatedSignonCertsAsync().then(\n          r => callback(null, r.certs, r.res), callback);\n    } else {\n      return this.getFederatedSignonCertsAsync();\n    }\n  }\n\n  async getFederatedSignonCertsAsync(): Promise {\n    const nowTime = (new Date()).getTime();\n    if (this.certificateExpiry &&\n        (nowTime = now + maxExpiry) {\n      throw new Error(\n          'Expiration time too far in future: ' + JSON.stringify(payload));\n    }\n\n    const earliest = iat - OAuth2Client.CLOCK_SKEW_SECS_;\n    const latest = exp + OAuth2Client.CLOCK_SKEW_SECS_;\n\n    if (now  latest) {\n      throw new Error(\n          'Token used too late, ' + now + ' > ' + latest + ': ' +\n          JSON.stringify(payload));\n    }\n\n    if (issuers && issuers.indexOf(payload.iss)  -1);\n      } else {\n        audVerified = (aud === requiredAudience);\n      }\n      if (!audVerified) {\n        throw new Error(\n            'Wrong recipient, payload audience != requiredAudience');\n      }\n    }\n    return new LoginTicket(envelope, payload);\n  }\n\n  /**\n   * This is a utils method to decode a base64 string\n   * @param b64String The string to base64 decode\n   * @return The decoded string\n   */\n  decodeBase64(b64String: string) {\n    const buffer = Buffer.from(b64String, 'base64');\n    return buffer.toString('utf8');\n  }\n\n  /**\n   * Returns true if a token is expired or will expire within\n   * eagerRefreshThresholdMillismilliseconds.\n   * If there is no expiry time, assumes the token is not expired or expiring.\n   */\n  protected isTokenExpiring(): boolean {\n    const expiryDate = this.credentials.expiry_date;\n    return expiryDate ? expiryDate \n    \n\n\n\n\n\n\n\n                   \n    \n         result-matching \"\"\n        \n    \n    \n        No results matching \"\"\n    \n\n"},"interfaces/GetTokenCallback.html":{"url":"interfaces/GetTokenCallback.html","title":"interface - GetTokenCallback","body":"\n                   \n\n\n\n\n\n\n\n\n\n\n\n\n\n  Interfaces\n  GetTokenCallback\n\n\n\n        \n            Info\n        \n        \n            Source\n        \n\n\n\n    \n        \n            File\n        \n        \n            src/auth/oauth2client.ts\n        \n\n\n\n        \n            Index\n            \n                \n                    \n                        \n                            Properties\n                        \n                    \n                    \n                        \n                            \n                                \n                                            Unamed property\n                                \n                            \n                        \n                    \n                \n            \n        \n\n\n\n            \n                Properties\n                    \n                        \n\n                                    \n                                        \n                                            Signature :\n                                            \n                                            \n                                                \n                                                    [err: AxiosError | null, token: Credentials | null, res: AxiosResponse | null]\n                                            \n                                        \n                                    \n\n\n                                    \n                                        \n                                            Returns :     void\n\n                                        \n                                    \n\n\n\n\n                        \n                    \n            \n    \n\n\n    \n        import {AxiosError, AxiosPromise, AxiosRequestConfig, AxiosResponse} from 'axios';\nimport * as crypto from 'crypto';\nimport * as querystring from 'querystring';\nimport * as stream from 'stream';\nimport * as messages from '../messages';\nimport {PemVerifier} from './../pemverifier';\nimport {BodyResponseCallback} from './../transporters';\nimport {AuthClient} from './authclient';\nimport {CredentialRequest, Credentials} from './credentials';\nimport {LoginTicket, TokenPayload} from './loginticket';\n\nexport type Certificates = {\n  [index: string]: string\n};\n\nexport type Headers = {\n  [index: string]: string\n};\n\nexport enum CodeChallengeMethod {\n  Plain = 'plain',\n  S256 = 'S256'\n}\n\nexport interface GetTokenOptions {\n  code: string;\n  codeVerifier?: string;\n  /**\n   * The client ID for your application. The value passed into the constructor\n   * will be used if not provided. Must match any client_id option passed to\n   * a corresponding call to generateAuthUrl.\n   */\n  client_id?: string;\n  /**\n   * Determines where the API server redirects the user after the user\n   * completes the authorization flow. The value passed into the constructor\n   * will be used if not provided. Must match any redirect_uri option passed to\n   * a corresponding call to generateAuthUrl.\n   */\n  redirect_uri?: string;\n}\n\nexport interface TokenInfo {\n  /**\n   * The application that is the intended user of the access token.\n   */\n  aud: string;\n\n  /**\n   * This value lets you correlate profile information from multiple Google\n   * APIs. It is only present in the response if you included the profile scope\n   * in your request in step 1. The field value is an immutable identifier for\n   * the logged-in user that can be used to create and manage user sessions in\n   * your application. The identifier is the same regardless of which client ID\n   * is used to retrieve it. This enables multiple applications in the same\n   * organization to correlate profile information.\n   */\n  user_id?: string;\n\n  /**\n   * An array of scopes that the user granted access to.\n   */\n  scopes: string[];\n\n  /**\n   * The datetime when the token becomes invalid.\n   */\n  expiry_date: number;\n\n  /**\n   * An identifier for the user, unique among all Google accounts and never\n   * reused. A Google account can have multiple emails at different points in\n   * time, but the sub value is never changed. Use sub within your application\n   * as the unique-identifier key for the user.\n   */\n  sub?: string;\n\n  /**\n   * The client_id of the authorized presenter. This claim is only needed when\n   * the party requesting the ID token is not the same as the audience of the ID\n   * token. This may be the case at Google for hybrid apps where a web\n   * application and Android app have a different client_id but share the same\n   * project.\n   */\n  azp?: string;\n\n  /**\n   * Indicates whether your application can refresh access tokens\n   * when the user is not present at the browser. Valid parameter values are\n   * 'online', which is the default value, and 'offline'. Set the value to\n   * 'offline' if your application needs to refresh access tokens when the user\n   * is not present at the browser. This value instructs the Google\n   * authorization server to return a refresh token and an access token the\n   * first time that your application exchanges an authorization code for\n   * tokens.\n   */\n  access_type?: string;\n}\n\ninterface TokenInfoRequest {\n  aud: string;\n  user_id?: string;\n  scope: string;\n  expires_in: number;\n  azp?: string;\n  sub?: string;\n  exp?: number;\n  access_type?: string;\n}\n\nexport interface GenerateAuthUrlOpts {\n  /**\n   * Recommended. Indicates whether your application can refresh access tokens\n   * when the user is not present at the browser. Valid parameter values are\n   * 'online', which is the default value, and 'offline'. Set the value to\n   * 'offline' if your application needs to refresh access tokens when the user\n   * is not present at the browser. This value instructs the Google\n   * authorization server to return a refresh token and an access token the\n   * first time that your application exchanges an authorization code for\n   * tokens.\n   */\n  access_type?: string;\n\n  /**\n   * The hd (hosted domain) parameter streamlines the login process for G Suite\n   * hosted accounts. By including the domain of the G Suite user (for example,\n   * mycollege.edu), you can indicate that the account selection UI should be\n   * optimized for accounts at that domain. To optimize for G Suite accounts\n   * generally instead of just one domain, use an asterisk: hd=*.\n   * Don't rely on this UI optimization to control who can access your app,\n   * as client-side requests can be modified. Be sure to validate that the\n   * returned ID token has an hd claim value that matches what you expect\n   * (e.g. mycolledge.edu). Unlike the request parameter, the ID token claim is\n   * contained within a security token from Google, so the value can be trusted.\n   */\n  hd?: string;\n\n  /**\n   * The 'response_type' will always be set to 'CODE'.\n   */\n  response_type?: string;\n\n  /**\n   * The client ID for your application. The value passed into the constructor\n   * will be used if not provided. You can find this value in the API Console.\n   */\n  client_id?: string;\n\n  /**\n   * Determines where the API server redirects the user after the user\n   * completes the authorization flow. The value must exactly match one of the\n   * 'redirect_uri' values listed for your project in the API Console. Note that\n   * the http or https scheme, case, and trailing slash ('/') must all match.\n   * The value passed into the constructor will be used if not provided.\n   */\n  redirect_uri?: string;\n\n  /**\n   * Required. A space-delimited list of scopes that identify the resources that\n   * your application could access on the user's behalf. These values inform the\n   * consent screen that Google displays to the user. Scopes enable your\n   * application to only request access to the resources that it needs while\n   * also enabling users to control the amount of access that they grant to your\n   * application. Thus, there is an inverse relationship between the number of\n   * scopes requested and the likelihood of obtaining user consent. The\n   * OAuth 2.0 API Scopes document provides a full list of scopes that you might\n   * use to access Google APIs. We recommend that your application request\n   * access to authorization scopes in context whenever possible. By requesting\n   * access to user data in context, via incremental authorization, you help\n   * users to more easily understand why your application needs the access it is\n   * requesting.\n   */\n  scope?: string[]|string;\n\n  /**\n   * Recommended. Specifies any string value that your application uses to\n   * maintain state between your authorization request and the authorization\n   * server's response. The server returns the exact value that you send as a\n   * name=value pair in the hash (#) fragment of the 'redirect_uri' after the\n   * user consents to or denies your application's access request. You can use\n   * this parameter for several purposes, such as directing the user to the\n   * correct resource in your application, sending nonces, and mitigating\n   * cross-site request forgery. Since your redirect_uri can be guessed, using a\n   * state value can increase your assurance that an incoming connection is the\n   * result of an authentication request. If you generate a random string or\n   * encode the hash of a cookie or another value that captures the client's\n   * state, you can validate the response to additionally ensure that the\n   * request and response originated in the same browser, providing protection\n   * against attacks such as cross-site request forgery. See the OpenID Connect\n   * documentation for an example of how to create and confirm a state token.\n   */\n  state?: string;\n\n  /**\n   * Optional. Enables applications to use incremental authorization to request\n   * access to additional scopes in context. If you set this parameter's value\n   * to true and the authorization request is granted, then the new access token\n   * will also cover any scopes to which the user previously granted the\n   * application access. See the incremental authorization section for examples.\n   */\n  include_granted_scopes?: boolean;\n\n  /**\n   * Optional. If your application knows which user is trying to authenticate,\n   * it can use this parameter to provide a hint to the Google Authentication\n   * Server. The server uses the hint to simplify the login flow either by\n   * prefilling the email field in the sign-in form or by selecting the\n   * appropriate multi-login session. Set the parameter value to an email\n   * address or sub identifier, which is equivalent to the user's Google ID.\n   */\n  login_hint?: string;\n\n  /**\n   * Optional. A space-delimited, case-sensitive list of prompts to present the\n   * user. If you don't specify this parameter, the user will be prompted only\n   * the first time your app requests access.  Possible values are:\n   *\n   * 'none' - Donot display any authentication or consent screens. Must not be\n   *        specified with other values.\n   * 'consent' - \tPrompt the user for consent.\n   * 'select_account' - Prompt the user to select an account.\n   */\n  prompt?: string;\n\n  /**\n   * Recommended. Specifies what method was used to encode a 'code_verifier'\n   * that will be used during authorization code exchange. This parameter must\n   * be used with the 'code_challenge' parameter. The value of the\n   * 'code_challenge_method' defaults to \"plain\" if not present in the request\n   * that includes a 'code_challenge'. The only supported values for this\n   * parameter are \"S256\" or \"plain\".\n   */\n  code_challenge_method?: CodeChallengeMethod;\n\n  /**\n   * Recommended. Specifies an encoded 'code_verifier' that will be used as a\n   * server-side challenge during authorization code exchange. This parameter\n   * must be used with the 'code_challenge' parameter described above.\n   */\n  code_challenge?: string;\n}\n\nexport interface GetTokenCallback {\n  (err: AxiosError|null, token?: Credentials|null,\n   res?: AxiosResponse|null): void;\n}\n\nexport interface GetTokenResponse {\n  tokens: Credentials;\n  res: AxiosResponse|null;\n}\n\nexport interface GetAccessTokenCallback {\n  (err: AxiosError|null, token?: string|null, res?: AxiosResponse|null): void;\n}\n\nexport interface GetAccessTokenResponse {\n  token?: string|null;\n  res?: AxiosResponse|null;\n}\n\nexport interface RefreshAccessTokenCallback {\n  (err: AxiosError|null, credentials?: Credentials|null,\n   res?: AxiosResponse|null): void;\n}\n\nexport interface RefreshAccessTokenResponse {\n  credentials: Credentials;\n  res: AxiosResponse|null;\n}\n\nexport interface RequestMetadataResponse {\n  headers: Headers;\n  res?: AxiosResponse|null;\n}\n\nexport interface RequestMetadataCallback {\n  (err: AxiosError|null, headers?: Headers,\n   res?: AxiosResponse|null): void;\n}\n\nexport interface GetFederatedSignonCertsCallback {\n  (err: AxiosError|null, certs?: Certificates,\n   response?: AxiosResponse|null): void;\n}\n\nexport interface FederatedSignonCertsResponse {\n  certs: Certificates;\n  res?: AxiosResponse|null;\n}\n\nexport interface RevokeCredentialsResult {\n  success: boolean;\n}\n\nexport interface VerifyIdTokenOptions {\n  idToken: string;\n  audience: string|string[];\n  maxExpiry?: number;\n}\n\nexport interface OAuth2ClientOptions extends RefreshOptions {\n  clientId?: string;\n  clientSecret?: string;\n  redirectUri?: string;\n}\n\nexport interface RefreshOptions {\n  // Eagerly refresh unexpired tokens when they are within this many\n  // milliseconds from expiring\".\n  // Defaults to a value of 300000 (5 minutes).\n  eagerRefreshThresholdMillis?: number;\n}\n\nexport class OAuth2Client extends AuthClient {\n  private redirectUri?: string;\n  private certificateCache?: Certificates;\n  private certificateExpiry: Date|null = null;\n  protected refreshTokenPromises = new Map>();\n\n  // TODO: refactor tests to make this private\n  _clientId?: string;\n\n  // TODO: refactor tests to make this private\n  _clientSecret?: string;\n\n  apiKey?: string;\n\n  projectId?: string;\n\n  eagerRefreshThresholdMillis: number;\n\n  /**\n   * Handles OAuth2 flow for Google APIs.\n   *\n   * @param clientId The authentication client ID.\n   * @param clientSecret The authentication client secret.\n   * @param redirectUri The URI to redirect to after completing the auth\n   * request.\n   * @param opts optional options for overriding the given parameters.\n   * @constructor\n   */\n  constructor(options?: OAuth2ClientOptions);\n  constructor(clientId?: string, clientSecret?: string, redirectUri?: string);\n  constructor(\n      optionsOrClientId?: string|OAuth2ClientOptions, clientSecret?: string,\n      redirectUri?: string) {\n    super();\n    const opts = (optionsOrClientId && typeof optionsOrClientId === 'object') ?\n        optionsOrClientId :\n        {clientId: optionsOrClientId, clientSecret, redirectUri};\n    this._clientId = opts.clientId;\n    this._clientSecret = opts.clientSecret;\n    this.redirectUri = opts.redirectUri;\n    this.eagerRefreshThresholdMillis =\n        opts.eagerRefreshThresholdMillis || 5 * 60 * 1000;\n  }\n\n  protected static readonly GOOGLE_TOKEN_INFO_URL =\n      'https://oauth2.googleapis.com/tokeninfo';\n\n  /**\n   * The base URL for auth endpoints.\n   */\n  private static readonly GOOGLE_OAUTH2_AUTH_BASE_URL_ =\n      'https://accounts.google.com/o/oauth2/v2/auth';\n\n  /**\n   * The base endpoint for token retrieval.\n   */\n  private static readonly GOOGLE_OAUTH2_TOKEN_URL_ =\n      'https://oauth2.googleapis.com/token';\n\n  /**\n   * The base endpoint to revoke tokens.\n   */\n  private static readonly GOOGLE_OAUTH2_REVOKE_URL_ =\n      'https://oauth2.googleapis.com/revoke';\n\n  /**\n   * Google Sign on certificates.\n   */\n  private static readonly GOOGLE_OAUTH2_FEDERATED_SIGNON_CERTS_URL_ =\n      'https://www.googleapis.com/oauth2/v1/certs';\n\n  /**\n   * Clock skew - five minutes in seconds\n   */\n  private static readonly CLOCK_SKEW_SECS_ = 300;\n\n  /**\n   * Max Token Lifetime is one day in seconds\n   */\n  private static readonly MAX_TOKEN_LIFETIME_SECS_ = 86400;\n\n  /**\n   * The allowed oauth token issuers.\n   */\n  private static readonly ISSUERS_ =\n      ['accounts.google.com', 'https://accounts.google.com'];\n\n  /**\n   * Generates URL for consent page landing.\n   * @param opts Options.\n   * @return URL to consent page.\n   */\n  generateAuthUrl(opts: GenerateAuthUrlOpts = {}) {\n    if (opts.code_challenge_method && !opts.code_challenge) {\n      throw new Error(\n          'If a code_challenge_method is provided, code_challenge must be included.');\n    }\n    opts.response_type = opts.response_type || 'code';\n    opts.client_id = opts.client_id || this._clientId;\n    opts.redirect_uri = opts.redirect_uri || this.redirectUri;\n    // Allow scopes to be passed either as array or a string\n    if (opts.scope instanceof Array) {\n      opts.scope = opts.scope.join(' ');\n    }\n    const rootUrl = OAuth2Client.GOOGLE_OAUTH2_AUTH_BASE_URL_;\n    return rootUrl + '?' + querystring.stringify(opts);\n  }\n\n  /**\n   * Convenience method to automatically generate a code_verifier, and it's\n   * resulting SHA256. If used, this must be paired with a S256\n   * code_challenge_method.\n   */\n  generateCodeVerifier() {\n    // base64 encoding uses 6 bits per character, and we want to generate128\n    // characters. 6*128/8 = 96.\n    const randomString = crypto.randomBytes(96).toString('base64');\n    // The valid characters in the code_verifier are [A-Z]/[a-z]/[0-9]/\n    // \"-\"/\".\"/\"_\"/\"~\". Base64 encoded strings are pretty close, so we're just\n    // swapping out a few chars.\n    const codeVerifier =\n        randomString.replace(/\\+/g, '~').replace(/=/g, '_').replace(/\\//g, '-');\n    // Generate the base64 encoded SHA256\n    const unencodedCodeChallenge =\n        crypto.createHash('sha256').update(codeVerifier).digest('base64');\n    // We need to use base64UrlEncoding instead of standard base64\n    const codeChallenge = unencodedCodeChallenge.split('=')[0]\n                              .replace(/\\+/g, '-')\n                              .replace(/\\//g, '_');\n    return {codeVerifier, codeChallenge};\n  }\n\n  /**\n   * Gets the access token for the given code.\n   * @param code The authorization code.\n   * @param callback Optional callback fn.\n   */\n  getToken(code: string): Promise;\n  getToken(options: GetTokenOptions): Promise;\n  getToken(code: string, callback: GetTokenCallback): void;\n  getToken(options: GetTokenOptions, callback: GetTokenCallback): void;\n  getToken(codeOrOptions: string|GetTokenOptions, callback?: GetTokenCallback):\n      Promise|void {\n    const options = (typeof codeOrOptions === 'string') ?\n        {code: codeOrOptions} :\n        codeOrOptions;\n    if (callback) {\n      this.getTokenAsync(options).then(\n          r => callback(null, r.tokens, r.res),\n          e => callback(e, null, e.response));\n    } else {\n      return this.getTokenAsync(options);\n    }\n  }\n\n  private async getTokenAsync(options: GetTokenOptions):\n      Promise {\n    const url = OAuth2Client.GOOGLE_OAUTH2_TOKEN_URL_;\n    const values = {\n      code: options.code,\n      client_id: options.client_id || this._clientId,\n      client_secret: this._clientSecret,\n      redirect_uri: options.redirect_uri || this.redirectUri,\n      grant_type: 'authorization_code',\n      code_verifier: options.codeVerifier\n    };\n    const res = await this.transporter.request({\n      method: 'POST',\n      url,\n      data: querystring.stringify(values),\n      headers: {'Content-Type': 'application/x-www-form-urlencoded'}\n    });\n    const tokens = res.data as Credentials;\n    if (res.data && res.data.expires_in) {\n      tokens.expiry_date =\n          ((new Date()).getTime() + (res.data.expires_in * 1000));\n      delete (tokens as CredentialRequest).expires_in;\n    }\n    this.emit('tokens', tokens);\n    return {tokens, res};\n  }\n\n  /**\n   * Refreshes the access token.\n   * @param refresh_token Existing refresh token.\n   * @private\n   */\n  protected async refreshToken(refreshToken?: string|\n                               null): Promise {\n    if (!refreshToken) {\n      return this.refreshTokenNoCache(refreshToken);\n    }\n    // If a request to refresh using the same token has started,\n    // return the same promise.\n    if (this.refreshTokenPromises.has(refreshToken)) {\n      return this.refreshTokenPromises.get(refreshToken)!;\n    }\n\n    const p = this.refreshTokenNoCache(refreshToken)\n                  .then(\n                      r => {\n                        this.refreshTokenPromises.delete(refreshToken);\n                        return r;\n                      },\n                      e => {\n                        this.refreshTokenPromises.delete(refreshToken);\n                        throw e;\n                      });\n    this.refreshTokenPromises.set(refreshToken, p);\n    return p;\n  }\n\n  protected async refreshTokenNoCache(refreshToken?: string|\n                                      null): Promise {\n    const url = OAuth2Client.GOOGLE_OAUTH2_TOKEN_URL_;\n    const data = {\n      refresh_token: refreshToken,\n      client_id: this._clientId,\n      client_secret: this._clientSecret,\n      grant_type: 'refresh_token'\n    };\n\n    // request for new token\n    const res = await this.transporter.request({\n      method: 'POST',\n      url,\n      data: querystring.stringify(data),\n      headers: {'Content-Type': 'application/x-www-form-urlencoded'}\n    });\n\n    const tokens = res.data as Credentials;\n    // TODO: de-duplicate this code from a few spots\n    if (res.data && res.data.expires_in) {\n      tokens.expiry_date =\n          ((new Date()).getTime() + (res.data.expires_in * 1000));\n      delete (tokens as CredentialRequest).expires_in;\n    }\n    this.emit('tokens', tokens);\n    return {tokens, res};\n  }\n\n  /**\n   * Retrieves the access token using refresh token\n   *\n   * @deprecated use getRequestHeaders instead.\n   * @param callback callback\n   */\n  refreshAccessToken(): Promise;\n  refreshAccessToken(callback: RefreshAccessTokenCallback): void;\n  refreshAccessToken(callback?: RefreshAccessTokenCallback):\n      Promise|void {\n    messages.warn(messages.REFRESH_ACCESS_TOKEN_DEPRECATED);\n    if (callback) {\n      this.refreshAccessTokenAsync().then(\n          r => callback(null, r.credentials, r.res), callback);\n    } else {\n      return this.refreshAccessTokenAsync();\n    }\n  }\n\n  private async refreshAccessTokenAsync() {\n    if (!this.credentials.refresh_token) {\n      throw new Error('No refresh token is set.');\n    }\n    const r = await this.refreshToken(this.credentials.refresh_token);\n    const tokens = r.tokens as Credentials;\n    tokens.refresh_token = this.credentials.refresh_token;\n    this.credentials = tokens;\n    return {credentials: this.credentials, res: r.res};\n  }\n\n  /**\n   * Get a non-expired access token, after refreshing if necessary\n   *\n   * @param callback Callback to call with the access token\n   */\n  getAccessToken(): Promise;\n  getAccessToken(callback: GetAccessTokenCallback): void;\n  getAccessToken(callback?: GetAccessTokenCallback):\n      Promise|void {\n    if (callback) {\n      this.getAccessTokenAsync().then(\n          r => callback(null, r.token, r.res), callback);\n    } else {\n      return this.getAccessTokenAsync();\n    }\n  }\n\n  private async getAccessTokenAsync(): Promise {\n    const shouldRefresh =\n        !this.credentials.access_token || this.isTokenExpiring();\n    if (shouldRefresh && this.credentials.refresh_token) {\n      if (!this.credentials.refresh_token) {\n        throw new Error('No refresh token is set.');\n      }\n\n      const r = await this.refreshAccessTokenAsync();\n      if (!r.credentials || (r.credentials && !r.credentials.access_token)) {\n        throw new Error('Could not refresh access token.');\n      }\n      return {token: r.credentials.access_token, res: r.res};\n    } else {\n      return {token: this.credentials.access_token};\n    }\n  }\n\n  /**\n   * Obtain the set of headers required to authenticate a request.\n   *\n   * @deprecated Use getRequestHeaders instead.\n   * @param url the Uri being authorized\n   * @param callback the func described above\n   */\n  getRequestMetadata(url?: string|null): Promise;\n  getRequestMetadata(url: string|null, callback: RequestMetadataCallback): void;\n  getRequestMetadata(url: string|null, callback?: RequestMetadataCallback):\n      Promise|void {\n    messages.warn(messages.OAUTH_GET_REQUEST_METADATA_DEPRECATED);\n    if (callback) {\n      this.getRequestMetadataAsync(url).then(\n          r => callback(null, r.headers, r.res), callback);\n    } else {\n      return this.getRequestMetadataAsync();\n    }\n  }\n\n  /**\n   * The main authentication interface.  It takes an optional url which when\n   * present is the endpoint being accessed, and returns a Promise which\n   * resolves with authorization header fields.\n   *\n   * In OAuth2Client, the result has the form:\n   * { Authorization: 'Bearer ' }\n   * @param url The optional url being authorized\n   */\n  async getRequestHeaders(url?: string): Promise {\n    const res = await this.getRequestMetadataAsync(url);\n    return res.headers;\n  }\n\n  protected async getRequestMetadataAsync(url?: string|null):\n      Promise {\n    const thisCreds = this.credentials;\n    if (!thisCreds.access_token && !thisCreds.refresh_token && !this.apiKey) {\n      throw new Error('No access, refresh token or API key is set.');\n    }\n\n    if (thisCreds.access_token && !this.isTokenExpiring()) {\n      thisCreds.token_type = thisCreds.token_type || 'Bearer';\n      const headers = {\n        Authorization: thisCreds.token_type + ' ' + thisCreds.access_token\n      };\n      return {headers};\n    }\n\n    if (this.apiKey) {\n      return {headers: {}};\n    }\n    let r: GetTokenResponse|null = null;\n    let tokens: Credentials|null = null;\n    try {\n      r = await this.refreshToken(thisCreds.refresh_token);\n      tokens = r.tokens;\n    } catch (err) {\n      const e = err as AxiosError;\n      if (e.response &&\n          (e.response.status === 403 || e.response.status === 404)) {\n        e.message = 'Could not refresh access token.';\n      }\n      throw e;\n    }\n\n    const credentials = this.credentials;\n    credentials.token_type = credentials.token_type || 'Bearer';\n    tokens.refresh_token = credentials.refresh_token;\n    this.credentials = tokens;\n    const headers = {\n      Authorization: credentials.token_type + ' ' + tokens.access_token\n    };\n    return {headers, res: r.res};\n  }\n\n  /**\n   * Revokes the access given to token.\n   * @param token The existing token to be revoked.\n   * @param callback Optional callback fn.\n   */\n  revokeToken(token: string): AxiosPromise;\n  revokeToken(\n      token: string,\n      callback: BodyResponseCallback): void;\n  revokeToken(\n      token: string, callback?: BodyResponseCallback):\n      AxiosPromise|void {\n    const opts = {\n      url: OAuth2Client.GOOGLE_OAUTH2_REVOKE_URL_ + '?' +\n          querystring.stringify({token}),\n      method: 'POST'\n    };\n    if (callback) {\n      this.transporter.request(opts).then(\n          r => callback(null, r), callback);\n    } else {\n      return this.transporter.request(opts);\n    }\n  }\n\n\n  /**\n   * Revokes access token and clears the credentials object\n   * @param callback callback\n   */\n  revokeCredentials(): AxiosPromise;\n  revokeCredentials(callback: BodyResponseCallback):\n      void;\n  revokeCredentials(callback?: BodyResponseCallback):\n      AxiosPromise|void {\n    if (callback) {\n      this.revokeCredentialsAsync().then(res => callback(null, res), callback);\n    } else {\n      return this.revokeCredentialsAsync();\n    }\n  }\n\n  private async revokeCredentialsAsync() {\n    const token = this.credentials.access_token;\n    this.credentials = {};\n    if (token) {\n      return this.revokeToken(token);\n    } else {\n      throw new Error('No access token to revoke.');\n    }\n  }\n\n  /**\n   * Provides a request implementation with OAuth 2.0 flow. If credentials have\n   * a refresh_token, in cases of HTTP 401 and 403 responses, it automatically\n   * asks for a new access token and replays the unsuccessful request.\n   * @param opts Request options.\n   * @param callback callback.\n   * @return Request object\n   */\n  request(opts: AxiosRequestConfig): AxiosPromise;\n  request(opts: AxiosRequestConfig, callback: BodyResponseCallback): void;\n  request(opts: AxiosRequestConfig, callback?: BodyResponseCallback):\n      AxiosPromise|void {\n    if (callback) {\n      this.requestAsync(opts).then(r => callback(null, r), e => {\n        return callback(e, e.response);\n      });\n    } else {\n      return this.requestAsync(opts);\n    }\n  }\n\n  protected async requestAsync(opts: AxiosRequestConfig, retry = false):\n      Promise> {\n    let r2: AxiosResponse;\n    try {\n      const r = await this.getRequestMetadataAsync(opts.url);\n      if (r.headers && r.headers.Authorization) {\n        opts.headers = opts.headers || {};\n        opts.headers.Authorization = r.headers.Authorization;\n      }\n\n      if (this.apiKey) {\n        opts.params = Object.assign(opts.params || {}, {key: this.apiKey});\n      }\n      r2 = await this.transporter.request(opts);\n    } catch (e) {\n      const res = (e as AxiosError).response;\n      if (res) {\n        const statusCode = res.status;\n        // Retry the request for metadata if the following criteria are true:\n        // - We haven't already retried.  It only makes sense to retry once.\n        // - The response was a 401 or a 403\n        // - The request didn't send a readableStream\n        // - An access_token and refresh_token were available, but no\n        //   expiry_date was availabe. This can happen when developers stash\n        //   the access_token and refresh_token for later use, but the\n        //   access_token fails on the first try because it's expired.\n        const mayRequireRefresh = this.credentials &&\n            this.credentials.access_token && this.credentials.refresh_token &&\n            !this.credentials.expiry_date;\n        const isReadableStream = res.config.data instanceof stream.Readable;\n        const isAuthErr = statusCode === 401 || statusCode === 403;\n        if (!retry && isAuthErr && !isReadableStream && mayRequireRefresh) {\n          await this.refreshAccessTokenAsync();\n          return this.requestAsync(opts, true);\n        }\n      }\n      throw e;\n    }\n    return r2;\n  }\n\n  /**\n   * Verify id token is token by checking the certs and audience\n   * @param options that contains all options.\n   * @param callback Callback supplying GoogleLogin if successful\n   */\n  verifyIdToken(options: VerifyIdTokenOptions): Promise;\n  verifyIdToken(\n      options: VerifyIdTokenOptions,\n      callback: (err: Error|null, login?: LoginTicket) => void): void;\n  verifyIdToken(\n      options: VerifyIdTokenOptions,\n      callback?: (err: Error|null, login?: LoginTicket) => void):\n      void|Promise {\n    // This function used to accept two arguments instead of an options object.\n    // Check the types to help users upgrade with less pain.\n    // This check can be removed after a 2.0 release.\n    if (callback && typeof callback !== 'function') {\n      throw new Error(\n          'This method accepts an options object as the first parameter, which includes the idToken, audience, and maxExpiry.');\n    }\n\n    if (callback) {\n      this.verifyIdTokenAsync(options).then(r => callback(null, r), callback);\n    } else {\n      return this.verifyIdTokenAsync(options);\n    }\n  }\n\n  private async verifyIdTokenAsync(options: VerifyIdTokenOptions):\n      Promise {\n    if (!options.idToken) {\n      throw new Error('The verifyIdToken method requires an ID Token');\n    }\n\n    const response = await this.getFederatedSignonCertsAsync();\n    const login = this.verifySignedJwtWithCerts(\n        options.idToken, response.certs, options.audience,\n        OAuth2Client.ISSUERS_, options.maxExpiry);\n\n    return login;\n  }\n\n  /**\n   * Obtains information about the provisioned access token.  Especially useful\n   * if you want to check the scopes that were provisioned to a given token.\n   *\n   * @param accessToken Required.  The Access Token for which you want to get\n   * user info.\n   */\n  async getTokenInfo(accessToken: string): Promise {\n    const {data} = await this.transporter.request({\n      method: 'GET',\n      url: OAuth2Client.GOOGLE_TOKEN_INFO_URL,\n      params: {access_token: accessToken}\n    });\n    const info = Object.assign(\n        {\n          expiry_date: ((new Date()).getTime() + (data.expires_in * 1000)),\n          scopes: data.scope.split(' ')\n        },\n        data);\n    delete info.expires_in;\n    delete info.scope;\n    return info;\n  }\n\n  /**\n   * Gets federated sign-on certificates to use for verifying identity tokens.\n   * Returns certs as array structure, where keys are key ids, and values\n   * are PEM encoded certificates.\n   * @param callback Callback supplying the certificates\n   */\n  getFederatedSignonCerts(): Promise;\n  getFederatedSignonCerts(callback: GetFederatedSignonCertsCallback): void;\n  getFederatedSignonCerts(callback?: GetFederatedSignonCertsCallback):\n      Promise|void {\n    if (callback) {\n      this.getFederatedSignonCertsAsync().then(\n          r => callback(null, r.certs, r.res), callback);\n    } else {\n      return this.getFederatedSignonCertsAsync();\n    }\n  }\n\n  async getFederatedSignonCertsAsync(): Promise {\n    const nowTime = (new Date()).getTime();\n    if (this.certificateExpiry &&\n        (nowTime = now + maxExpiry) {\n      throw new Error(\n          'Expiration time too far in future: ' + JSON.stringify(payload));\n    }\n\n    const earliest = iat - OAuth2Client.CLOCK_SKEW_SECS_;\n    const latest = exp + OAuth2Client.CLOCK_SKEW_SECS_;\n\n    if (now  latest) {\n      throw new Error(\n          'Token used too late, ' + now + ' > ' + latest + ': ' +\n          JSON.stringify(payload));\n    }\n\n    if (issuers && issuers.indexOf(payload.iss)  -1);\n      } else {\n        audVerified = (aud === requiredAudience);\n      }\n      if (!audVerified) {\n        throw new Error(\n            'Wrong recipient, payload audience != requiredAudience');\n      }\n    }\n    return new LoginTicket(envelope, payload);\n  }\n\n  /**\n   * This is a utils method to decode a base64 string\n   * @param b64String The string to base64 decode\n   * @return The decoded string\n   */\n  decodeBase64(b64String: string) {\n    const buffer = Buffer.from(b64String, 'base64');\n    return buffer.toString('utf8');\n  }\n\n  /**\n   * Returns true if a token is expired or will expire within\n   * eagerRefreshThresholdMillismilliseconds.\n   * If there is no expiry time, assumes the token is not expired or expiring.\n   */\n  protected isTokenExpiring(): boolean {\n    const expiryDate = this.credentials.expiry_date;\n    return expiryDate ? expiryDate \n    \n\n\n\n\n\n\n\n                   \n    \n         result-matching \"\"\n        \n    \n    \n        No results matching \"\"\n    \n\n"},"interfaces/GetTokenOptions.html":{"url":"interfaces/GetTokenOptions.html","title":"interface - GetTokenOptions","body":"\n                   \n\n\n\n\n\n\n\n\n\n\n\n\n\n  Interfaces\n  GetTokenOptions\n\n\n\n        \n            Info\n        \n        \n            Source\n        \n\n\n\n    \n        \n            File\n        \n        \n            src/auth/oauth2client.ts\n        \n\n\n\n        \n            Index\n            \n                \n                    \n                        \n                            Properties\n                        \n                    \n                    \n                        \n                            \n                                \n                                            Optional\n                                        client_id\n                                \n                                \n                                        code\n                                \n                                \n                                            Optional\n                                        codeVerifier\n                                \n                                \n                                            Optional\n                                        redirect_uri\n                                \n                            \n                        \n                    \n                \n            \n        \n\n\n\n            \n                Properties\n                    \n                        \n                                \n                                    \n                                        \n                                        client_id\n                                    \n                                \n                                \n                                    \n                                        client_id:     string\n\n                                    \n                                \n\n\n                                    \n                                        \n                                            Type :     string\n\n                                        \n                                    \n\n                                    \n                                        \n                                            Optional\n                                        \n                                    \n\n\n\n\n                            \n                                \n                                    The client ID for your application. The value passed into the constructor\nwill be used if not provided. Must match any client_id option passed to\na corresponding call to generateAuthUrl.\n\n                                \n                            \n                        \n                    \n                    \n                        \n                                \n                                    \n                                        \n                                        code\n                                    \n                                \n                                \n                                    \n                                        code:     string\n\n                                    \n                                \n\n\n                                    \n                                        \n                                            Type :     string\n\n                                        \n                                    \n\n\n\n\n\n                        \n                    \n                    \n                        \n                                \n                                    \n                                        \n                                        codeVerifier\n                                    \n                                \n                                \n                                    \n                                        codeVerifier:     string\n\n                                    \n                                \n\n\n                                    \n                                        \n                                            Type :     string\n\n                                        \n                                    \n\n                                    \n                                        \n                                            Optional\n                                        \n                                    \n\n\n\n\n                        \n                    \n                    \n                        \n                                \n                                    \n                                        \n                                        redirect_uri\n                                    \n                                \n                                \n                                    \n                                        redirect_uri:     string\n\n                                    \n                                \n\n\n                                    \n                                        \n                                            Type :     string\n\n                                        \n                                    \n\n                                    \n                                        \n                                            Optional\n                                        \n                                    \n\n\n\n\n                            \n                                \n                                    Determines where the API server redirects the user after the user\ncompletes the authorization flow. The value passed into the constructor\nwill be used if not provided. Must match any redirect_uri option passed to\na corresponding call to generateAuthUrl.\n\n                                \n                            \n                        \n                    \n            \n    \n\n\n    \n        import {AxiosError, AxiosPromise, AxiosRequestConfig, AxiosResponse} from 'axios';\nimport * as crypto from 'crypto';\nimport * as querystring from 'querystring';\nimport * as stream from 'stream';\nimport * as messages from '../messages';\nimport {PemVerifier} from './../pemverifier';\nimport {BodyResponseCallback} from './../transporters';\nimport {AuthClient} from './authclient';\nimport {CredentialRequest, Credentials} from './credentials';\nimport {LoginTicket, TokenPayload} from './loginticket';\n\nexport type Certificates = {\n  [index: string]: string\n};\n\nexport type Headers = {\n  [index: string]: string\n};\n\nexport enum CodeChallengeMethod {\n  Plain = 'plain',\n  S256 = 'S256'\n}\n\nexport interface GetTokenOptions {\n  code: string;\n  codeVerifier?: string;\n  /**\n   * The client ID for your application. The value passed into the constructor\n   * will be used if not provided. Must match any client_id option passed to\n   * a corresponding call to generateAuthUrl.\n   */\n  client_id?: string;\n  /**\n   * Determines where the API server redirects the user after the user\n   * completes the authorization flow. The value passed into the constructor\n   * will be used if not provided. Must match any redirect_uri option passed to\n   * a corresponding call to generateAuthUrl.\n   */\n  redirect_uri?: string;\n}\n\nexport interface TokenInfo {\n  /**\n   * The application that is the intended user of the access token.\n   */\n  aud: string;\n\n  /**\n   * This value lets you correlate profile information from multiple Google\n   * APIs. It is only present in the response if you included the profile scope\n   * in your request in step 1. The field value is an immutable identifier for\n   * the logged-in user that can be used to create and manage user sessions in\n   * your application. The identifier is the same regardless of which client ID\n   * is used to retrieve it. This enables multiple applications in the same\n   * organization to correlate profile information.\n   */\n  user_id?: string;\n\n  /**\n   * An array of scopes that the user granted access to.\n   */\n  scopes: string[];\n\n  /**\n   * The datetime when the token becomes invalid.\n   */\n  expiry_date: number;\n\n  /**\n   * An identifier for the user, unique among all Google accounts and never\n   * reused. A Google account can have multiple emails at different points in\n   * time, but the sub value is never changed. Use sub within your application\n   * as the unique-identifier key for the user.\n   */\n  sub?: string;\n\n  /**\n   * The client_id of the authorized presenter. This claim is only needed when\n   * the party requesting the ID token is not the same as the audience of the ID\n   * token. This may be the case at Google for hybrid apps where a web\n   * application and Android app have a different client_id but share the same\n   * project.\n   */\n  azp?: string;\n\n  /**\n   * Indicates whether your application can refresh access tokens\n   * when the user is not present at the browser. Valid parameter values are\n   * 'online', which is the default value, and 'offline'. Set the value to\n   * 'offline' if your application needs to refresh access tokens when the user\n   * is not present at the browser. This value instructs the Google\n   * authorization server to return a refresh token and an access token the\n   * first time that your application exchanges an authorization code for\n   * tokens.\n   */\n  access_type?: string;\n}\n\ninterface TokenInfoRequest {\n  aud: string;\n  user_id?: string;\n  scope: string;\n  expires_in: number;\n  azp?: string;\n  sub?: string;\n  exp?: number;\n  access_type?: string;\n}\n\nexport interface GenerateAuthUrlOpts {\n  /**\n   * Recommended. Indicates whether your application can refresh access tokens\n   * when the user is not present at the browser. Valid parameter values are\n   * 'online', which is the default value, and 'offline'. Set the value to\n   * 'offline' if your application needs to refresh access tokens when the user\n   * is not present at the browser. This value instructs the Google\n   * authorization server to return a refresh token and an access token the\n   * first time that your application exchanges an authorization code for\n   * tokens.\n   */\n  access_type?: string;\n\n  /**\n   * The hd (hosted domain) parameter streamlines the login process for G Suite\n   * hosted accounts. By including the domain of the G Suite user (for example,\n   * mycollege.edu), you can indicate that the account selection UI should be\n   * optimized for accounts at that domain. To optimize for G Suite accounts\n   * generally instead of just one domain, use an asterisk: hd=*.\n   * Don't rely on this UI optimization to control who can access your app,\n   * as client-side requests can be modified. Be sure to validate that the\n   * returned ID token has an hd claim value that matches what you expect\n   * (e.g. mycolledge.edu). Unlike the request parameter, the ID token claim is\n   * contained within a security token from Google, so the value can be trusted.\n   */\n  hd?: string;\n\n  /**\n   * The 'response_type' will always be set to 'CODE'.\n   */\n  response_type?: string;\n\n  /**\n   * The client ID for your application. The value passed into the constructor\n   * will be used if not provided. You can find this value in the API Console.\n   */\n  client_id?: string;\n\n  /**\n   * Determines where the API server redirects the user after the user\n   * completes the authorization flow. The value must exactly match one of the\n   * 'redirect_uri' values listed for your project in the API Console. Note that\n   * the http or https scheme, case, and trailing slash ('/') must all match.\n   * The value passed into the constructor will be used if not provided.\n   */\n  redirect_uri?: string;\n\n  /**\n   * Required. A space-delimited list of scopes that identify the resources that\n   * your application could access on the user's behalf. These values inform the\n   * consent screen that Google displays to the user. Scopes enable your\n   * application to only request access to the resources that it needs while\n   * also enabling users to control the amount of access that they grant to your\n   * application. Thus, there is an inverse relationship between the number of\n   * scopes requested and the likelihood of obtaining user consent. The\n   * OAuth 2.0 API Scopes document provides a full list of scopes that you might\n   * use to access Google APIs. We recommend that your application request\n   * access to authorization scopes in context whenever possible. By requesting\n   * access to user data in context, via incremental authorization, you help\n   * users to more easily understand why your application needs the access it is\n   * requesting.\n   */\n  scope?: string[]|string;\n\n  /**\n   * Recommended. Specifies any string value that your application uses to\n   * maintain state between your authorization request and the authorization\n   * server's response. The server returns the exact value that you send as a\n   * name=value pair in the hash (#) fragment of the 'redirect_uri' after the\n   * user consents to or denies your application's access request. You can use\n   * this parameter for several purposes, such as directing the user to the\n   * correct resource in your application, sending nonces, and mitigating\n   * cross-site request forgery. Since your redirect_uri can be guessed, using a\n   * state value can increase your assurance that an incoming connection is the\n   * result of an authentication request. If you generate a random string or\n   * encode the hash of a cookie or another value that captures the client's\n   * state, you can validate the response to additionally ensure that the\n   * request and response originated in the same browser, providing protection\n   * against attacks such as cross-site request forgery. See the OpenID Connect\n   * documentation for an example of how to create and confirm a state token.\n   */\n  state?: string;\n\n  /**\n   * Optional. Enables applications to use incremental authorization to request\n   * access to additional scopes in context. If you set this parameter's value\n   * to true and the authorization request is granted, then the new access token\n   * will also cover any scopes to which the user previously granted the\n   * application access. See the incremental authorization section for examples.\n   */\n  include_granted_scopes?: boolean;\n\n  /**\n   * Optional. If your application knows which user is trying to authenticate,\n   * it can use this parameter to provide a hint to the Google Authentication\n   * Server. The server uses the hint to simplify the login flow either by\n   * prefilling the email field in the sign-in form or by selecting the\n   * appropriate multi-login session. Set the parameter value to an email\n   * address or sub identifier, which is equivalent to the user's Google ID.\n   */\n  login_hint?: string;\n\n  /**\n   * Optional. A space-delimited, case-sensitive list of prompts to present the\n   * user. If you don't specify this parameter, the user will be prompted only\n   * the first time your app requests access.  Possible values are:\n   *\n   * 'none' - Donot display any authentication or consent screens. Must not be\n   *        specified with other values.\n   * 'consent' - \tPrompt the user for consent.\n   * 'select_account' - Prompt the user to select an account.\n   */\n  prompt?: string;\n\n  /**\n   * Recommended. Specifies what method was used to encode a 'code_verifier'\n   * that will be used during authorization code exchange. This parameter must\n   * be used with the 'code_challenge' parameter. The value of the\n   * 'code_challenge_method' defaults to \"plain\" if not present in the request\n   * that includes a 'code_challenge'. The only supported values for this\n   * parameter are \"S256\" or \"plain\".\n   */\n  code_challenge_method?: CodeChallengeMethod;\n\n  /**\n   * Recommended. Specifies an encoded 'code_verifier' that will be used as a\n   * server-side challenge during authorization code exchange. This parameter\n   * must be used with the 'code_challenge' parameter described above.\n   */\n  code_challenge?: string;\n}\n\nexport interface GetTokenCallback {\n  (err: AxiosError|null, token?: Credentials|null,\n   res?: AxiosResponse|null): void;\n}\n\nexport interface GetTokenResponse {\n  tokens: Credentials;\n  res: AxiosResponse|null;\n}\n\nexport interface GetAccessTokenCallback {\n  (err: AxiosError|null, token?: string|null, res?: AxiosResponse|null): void;\n}\n\nexport interface GetAccessTokenResponse {\n  token?: string|null;\n  res?: AxiosResponse|null;\n}\n\nexport interface RefreshAccessTokenCallback {\n  (err: AxiosError|null, credentials?: Credentials|null,\n   res?: AxiosResponse|null): void;\n}\n\nexport interface RefreshAccessTokenResponse {\n  credentials: Credentials;\n  res: AxiosResponse|null;\n}\n\nexport interface RequestMetadataResponse {\n  headers: Headers;\n  res?: AxiosResponse|null;\n}\n\nexport interface RequestMetadataCallback {\n  (err: AxiosError|null, headers?: Headers,\n   res?: AxiosResponse|null): void;\n}\n\nexport interface GetFederatedSignonCertsCallback {\n  (err: AxiosError|null, certs?: Certificates,\n   response?: AxiosResponse|null): void;\n}\n\nexport interface FederatedSignonCertsResponse {\n  certs: Certificates;\n  res?: AxiosResponse|null;\n}\n\nexport interface RevokeCredentialsResult {\n  success: boolean;\n}\n\nexport interface VerifyIdTokenOptions {\n  idToken: string;\n  audience: string|string[];\n  maxExpiry?: number;\n}\n\nexport interface OAuth2ClientOptions extends RefreshOptions {\n  clientId?: string;\n  clientSecret?: string;\n  redirectUri?: string;\n}\n\nexport interface RefreshOptions {\n  // Eagerly refresh unexpired tokens when they are within this many\n  // milliseconds from expiring\".\n  // Defaults to a value of 300000 (5 minutes).\n  eagerRefreshThresholdMillis?: number;\n}\n\nexport class OAuth2Client extends AuthClient {\n  private redirectUri?: string;\n  private certificateCache?: Certificates;\n  private certificateExpiry: Date|null = null;\n  protected refreshTokenPromises = new Map>();\n\n  // TODO: refactor tests to make this private\n  _clientId?: string;\n\n  // TODO: refactor tests to make this private\n  _clientSecret?: string;\n\n  apiKey?: string;\n\n  projectId?: string;\n\n  eagerRefreshThresholdMillis: number;\n\n  /**\n   * Handles OAuth2 flow for Google APIs.\n   *\n   * @param clientId The authentication client ID.\n   * @param clientSecret The authentication client secret.\n   * @param redirectUri The URI to redirect to after completing the auth\n   * request.\n   * @param opts optional options for overriding the given parameters.\n   * @constructor\n   */\n  constructor(options?: OAuth2ClientOptions);\n  constructor(clientId?: string, clientSecret?: string, redirectUri?: string);\n  constructor(\n      optionsOrClientId?: string|OAuth2ClientOptions, clientSecret?: string,\n      redirectUri?: string) {\n    super();\n    const opts = (optionsOrClientId && typeof optionsOrClientId === 'object') ?\n        optionsOrClientId :\n        {clientId: optionsOrClientId, clientSecret, redirectUri};\n    this._clientId = opts.clientId;\n    this._clientSecret = opts.clientSecret;\n    this.redirectUri = opts.redirectUri;\n    this.eagerRefreshThresholdMillis =\n        opts.eagerRefreshThresholdMillis || 5 * 60 * 1000;\n  }\n\n  protected static readonly GOOGLE_TOKEN_INFO_URL =\n      'https://oauth2.googleapis.com/tokeninfo';\n\n  /**\n   * The base URL for auth endpoints.\n   */\n  private static readonly GOOGLE_OAUTH2_AUTH_BASE_URL_ =\n      'https://accounts.google.com/o/oauth2/v2/auth';\n\n  /**\n   * The base endpoint for token retrieval.\n   */\n  private static readonly GOOGLE_OAUTH2_TOKEN_URL_ =\n      'https://oauth2.googleapis.com/token';\n\n  /**\n   * The base endpoint to revoke tokens.\n   */\n  private static readonly GOOGLE_OAUTH2_REVOKE_URL_ =\n      'https://oauth2.googleapis.com/revoke';\n\n  /**\n   * Google Sign on certificates.\n   */\n  private static readonly GOOGLE_OAUTH2_FEDERATED_SIGNON_CERTS_URL_ =\n      'https://www.googleapis.com/oauth2/v1/certs';\n\n  /**\n   * Clock skew - five minutes in seconds\n   */\n  private static readonly CLOCK_SKEW_SECS_ = 300;\n\n  /**\n   * Max Token Lifetime is one day in seconds\n   */\n  private static readonly MAX_TOKEN_LIFETIME_SECS_ = 86400;\n\n  /**\n   * The allowed oauth token issuers.\n   */\n  private static readonly ISSUERS_ =\n      ['accounts.google.com', 'https://accounts.google.com'];\n\n  /**\n   * Generates URL for consent page landing.\n   * @param opts Options.\n   * @return URL to consent page.\n   */\n  generateAuthUrl(opts: GenerateAuthUrlOpts = {}) {\n    if (opts.code_challenge_method && !opts.code_challenge) {\n      throw new Error(\n          'If a code_challenge_method is provided, code_challenge must be included.');\n    }\n    opts.response_type = opts.response_type || 'code';\n    opts.client_id = opts.client_id || this._clientId;\n    opts.redirect_uri = opts.redirect_uri || this.redirectUri;\n    // Allow scopes to be passed either as array or a string\n    if (opts.scope instanceof Array) {\n      opts.scope = opts.scope.join(' ');\n    }\n    const rootUrl = OAuth2Client.GOOGLE_OAUTH2_AUTH_BASE_URL_;\n    return rootUrl + '?' + querystring.stringify(opts);\n  }\n\n  /**\n   * Convenience method to automatically generate a code_verifier, and it's\n   * resulting SHA256. If used, this must be paired with a S256\n   * code_challenge_method.\n   */\n  generateCodeVerifier() {\n    // base64 encoding uses 6 bits per character, and we want to generate128\n    // characters. 6*128/8 = 96.\n    const randomString = crypto.randomBytes(96).toString('base64');\n    // The valid characters in the code_verifier are [A-Z]/[a-z]/[0-9]/\n    // \"-\"/\".\"/\"_\"/\"~\". Base64 encoded strings are pretty close, so we're just\n    // swapping out a few chars.\n    const codeVerifier =\n        randomString.replace(/\\+/g, '~').replace(/=/g, '_').replace(/\\//g, '-');\n    // Generate the base64 encoded SHA256\n    const unencodedCodeChallenge =\n        crypto.createHash('sha256').update(codeVerifier).digest('base64');\n    // We need to use base64UrlEncoding instead of standard base64\n    const codeChallenge = unencodedCodeChallenge.split('=')[0]\n                              .replace(/\\+/g, '-')\n                              .replace(/\\//g, '_');\n    return {codeVerifier, codeChallenge};\n  }\n\n  /**\n   * Gets the access token for the given code.\n   * @param code The authorization code.\n   * @param callback Optional callback fn.\n   */\n  getToken(code: string): Promise;\n  getToken(options: GetTokenOptions): Promise;\n  getToken(code: string, callback: GetTokenCallback): void;\n  getToken(options: GetTokenOptions, callback: GetTokenCallback): void;\n  getToken(codeOrOptions: string|GetTokenOptions, callback?: GetTokenCallback):\n      Promise|void {\n    const options = (typeof codeOrOptions === 'string') ?\n        {code: codeOrOptions} :\n        codeOrOptions;\n    if (callback) {\n      this.getTokenAsync(options).then(\n          r => callback(null, r.tokens, r.res),\n          e => callback(e, null, e.response));\n    } else {\n      return this.getTokenAsync(options);\n    }\n  }\n\n  private async getTokenAsync(options: GetTokenOptions):\n      Promise {\n    const url = OAuth2Client.GOOGLE_OAUTH2_TOKEN_URL_;\n    const values = {\n      code: options.code,\n      client_id: options.client_id || this._clientId,\n      client_secret: this._clientSecret,\n      redirect_uri: options.redirect_uri || this.redirectUri,\n      grant_type: 'authorization_code',\n      code_verifier: options.codeVerifier\n    };\n    const res = await this.transporter.request({\n      method: 'POST',\n      url,\n      data: querystring.stringify(values),\n      headers: {'Content-Type': 'application/x-www-form-urlencoded'}\n    });\n    const tokens = res.data as Credentials;\n    if (res.data && res.data.expires_in) {\n      tokens.expiry_date =\n          ((new Date()).getTime() + (res.data.expires_in * 1000));\n      delete (tokens as CredentialRequest).expires_in;\n    }\n    this.emit('tokens', tokens);\n    return {tokens, res};\n  }\n\n  /**\n   * Refreshes the access token.\n   * @param refresh_token Existing refresh token.\n   * @private\n   */\n  protected async refreshToken(refreshToken?: string|\n                               null): Promise {\n    if (!refreshToken) {\n      return this.refreshTokenNoCache(refreshToken);\n    }\n    // If a request to refresh using the same token has started,\n    // return the same promise.\n    if (this.refreshTokenPromises.has(refreshToken)) {\n      return this.refreshTokenPromises.get(refreshToken)!;\n    }\n\n    const p = this.refreshTokenNoCache(refreshToken)\n                  .then(\n                      r => {\n                        this.refreshTokenPromises.delete(refreshToken);\n                        return r;\n                      },\n                      e => {\n                        this.refreshTokenPromises.delete(refreshToken);\n                        throw e;\n                      });\n    this.refreshTokenPromises.set(refreshToken, p);\n    return p;\n  }\n\n  protected async refreshTokenNoCache(refreshToken?: string|\n                                      null): Promise {\n    const url = OAuth2Client.GOOGLE_OAUTH2_TOKEN_URL_;\n    const data = {\n      refresh_token: refreshToken,\n      client_id: this._clientId,\n      client_secret: this._clientSecret,\n      grant_type: 'refresh_token'\n    };\n\n    // request for new token\n    const res = await this.transporter.request({\n      method: 'POST',\n      url,\n      data: querystring.stringify(data),\n      headers: {'Content-Type': 'application/x-www-form-urlencoded'}\n    });\n\n    const tokens = res.data as Credentials;\n    // TODO: de-duplicate this code from a few spots\n    if (res.data && res.data.expires_in) {\n      tokens.expiry_date =\n          ((new Date()).getTime() + (res.data.expires_in * 1000));\n      delete (tokens as CredentialRequest).expires_in;\n    }\n    this.emit('tokens', tokens);\n    return {tokens, res};\n  }\n\n  /**\n   * Retrieves the access token using refresh token\n   *\n   * @deprecated use getRequestHeaders instead.\n   * @param callback callback\n   */\n  refreshAccessToken(): Promise;\n  refreshAccessToken(callback: RefreshAccessTokenCallback): void;\n  refreshAccessToken(callback?: RefreshAccessTokenCallback):\n      Promise|void {\n    messages.warn(messages.REFRESH_ACCESS_TOKEN_DEPRECATED);\n    if (callback) {\n      this.refreshAccessTokenAsync().then(\n          r => callback(null, r.credentials, r.res), callback);\n    } else {\n      return this.refreshAccessTokenAsync();\n    }\n  }\n\n  private async refreshAccessTokenAsync() {\n    if (!this.credentials.refresh_token) {\n      throw new Error('No refresh token is set.');\n    }\n    const r = await this.refreshToken(this.credentials.refresh_token);\n    const tokens = r.tokens as Credentials;\n    tokens.refresh_token = this.credentials.refresh_token;\n    this.credentials = tokens;\n    return {credentials: this.credentials, res: r.res};\n  }\n\n  /**\n   * Get a non-expired access token, after refreshing if necessary\n   *\n   * @param callback Callback to call with the access token\n   */\n  getAccessToken(): Promise;\n  getAccessToken(callback: GetAccessTokenCallback): void;\n  getAccessToken(callback?: GetAccessTokenCallback):\n      Promise|void {\n    if (callback) {\n      this.getAccessTokenAsync().then(\n          r => callback(null, r.token, r.res), callback);\n    } else {\n      return this.getAccessTokenAsync();\n    }\n  }\n\n  private async getAccessTokenAsync(): Promise {\n    const shouldRefresh =\n        !this.credentials.access_token || this.isTokenExpiring();\n    if (shouldRefresh && this.credentials.refresh_token) {\n      if (!this.credentials.refresh_token) {\n        throw new Error('No refresh token is set.');\n      }\n\n      const r = await this.refreshAccessTokenAsync();\n      if (!r.credentials || (r.credentials && !r.credentials.access_token)) {\n        throw new Error('Could not refresh access token.');\n      }\n      return {token: r.credentials.access_token, res: r.res};\n    } else {\n      return {token: this.credentials.access_token};\n    }\n  }\n\n  /**\n   * Obtain the set of headers required to authenticate a request.\n   *\n   * @deprecated Use getRequestHeaders instead.\n   * @param url the Uri being authorized\n   * @param callback the func described above\n   */\n  getRequestMetadata(url?: string|null): Promise;\n  getRequestMetadata(url: string|null, callback: RequestMetadataCallback): void;\n  getRequestMetadata(url: string|null, callback?: RequestMetadataCallback):\n      Promise|void {\n    messages.warn(messages.OAUTH_GET_REQUEST_METADATA_DEPRECATED);\n    if (callback) {\n      this.getRequestMetadataAsync(url).then(\n          r => callback(null, r.headers, r.res), callback);\n    } else {\n      return this.getRequestMetadataAsync();\n    }\n  }\n\n  /**\n   * The main authentication interface.  It takes an optional url which when\n   * present is the endpoint being accessed, and returns a Promise which\n   * resolves with authorization header fields.\n   *\n   * In OAuth2Client, the result has the form:\n   * { Authorization: 'Bearer ' }\n   * @param url The optional url being authorized\n   */\n  async getRequestHeaders(url?: string): Promise {\n    const res = await this.getRequestMetadataAsync(url);\n    return res.headers;\n  }\n\n  protected async getRequestMetadataAsync(url?: string|null):\n      Promise {\n    const thisCreds = this.credentials;\n    if (!thisCreds.access_token && !thisCreds.refresh_token && !this.apiKey) {\n      throw new Error('No access, refresh token or API key is set.');\n    }\n\n    if (thisCreds.access_token && !this.isTokenExpiring()) {\n      thisCreds.token_type = thisCreds.token_type || 'Bearer';\n      const headers = {\n        Authorization: thisCreds.token_type + ' ' + thisCreds.access_token\n      };\n      return {headers};\n    }\n\n    if (this.apiKey) {\n      return {headers: {}};\n    }\n    let r: GetTokenResponse|null = null;\n    let tokens: Credentials|null = null;\n    try {\n      r = await this.refreshToken(thisCreds.refresh_token);\n      tokens = r.tokens;\n    } catch (err) {\n      const e = err as AxiosError;\n      if (e.response &&\n          (e.response.status === 403 || e.response.status === 404)) {\n        e.message = 'Could not refresh access token.';\n      }\n      throw e;\n    }\n\n    const credentials = this.credentials;\n    credentials.token_type = credentials.token_type || 'Bearer';\n    tokens.refresh_token = credentials.refresh_token;\n    this.credentials = tokens;\n    const headers = {\n      Authorization: credentials.token_type + ' ' + tokens.access_token\n    };\n    return {headers, res: r.res};\n  }\n\n  /**\n   * Revokes the access given to token.\n   * @param token The existing token to be revoked.\n   * @param callback Optional callback fn.\n   */\n  revokeToken(token: string): AxiosPromise;\n  revokeToken(\n      token: string,\n      callback: BodyResponseCallback): void;\n  revokeToken(\n      token: string, callback?: BodyResponseCallback):\n      AxiosPromise|void {\n    const opts = {\n      url: OAuth2Client.GOOGLE_OAUTH2_REVOKE_URL_ + '?' +\n          querystring.stringify({token}),\n      method: 'POST'\n    };\n    if (callback) {\n      this.transporter.request(opts).then(\n          r => callback(null, r), callback);\n    } else {\n      return this.transporter.request(opts);\n    }\n  }\n\n\n  /**\n   * Revokes access token and clears the credentials object\n   * @param callback callback\n   */\n  revokeCredentials(): AxiosPromise;\n  revokeCredentials(callback: BodyResponseCallback):\n      void;\n  revokeCredentials(callback?: BodyResponseCallback):\n      AxiosPromise|void {\n    if (callback) {\n      this.revokeCredentialsAsync().then(res => callback(null, res), callback);\n    } else {\n      return this.revokeCredentialsAsync();\n    }\n  }\n\n  private async revokeCredentialsAsync() {\n    const token = this.credentials.access_token;\n    this.credentials = {};\n    if (token) {\n      return this.revokeToken(token);\n    } else {\n      throw new Error('No access token to revoke.');\n    }\n  }\n\n  /**\n   * Provides a request implementation with OAuth 2.0 flow. If credentials have\n   * a refresh_token, in cases of HTTP 401 and 403 responses, it automatically\n   * asks for a new access token and replays the unsuccessful request.\n   * @param opts Request options.\n   * @param callback callback.\n   * @return Request object\n   */\n  request(opts: AxiosRequestConfig): AxiosPromise;\n  request(opts: AxiosRequestConfig, callback: BodyResponseCallback): void;\n  request(opts: AxiosRequestConfig, callback?: BodyResponseCallback):\n      AxiosPromise|void {\n    if (callback) {\n      this.requestAsync(opts).then(r => callback(null, r), e => {\n        return callback(e, e.response);\n      });\n    } else {\n      return this.requestAsync(opts);\n    }\n  }\n\n  protected async requestAsync(opts: AxiosRequestConfig, retry = false):\n      Promise> {\n    let r2: AxiosResponse;\n    try {\n      const r = await this.getRequestMetadataAsync(opts.url);\n      if (r.headers && r.headers.Authorization) {\n        opts.headers = opts.headers || {};\n        opts.headers.Authorization = r.headers.Authorization;\n      }\n\n      if (this.apiKey) {\n        opts.params = Object.assign(opts.params || {}, {key: this.apiKey});\n      }\n      r2 = await this.transporter.request(opts);\n    } catch (e) {\n      const res = (e as AxiosError).response;\n      if (res) {\n        const statusCode = res.status;\n        // Retry the request for metadata if the following criteria are true:\n        // - We haven't already retried.  It only makes sense to retry once.\n        // - The response was a 401 or a 403\n        // - The request didn't send a readableStream\n        // - An access_token and refresh_token were available, but no\n        //   expiry_date was availabe. This can happen when developers stash\n        //   the access_token and refresh_token for later use, but the\n        //   access_token fails on the first try because it's expired.\n        const mayRequireRefresh = this.credentials &&\n            this.credentials.access_token && this.credentials.refresh_token &&\n            !this.credentials.expiry_date;\n        const isReadableStream = res.config.data instanceof stream.Readable;\n        const isAuthErr = statusCode === 401 || statusCode === 403;\n        if (!retry && isAuthErr && !isReadableStream && mayRequireRefresh) {\n          await this.refreshAccessTokenAsync();\n          return this.requestAsync(opts, true);\n        }\n      }\n      throw e;\n    }\n    return r2;\n  }\n\n  /**\n   * Verify id token is token by checking the certs and audience\n   * @param options that contains all options.\n   * @param callback Callback supplying GoogleLogin if successful\n   */\n  verifyIdToken(options: VerifyIdTokenOptions): Promise;\n  verifyIdToken(\n      options: VerifyIdTokenOptions,\n      callback: (err: Error|null, login?: LoginTicket) => void): void;\n  verifyIdToken(\n      options: VerifyIdTokenOptions,\n      callback?: (err: Error|null, login?: LoginTicket) => void):\n      void|Promise {\n    // This function used to accept two arguments instead of an options object.\n    // Check the types to help users upgrade with less pain.\n    // This check can be removed after a 2.0 release.\n    if (callback && typeof callback !== 'function') {\n      throw new Error(\n          'This method accepts an options object as the first parameter, which includes the idToken, audience, and maxExpiry.');\n    }\n\n    if (callback) {\n      this.verifyIdTokenAsync(options).then(r => callback(null, r), callback);\n    } else {\n      return this.verifyIdTokenAsync(options);\n    }\n  }\n\n  private async verifyIdTokenAsync(options: VerifyIdTokenOptions):\n      Promise {\n    if (!options.idToken) {\n      throw new Error('The verifyIdToken method requires an ID Token');\n    }\n\n    const response = await this.getFederatedSignonCertsAsync();\n    const login = this.verifySignedJwtWithCerts(\n        options.idToken, response.certs, options.audience,\n        OAuth2Client.ISSUERS_, options.maxExpiry);\n\n    return login;\n  }\n\n  /**\n   * Obtains information about the provisioned access token.  Especially useful\n   * if you want to check the scopes that were provisioned to a given token.\n   *\n   * @param accessToken Required.  The Access Token for which you want to get\n   * user info.\n   */\n  async getTokenInfo(accessToken: string): Promise {\n    const {data} = await this.transporter.request({\n      method: 'GET',\n      url: OAuth2Client.GOOGLE_TOKEN_INFO_URL,\n      params: {access_token: accessToken}\n    });\n    const info = Object.assign(\n        {\n          expiry_date: ((new Date()).getTime() + (data.expires_in * 1000)),\n          scopes: data.scope.split(' ')\n        },\n        data);\n    delete info.expires_in;\n    delete info.scope;\n    return info;\n  }\n\n  /**\n   * Gets federated sign-on certificates to use for verifying identity tokens.\n   * Returns certs as array structure, where keys are key ids, and values\n   * are PEM encoded certificates.\n   * @param callback Callback supplying the certificates\n   */\n  getFederatedSignonCerts(): Promise;\n  getFederatedSignonCerts(callback: GetFederatedSignonCertsCallback): void;\n  getFederatedSignonCerts(callback?: GetFederatedSignonCertsCallback):\n      Promise|void {\n    if (callback) {\n      this.getFederatedSignonCertsAsync().then(\n          r => callback(null, r.certs, r.res), callback);\n    } else {\n      return this.getFederatedSignonCertsAsync();\n    }\n  }\n\n  async getFederatedSignonCertsAsync(): Promise {\n    const nowTime = (new Date()).getTime();\n    if (this.certificateExpiry &&\n        (nowTime = now + maxExpiry) {\n      throw new Error(\n          'Expiration time too far in future: ' + JSON.stringify(payload));\n    }\n\n    const earliest = iat - OAuth2Client.CLOCK_SKEW_SECS_;\n    const latest = exp + OAuth2Client.CLOCK_SKEW_SECS_;\n\n    if (now  latest) {\n      throw new Error(\n          'Token used too late, ' + now + ' > ' + latest + ': ' +\n          JSON.stringify(payload));\n    }\n\n    if (issuers && issuers.indexOf(payload.iss)  -1);\n      } else {\n        audVerified = (aud === requiredAudience);\n      }\n      if (!audVerified) {\n        throw new Error(\n            'Wrong recipient, payload audience != requiredAudience');\n      }\n    }\n    return new LoginTicket(envelope, payload);\n  }\n\n  /**\n   * This is a utils method to decode a base64 string\n   * @param b64String The string to base64 decode\n   * @return The decoded string\n   */\n  decodeBase64(b64String: string) {\n    const buffer = Buffer.from(b64String, 'base64');\n    return buffer.toString('utf8');\n  }\n\n  /**\n   * Returns true if a token is expired or will expire within\n   * eagerRefreshThresholdMillismilliseconds.\n   * If there is no expiry time, assumes the token is not expired or expiring.\n   */\n  protected isTokenExpiring(): boolean {\n    const expiryDate = this.credentials.expiry_date;\n    return expiryDate ? expiryDate \n    \n\n\n\n\n\n\n\n                   \n    \n         result-matching \"\"\n        \n    \n    \n        No results matching \"\"\n    \n\n"},"interfaces/GetTokenResponse.html":{"url":"interfaces/GetTokenResponse.html","title":"interface - GetTokenResponse","body":"\n                   \n\n\n\n\n\n\n\n\n\n\n\n\n\n  Interfaces\n  GetTokenResponse\n\n\n\n        \n            Info\n        \n        \n            Source\n        \n\n\n\n    \n        \n            File\n        \n        \n            src/auth/oauth2client.ts\n        \n\n\n\n        \n            Index\n            \n                \n                    \n                        \n                            Properties\n                        \n                    \n                    \n                        \n                            \n                                \n                                        res\n                                \n                                \n                                        tokens\n                                \n                            \n                        \n                    \n                \n            \n        \n\n\n\n            \n                Properties\n                    \n                        \n                                \n                                    \n                                        \n                                        res\n                                    \n                                \n                                \n                                    \n                                        res:     AxiosResponse | null\n\n                                    \n                                \n\n\n                                    \n                                        \n                                            Type :     AxiosResponse | null\n\n                                        \n                                    \n\n\n\n\n\n                        \n                    \n                    \n                        \n                                \n                                    \n                                        \n                                        tokens\n                                    \n                                \n                                \n                                    \n                                        tokens:     Credentials\n\n                                    \n                                \n\n\n                                    \n                                        \n                                            Type :     Credentials\n\n                                        \n                                    \n\n\n\n\n\n                        \n                    \n            \n    \n\n\n    \n        import {AxiosError, AxiosPromise, AxiosRequestConfig, AxiosResponse} from 'axios';\nimport * as crypto from 'crypto';\nimport * as querystring from 'querystring';\nimport * as stream from 'stream';\nimport * as messages from '../messages';\nimport {PemVerifier} from './../pemverifier';\nimport {BodyResponseCallback} from './../transporters';\nimport {AuthClient} from './authclient';\nimport {CredentialRequest, Credentials} from './credentials';\nimport {LoginTicket, TokenPayload} from './loginticket';\n\nexport type Certificates = {\n  [index: string]: string\n};\n\nexport type Headers = {\n  [index: string]: string\n};\n\nexport enum CodeChallengeMethod {\n  Plain = 'plain',\n  S256 = 'S256'\n}\n\nexport interface GetTokenOptions {\n  code: string;\n  codeVerifier?: string;\n  /**\n   * The client ID for your application. The value passed into the constructor\n   * will be used if not provided. Must match any client_id option passed to\n   * a corresponding call to generateAuthUrl.\n   */\n  client_id?: string;\n  /**\n   * Determines where the API server redirects the user after the user\n   * completes the authorization flow. The value passed into the constructor\n   * will be used if not provided. Must match any redirect_uri option passed to\n   * a corresponding call to generateAuthUrl.\n   */\n  redirect_uri?: string;\n}\n\nexport interface TokenInfo {\n  /**\n   * The application that is the intended user of the access token.\n   */\n  aud: string;\n\n  /**\n   * This value lets you correlate profile information from multiple Google\n   * APIs. It is only present in the response if you included the profile scope\n   * in your request in step 1. The field value is an immutable identifier for\n   * the logged-in user that can be used to create and manage user sessions in\n   * your application. The identifier is the same regardless of which client ID\n   * is used to retrieve it. This enables multiple applications in the same\n   * organization to correlate profile information.\n   */\n  user_id?: string;\n\n  /**\n   * An array of scopes that the user granted access to.\n   */\n  scopes: string[];\n\n  /**\n   * The datetime when the token becomes invalid.\n   */\n  expiry_date: number;\n\n  /**\n   * An identifier for the user, unique among all Google accounts and never\n   * reused. A Google account can have multiple emails at different points in\n   * time, but the sub value is never changed. Use sub within your application\n   * as the unique-identifier key for the user.\n   */\n  sub?: string;\n\n  /**\n   * The client_id of the authorized presenter. This claim is only needed when\n   * the party requesting the ID token is not the same as the audience of the ID\n   * token. This may be the case at Google for hybrid apps where a web\n   * application and Android app have a different client_id but share the same\n   * project.\n   */\n  azp?: string;\n\n  /**\n   * Indicates whether your application can refresh access tokens\n   * when the user is not present at the browser. Valid parameter values are\n   * 'online', which is the default value, and 'offline'. Set the value to\n   * 'offline' if your application needs to refresh access tokens when the user\n   * is not present at the browser. This value instructs the Google\n   * authorization server to return a refresh token and an access token the\n   * first time that your application exchanges an authorization code for\n   * tokens.\n   */\n  access_type?: string;\n}\n\ninterface TokenInfoRequest {\n  aud: string;\n  user_id?: string;\n  scope: string;\n  expires_in: number;\n  azp?: string;\n  sub?: string;\n  exp?: number;\n  access_type?: string;\n}\n\nexport interface GenerateAuthUrlOpts {\n  /**\n   * Recommended. Indicates whether your application can refresh access tokens\n   * when the user is not present at the browser. Valid parameter values are\n   * 'online', which is the default value, and 'offline'. Set the value to\n   * 'offline' if your application needs to refresh access tokens when the user\n   * is not present at the browser. This value instructs the Google\n   * authorization server to return a refresh token and an access token the\n   * first time that your application exchanges an authorization code for\n   * tokens.\n   */\n  access_type?: string;\n\n  /**\n   * The hd (hosted domain) parameter streamlines the login process for G Suite\n   * hosted accounts. By including the domain of the G Suite user (for example,\n   * mycollege.edu), you can indicate that the account selection UI should be\n   * optimized for accounts at that domain. To optimize for G Suite accounts\n   * generally instead of just one domain, use an asterisk: hd=*.\n   * Don't rely on this UI optimization to control who can access your app,\n   * as client-side requests can be modified. Be sure to validate that the\n   * returned ID token has an hd claim value that matches what you expect\n   * (e.g. mycolledge.edu). Unlike the request parameter, the ID token claim is\n   * contained within a security token from Google, so the value can be trusted.\n   */\n  hd?: string;\n\n  /**\n   * The 'response_type' will always be set to 'CODE'.\n   */\n  response_type?: string;\n\n  /**\n   * The client ID for your application. The value passed into the constructor\n   * will be used if not provided. You can find this value in the API Console.\n   */\n  client_id?: string;\n\n  /**\n   * Determines where the API server redirects the user after the user\n   * completes the authorization flow. The value must exactly match one of the\n   * 'redirect_uri' values listed for your project in the API Console. Note that\n   * the http or https scheme, case, and trailing slash ('/') must all match.\n   * The value passed into the constructor will be used if not provided.\n   */\n  redirect_uri?: string;\n\n  /**\n   * Required. A space-delimited list of scopes that identify the resources that\n   * your application could access on the user's behalf. These values inform the\n   * consent screen that Google displays to the user. Scopes enable your\n   * application to only request access to the resources that it needs while\n   * also enabling users to control the amount of access that they grant to your\n   * application. Thus, there is an inverse relationship between the number of\n   * scopes requested and the likelihood of obtaining user consent. The\n   * OAuth 2.0 API Scopes document provides a full list of scopes that you might\n   * use to access Google APIs. We recommend that your application request\n   * access to authorization scopes in context whenever possible. By requesting\n   * access to user data in context, via incremental authorization, you help\n   * users to more easily understand why your application needs the access it is\n   * requesting.\n   */\n  scope?: string[]|string;\n\n  /**\n   * Recommended. Specifies any string value that your application uses to\n   * maintain state between your authorization request and the authorization\n   * server's response. The server returns the exact value that you send as a\n   * name=value pair in the hash (#) fragment of the 'redirect_uri' after the\n   * user consents to or denies your application's access request. You can use\n   * this parameter for several purposes, such as directing the user to the\n   * correct resource in your application, sending nonces, and mitigating\n   * cross-site request forgery. Since your redirect_uri can be guessed, using a\n   * state value can increase your assurance that an incoming connection is the\n   * result of an authentication request. If you generate a random string or\n   * encode the hash of a cookie or another value that captures the client's\n   * state, you can validate the response to additionally ensure that the\n   * request and response originated in the same browser, providing protection\n   * against attacks such as cross-site request forgery. See the OpenID Connect\n   * documentation for an example of how to create and confirm a state token.\n   */\n  state?: string;\n\n  /**\n   * Optional. Enables applications to use incremental authorization to request\n   * access to additional scopes in context. If you set this parameter's value\n   * to true and the authorization request is granted, then the new access token\n   * will also cover any scopes to which the user previously granted the\n   * application access. See the incremental authorization section for examples.\n   */\n  include_granted_scopes?: boolean;\n\n  /**\n   * Optional. If your application knows which user is trying to authenticate,\n   * it can use this parameter to provide a hint to the Google Authentication\n   * Server. The server uses the hint to simplify the login flow either by\n   * prefilling the email field in the sign-in form or by selecting the\n   * appropriate multi-login session. Set the parameter value to an email\n   * address or sub identifier, which is equivalent to the user's Google ID.\n   */\n  login_hint?: string;\n\n  /**\n   * Optional. A space-delimited, case-sensitive list of prompts to present the\n   * user. If you don't specify this parameter, the user will be prompted only\n   * the first time your app requests access.  Possible values are:\n   *\n   * 'none' - Donot display any authentication or consent screens. Must not be\n   *        specified with other values.\n   * 'consent' - \tPrompt the user for consent.\n   * 'select_account' - Prompt the user to select an account.\n   */\n  prompt?: string;\n\n  /**\n   * Recommended. Specifies what method was used to encode a 'code_verifier'\n   * that will be used during authorization code exchange. This parameter must\n   * be used with the 'code_challenge' parameter. The value of the\n   * 'code_challenge_method' defaults to \"plain\" if not present in the request\n   * that includes a 'code_challenge'. The only supported values for this\n   * parameter are \"S256\" or \"plain\".\n   */\n  code_challenge_method?: CodeChallengeMethod;\n\n  /**\n   * Recommended. Specifies an encoded 'code_verifier' that will be used as a\n   * server-side challenge during authorization code exchange. This parameter\n   * must be used with the 'code_challenge' parameter described above.\n   */\n  code_challenge?: string;\n}\n\nexport interface GetTokenCallback {\n  (err: AxiosError|null, token?: Credentials|null,\n   res?: AxiosResponse|null): void;\n}\n\nexport interface GetTokenResponse {\n  tokens: Credentials;\n  res: AxiosResponse|null;\n}\n\nexport interface GetAccessTokenCallback {\n  (err: AxiosError|null, token?: string|null, res?: AxiosResponse|null): void;\n}\n\nexport interface GetAccessTokenResponse {\n  token?: string|null;\n  res?: AxiosResponse|null;\n}\n\nexport interface RefreshAccessTokenCallback {\n  (err: AxiosError|null, credentials?: Credentials|null,\n   res?: AxiosResponse|null): void;\n}\n\nexport interface RefreshAccessTokenResponse {\n  credentials: Credentials;\n  res: AxiosResponse|null;\n}\n\nexport interface RequestMetadataResponse {\n  headers: Headers;\n  res?: AxiosResponse|null;\n}\n\nexport interface RequestMetadataCallback {\n  (err: AxiosError|null, headers?: Headers,\n   res?: AxiosResponse|null): void;\n}\n\nexport interface GetFederatedSignonCertsCallback {\n  (err: AxiosError|null, certs?: Certificates,\n   response?: AxiosResponse|null): void;\n}\n\nexport interface FederatedSignonCertsResponse {\n  certs: Certificates;\n  res?: AxiosResponse|null;\n}\n\nexport interface RevokeCredentialsResult {\n  success: boolean;\n}\n\nexport interface VerifyIdTokenOptions {\n  idToken: string;\n  audience: string|string[];\n  maxExpiry?: number;\n}\n\nexport interface OAuth2ClientOptions extends RefreshOptions {\n  clientId?: string;\n  clientSecret?: string;\n  redirectUri?: string;\n}\n\nexport interface RefreshOptions {\n  // Eagerly refresh unexpired tokens when they are within this many\n  // milliseconds from expiring\".\n  // Defaults to a value of 300000 (5 minutes).\n  eagerRefreshThresholdMillis?: number;\n}\n\nexport class OAuth2Client extends AuthClient {\n  private redirectUri?: string;\n  private certificateCache?: Certificates;\n  private certificateExpiry: Date|null = null;\n  protected refreshTokenPromises = new Map>();\n\n  // TODO: refactor tests to make this private\n  _clientId?: string;\n\n  // TODO: refactor tests to make this private\n  _clientSecret?: string;\n\n  apiKey?: string;\n\n  projectId?: string;\n\n  eagerRefreshThresholdMillis: number;\n\n  /**\n   * Handles OAuth2 flow for Google APIs.\n   *\n   * @param clientId The authentication client ID.\n   * @param clientSecret The authentication client secret.\n   * @param redirectUri The URI to redirect to after completing the auth\n   * request.\n   * @param opts optional options for overriding the given parameters.\n   * @constructor\n   */\n  constructor(options?: OAuth2ClientOptions);\n  constructor(clientId?: string, clientSecret?: string, redirectUri?: string);\n  constructor(\n      optionsOrClientId?: string|OAuth2ClientOptions, clientSecret?: string,\n      redirectUri?: string) {\n    super();\n    const opts = (optionsOrClientId && typeof optionsOrClientId === 'object') ?\n        optionsOrClientId :\n        {clientId: optionsOrClientId, clientSecret, redirectUri};\n    this._clientId = opts.clientId;\n    this._clientSecret = opts.clientSecret;\n    this.redirectUri = opts.redirectUri;\n    this.eagerRefreshThresholdMillis =\n        opts.eagerRefreshThresholdMillis || 5 * 60 * 1000;\n  }\n\n  protected static readonly GOOGLE_TOKEN_INFO_URL =\n      'https://oauth2.googleapis.com/tokeninfo';\n\n  /**\n   * The base URL for auth endpoints.\n   */\n  private static readonly GOOGLE_OAUTH2_AUTH_BASE_URL_ =\n      'https://accounts.google.com/o/oauth2/v2/auth';\n\n  /**\n   * The base endpoint for token retrieval.\n   */\n  private static readonly GOOGLE_OAUTH2_TOKEN_URL_ =\n      'https://oauth2.googleapis.com/token';\n\n  /**\n   * The base endpoint to revoke tokens.\n   */\n  private static readonly GOOGLE_OAUTH2_REVOKE_URL_ =\n      'https://oauth2.googleapis.com/revoke';\n\n  /**\n   * Google Sign on certificates.\n   */\n  private static readonly GOOGLE_OAUTH2_FEDERATED_SIGNON_CERTS_URL_ =\n      'https://www.googleapis.com/oauth2/v1/certs';\n\n  /**\n   * Clock skew - five minutes in seconds\n   */\n  private static readonly CLOCK_SKEW_SECS_ = 300;\n\n  /**\n   * Max Token Lifetime is one day in seconds\n   */\n  private static readonly MAX_TOKEN_LIFETIME_SECS_ = 86400;\n\n  /**\n   * The allowed oauth token issuers.\n   */\n  private static readonly ISSUERS_ =\n      ['accounts.google.com', 'https://accounts.google.com'];\n\n  /**\n   * Generates URL for consent page landing.\n   * @param opts Options.\n   * @return URL to consent page.\n   */\n  generateAuthUrl(opts: GenerateAuthUrlOpts = {}) {\n    if (opts.code_challenge_method && !opts.code_challenge) {\n      throw new Error(\n          'If a code_challenge_method is provided, code_challenge must be included.');\n    }\n    opts.response_type = opts.response_type || 'code';\n    opts.client_id = opts.client_id || this._clientId;\n    opts.redirect_uri = opts.redirect_uri || this.redirectUri;\n    // Allow scopes to be passed either as array or a string\n    if (opts.scope instanceof Array) {\n      opts.scope = opts.scope.join(' ');\n    }\n    const rootUrl = OAuth2Client.GOOGLE_OAUTH2_AUTH_BASE_URL_;\n    return rootUrl + '?' + querystring.stringify(opts);\n  }\n\n  /**\n   * Convenience method to automatically generate a code_verifier, and it's\n   * resulting SHA256. If used, this must be paired with a S256\n   * code_challenge_method.\n   */\n  generateCodeVerifier() {\n    // base64 encoding uses 6 bits per character, and we want to generate128\n    // characters. 6*128/8 = 96.\n    const randomString = crypto.randomBytes(96).toString('base64');\n    // The valid characters in the code_verifier are [A-Z]/[a-z]/[0-9]/\n    // \"-\"/\".\"/\"_\"/\"~\". Base64 encoded strings are pretty close, so we're just\n    // swapping out a few chars.\n    const codeVerifier =\n        randomString.replace(/\\+/g, '~').replace(/=/g, '_').replace(/\\//g, '-');\n    // Generate the base64 encoded SHA256\n    const unencodedCodeChallenge =\n        crypto.createHash('sha256').update(codeVerifier).digest('base64');\n    // We need to use base64UrlEncoding instead of standard base64\n    const codeChallenge = unencodedCodeChallenge.split('=')[0]\n                              .replace(/\\+/g, '-')\n                              .replace(/\\//g, '_');\n    return {codeVerifier, codeChallenge};\n  }\n\n  /**\n   * Gets the access token for the given code.\n   * @param code The authorization code.\n   * @param callback Optional callback fn.\n   */\n  getToken(code: string): Promise;\n  getToken(options: GetTokenOptions): Promise;\n  getToken(code: string, callback: GetTokenCallback): void;\n  getToken(options: GetTokenOptions, callback: GetTokenCallback): void;\n  getToken(codeOrOptions: string|GetTokenOptions, callback?: GetTokenCallback):\n      Promise|void {\n    const options = (typeof codeOrOptions === 'string') ?\n        {code: codeOrOptions} :\n        codeOrOptions;\n    if (callback) {\n      this.getTokenAsync(options).then(\n          r => callback(null, r.tokens, r.res),\n          e => callback(e, null, e.response));\n    } else {\n      return this.getTokenAsync(options);\n    }\n  }\n\n  private async getTokenAsync(options: GetTokenOptions):\n      Promise {\n    const url = OAuth2Client.GOOGLE_OAUTH2_TOKEN_URL_;\n    const values = {\n      code: options.code,\n      client_id: options.client_id || this._clientId,\n      client_secret: this._clientSecret,\n      redirect_uri: options.redirect_uri || this.redirectUri,\n      grant_type: 'authorization_code',\n      code_verifier: options.codeVerifier\n    };\n    const res = await this.transporter.request({\n      method: 'POST',\n      url,\n      data: querystring.stringify(values),\n      headers: {'Content-Type': 'application/x-www-form-urlencoded'}\n    });\n    const tokens = res.data as Credentials;\n    if (res.data && res.data.expires_in) {\n      tokens.expiry_date =\n          ((new Date()).getTime() + (res.data.expires_in * 1000));\n      delete (tokens as CredentialRequest).expires_in;\n    }\n    this.emit('tokens', tokens);\n    return {tokens, res};\n  }\n\n  /**\n   * Refreshes the access token.\n   * @param refresh_token Existing refresh token.\n   * @private\n   */\n  protected async refreshToken(refreshToken?: string|\n                               null): Promise {\n    if (!refreshToken) {\n      return this.refreshTokenNoCache(refreshToken);\n    }\n    // If a request to refresh using the same token has started,\n    // return the same promise.\n    if (this.refreshTokenPromises.has(refreshToken)) {\n      return this.refreshTokenPromises.get(refreshToken)!;\n    }\n\n    const p = this.refreshTokenNoCache(refreshToken)\n                  .then(\n                      r => {\n                        this.refreshTokenPromises.delete(refreshToken);\n                        return r;\n                      },\n                      e => {\n                        this.refreshTokenPromises.delete(refreshToken);\n                        throw e;\n                      });\n    this.refreshTokenPromises.set(refreshToken, p);\n    return p;\n  }\n\n  protected async refreshTokenNoCache(refreshToken?: string|\n                                      null): Promise {\n    const url = OAuth2Client.GOOGLE_OAUTH2_TOKEN_URL_;\n    const data = {\n      refresh_token: refreshToken,\n      client_id: this._clientId,\n      client_secret: this._clientSecret,\n      grant_type: 'refresh_token'\n    };\n\n    // request for new token\n    const res = await this.transporter.request({\n      method: 'POST',\n      url,\n      data: querystring.stringify(data),\n      headers: {'Content-Type': 'application/x-www-form-urlencoded'}\n    });\n\n    const tokens = res.data as Credentials;\n    // TODO: de-duplicate this code from a few spots\n    if (res.data && res.data.expires_in) {\n      tokens.expiry_date =\n          ((new Date()).getTime() + (res.data.expires_in * 1000));\n      delete (tokens as CredentialRequest).expires_in;\n    }\n    this.emit('tokens', tokens);\n    return {tokens, res};\n  }\n\n  /**\n   * Retrieves the access token using refresh token\n   *\n   * @deprecated use getRequestHeaders instead.\n   * @param callback callback\n   */\n  refreshAccessToken(): Promise;\n  refreshAccessToken(callback: RefreshAccessTokenCallback): void;\n  refreshAccessToken(callback?: RefreshAccessTokenCallback):\n      Promise|void {\n    messages.warn(messages.REFRESH_ACCESS_TOKEN_DEPRECATED);\n    if (callback) {\n      this.refreshAccessTokenAsync().then(\n          r => callback(null, r.credentials, r.res), callback);\n    } else {\n      return this.refreshAccessTokenAsync();\n    }\n  }\n\n  private async refreshAccessTokenAsync() {\n    if (!this.credentials.refresh_token) {\n      throw new Error('No refresh token is set.');\n    }\n    const r = await this.refreshToken(this.credentials.refresh_token);\n    const tokens = r.tokens as Credentials;\n    tokens.refresh_token = this.credentials.refresh_token;\n    this.credentials = tokens;\n    return {credentials: this.credentials, res: r.res};\n  }\n\n  /**\n   * Get a non-expired access token, after refreshing if necessary\n   *\n   * @param callback Callback to call with the access token\n   */\n  getAccessToken(): Promise;\n  getAccessToken(callback: GetAccessTokenCallback): void;\n  getAccessToken(callback?: GetAccessTokenCallback):\n      Promise|void {\n    if (callback) {\n      this.getAccessTokenAsync().then(\n          r => callback(null, r.token, r.res), callback);\n    } else {\n      return this.getAccessTokenAsync();\n    }\n  }\n\n  private async getAccessTokenAsync(): Promise {\n    const shouldRefresh =\n        !this.credentials.access_token || this.isTokenExpiring();\n    if (shouldRefresh && this.credentials.refresh_token) {\n      if (!this.credentials.refresh_token) {\n        throw new Error('No refresh token is set.');\n      }\n\n      const r = await this.refreshAccessTokenAsync();\n      if (!r.credentials || (r.credentials && !r.credentials.access_token)) {\n        throw new Error('Could not refresh access token.');\n      }\n      return {token: r.credentials.access_token, res: r.res};\n    } else {\n      return {token: this.credentials.access_token};\n    }\n  }\n\n  /**\n   * Obtain the set of headers required to authenticate a request.\n   *\n   * @deprecated Use getRequestHeaders instead.\n   * @param url the Uri being authorized\n   * @param callback the func described above\n   */\n  getRequestMetadata(url?: string|null): Promise;\n  getRequestMetadata(url: string|null, callback: RequestMetadataCallback): void;\n  getRequestMetadata(url: string|null, callback?: RequestMetadataCallback):\n      Promise|void {\n    messages.warn(messages.OAUTH_GET_REQUEST_METADATA_DEPRECATED);\n    if (callback) {\n      this.getRequestMetadataAsync(url).then(\n          r => callback(null, r.headers, r.res), callback);\n    } else {\n      return this.getRequestMetadataAsync();\n    }\n  }\n\n  /**\n   * The main authentication interface.  It takes an optional url which when\n   * present is the endpoint being accessed, and returns a Promise which\n   * resolves with authorization header fields.\n   *\n   * In OAuth2Client, the result has the form:\n   * { Authorization: 'Bearer ' }\n   * @param url The optional url being authorized\n   */\n  async getRequestHeaders(url?: string): Promise {\n    const res = await this.getRequestMetadataAsync(url);\n    return res.headers;\n  }\n\n  protected async getRequestMetadataAsync(url?: string|null):\n      Promise {\n    const thisCreds = this.credentials;\n    if (!thisCreds.access_token && !thisCreds.refresh_token && !this.apiKey) {\n      throw new Error('No access, refresh token or API key is set.');\n    }\n\n    if (thisCreds.access_token && !this.isTokenExpiring()) {\n      thisCreds.token_type = thisCreds.token_type || 'Bearer';\n      const headers = {\n        Authorization: thisCreds.token_type + ' ' + thisCreds.access_token\n      };\n      return {headers};\n    }\n\n    if (this.apiKey) {\n      return {headers: {}};\n    }\n    let r: GetTokenResponse|null = null;\n    let tokens: Credentials|null = null;\n    try {\n      r = await this.refreshToken(thisCreds.refresh_token);\n      tokens = r.tokens;\n    } catch (err) {\n      const e = err as AxiosError;\n      if (e.response &&\n          (e.response.status === 403 || e.response.status === 404)) {\n        e.message = 'Could not refresh access token.';\n      }\n      throw e;\n    }\n\n    const credentials = this.credentials;\n    credentials.token_type = credentials.token_type || 'Bearer';\n    tokens.refresh_token = credentials.refresh_token;\n    this.credentials = tokens;\n    const headers = {\n      Authorization: credentials.token_type + ' ' + tokens.access_token\n    };\n    return {headers, res: r.res};\n  }\n\n  /**\n   * Revokes the access given to token.\n   * @param token The existing token to be revoked.\n   * @param callback Optional callback fn.\n   */\n  revokeToken(token: string): AxiosPromise;\n  revokeToken(\n      token: string,\n      callback: BodyResponseCallback): void;\n  revokeToken(\n      token: string, callback?: BodyResponseCallback):\n      AxiosPromise|void {\n    const opts = {\n      url: OAuth2Client.GOOGLE_OAUTH2_REVOKE_URL_ + '?' +\n          querystring.stringify({token}),\n      method: 'POST'\n    };\n    if (callback) {\n      this.transporter.request(opts).then(\n          r => callback(null, r), callback);\n    } else {\n      return this.transporter.request(opts);\n    }\n  }\n\n\n  /**\n   * Revokes access token and clears the credentials object\n   * @param callback callback\n   */\n  revokeCredentials(): AxiosPromise;\n  revokeCredentials(callback: BodyResponseCallback):\n      void;\n  revokeCredentials(callback?: BodyResponseCallback):\n      AxiosPromise|void {\n    if (callback) {\n      this.revokeCredentialsAsync().then(res => callback(null, res), callback);\n    } else {\n      return this.revokeCredentialsAsync();\n    }\n  }\n\n  private async revokeCredentialsAsync() {\n    const token = this.credentials.access_token;\n    this.credentials = {};\n    if (token) {\n      return this.revokeToken(token);\n    } else {\n      throw new Error('No access token to revoke.');\n    }\n  }\n\n  /**\n   * Provides a request implementation with OAuth 2.0 flow. If credentials have\n   * a refresh_token, in cases of HTTP 401 and 403 responses, it automatically\n   * asks for a new access token and replays the unsuccessful request.\n   * @param opts Request options.\n   * @param callback callback.\n   * @return Request object\n   */\n  request(opts: AxiosRequestConfig): AxiosPromise;\n  request(opts: AxiosRequestConfig, callback: BodyResponseCallback): void;\n  request(opts: AxiosRequestConfig, callback?: BodyResponseCallback):\n      AxiosPromise|void {\n    if (callback) {\n      this.requestAsync(opts).then(r => callback(null, r), e => {\n        return callback(e, e.response);\n      });\n    } else {\n      return this.requestAsync(opts);\n    }\n  }\n\n  protected async requestAsync(opts: AxiosRequestConfig, retry = false):\n      Promise> {\n    let r2: AxiosResponse;\n    try {\n      const r = await this.getRequestMetadataAsync(opts.url);\n      if (r.headers && r.headers.Authorization) {\n        opts.headers = opts.headers || {};\n        opts.headers.Authorization = r.headers.Authorization;\n      }\n\n      if (this.apiKey) {\n        opts.params = Object.assign(opts.params || {}, {key: this.apiKey});\n      }\n      r2 = await this.transporter.request(opts);\n    } catch (e) {\n      const res = (e as AxiosError).response;\n      if (res) {\n        const statusCode = res.status;\n        // Retry the request for metadata if the following criteria are true:\n        // - We haven't already retried.  It only makes sense to retry once.\n        // - The response was a 401 or a 403\n        // - The request didn't send a readableStream\n        // - An access_token and refresh_token were available, but no\n        //   expiry_date was availabe. This can happen when developers stash\n        //   the access_token and refresh_token for later use, but the\n        //   access_token fails on the first try because it's expired.\n        const mayRequireRefresh = this.credentials &&\n            this.credentials.access_token && this.credentials.refresh_token &&\n            !this.credentials.expiry_date;\n        const isReadableStream = res.config.data instanceof stream.Readable;\n        const isAuthErr = statusCode === 401 || statusCode === 403;\n        if (!retry && isAuthErr && !isReadableStream && mayRequireRefresh) {\n          await this.refreshAccessTokenAsync();\n          return this.requestAsync(opts, true);\n        }\n      }\n      throw e;\n    }\n    return r2;\n  }\n\n  /**\n   * Verify id token is token by checking the certs and audience\n   * @param options that contains all options.\n   * @param callback Callback supplying GoogleLogin if successful\n   */\n  verifyIdToken(options: VerifyIdTokenOptions): Promise;\n  verifyIdToken(\n      options: VerifyIdTokenOptions,\n      callback: (err: Error|null, login?: LoginTicket) => void): void;\n  verifyIdToken(\n      options: VerifyIdTokenOptions,\n      callback?: (err: Error|null, login?: LoginTicket) => void):\n      void|Promise {\n    // This function used to accept two arguments instead of an options object.\n    // Check the types to help users upgrade with less pain.\n    // This check can be removed after a 2.0 release.\n    if (callback && typeof callback !== 'function') {\n      throw new Error(\n          'This method accepts an options object as the first parameter, which includes the idToken, audience, and maxExpiry.');\n    }\n\n    if (callback) {\n      this.verifyIdTokenAsync(options).then(r => callback(null, r), callback);\n    } else {\n      return this.verifyIdTokenAsync(options);\n    }\n  }\n\n  private async verifyIdTokenAsync(options: VerifyIdTokenOptions):\n      Promise {\n    if (!options.idToken) {\n      throw new Error('The verifyIdToken method requires an ID Token');\n    }\n\n    const response = await this.getFederatedSignonCertsAsync();\n    const login = this.verifySignedJwtWithCerts(\n        options.idToken, response.certs, options.audience,\n        OAuth2Client.ISSUERS_, options.maxExpiry);\n\n    return login;\n  }\n\n  /**\n   * Obtains information about the provisioned access token.  Especially useful\n   * if you want to check the scopes that were provisioned to a given token.\n   *\n   * @param accessToken Required.  The Access Token for which you want to get\n   * user info.\n   */\n  async getTokenInfo(accessToken: string): Promise {\n    const {data} = await this.transporter.request({\n      method: 'GET',\n      url: OAuth2Client.GOOGLE_TOKEN_INFO_URL,\n      params: {access_token: accessToken}\n    });\n    const info = Object.assign(\n        {\n          expiry_date: ((new Date()).getTime() + (data.expires_in * 1000)),\n          scopes: data.scope.split(' ')\n        },\n        data);\n    delete info.expires_in;\n    delete info.scope;\n    return info;\n  }\n\n  /**\n   * Gets federated sign-on certificates to use for verifying identity tokens.\n   * Returns certs as array structure, where keys are key ids, and values\n   * are PEM encoded certificates.\n   * @param callback Callback supplying the certificates\n   */\n  getFederatedSignonCerts(): Promise;\n  getFederatedSignonCerts(callback: GetFederatedSignonCertsCallback): void;\n  getFederatedSignonCerts(callback?: GetFederatedSignonCertsCallback):\n      Promise|void {\n    if (callback) {\n      this.getFederatedSignonCertsAsync().then(\n          r => callback(null, r.certs, r.res), callback);\n    } else {\n      return this.getFederatedSignonCertsAsync();\n    }\n  }\n\n  async getFederatedSignonCertsAsync(): Promise {\n    const nowTime = (new Date()).getTime();\n    if (this.certificateExpiry &&\n        (nowTime = now + maxExpiry) {\n      throw new Error(\n          'Expiration time too far in future: ' + JSON.stringify(payload));\n    }\n\n    const earliest = iat - OAuth2Client.CLOCK_SKEW_SECS_;\n    const latest = exp + OAuth2Client.CLOCK_SKEW_SECS_;\n\n    if (now  latest) {\n      throw new Error(\n          'Token used too late, ' + now + ' > ' + latest + ': ' +\n          JSON.stringify(payload));\n    }\n\n    if (issuers && issuers.indexOf(payload.iss)  -1);\n      } else {\n        audVerified = (aud === requiredAudience);\n      }\n      if (!audVerified) {\n        throw new Error(\n            'Wrong recipient, payload audience != requiredAudience');\n      }\n    }\n    return new LoginTicket(envelope, payload);\n  }\n\n  /**\n   * This is a utils method to decode a base64 string\n   * @param b64String The string to base64 decode\n   * @return The decoded string\n   */\n  decodeBase64(b64String: string) {\n    const buffer = Buffer.from(b64String, 'base64');\n    return buffer.toString('utf8');\n  }\n\n  /**\n   * Returns true if a token is expired or will expire within\n   * eagerRefreshThresholdMillismilliseconds.\n   * If there is no expiry time, assumes the token is not expired or expiring.\n   */\n  protected isTokenExpiring(): boolean {\n    const expiryDate = this.credentials.expiry_date;\n    return expiryDate ? expiryDate \n    \n\n\n\n\n\n\n\n                   \n    \n         result-matching \"\"\n        \n    \n    \n        No results matching \"\"\n    \n\n"},"interfaces/GoogleAuthOptions.html":{"url":"interfaces/GoogleAuthOptions.html","title":"interface - GoogleAuthOptions","body":"\n                   \n\n\n\n\n\n\n\n\n\n\n\n\n\n  Interfaces\n  GoogleAuthOptions\n\n\n\n        \n            Info\n        \n        \n            Source\n        \n\n\n\n    \n        \n            File\n        \n        \n            src/auth/googleauth.ts\n        \n\n\n\n        \n            Index\n            \n                \n                    \n                        \n                            Properties\n                        \n                    \n                    \n                        \n                            \n                                \n                                            Optional\n                                        credentials\n                                \n                                \n                                            Optional\n                                        keyFile\n                                \n                                \n                                            Optional\n                                        keyFilename\n                                \n                                \n                                            Optional\n                                        projectId\n                                \n                                \n                                            Optional\n                                        scopes\n                                \n                            \n                        \n                    \n                \n            \n        \n\n\n\n            \n                Properties\n                    \n                        \n                                \n                                    \n                                        \n                                        credentials\n                                    \n                                \n                                \n                                    \n                                        credentials:     CredentialBody\n\n                                    \n                                \n\n\n                                    \n                                        \n                                            Type :     CredentialBody\n\n                                        \n                                    \n\n                                    \n                                        \n                                            Optional\n                                        \n                                    \n\n\n\n\n                            \n                                \n                                    Object containing client_email and private_key properties\n\n                                \n                            \n                        \n                    \n                    \n                        \n                                \n                                    \n                                        \n                                        keyFile\n                                    \n                                \n                                \n                                    \n                                        keyFile:     string\n\n                                    \n                                \n\n\n                                    \n                                        \n                                            Type :     string\n\n                                        \n                                    \n\n                                    \n                                        \n                                            Optional\n                                        \n                                    \n\n\n\n\n                            \n                                \n                                    Path to a .json, .pem, or .p12 key file\n\n                                \n                            \n                        \n                    \n                    \n                        \n                                \n                                    \n                                        \n                                        keyFilename\n                                    \n                                \n                                \n                                    \n                                        keyFilename:     string\n\n                                    \n                                \n\n\n                                    \n                                        \n                                            Type :     string\n\n                                        \n                                    \n\n                                    \n                                        \n                                            Optional\n                                        \n                                    \n\n\n\n\n                            \n                                \n                                    Path to a .json, .pem, or .p12 key file\n\n                                \n                            \n                        \n                    \n                    \n                        \n                                \n                                    \n                                        \n                                        projectId\n                                    \n                                \n                                \n                                    \n                                        projectId:     string\n\n                                    \n                                \n\n\n                                    \n                                        \n                                            Type :     string\n\n                                        \n                                    \n\n                                    \n                                        \n                                            Optional\n                                        \n                                    \n\n\n\n\n                            \n                                \n                                    Your project ID.\n\n                                \n                            \n                        \n                    \n                    \n                        \n                                \n                                    \n                                        \n                                        scopes\n                                    \n                                \n                                \n                                    \n                                        scopes:     string | string[]\n\n                                    \n                                \n\n\n                                    \n                                        \n                                            Type :     string | string[]\n\n                                        \n                                    \n\n                                    \n                                        \n                                            Optional\n                                        \n                                    \n\n\n\n\n                            \n                                \n                                    Required scopes for the desired API request\n\n                                \n                            \n                        \n                    \n            \n    \n\n\n    \n        import {AxiosRequestConfig, AxiosResponse} from 'axios';\nimport {exec} from 'child_process';\nimport * as crypto from 'crypto';\nimport * as fs from 'fs';\nimport * as gcpMetadata from 'gcp-metadata';\nimport * as http from 'http';\nimport * as os from 'os';\nimport * as path from 'path';\nimport * as stream from 'stream';\nimport * as util from 'util';\n\nimport * as messages from '../messages';\nimport {DefaultTransporter, Transporter} from '../transporters';\n\nimport {Compute} from './computeclient';\nimport {CredentialBody, JWTInput} from './credentials';\nimport {GCPEnv, getEnv} from './envDetect';\nimport {JWT, JWTOptions} from './jwtclient';\nimport {Headers, OAuth2Client, RefreshOptions} from './oauth2client';\nimport {UserRefreshClient} from './refreshclient';\n\nexport interface ProjectIdCallback {\n  (err?: Error|null, projectId?: string|null): void;\n}\n\nexport interface CredentialCallback {\n  (err: Error|null, result?: UserRefreshClient|JWT): void;\n}\n\nexport interface ADCCallback {\n  (err: Error|null, credential?: OAuth2Client, projectId?: string|null): void;\n}\n\nexport interface ADCResponse {\n  credential: OAuth2Client;\n  projectId: string|null;\n}\n\nexport interface GoogleAuthOptions {\n  /**\n   * Path to a .json, .pem, or .p12 key file\n   */\n  keyFilename?: string;\n\n  /**\n   * Path to a .json, .pem, or .p12 key file\n   */\n  keyFile?: string;\n\n  /**\n   * Object containing client_email and private_key properties\n   */\n  credentials?: CredentialBody;\n\n  /**\n   * Required scopes for the desired API request\n   */\n  scopes?: string|string[];\n\n  /**\n   * Your project ID.\n   */\n  projectId?: string;\n}\n\nexport const CLOUD_SDK_CLIENT_ID =\n    '764086051850-6qr4p6gpi6hn506pt8ejuq83di341hur.apps.googleusercontent.com';\n\nexport class GoogleAuth {\n  transporter?: Transporter;\n\n  /**\n   * Caches a value indicating whether the auth layer is running on Google\n   * Compute Engine.\n   * @private\n   */\n  private checkIsGCE?: boolean = undefined;\n\n  // Note:  this properly is only public to satisify unit tests.\n  // https://github.com/Microsoft/TypeScript/issues/5228\n  get isGCE() {\n    return this.checkIsGCE;\n  }\n\n  private _getDefaultProjectIdPromise?: Promise;\n  private _cachedProjectId?: string|null;\n\n  // To save the contents of the JSON credential file\n  jsonContent: JWTInput|null = null;\n\n  cachedCredential: JWT|UserRefreshClient|Compute|null = null;\n\n  private keyFilename?: string;\n  private scopes?: string|string[];\n\n  /**\n   * Export DefaultTransporter as a static property of the class.\n   */\n  static DefaultTransporter = DefaultTransporter;\n\n  constructor(opts?: GoogleAuthOptions) {\n    opts = opts || {};\n    this._cachedProjectId = opts.projectId || null;\n    this.keyFilename = opts.keyFilename || opts.keyFile;\n    this.scopes = opts.scopes;\n    this.jsonContent = opts.credentials || null;\n  }\n\n  /**\n   * THIS METHOD HAS BEEN DEPRECATED.\n   * It will be removed in 3.0.  Please use getProjectId instead.\n   */\n  getDefaultProjectId(): Promise;\n  getDefaultProjectId(callback: ProjectIdCallback): void;\n  getDefaultProjectId(callback?: ProjectIdCallback): Promise|void {\n    messages.warn(messages.DEFAULT_PROJECT_ID_DEPRECATED);\n    if (callback) {\n      this.getProjectIdAsync().then(r => callback(null, r), callback);\n    } else {\n      return this.getProjectIdAsync();\n    }\n  }\n\n  /**\n   * Obtains the default project ID for the application.\n   * @param callback Optional callback\n   * @returns Promise that resolves with project Id (if used without callback)\n   */\n  getProjectId(): Promise;\n  getProjectId(callback: ProjectIdCallback): void;\n  getProjectId(callback?: ProjectIdCallback): Promise|void {\n    if (callback) {\n      this.getProjectIdAsync().then(r => callback(null, r), callback);\n    } else {\n      return this.getProjectIdAsync();\n    }\n  }\n\n  private getProjectIdAsync(): Promise {\n    if (this._cachedProjectId) {\n      return Promise.resolve(this._cachedProjectId);\n    }\n\n    // In implicit case, supports three environments. In order of precedence,\n    // the implicit environments are:\n    // - GCLOUD_PROJECT or GOOGLE_CLOUD_PROJECT environment variable\n    // - GOOGLE_APPLICATION_CREDENTIALS JSON file\n    // - Cloud SDK: `gcloud config config-helper --format json`\n    // - GCE project ID from metadata server)\n    if (!this._getDefaultProjectIdPromise) {\n      this._getDefaultProjectIdPromise =\n          new Promise(async (resolve, reject) => {\n            try {\n              const projectId = this.getProductionProjectId() ||\n                  await this.getFileProjectId() ||\n                  await this.getDefaultServiceProjectId() ||\n                  await this.getGCEProjectId();\n              this._cachedProjectId = projectId;\n              resolve(projectId);\n            } catch (e) {\n              reject(e);\n            }\n          });\n    }\n    return this._getDefaultProjectIdPromise;\n  }\n\n  /**\n   * Obtains the default service-level credentials for the application.\n   * @param callback Optional callback.\n   * @returns Promise that resolves with the ADCResponse (if no callback was\n   * passed).\n   */\n  getApplicationDefault(): Promise;\n  getApplicationDefault(callback: ADCCallback): void;\n  getApplicationDefault(options: RefreshOptions): Promise;\n  getApplicationDefault(options: RefreshOptions, callback: ADCCallback): void;\n  getApplicationDefault(\n      optionsOrCallback: ADCCallback|RefreshOptions = {},\n      callback?: ADCCallback): void|Promise {\n    let options: RefreshOptions|undefined;\n    if (typeof optionsOrCallback === 'function') {\n      callback = optionsOrCallback;\n    } else {\n      options = optionsOrCallback;\n    }\n    if (callback) {\n      this.getApplicationDefaultAsync(options).then(\n          r => callback!(null, r.credential, r.projectId), callback);\n    } else {\n      return this.getApplicationDefaultAsync(options);\n    }\n  }\n\n  private async getApplicationDefaultAsync(options?: RefreshOptions):\n      Promise {\n    // If we've already got a cached credential, just return it.\n    if (this.cachedCredential) {\n      return {\n        credential: this.cachedCredential as JWT | UserRefreshClient,\n        projectId: await this.getProjectIdAsync()\n      };\n    }\n\n    let credential: JWT|UserRefreshClient|null;\n    let projectId: string|null;\n    // Check for the existence of a local environment variable pointing to the\n    // location of the credential file. This is typically used in local\n    // developer scenarios.\n    credential =\n        await this._tryGetApplicationCredentialsFromEnvironmentVariable(\n            options);\n    if (credential) {\n      if (credential instanceof JWT) {\n        credential.scopes = this.scopes;\n      }\n      this.cachedCredential = credential;\n      projectId = await this.getProjectId();\n      return {credential, projectId};\n    }\n\n    // Look in the well-known credential file location.\n    credential =\n        await this._tryGetApplicationCredentialsFromWellKnownFile(options);\n    if (credential) {\n      if (credential instanceof JWT) {\n        credential.scopes = this.scopes;\n      }\n      this.cachedCredential = credential;\n      projectId = await this.getProjectId();\n      return {credential, projectId};\n    }\n\n    // Determine if we're running on GCE.\n    let isGCE;\n    try {\n      isGCE = await this._checkIsGCE();\n    } catch (e) {\n      throw new Error(\n          'Unexpected error determining execution environment: ' + e.message);\n    }\n\n    if (!isGCE) {\n      // We failed to find the default credentials. Bail out with an error.\n      throw new Error(\n          'Could not load the default credentials. Browse to https://cloud.google.com/docs/authentication/getting-started for more information.');\n    }\n\n    // For GCE, just return a default ComputeClient. It will take care of\n    // the rest.\n    this.cachedCredential = new Compute(options);\n    projectId = await this.getProjectId();\n    return {projectId, credential: this.cachedCredential};\n  }\n\n  /**\n   * Determines whether the auth layer is running on Google Compute Engine.\n   * @returns A promise that resolves with the boolean.\n   * @api private\n   */\n  async _checkIsGCE() {\n    if (this.checkIsGCE === undefined) {\n      this.checkIsGCE = await gcpMetadata.isAvailable();\n    }\n    return this.checkIsGCE;\n  }\n\n  /**\n   * Attempts to load default credentials from the environment variable path..\n   * @returns Promise that resolves with the OAuth2Client or null.\n   * @api private\n   */\n  async _tryGetApplicationCredentialsFromEnvironmentVariable(\n      options?: RefreshOptions): Promise {\n    const credentialsPath = process.env['GOOGLE_APPLICATION_CREDENTIALS'];\n    if (!credentialsPath || credentialsPath.length === 0) {\n      return null;\n    }\n    try {\n      return this._getApplicationCredentialsFromFilePath(\n          credentialsPath, options);\n    } catch (e) {\n      throw this.createError(\n          'Unable to read the credential file specified by the GOOGLE_APPLICATION_CREDENTIALS environment variable.',\n          e);\n    }\n  }\n\n  /**\n   * Attempts to load default credentials from a well-known file location\n   * @return Promise that resolves with the OAuth2Client or null.\n   * @api private\n   */\n  async _tryGetApplicationCredentialsFromWellKnownFile(\n      options?: RefreshOptions): Promise {\n    // First, figure out the location of the file, depending upon the OS type.\n    let location = null;\n    if (this._isWindows()) {\n      // Windows\n      location = process.env['APPDATA'];\n    } else {\n      // Linux or Mac\n      const home = process.env['HOME'];\n      if (home) {\n        location = this._pathJoin(home, '.config');\n      }\n    }\n    // If we found the root path, expand it.\n    if (location) {\n      location = this._pathJoin(location, 'gcloud');\n      location =\n          this._pathJoin(location, 'application_default_credentials.json');\n      location = this._mockWellKnownFilePath(location);\n      // Check whether the file exists.\n      if (!this._fileExists(location)) {\n        location = null;\n      }\n    }\n    // The file does not exist.\n    if (!location) {\n      return null;\n    }\n    // The file seems to exist. Try to use it.\n    const client =\n        await this._getApplicationCredentialsFromFilePath(location, options);\n    this.warnOnProblematicCredentials(client as JWT);\n    return client;\n  }\n\n  /**\n   * Attempts to load default credentials from a file at the given path..\n   * @param filePath The path to the file to read.\n   * @returns Promise that resolves with the OAuth2Client\n   * @api private\n   */\n  async _getApplicationCredentialsFromFilePath(\n      filePath: string,\n      options: RefreshOptions = {}): Promise {\n    // Make sure the path looks like a string.\n    if (!filePath || filePath.length === 0) {\n      throw new Error('The file path is invalid.');\n    }\n\n    // Make sure there is a file at the path. lstatSync will throw if there is\n    // nothing there.\n    try {\n      // Resolve path to actual file in case of symlink. Expect a thrown error\n      // if not resolvable.\n      filePath = fs.realpathSync(filePath);\n\n      if (!fs.lstatSync(filePath).isFile()) {\n        throw new Error();\n      }\n    } catch (err) {\n      throw this.createError(\n          util.format(\n              'The file at %s does not exist, or it is not a file.', filePath),\n          err);\n    }\n\n    // Now open a read stream on the file, and parse it.\n    try {\n      const readStream = this._createReadStream(filePath);\n      return this.fromStream(readStream, options);\n    } catch (err) {\n      throw this.createError(\n          util.format('Unable to read the file at %s.', filePath), err);\n    }\n  }\n\n  /**\n   * Credentials from the Cloud SDK that are associated with Cloud SDK's project\n   * are problematic because they may not have APIs enabled and have limited\n   * quota. If this is the case, warn about it.\n   */\n  protected warnOnProblematicCredentials(client: JWT) {\n    if (client.email === CLOUD_SDK_CLIENT_ID) {\n      messages.warn(messages.PROBLEMATIC_CREDENTIALS_WARNING);\n    }\n  }\n\n  /**\n   * Create a credentials instance using the given input options.\n   * @param json The input object.\n   * @returns JWT or UserRefresh Client with data\n   */\n  fromJSON(json: JWTInput, options?: RefreshOptions): JWT|UserRefreshClient {\n    let client: UserRefreshClient|JWT;\n    if (!json) {\n      throw new Error(\n          'Must pass in a JSON object containing the Google auth settings.');\n    }\n    this.jsonContent = json;\n    options = options || {};\n    if (json.type === 'authorized_user') {\n      client = new UserRefreshClient(options);\n    } else {\n      (options as JWTOptions).scopes = this.scopes;\n      client = new JWT(options);\n    }\n    client.fromJSON(json);\n    return client;\n  }\n\n  /**\n   * Create a credentials instance using the given input stream.\n   * @param inputStream The input stream.\n   * @param callback Optional callback.\n   */\n  fromStream(inputStream: stream.Readable): Promise;\n  fromStream(inputStream: stream.Readable, callback: CredentialCallback): void;\n  fromStream(inputStream: stream.Readable, options: RefreshOptions):\n      Promise;\n  fromStream(\n      inputStream: stream.Readable, options: RefreshOptions,\n      callback: CredentialCallback): void;\n  fromStream(\n      inputStream: stream.Readable,\n      optionsOrCallback: RefreshOptions|CredentialCallback = {},\n      callback?: CredentialCallback): Promise|void {\n    let options: RefreshOptions = {};\n    if (typeof optionsOrCallback === 'function') {\n      callback = optionsOrCallback;\n    } else {\n      options = optionsOrCallback;\n    }\n    if (callback) {\n      this.fromStreamAsync(inputStream, options)\n          .then(r => callback!(null, r), callback);\n    } else {\n      return this.fromStreamAsync(inputStream, options);\n    }\n  }\n\n  private fromStreamAsync(\n      inputStream: stream.Readable,\n      options?: RefreshOptions): Promise {\n    return new Promise((resolve, reject) => {\n      if (!inputStream) {\n        throw new Error(\n            'Must pass in a stream containing the Google auth settings.');\n      }\n      let s = '';\n      inputStream.setEncoding('utf8')\n          .on('error', reject)\n          .on('data', (chunk) => s += chunk)\n          .on('end', () => {\n            try {\n              const data = JSON.parse(s);\n              const r = this.fromJSON(data, options);\n              return resolve(r);\n            } catch (err) {\n              return reject(err);\n            }\n          });\n    });\n  }\n\n  /**\n   * Create a credentials instance using the given API key string.\n   * @param apiKey The API key string\n   * @param options An optional options object.\n   * @returns A JWT loaded from the key\n   */\n  fromAPIKey(apiKey: string, options?: RefreshOptions): JWT {\n    options = options || {};\n    const client = new JWT(options);\n    client.fromAPIKey(apiKey);\n    return client;\n  }\n\n  /**\n   * Determines whether the current operating system is Windows.\n   * @api private\n   */\n  private _isWindows() {\n    const sys = this._osPlatform();\n    if (sys && sys.length >= 3) {\n      if (sys.substring(0, 3).toLowerCase() === 'win') {\n        return true;\n      }\n    }\n    return false;\n  }\n\n  /**\n   * Creates a file stream. Allows mocking.\n   * @api private\n   */\n  _createReadStream(filePath: string) {\n    return fs.createReadStream(filePath);\n  }\n\n  /**\n   * Gets the current operating system platform. Allows mocking.\n   * @api private\n   */\n  _osPlatform() {\n    return os.platform();\n  }\n\n  /**\n   * Determines whether a file exists. Allows mocking.\n   * @api private\n   */\n  _fileExists(filePath: string) {\n    return fs.existsSync(filePath);\n  }\n\n  /**\n   * Joins two parts of a path. Allows mocking.\n   * @api private\n   */\n  _pathJoin(item1: string, item2: string) {\n    return path.join(item1, item2);\n  }\n\n  /**\n   * Allows mocking of the path to a well-known file.\n   * @api private\n   */\n  _mockWellKnownFilePath(filePath: string) {\n    return filePath;\n  }\n\n  // Creates an Error containing the given message, and includes the message\n  // from the optional err passed in.\n  private createError(message: string, err: Error) {\n    let s = message || '';\n    if (err) {\n      const errorMessage = String(err);\n      if (errorMessage && errorMessage.length > 0) {\n        if (s.length > 0) {\n          s += ' ';\n        }\n        s += errorMessage;\n      }\n    }\n    return Error(s);\n  }\n\n  /**\n   * Run the Google Cloud SDK command that prints the default project ID\n   */\n  private async getDefaultServiceProjectId(): Promise {\n    return new Promise(resolve => {\n      exec(\n          'gcloud config config-helper --format json',\n          (err, stdout, stderr) => {\n            if (!err && stdout) {\n              try {\n                const projectId =\n                    JSON.parse(stdout).configuration.properties.core.project;\n                resolve(projectId);\n                return;\n              } catch (e) {\n                // ignore errors\n              }\n            }\n            resolve(null);\n          });\n    });\n  }\n\n  /**\n   * Loads the project id from environment variables.\n   * @api private\n   */\n  private getProductionProjectId() {\n    return process.env['GCLOUD_PROJECT'] || process.env['GOOGLE_CLOUD_PROJECT'];\n  }\n\n  /**\n   * Loads the project id from the GOOGLE_APPLICATION_CREDENTIALS json file.\n   * @api private\n   */\n  private async getFileProjectId(): Promise {\n    if (this.cachedCredential) {\n      // Try to read the project ID from the cached credentials file\n      return this.cachedCredential.projectId;\n    }\n\n    // Try to load a credentials file and read its project ID\n    const r = await this._tryGetApplicationCredentialsFromEnvironmentVariable();\n    if (r) {\n      return r.projectId;\n    } else {\n      return null;\n    }\n  }\n\n  /**\n   * Gets the Compute Engine project ID if it can be inferred.\n   */\n  private async getGCEProjectId() {\n    try {\n      const r = await gcpMetadata.project('project-id');\n      return r.data;\n    } catch (e) {\n      // Ignore any errors\n      return null;\n    }\n  }\n\n  /**\n   * The callback function handles a credential object that contains the\n   * client_email and private_key (if exists).\n   * getCredentials checks for these values from the user JSON at first.\n   * If it doesn't exist, and the environment is on GCE, it gets the\n   * client_email from the cloud metadata server.\n   * @param callback Callback that handles the credential object that contains\n   * a client_email and optional private key, or the error.\n   * returned\n   */\n  getCredentials(): Promise;\n  getCredentials(\n      callback: (err: Error|null, credentials?: CredentialBody) => void): void;\n  getCredentials(\n      callback?: (err: Error|null, credentials?: CredentialBody) => void):\n      void|Promise {\n    if (callback) {\n      this.getCredentialsAsync().then(r => callback(null, r), callback);\n    } else {\n      return this.getCredentialsAsync();\n    }\n  }\n\n  private async getCredentialsAsync(): Promise {\n    if (this.jsonContent) {\n      const credential: CredentialBody = {\n        client_email: this.jsonContent.client_email,\n        private_key: this.jsonContent.private_key\n      };\n      return credential;\n    }\n\n    const isGCE = await this._checkIsGCE();\n    if (!isGCE) {\n      throw new Error('Unknown error.');\n    }\n\n    // For GCE, return the service account details from the metadata server\n    // NOTE: The trailing '/' at the end of service-accounts/ is very important!\n    // The GCF metadata server doesn't respect querystring params if this / is\n    // not included.\n    const {data} = await gcpMetadata.instance(\n        {property: 'service-accounts/', params: {recursive: true}});\n\n    if (!data || !data.default || !data.default.email) {\n      throw new Error('Failure from metadata server.');\n    }\n\n    return {client_email: data.default.email};\n  }\n\n  /**\n   * Automatically obtain a client based on the provided configuration.  If no\n   * options were passed, use Application Default Credentials.\n   */\n  async getClient(options?: GoogleAuthOptions) {\n    if (options) {\n      this.keyFilename =\n          options.keyFilename || options.keyFile || this.keyFilename;\n      this.scopes = options.scopes || this.scopes;\n      this.jsonContent = options.credentials || this.jsonContent;\n    }\n    if (!this.cachedCredential) {\n      if (this.jsonContent) {\n        this.cachedCredential = await this.fromJSON(this.jsonContent);\n      } else if (this.keyFilename) {\n        const filePath = path.resolve(this.keyFilename);\n        const stream = fs.createReadStream(filePath);\n        this.cachedCredential = await this.fromStreamAsync(stream);\n      } else {\n        await this.getApplicationDefaultAsync();\n      }\n    }\n    return this.cachedCredential!;\n  }\n\n  /**\n   * Automatically obtain application default credentials, and return\n   * an access token for making requests.\n   */\n  async getAccessToken() {\n    const client = await this.getClient();\n    return (await client.getAccessToken()).token;\n  }\n\n  /**\n   * Obtain the HTTP headers that will provide authorization for a given\n   * request.\n   */\n  async getRequestHeaders(url?: string) {\n    const client = await this.getClient();\n    return client.getRequestHeaders(url);\n  }\n\n  /**\n   * Obtain credentials for a request, then attach the appropriate headers to\n   * the request options.\n   * @param opts Axios or Request options on which to attach the headers\n   */\n  async authorizeRequest(opts:\n                             {url?: string, uri?: string, headers?: Headers}) {\n    opts = opts || {};\n    const url = opts.url || opts.uri;\n    const client = await this.getClient();\n    const headers = await client.getRequestHeaders(url);\n    opts.headers = Object.assign(opts.headers || {}, headers);\n    return opts;\n  }\n\n  /**\n   * Automatically obtain application default credentials, and make an\n   * HTTP request using the given options.\n   * @param opts Axios request options for the HTTP request.\n   */\n  // tslint:disable-next-line no-any\n  async request(opts: AxiosRequestConfig): Promise> {\n    const client = await this.getClient();\n    return client.request(opts);\n  }\n\n  /**\n   * Determine the compute environment in which the code is running.\n   */\n  getEnv(): Promise {\n    return getEnv();\n  }\n\n  /**\n   * Sign the given data with the current private key, or go out\n   * to the IAM API to sign it.\n   * @param data The data to be signed.\n   */\n  async sign(data: string): Promise {\n    const client = await this.getClient();\n    if (client instanceof JWT && client.key) {\n      const sign = crypto.createSign('RSA-SHA256');\n      sign.update(data);\n      return sign.sign(client.key, 'base64');\n    }\n\n    const projectId = await this.getProjectId();\n    if (!projectId) {\n      throw new Error('Cannot sign data without a project ID.');\n    }\n\n    const creds = await this.getCredentials();\n    if (!creds.client_email) {\n      throw new Error('Cannot sign data without `client_email`.');\n    }\n\n    const id = `projects/${projectId}/serviceAccounts/${creds.client_email}`;\n    const res = await this.request({\n      method: 'POST',\n      url: `https://iam.googleapis.com/v1/${id}:signBlob`,\n      data: {bytesToSign: Buffer.from(data).toString('base64')}\n    });\n    return res.data.signature;\n  }\n}\n\nexport interface SignBlobResponse {\n  signature: string;\n}\n\n    \n\n\n\n\n\n\n\n                   \n    \n         result-matching \"\"\n        \n    \n    \n        No results matching \"\"\n    \n\n"},"classes/IAMAuth.html":{"url":"classes/IAMAuth.html","title":"class - IAMAuth","body":"\n                   \n\n\n\n\n\n\n\n\n\n\n\n\n  Classes\n  IAMAuth\n\n\n\n        \n            Info\n        \n        \n            Source\n        \n\n\n\n    \n        \n            File\n        \n        \n            src/auth/iam.ts\n        \n\n\n\n\n\n            \n    Index\n    \n        \n                \n                    \n                        Properties\n                    \n                \n                \n                    \n                        \n                            \n                                    Public\n                                selector\n                            \n                            \n                                    Public\n                                token\n                            \n                        \n                    \n                \n\n                \n                    \n                        Methods\n                    \n                \n                \n                    \n                        \n                            \n                                createScopedRequired\n                            \n                            \n                                getRequestHeaders\n                            \n                            \n                                getRequestMetadata\n                            \n                        \n                    \n                \n\n\n\n\n\n        \n    \n\n\n            \n    Constructor\n        \n            \n                \n                    \nconstructor(selector: string, token: string)\n                    \n                \n                        \n                            \n                                Defined in src/auth/iam.ts:24\n                            \n                        \n\n                \n                    \n                            IAM credentials.\n\n                            \n                                    Parameters :\n                                    \n                                        \n                                            \n                                                Name\n                                                    Type\n                                                Optional\n                                                    Description\n                                            \n                                        \n                                        \n                                                \n                                                        selector\n                                                  \n                                                        \n                                                                    string\n                                                        \n                                                  \n                                                    \n                                                            No\n                                                    \n                                                    \n                                                        \n                                                                the iam authority selector\n\n                                                        \n                                                \n                                                \n                                                        token\n                                                  \n                                                        \n                                                                    string\n                                                        \n                                                  \n                                                    \n                                                            No\n                                                    \n                                                    \n                                                        \n                                                                the token\n\n                                                        \n                                                \n                                        \n                                    \n                            \n                    \n                \n            \n        \n\n\n            \n    \n        \n            Properties\n        \n        \n            \n                \n                    \n                        \n                        \n                            \n                                Public\n                            selector\n                            \n                            \n                        \n                    \n                \n                \n                    \n                        selector:     string\n\n                    \n                \n                    \n                        \n                            Type :     string\n\n                        \n                    \n                        \n                            \n                                    Defined in src/auth/iam.ts:32\n                            \n                        \n\n                \n                    \n                        the iam authority selector\n                    \n                \n\n            \n        \n        \n            \n                \n                    \n                        \n                        \n                            \n                                Public\n                            token\n                            \n                            \n                        \n                    \n                \n                \n                    \n                        token:     string\n\n                    \n                \n                    \n                        \n                            Type :     string\n\n                        \n                    \n                        \n                            \n                                    Defined in src/auth/iam.ts:32\n                            \n                        \n\n                \n                    \n                        the token\n                    \n                \n\n            \n        \n\n\n            \n    \n        \n            Methods\n        \n        \n            \n                \n                    \n                        \n                        \n                            \n                            createScopedRequired\n                            \n                            \n                        \n                    \n                \n                \n                    \ncreateScopedRequired()\n                    \n                \n\n\n                        \n                            \n                                    Defined in src/auth/iam.ts:43\n                            \n                        \n\n\n                \n                    \n                            Indicates whether the credential requires scopes to be created by calling\ncreatedScoped before use.\n\n\n                            \n                            \n                            \n                                Returns :     boolean\n\n                            \n                                \n                                    always false\n\n                                \n                    \n                \n            \n        \n        \n            \n                \n                    \n                        \n                        \n                            \n                            getRequestHeaders\n                            \n                            \n                        \n                    \n                \n                \n                    \ngetRequestHeaders()\n                    \n                \n\n\n                        \n                            \n                                    Defined in src/auth/iam.ts:66\n                            \n                        \n\n\n                \n                    \n                            Acquire the HTTP headers required to make an authenticated request.\n\n\n                            \n                                Returns :     { 'x-goog-iam-authority-selector': string; 'x-goog-iam-authorization-token': string; }\n\n                            \n                    \n                \n            \n        \n        \n            \n                \n                    \n                        \n                        \n                            \n                            getRequestMetadata\n                            \n                            \n                        \n                    \n                \n                \n                    \ngetRequestMetadata(unusedUri: string | null, metadataFn: (err: Error | null,metadata: RequestMetadata) => void)\n                    \n                \n\n\n                        \n                            \n                                    Defined in src/auth/iam.ts:56\n                            \n                        \n\n\n                \n                    \n                            Pass the selector and token to the metadataFn callback.\n\n\n                            \n                                    Parameters :\n                                    \n                                        \n                                            \n                                                Name\n                                                    Type\n                                                Optional\n                                                    Description\n                                            \n                                        \n                                        \n                                                \n                                                        unusedUri\n                                                        \n                                                                    string | null\n                                                        \n                                                    \n                                                    \n                                                            No\n                                                    \n                                                    \n\n                                                        \n                                                        \n                                                \n                                                \n                                                        metadataFn\n                                                        \n                                                                    function\n                                                        \n                                                    \n                                                    \n                                                            No\n                                                    \n                                                    \n\n                                                        \n                                                                a callback invoked with object containing request\nmetadata.\n\n                                                        \n                                                \n                                        \n                                    \n                            \n                            \n                            \n                            \n                                Returns :     void\n\n                            \n                                \n                                    \n                                \n                    \n                \n            \n        \n\n\n\n\n\n\n\n    \n\n\n    \n        import * as messages from '../messages';\n\nexport interface RequestMetadata {\n  'x-goog-iam-authority-selector': string;\n  'x-goog-iam-authorization-token': string;\n}\n\nexport class IAMAuth {\n  /**\n   * IAM credentials.\n   *\n   * @param selector the iam authority selector\n   * @param token the token\n   * @constructor\n   */\n  constructor(public selector: string, public token: string) {\n    this.selector = selector;\n    this.token = token;\n  }\n\n  /**\n   * Indicates whether the credential requires scopes to be created by calling\n   * createdScoped before use.\n   * @deprecated\n   * @return always false\n   */\n  createScopedRequired() {\n    // IAM authorization does not use scopes.\n    messages.warn(messages.IAM_CREATE_SCOPED_DEPRECATED);\n    return false;\n  }\n\n  /**\n   * Pass the selector and token to the metadataFn callback.\n   * @deprecated\n   * @param unused_uri is required of the credentials interface\n   * @param metadataFn a callback invoked with object containing request\n   * metadata.\n   */\n  getRequestMetadata(\n      unusedUri: string|null,\n      metadataFn: (err: Error|null, metadata?: RequestMetadata) => void) {\n    messages.warn(messages.IAM_GET_REQUEST_METADATA_DEPRECATED);\n    metadataFn(null, this.getRequestHeaders());\n  }\n\n  /**\n   * Acquire the HTTP headers required to make an authenticated request.\n   */\n  getRequestHeaders() {\n    return {\n      'x-goog-iam-authority-selector': this.selector,\n      'x-goog-iam-authorization-token': this.token\n    };\n  }\n}\n\n    \n\n\n\n\n\n\n\n\n                   \n    \n         result-matching \"\"\n        \n    \n    \n        No results matching \"\"\n    \n\n"},"classes/JWTAccess.html":{"url":"classes/JWTAccess.html","title":"class - JWTAccess","body":"\n                   \n\n\n\n\n\n\n\n\n\n\n\n\n  Classes\n  JWTAccess\n\n\n\n        \n            Info\n        \n        \n            Source\n        \n\n\n\n    \n        \n            File\n        \n        \n            src/auth/jwtaccess.ts\n        \n\n\n\n\n\n            \n    Index\n    \n        \n                \n                    \n                        Properties\n                    \n                \n                \n                    \n                        \n                            \n                                    Optional\n                                email\n                            \n                            \n                                    Optional\n                                key\n                            \n                            \n                                    Optional\n                                keyId\n                            \n                            \n                                    Optional\n                                projectId\n                            \n                        \n                    \n                \n\n                \n                    \n                        Methods\n                    \n                \n                \n                    \n                        \n                            \n                                createScopedRequired\n                            \n                            \n                                fromJSON\n                            \n                            \n                                fromStream\n                            \n                            \n                                fromStream\n                            \n                            \n                                fromStream\n                            \n                            \n                                getRequestHeaders\n                            \n                            \n                                getRequestMetadata\n                            \n                        \n                    \n                \n\n\n\n\n\n        \n    \n\n\n            \n    Constructor\n        \n            \n                \n                    \nconstructor(email?: string | null, key?: string | null, keyId?: string | null)\n                    \n                \n                        \n                            \n                                Defined in src/auth/jwtaccess.ts:41\n                            \n                        \n\n                \n                    \n                            JWTAccess service account credentials.\nCreate a new access token by using the credential to create a new JWT token\nthat's recognized as the access token.\n\n                            \n                                    Parameters :\n                                    \n                                        \n                                            \n                                                Name\n                                                    Type\n                                                Optional\n                                                    Description\n                                            \n                                        \n                                        \n                                                \n                                                        email\n                                                  \n                                                        \n                                                                    string | null\n                                                        \n                                                  \n                                                    \n                                                            Yes\n                                                    \n                                                    \n                                                        \n                                                                the service account email address.\n\n                                                        \n                                                \n                                                \n                                                        key\n                                                  \n                                                        \n                                                                    string | null\n                                                        \n                                                  \n                                                    \n                                                            Yes\n                                                    \n                                                    \n                                                        \n                                                                the private key that will be used to sign the token.\n\n                                                        \n                                                \n                                                \n                                                        keyId\n                                                  \n                                                        \n                                                                    string | null\n                                                        \n                                                  \n                                                    \n                                                            Yes\n                                                    \n                                                    \n                                                        \n                                                                the ID of the private key used to sign the token.\n\n                                                        \n                                                \n                                        \n                                    \n                            \n                    \n                \n            \n        \n\n\n            \n    \n        \n            Properties\n        \n        \n            \n                \n                    \n                        \n                        \n                            \n                                Optional\n                            email\n                            \n                            \n                        \n                    \n                \n                \n                    \n                        email:     string | null\n\n                    \n                \n                    \n                        \n                            Type :     string | null\n\n                        \n                    \n                        \n                            \n                                    Defined in src/auth/jwtaccess.ts:36\n                            \n                        \n\n\n            \n        \n        \n            \n                \n                    \n                        \n                        \n                            \n                                Optional\n                            key\n                            \n                            \n                        \n                    \n                \n                \n                    \n                        key:     string | null\n\n                    \n                \n                    \n                        \n                            Type :     string | null\n\n                        \n                    \n                        \n                            \n                                    Defined in src/auth/jwtaccess.ts:37\n                            \n                        \n\n\n            \n        \n        \n            \n                \n                    \n                        \n                        \n                            \n                                Optional\n                            keyId\n                            \n                            \n                        \n                    \n                \n                \n                    \n                        keyId:     string | null\n\n                    \n                \n                    \n                        \n                            Type :     string | null\n\n                        \n                    \n                        \n                            \n                                    Defined in src/auth/jwtaccess.ts:38\n                            \n                        \n\n\n            \n        \n        \n            \n                \n                    \n                        \n                        \n                            \n                                Optional\n                            projectId\n                            \n                            \n                        \n                    \n                \n                \n                    \n                        projectId:     string\n\n                    \n                \n                    \n                        \n                            Type :     string\n\n                        \n                    \n                        \n                            \n                                    Defined in src/auth/jwtaccess.ts:39\n                            \n                        \n\n\n            \n        \n\n\n            \n    \n        \n            Methods\n        \n        \n            \n                \n                    \n                        \n                        \n                            \n                            createScopedRequired\n                            \n                            \n                        \n                    \n                \n                \n                    \ncreateScopedRequired()\n                    \n                \n\n\n                        \n                            \n                                    Defined in src/auth/jwtaccess.ts:65\n                            \n                        \n\n\n                \n                    \n                            Indicates whether the credential requires scopes to be created by calling\ncreatedScoped before use.\n\n\n                            \n                            \n                            \n                                Returns :     boolean\n\n                            \n                                \n                                    always false\n\n                                \n                    \n                \n            \n        \n        \n            \n                \n                    \n                        \n                        \n                            \n                            fromJSON\n                            \n                            \n                        \n                    \n                \n                \n                    \nfromJSON(json: JWTInput)\n                    \n                \n\n\n                        \n                            \n                                    Defined in src/auth/jwtaccess.ts:134\n                            \n                        \n\n\n                \n                    \n                            Create a JWTAccess credentials instance using the given input options.\n\n\n                            \n                                    Parameters :\n                                    \n                                        \n                                            \n                                                Name\n                                                    Type\n                                                Optional\n                                                    Description\n                                            \n                                        \n                                        \n                                                \n                                                        json\n                                                        \n                                                                    JWTInput\n                                                        \n                                                    \n                                                    \n                                                            No\n                                                    \n                                                    \n\n                                                        \n                                                                The input object.\n\n                                                        \n                                                \n                                        \n                                    \n                            \n                            \n                            \n                            \n                                Returns :     void\n\n                            \n                                \n                                    \n                                \n                    \n                \n            \n        \n        \n            \n                \n                    \n                        \n                        \n                            \n                            fromStream\n                            \n                            \n                        \n                    \n                \n                \n                    \nfromStream(inputStream: stream.Readable)\n                    \n                \n\n\n                        \n                            \n                                    Defined in src/auth/jwtaccess.ts:159\n                            \n                        \n\n\n                \n                    \n                            Create a JWTAccess credentials instance using the given input stream.\n\n\n                            \n                                    Parameters :\n                                    \n                                        \n                                            \n                                                Name\n                                                    Type\n                                                Optional\n                                                    Description\n                                            \n                                        \n                                        \n                                                \n                                                        inputStream\n                                                        \n                                                                    stream.Readable\n                                                        \n                                                    \n                                                    \n                                                            No\n                                                    \n                                                    \n\n                                                        \n                                                                The input stream.\n\n                                                        \n                                                \n                                        \n                                    \n                            \n                            \n                            \n                            \n                                Returns :     Promise\n\n                            \n                                \n                                    \n                                \n                    \n                \n            \n        \n        \n            \n                \n                    \n                        \n                        \n                            \n                            fromStream\n                            \n                            \n                        \n                    \n                \n                \n                    \nfromStream(inputStream: stream.Readable, callback: (err: Error) => void)\n                    \n                \n\n\n                        \n                            \n                                    Defined in src/auth/jwtaccess.ts:160\n                            \n                        \n\n\n                \n                    \n\n                            \n                                    Parameters :\n                                    \n                                        \n                                            \n                                                Name\n                                                    Type\n                                                Optional\n                                            \n                                        \n                                        \n                                                \n                                                        inputStream\n                                                        \n                                                                    stream.Readable\n                                                        \n                                                    \n                                                    \n                                                            No\n                                                    \n                                                    \n\n                                                \n                                                \n                                                        callback\n                                                        \n                                                                    function\n                                                        \n                                                    \n                                                    \n                                                            No\n                                                    \n                                                    \n\n                                                \n                                        \n                                    \n                            \n                            \n                            \n                            \n                                Returns :     void\n\n                            \n                                \n                                    \n                                \n                    \n                \n            \n        \n        \n            \n                \n                    \n                        \n                        \n                            \n                            fromStream\n                            \n                            \n                        \n                    \n                \n                \n                    \nfromStream(inputStream: stream.Readable, callback?: (err?: Error) => void)\n                    \n                \n\n\n                        \n                            \n                                    Defined in src/auth/jwtaccess.ts:162\n                            \n                        \n\n\n                \n                    \n\n                            \n                                    Parameters :\n                                    \n                                        \n                                            \n                                                Name\n                                                    Type\n                                                Optional\n                                            \n                                        \n                                        \n                                                \n                                                        inputStream\n                                                        \n                                                                    stream.Readable\n                                                        \n                                                    \n                                                    \n                                                            No\n                                                    \n                                                    \n\n                                                \n                                                \n                                                        callback\n                                                        \n                                                                    function\n                                                        \n                                                    \n                                                    \n                                                            Yes\n                                                    \n                                                    \n\n                                                \n                                        \n                                    \n                            \n                            \n                            \n                            \n                                Returns :     void | Promise\n\n                            \n                                \n                                    \n                                \n                    \n                \n            \n        \n        \n            \n                \n                    \n                        \n                        \n                            \n                            getRequestHeaders\n                            \n                            \n                        \n                    \n                \n                \n                    \ngetRequestHeaders(url: string, additionalClaims?: Claims)\n                    \n                \n\n\n                        \n                            \n                                    Defined in src/auth/jwtaccess.ts:94\n                            \n                        \n\n\n                \n                    \n                            Get a non-expired access token, after refreshing if necessary.\n\n\n                            \n                                    Parameters :\n                                    \n                                        \n                                            \n                                                Name\n                                                    Type\n                                                Optional\n                                                    Description\n                                            \n                                        \n                                        \n                                                \n                                                        url\n                                                        \n                                                                    string\n                                                        \n                                                    \n                                                    \n                                                            No\n                                                    \n                                                    \n\n                                                        \n                                                                The URI being authorized.\n\n                                                        \n                                                \n                                                \n                                                        additionalClaims\n                                                        \n                                                                    Claims\n                                                        \n                                                    \n                                                    \n                                                            Yes\n                                                    \n                                                    \n\n                                                        \n                                                                An object with a set of additional claims to\ninclude in the payload.\n\n                                                        \n                                                \n                                        \n                                    \n                            \n                            \n                            \n                            \n                                Returns :     Headers\n\n                            \n                                \n                                    An object that includes the authorization header.\n\n                                \n                    \n                \n            \n        \n        \n            \n                \n                    \n                        \n                        \n                            \n                            getRequestMetadata\n                            \n                            \n                        \n                    \n                \n                \n                    \ngetRequestMetadata(url: string, additionalClaims?: Claims)\n                    \n                \n\n\n                        \n                            \n                                    Defined in src/auth/jwtaccess.ts:80\n                            \n                        \n\n\n                \n                    \n                            Get a non-expired access token, after refreshing if necessary.\n\n\n                            \n                                    Parameters :\n                                    \n                                        \n                                            \n                                                Name\n                                                    Type\n                                                Optional\n                                                    Description\n                                            \n                                        \n                                        \n                                                \n                                                        url\n                                                        \n                                                                    string\n                                                        \n                                                    \n                                                    \n                                                            No\n                                                    \n                                                    \n\n                                                        \n                                                        \n                                                \n                                                \n                                                        additionalClaims\n                                                        \n                                                                    Claims\n                                                        \n                                                    \n                                                    \n                                                            Yes\n                                                    \n                                                    \n\n                                                        \n                                                                An object with a set of additional claims to\ninclude in the payload.\n\n                                                        \n                                                \n                                        \n                                    \n                            \n                            \n                            \n                            \n                                Returns :     RequestMetadataResponse\n\n                            \n                                \n                                    An object that includes the authorization header.\n\n                                \n                    \n                \n            \n        \n\n\n\n\n\n\n\n    \n\n\n    \n        import * as jws from 'jws';\nimport * as LRU from 'lru-cache';\nimport * as stream from 'stream';\n\nimport * as messages from '../messages';\n\nimport {JWTInput} from './credentials';\nimport {Headers, RequestMetadataResponse} from './oauth2client';\n\nconst DEFAULT_HEADER: jws.Header = {\n  alg: 'RS256',\n  typ: 'JWT'\n};\n\nexport type Claims = {\n  [index: string]: string\n};\n\nexport class JWTAccess {\n  email?: string|null;\n  key?: string|null;\n  keyId?: string|null;\n  projectId?: string;\n\n  private cache = new LRU({max: 500, maxAge: 60 * 60 * 1000});\n\n  /**\n   * JWTAccess service account credentials.\n   *\n   * Create a new access token by using the credential to create a new JWT token\n   * that's recognized as the access token.\n   *\n   * @param email the service account email address.\n   * @param key the private key that will be used to sign the token.\n   * @param keyId the ID of the private key used to sign the token.\n   */\n  constructor(email?: string|null, key?: string|null, keyId?: string|null) {\n    this.email = email;\n    this.key = key;\n    this.keyId = keyId;\n  }\n\n  /**\n   * Indicates whether the credential requires scopes to be created by calling\n   * createdScoped before use.\n   * @deprecated\n   * @return always false\n   */\n  createScopedRequired(): boolean {\n    // JWT Header authentication does not use scopes.\n    messages.warn(messages.JWT_ACCESS_CREATE_SCOPED_DEPRECATED);\n    return false;\n  }\n\n  /**\n   * Get a non-expired access token, after refreshing if necessary.\n   *\n   * @param authURI The URI being authorized.\n   * @param additionalClaims An object with a set of additional claims to\n   * include in the payload.\n   * @deprecated Please use `getRequestHeaders` instead.\n   * @returns An object that includes the authorization header.\n   */\n  getRequestMetadata(url: string, additionalClaims?: Claims):\n      RequestMetadataResponse {\n    messages.warn(messages.JWT_ACCESS_GET_REQUEST_METADATA_DEPRECATED);\n    return {headers: this.getRequestHeaders(url, additionalClaims)};\n  }\n\n  /**\n   * Get a non-expired access token, after refreshing if necessary.\n   *\n   * @param url The URI being authorized.\n   * @param additionalClaims An object with a set of additional claims to\n   * include in the payload.\n   * @returns An object that includes the authorization header.\n   */\n  getRequestHeaders(url: string, additionalClaims?: Claims): Headers {\n    const cachedToken = this.cache.get(url);\n    if (cachedToken) {\n      return cachedToken;\n    }\n    const iat = Math.floor(new Date().getTime() / 1000);\n    const exp = iat + 3600;  // 3600 seconds = 1 hour\n\n    // The payload used for signed JWT headers has:\n    // iss == sub == \n    // aud == \n    const defaultClaims =\n        {iss: this.email, sub: this.email, aud: url, exp, iat};\n\n    // if additionalClaims are provided, ensure they do not collide with\n    // other required claims.\n    if (additionalClaims) {\n      for (const claim in defaultClaims) {\n        if (additionalClaims[claim]) {\n          throw new Error(`The '${\n              claim}' property is not allowed when passing additionalClaims. This claim is included in the JWT by default.`);\n        }\n      }\n    }\n\n    const header =\n        this.keyId ? {...DEFAULT_HEADER, kid: this.keyId} : DEFAULT_HEADER;\n    const payload = Object.assign(defaultClaims, additionalClaims);\n\n    // Sign the jwt and add it to the cache\n    const signedJWT = jws.sign({header, payload, secret: this.key});\n    const headers = {Authorization: `Bearer ${signedJWT}`};\n    this.cache.set(url, headers);\n    return headers;\n  }\n\n  /**\n   * Create a JWTAccess credentials instance using the given input options.\n   * @param json The input object.\n   */\n  fromJSON(json: JWTInput): void {\n    if (!json) {\n      throw new Error(\n          'Must pass in a JSON object containing the service account auth settings.');\n    }\n    if (!json.client_email) {\n      throw new Error(\n          'The incoming JSON object does not contain a client_email field');\n    }\n    if (!json.private_key) {\n      throw new Error(\n          'The incoming JSON object does not contain a private_key field');\n    }\n    // Extract the relevant information from the json key file.\n    this.email = json.client_email;\n    this.key = json.private_key;\n    this.keyId = json.private_key_id;\n    this.projectId = json.project_id;\n  }\n\n  /**\n   * Create a JWTAccess credentials instance using the given input stream.\n   * @param inputStream The input stream.\n   * @param callback Optional callback.\n   */\n  fromStream(inputStream: stream.Readable): Promise;\n  fromStream(inputStream: stream.Readable, callback: (err?: Error) => void):\n      void;\n  fromStream(inputStream: stream.Readable, callback?: (err?: Error) => void):\n      void|Promise {\n    if (callback) {\n      this.fromStreamAsync(inputStream).then(r => callback(), callback);\n    } else {\n      return this.fromStreamAsync(inputStream);\n    }\n  }\n\n  private fromStreamAsync(inputStream: stream.Readable): Promise {\n    return new Promise((resolve, reject) => {\n      if (!inputStream) {\n        reject(new Error(\n            'Must pass in a stream containing the service account auth settings.'));\n      }\n      let s = '';\n      inputStream.setEncoding('utf8')\n          .on('data', (chunk) => s += chunk)\n          .on('error', reject)\n          .on('end', () => {\n            try {\n              const data = JSON.parse(s);\n              this.fromJSON(data);\n              resolve();\n            } catch (err) {\n              reject(err);\n            }\n          });\n    });\n  }\n}\n\n    \n\n\n\n\n\n\n\n\n                   \n    \n         result-matching \"\"\n        \n    \n    \n        No results matching \"\"\n    \n\n"},"interfaces/JWTInput.html":{"url":"interfaces/JWTInput.html","title":"interface - JWTInput","body":"\n                   \n\n\n\n\n\n\n\n\n\n\n\n\n\n  Interfaces\n  JWTInput\n\n\n\n        \n            Info\n        \n        \n            Source\n        \n\n\n\n    \n        \n            File\n        \n        \n            src/auth/credentials.ts\n        \n\n\n\n        \n            Index\n            \n                \n                    \n                        \n                            Properties\n                        \n                    \n                    \n                        \n                            \n                                \n                                            Optional\n                                        client_email\n                                \n                                \n                                            Optional\n                                        client_id\n                                \n                                \n                                            Optional\n                                        client_secret\n                                \n                                \n                                            Optional\n                                        private_key\n                                \n                                \n                                            Optional\n                                        private_key_id\n                                \n                                \n                                            Optional\n                                        project_id\n                                \n                                \n                                            Optional\n                                        refresh_token\n                                \n                                \n                                            Optional\n                                        type\n                                \n                            \n                        \n                    \n                \n            \n        \n\n\n\n            \n                Properties\n                    \n                        \n                                \n                                    \n                                        \n                                        client_email\n                                    \n                                \n                                \n                                    \n                                        client_email:     string\n\n                                    \n                                \n\n\n                                    \n                                        \n                                            Type :     string\n\n                                        \n                                    \n\n                                    \n                                        \n                                            Optional\n                                        \n                                    \n\n\n\n\n                        \n                    \n                    \n                        \n                                \n                                    \n                                        \n                                        client_id\n                                    \n                                \n                                \n                                    \n                                        client_id:     string\n\n                                    \n                                \n\n\n                                    \n                                        \n                                            Type :     string\n\n                                        \n                                    \n\n                                    \n                                        \n                                            Optional\n                                        \n                                    \n\n\n\n\n                        \n                    \n                    \n                        \n                                \n                                    \n                                        \n                                        client_secret\n                                    \n                                \n                                \n                                    \n                                        client_secret:     string\n\n                                    \n                                \n\n\n                                    \n                                        \n                                            Type :     string\n\n                                        \n                                    \n\n                                    \n                                        \n                                            Optional\n                                        \n                                    \n\n\n\n\n                        \n                    \n                    \n                        \n                                \n                                    \n                                        \n                                        private_key\n                                    \n                                \n                                \n                                    \n                                        private_key:     string\n\n                                    \n                                \n\n\n                                    \n                                        \n                                            Type :     string\n\n                                        \n                                    \n\n                                    \n                                        \n                                            Optional\n                                        \n                                    \n\n\n\n\n                        \n                    \n                    \n                        \n                                \n                                    \n                                        \n                                        private_key_id\n                                    \n                                \n                                \n                                    \n                                        private_key_id:     string\n\n                                    \n                                \n\n\n                                    \n                                        \n                                            Type :     string\n\n                                        \n                                    \n\n                                    \n                                        \n                                            Optional\n                                        \n                                    \n\n\n\n\n                        \n                    \n                    \n                        \n                                \n                                    \n                                        \n                                        project_id\n                                    \n                                \n                                \n                                    \n                                        project_id:     string\n\n                                    \n                                \n\n\n                                    \n                                        \n                                            Type :     string\n\n                                        \n                                    \n\n                                    \n                                        \n                                            Optional\n                                        \n                                    \n\n\n\n\n                        \n                    \n                    \n                        \n                                \n                                    \n                                        \n                                        refresh_token\n                                    \n                                \n                                \n                                    \n                                        refresh_token:     string\n\n                                    \n                                \n\n\n                                    \n                                        \n                                            Type :     string\n\n                                        \n                                    \n\n                                    \n                                        \n                                            Optional\n                                        \n                                    \n\n\n\n\n                        \n                    \n                    \n                        \n                                \n                                    \n                                        \n                                        type\n                                    \n                                \n                                \n                                    \n                                        type:     string\n\n                                    \n                                \n\n\n                                    \n                                        \n                                            Type :     string\n\n                                        \n                                    \n\n                                    \n                                        \n                                            Optional\n                                        \n                                    \n\n\n\n\n                        \n                    \n            \n    \n\n\n    \n        export interface Credentials {\n  refresh_token?: string|null;\n  expiry_date?: number|null;\n  access_token?: string|null;\n  token_type?: string|null;\n  id_token?: string|null;\n}\n\nexport interface CredentialRequest {\n  refresh_token?: string;\n  access_token?: string;\n  token_type?: string;\n  expires_in?: number;\n  id_token?: string;\n}\n\nexport interface JWTInput {\n  type?: string;\n  client_email?: string;\n  private_key?: string;\n  private_key_id?: string;\n  project_id?: string;\n  client_id?: string;\n  client_secret?: string;\n  refresh_token?: string;\n}\n\nexport interface CredentialBody {\n  client_email?: string;\n  private_key?: string;\n}\n\n    \n\n\n\n\n\n\n\n                   \n    \n         result-matching \"\"\n        \n    \n    \n        No results matching \"\"\n    \n\n"},"interfaces/JWTOptions.html":{"url":"interfaces/JWTOptions.html","title":"interface - JWTOptions","body":"\n                   \n\n\n\n\n\n\n\n\n\n\n\n\n\n  Interfaces\n  JWTOptions\n\n\n\n        \n            Info\n        \n        \n            Source\n        \n\n\n\n    \n        \n            File\n        \n        \n            src/auth/jwtclient.ts\n        \n\n\n            \n                Extends\n            \n            \n                    RefreshOptions\n            \n\n        \n            Index\n            \n                \n                    \n                        \n                            Properties\n                        \n                    \n                    \n                        \n                            \n                                \n                                            Optional\n                                        additionalClaims\n                                \n                                \n                                            Optional\n                                        email\n                                \n                                \n                                            Optional\n                                        key\n                                \n                                \n                                            Optional\n                                        keyFile\n                                \n                                \n                                            Optional\n                                        keyId\n                                \n                                \n                                            Optional\n                                        scopes\n                                \n                                \n                                            Optional\n                                        subject\n                                \n                            \n                        \n                    \n                \n            \n        \n\n\n\n            \n                Properties\n                    \n                        \n                                \n                                    \n                                        \n                                        additionalClaims\n                                    \n                                \n                                \n                                    \n                                        additionalClaims:     literal type\n\n                                    \n                                \n\n\n                                    \n                                        \n                                            Type :     literal type\n\n                                        \n                                    \n\n                                    \n                                        \n                                            Optional\n                                        \n                                    \n\n\n\n\n                        \n                    \n                    \n                        \n                                \n                                    \n                                        \n                                        email\n                                    \n                                \n                                \n                                    \n                                        email:     string\n\n                                    \n                                \n\n\n                                    \n                                        \n                                            Type :     string\n\n                                        \n                                    \n\n                                    \n                                        \n                                            Optional\n                                        \n                                    \n\n\n\n\n                        \n                    \n                    \n                        \n                                \n                                    \n                                        \n                                        key\n                                    \n                                \n                                \n                                    \n                                        key:     string\n\n                                    \n                                \n\n\n                                    \n                                        \n                                            Type :     string\n\n                                        \n                                    \n\n                                    \n                                        \n                                            Optional\n                                        \n                                    \n\n\n\n\n                        \n                    \n                    \n                        \n                                \n                                    \n                                        \n                                        keyFile\n                                    \n                                \n                                \n                                    \n                                        keyFile:     string\n\n                                    \n                                \n\n\n                                    \n                                        \n                                            Type :     string\n\n                                        \n                                    \n\n                                    \n                                        \n                                            Optional\n                                        \n                                    \n\n\n\n\n                        \n                    \n                    \n                        \n                                \n                                    \n                                        \n                                        keyId\n                                    \n                                \n                                \n                                    \n                                        keyId:     string\n\n                                    \n                                \n\n\n                                    \n                                        \n                                            Type :     string\n\n                                        \n                                    \n\n                                    \n                                        \n                                            Optional\n                                        \n                                    \n\n\n\n\n                        \n                    \n                    \n                        \n                                \n                                    \n                                        \n                                        scopes\n                                    \n                                \n                                \n                                    \n                                        scopes:     string | string[]\n\n                                    \n                                \n\n\n                                    \n                                        \n                                            Type :     string | string[]\n\n                                        \n                                    \n\n                                    \n                                        \n                                            Optional\n                                        \n                                    \n\n\n\n\n                        \n                    \n                    \n                        \n                                \n                                    \n                                        \n                                        subject\n                                    \n                                \n                                \n                                    \n                                        subject:     string\n\n                                    \n                                \n\n\n                                    \n                                        \n                                            Type :     string\n\n                                        \n                                    \n\n                                    \n                                        \n                                            Optional\n                                        \n                                    \n\n\n\n\n                        \n                    \n            \n    \n\n\n    \n        import {GoogleToken} from 'gtoken';\nimport * as stream from 'stream';\n\nimport * as messages from '../messages';\nimport {CredentialBody, Credentials, JWTInput} from './credentials';\nimport {JWTAccess} from './jwtaccess';\nimport {GetTokenResponse, OAuth2Client, RefreshOptions, RequestMetadataResponse} from './oauth2client';\n\nexport interface JWTOptions extends RefreshOptions {\n  email?: string;\n  keyFile?: string;\n  key?: string;\n  keyId?: string;\n  scopes?: string|string[];\n  subject?: string;\n  additionalClaims?: {};\n}\n\nexport class JWT extends OAuth2Client {\n  email?: string;\n  keyFile?: string;\n  key?: string;\n  keyId?: string;\n  scopes?: string|string[];\n  scope?: string;\n  subject?: string;\n  gtoken?: GoogleToken;\n  additionalClaims?: {};\n\n  private access?: JWTAccess;\n\n  /**\n   * JWT service account credentials.\n   *\n   * Retrieve access token using gtoken.\n   *\n   * @param email service account email address.\n   * @param keyFile path to private key file.\n   * @param key value of key\n   * @param scopes list of requested scopes or a single scope.\n   * @param subject impersonated account's email address.\n   * @param key_id the ID of the key\n   */\n  constructor(options: JWTOptions);\n  constructor(\n      email?: string, keyFile?: string, key?: string, scopes?: string|string[],\n      subject?: string, keyId?: string);\n  constructor(\n      optionsOrEmail?: string|JWTOptions, keyFile?: string, key?: string,\n      scopes?: string|string[], subject?: string, keyId?: string) {\n    const opts = (optionsOrEmail && typeof optionsOrEmail === 'object') ?\n        optionsOrEmail :\n        {email: optionsOrEmail, keyFile, key, keyId, scopes, subject};\n    super({eagerRefreshThresholdMillis: opts.eagerRefreshThresholdMillis});\n    this.email = opts.email;\n    this.keyFile = opts.keyFile;\n    this.key = opts.key;\n    this.keyId = opts.keyId;\n    this.scopes = opts.scopes;\n    this.subject = opts.subject;\n    this.additionalClaims = opts.additionalClaims;\n    this.credentials = {refresh_token: 'jwt-placeholder', expiry_date: 1};\n  }\n\n  /**\n   * Creates a copy of the credential with the specified scopes.\n   * @param scopes List of requested scopes or a single scope.\n   * @return The cloned instance.\n   */\n  createScoped(scopes?: string|string[]) {\n    return new JWT({\n      email: this.email,\n      keyFile: this.keyFile,\n      key: this.key,\n      keyId: this.keyId,\n      scopes,\n      subject: this.subject,\n      additionalClaims: this.additionalClaims\n    });\n  }\n\n  /**\n   * Obtains the metadata to be sent with the request.\n   *\n   * @param url the URI being authorized.\n   */\n  protected async getRequestMetadataAsync(url?: string|null):\n      Promise {\n    if (!this.apiKey && !this.hasScopes() && url) {\n      if (this.additionalClaims && (this.additionalClaims as {\n                                     target_audience: string\n                                   }).target_audience) {\n        const {tokens} = await this.refreshToken();\n        return {headers: {Authorization: `Bearer ${tokens.id_token}`}};\n      } else {\n        // no scopes have been set, but a uri has been provided. Use JWTAccess\n        // credentials.\n        if (!this.access) {\n          this.access = new JWTAccess(this.email, this.key, this.keyId);\n        }\n        const headers =\n            await this.access.getRequestHeaders(url, this.additionalClaims);\n        return {headers};\n      }\n    } else {\n      return super.getRequestMetadataAsync(url);\n    }\n  }\n\n  /**\n   * Indicates whether the credential requires scopes to be created by calling\n   * createScoped before use.\n   * @deprecated\n   * @return false if createScoped does not need to be called.\n   */\n  createScopedRequired() {\n    messages.warn(messages.JWT_CREATE_SCOPED_DEPRECATED);\n    return !this.hasScopes();\n  }\n\n  /**\n   * Determine if there are currently scopes available.\n   */\n  private hasScopes() {\n    if (!this.scopes) {\n      return false;\n    }\n    // For arrays, check the array length.\n    if (this.scopes instanceof Array) {\n      return this.scopes.length > 0;\n    }\n    // For others, convert to a string and check the length.\n    return String(this.scopes).length > 0;\n  }\n\n  /**\n   * Get the initial access token using gToken.\n   * @param callback Optional callback.\n   * @returns Promise that resolves with credentials\n   */\n  authorize(): Promise;\n  authorize(callback: (err: Error|null, result?: Credentials) => void): void;\n  authorize(callback?: (err: Error|null, result?: Credentials) => void):\n      Promise|void {\n    if (callback) {\n      this.authorizeAsync().then(r => callback(null, r), callback);\n    } else {\n      return this.authorizeAsync();\n    }\n  }\n\n  private async authorizeAsync(): Promise {\n    const result = await this.refreshToken();\n    if (!result) {\n      throw new Error('No result returned');\n    }\n    this.credentials = result.tokens;\n    this.credentials.refresh_token = 'jwt-placeholder';\n    this.key = this.gtoken!.key;\n    this.email = this.gtoken!.iss;\n    return result.tokens;\n  }\n\n  /**\n   * Refreshes the access token.\n   * @param refreshToken ignored\n   * @private\n   */\n  protected async refreshTokenNoCache(refreshToken?: string|\n                                      null): Promise {\n    const gtoken = this.createGToken();\n    const token = await gtoken.getToken();\n    const tokens = {\n      access_token: token,\n      token_type: 'Bearer',\n      expiry_date: gtoken.expiresAt,\n      // tslint:disable-next-line no-any\n      id_token: (gtoken.rawToken! as any).id_token\n    };\n    this.emit('tokens', tokens);\n    return {res: null, tokens};\n  }\n\n  /**\n   * Create a gToken if it doesn't already exist.\n   */\n  private createGToken(): GoogleToken {\n    if (!this.gtoken) {\n      this.gtoken = new GoogleToken({\n        iss: this.email,\n        sub: this.subject,\n        scope: this.scopes,\n        keyFile: this.keyFile,\n        key: this.key,\n        additionalClaims: this.additionalClaims\n      });\n    }\n    return this.gtoken;\n  }\n\n  /**\n   * Create a JWT credentials instance using the given input options.\n   * @param json The input object.\n   */\n  fromJSON(json: JWTInput): void {\n    if (!json) {\n      throw new Error(\n          'Must pass in a JSON object containing the service account auth settings.');\n    }\n    if (!json.client_email) {\n      throw new Error(\n          'The incoming JSON object does not contain a client_email field');\n    }\n    if (!json.private_key) {\n      throw new Error(\n          'The incoming JSON object does not contain a private_key field');\n    }\n    // Extract the relevant information from the json key file.\n    this.email = json.client_email;\n    this.key = json.private_key;\n    this.keyId = json.private_key_id;\n    this.projectId = json.project_id;\n  }\n\n  /**\n   * Create a JWT credentials instance using the given input stream.\n   * @param inputStream The input stream.\n   * @param callback Optional callback.\n   */\n  fromStream(inputStream: stream.Readable): Promise;\n  fromStream(\n      inputStream: stream.Readable, callback: (err?: Error|null) => void): void;\n  fromStream(\n      inputStream: stream.Readable,\n      callback?: (err?: Error|null) => void): void|Promise {\n    if (callback) {\n      this.fromStreamAsync(inputStream).then(r => callback(), callback);\n    } else {\n      return this.fromStreamAsync(inputStream);\n    }\n  }\n\n  private fromStreamAsync(inputStream: stream.Readable) {\n    return new Promise((resolve, reject) => {\n      if (!inputStream) {\n        throw new Error(\n            'Must pass in a stream containing the service account auth settings.');\n      }\n      let s = '';\n      inputStream.setEncoding('utf8')\n          .on('error', reject)\n          .on('data', (chunk) => s += chunk)\n          .on('end', () => {\n            try {\n              const data = JSON.parse(s);\n              this.fromJSON(data);\n              resolve();\n            } catch (e) {\n              reject(e);\n            }\n          });\n    });\n  }\n\n  /**\n   * Creates a JWT credentials instance using an API Key for authentication.\n   * @param apiKey The API Key in string form.\n   */\n  fromAPIKey(apiKey: string): void {\n    if (typeof apiKey !== 'string') {\n      throw new Error('Must provide an API Key string.');\n    }\n    this.apiKey = apiKey;\n  }\n\n  /**\n   * Using the key or keyFile on the JWT client, obtain an object that contains\n   * the key and the client email.\n   */\n  async getCredentials(): Promise {\n    if (this.key) {\n      return {private_key: this.key, client_email: this.email};\n    } else if (this.keyFile) {\n      const gtoken = this.createGToken();\n      const creds = await gtoken.getCredentials(this.keyFile);\n      return {private_key: creds.privateKey, client_email: creds.clientEmail};\n    }\n    throw new Error('A key or a keyFile must be provided to getCredentials.');\n  }\n}\n\n    \n\n\n\n\n\n\n\n                   \n    \n         result-matching \"\"\n        \n    \n    \n        No results matching \"\"\n    \n\n"},"classes/LoginTicket.html":{"url":"classes/LoginTicket.html","title":"class - LoginTicket","body":"\n                   \n\n\n\n\n\n\n\n\n\n\n\n\n  Classes\n  LoginTicket\n\n\n\n        \n            Info\n        \n        \n            Source\n        \n\n\n\n    \n        \n            File\n        \n        \n            src/auth/loginticket.ts\n        \n\n            \n                Description\n            \n            \n                Copyright 2014 Google Inc. All Rights Reserved.\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n  http://www.apache.org/licenses/LICENSE-2.0Unless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n\n            \n\n\n\n\n            \n    Index\n    \n        \n\n                \n                    \n                        Methods\n                    \n                \n                \n                    \n                        \n                            \n                                getAttributes\n                            \n                            \n                                getEnvelope\n                            \n                            \n                                getPayload\n                            \n                            \n                                getUserId\n                            \n                        \n                    \n                \n\n\n\n\n\n        \n    \n\n\n            \n    Constructor\n        \n            \n                \n                    \nconstructor(env?: string, pay?: TokenPayload)\n                    \n                \n                        \n                            \n                                Defined in src/auth/loginticket.ts:19\n                            \n                        \n\n                \n                    \n                            Create a simple class to extract user ID from an ID Token\n\n                            \n                                    Parameters :\n                                    \n                                        \n                                            \n                                                Name\n                                                    Type\n                                                Optional\n                                                    Description\n                                            \n                                        \n                                        \n                                                \n                                                        env\n                                                  \n                                                        \n                                                                    string\n                                                        \n                                                  \n                                                    \n                                                            Yes\n                                                    \n                                                    \n                                                        \n                                                                Envelope of the jwt\n\n                                                        \n                                                \n                                                \n                                                        pay\n                                                  \n                                                        \n                                                                    TokenPayload\n                                                        \n                                                  \n                                                    \n                                                            Yes\n                                                    \n                                                    \n                                                        \n                                                                Payload of the jwt\n\n                                                        \n                                                \n                                        \n                                    \n                            \n                    \n                \n            \n        \n\n\n\n            \n    \n        \n            Methods\n        \n        \n            \n                \n                    \n                        \n                        \n                            \n                            getAttributes\n                            \n                            \n                        \n                    \n                \n                \n                    \ngetAttributes()\n                    \n                \n\n\n                        \n                            \n                                    Defined in src/auth/loginticket.ts:60\n                            \n                        \n\n\n                \n                    \n                            Returns attributes from the login ticket.  This can contain\nvarious information about the user session.\n\n\n                            \n                            \n                            \n                                Returns :     { envelope: string; payload: TokenPayload; }\n\n                            \n                                \n                                    The envelope and payload\n\n                                \n                    \n                \n            \n        \n        \n            \n                \n                    \n                        \n                        \n                            \n                            getEnvelope\n                            \n                            \n                        \n                    \n                \n                \n                    \ngetEnvelope()\n                    \n                \n\n\n                        \n                            \n                                    Defined in src/auth/loginticket.ts:33\n                            \n                        \n\n\n                \n                    \n\n                            \n                                Returns :     string\n\n                            \n                    \n                \n            \n        \n        \n            \n                \n                    \n                        \n                        \n                            \n                            getPayload\n                            \n                            \n                        \n                    \n                \n                \n                    \ngetPayload()\n                    \n                \n\n\n                        \n                            \n                                    Defined in src/auth/loginticket.ts:37\n                            \n                        \n\n\n                \n                    \n\n                            \n                                Returns :     TokenPayload\n\n                            \n                    \n                \n            \n        \n        \n            \n                \n                    \n                        \n                        \n                            \n                            getUserId\n                            \n                            \n                        \n                    \n                \n                \n                    \ngetUserId()\n                    \n                \n\n\n                        \n                            \n                                    Defined in src/auth/loginticket.ts:46\n                            \n                        \n\n\n                \n                    \n                            Create a simple class to extract user ID from an ID Token\n\n\n                            \n                            \n                            \n                                Returns :     string\n\n                            \n                                \n                                    The user ID\n\n                                \n                    \n                \n            \n        \n\n\n\n\n\n\n\n    \n\n\n    \n        export class LoginTicket {\n  private envelope?: string;\n  private payload?: TokenPayload;\n\n  /**\n   * Create a simple class to extract user ID from an ID Token\n   *\n   * @param {string} env Envelope of the jwt\n   * @param {TokenPayload} pay Payload of the jwt\n   * @constructor\n   */\n  constructor(env?: string, pay?: TokenPayload) {\n    this.envelope = env;\n    this.payload = pay;\n  }\n\n  getEnvelope() {\n    return this.envelope;\n  }\n\n  getPayload() {\n    return this.payload;\n  }\n\n  /**\n   * Create a simple class to extract user ID from an ID Token\n   *\n   * @return The user ID\n   */\n  getUserId() {\n    const payload = this.getPayload();\n    if (payload && payload.sub) {\n      return payload.sub;\n    }\n    return null;\n  }\n\n  /**\n   * Returns attributes from the login ticket.  This can contain\n   * various information about the user session.\n   *\n   * @return The envelope and payload\n   */\n  getAttributes() {\n    return {envelope: this.getEnvelope(), payload: this.getPayload()};\n  }\n}\n\nexport interface TokenPayload {\n  /**\n   * The Issuer Identifier for the Issuer of the response. Always\n   * https://accounts.google.com or accounts.google.com for Google ID tokens.\n   */\n  iss: string;\n\n  /**\n   * Access token hash. Provides validation that the access token is tied to the\n   * identity token. If the ID token is issued with an access token in the\n   * server flow, this is always included. This can be used as an alternate\n   * mechanism to protect against cross-site request forgery attacks, but if you\n   * follow Step 1 and Step 3 it is not necessary to verify the access token.\n   */\n  at_hash?: string;\n\n  /**\n   * True if the user's e-mail address has been verified; otherwise false.\n   */\n  email_verified?: boolean;\n\n  /**\n   * An identifier for the user, unique among all Google accounts and never\n   * reused. A Google account can have multiple emails at different points in\n   * time, but the sub value is never changed. Use sub within your application\n   * as the unique-identifier key for the user.\n   */\n  sub: string;\n\n  /**\n   * The client_id of the authorized presenter. This claim is only needed when\n   * the party requesting the ID token is not the same as the audience of the ID\n   * token. This may be the case at Google for hybrid apps where a web\n   * application and Android app have a different client_id but share the same\n   * project.\n   */\n  azp?: string;\n\n  /**\n   * The user's email address. This may not be unique and is not suitable for\n   * use as a primary key. Provided only if your scope included the string\n   * \"email\".\n   */\n  email?: string;\n\n  /**\n   * The URL of the user's profile page. Might be provided when:\n   * - The request scope included the string \"profile\"\n   * - The ID token is returned from a token refresh\n   * - When profile claims are present, you can use them to update your app's\n   * user records. Note that this claim is never guaranteed to be present.\n   */\n  profile?: string;\n\n  /**\n   * The URL of the user's profile picture. Might be provided when:\n   * - The request scope included the string \"profile\"\n   * - The ID token is returned from a token refresh\n   * - When picture claims are present, you can use them to update your app's\n   * user records. Note that this claim is never guaranteed to be present.\n   */\n  picture?: string;\n\n  /**\n   * The user's full name, in a displayable form. Might be provided when:\n   * - The request scope included the string \"profile\"\n   * - The ID token is returned from a token refresh\n   * - When name claims are present, you can use them to update your app's user\n   * records. Note that this claim is never guaranteed to be present.\n   */\n  name?: string;\n\n  /**\n   * The user's given name, in a displayable form. Might be provided when:\n   * - The request scope included the string \"profile\"\n   * - The ID token is returned from a token refresh\n   * - When name claims are present, you can use them to update your app's user\n   * records. Note that this claim is never guaranteed to be present.\n   */\n  given_name?: string;\n\n  /**\n   * The user's family name, in a displayable form. Might be provided when:\n   * - The request scope included the string \"profile\"\n   * - The ID token is returned from a token refresh\n   * - When name claims are present, you can use them to update your app's user\n   * records. Note that this claim is never guaranteed to be present.\n   */\n  family_name?: string;\n\n  /**\n   * Identifies the audience that this ID token is intended for. It must be one\n   * of the OAuth 2.0 client IDs of your application.\n   */\n  aud: string;\n\n  /**\n   * The time the ID token was issued, represented in Unix time (integer\n   * seconds).\n   */\n  iat: number;\n\n  /**\n   * The time the ID token expires, represented in Unix time (integer seconds).\n   */\n  exp: number;\n\n  /**\n   * The value of the nonce supplied by your app in the authentication request.\n   * You should enforce protection against replay attacks by ensuring it is\n   * presented only once.\n   */\n  nonce?: string;\n\n  /**\n   * The hosted G Suite domain of the user. Provided only if the user belongs to\n   * a hosted domain.\n   */\n  hd?: string;\n}\n\n    \n\n\n\n\n\n\n\n\n                   \n    \n         result-matching \"\"\n        \n    \n    \n        No results matching \"\"\n    \n\n"},"interfaces/OAuth2ClientOptions.html":{"url":"interfaces/OAuth2ClientOptions.html","title":"interface - OAuth2ClientOptions","body":"\n                   \n\n\n\n\n\n\n\n\n\n\n\n\n\n  Interfaces\n  OAuth2ClientOptions\n\n\n\n        \n            Info\n        \n        \n            Source\n        \n\n\n\n    \n        \n            File\n        \n        \n            src/auth/oauth2client.ts\n        \n\n\n            \n                Extends\n            \n            \n                    RefreshOptions\n            \n\n        \n            Index\n            \n                \n                    \n                        \n                            Properties\n                        \n                    \n                    \n                        \n                            \n                                \n                                            Optional\n                                        clientId\n                                \n                                \n                                            Optional\n                                        clientSecret\n                                \n                                \n                                            Optional\n                                        redirectUri\n                                \n                            \n                        \n                    \n                \n            \n        \n\n\n\n            \n                Properties\n                    \n                        \n                                \n                                    \n                                        \n                                        clientId\n                                    \n                                \n                                \n                                    \n                                        clientId:     string\n\n                                    \n                                \n\n\n                                    \n                                        \n                                            Type :     string\n\n                                        \n                                    \n\n                                    \n                                        \n                                            Optional\n                                        \n                                    \n\n\n\n\n                        \n                    \n                    \n                        \n                                \n                                    \n                                        \n                                        clientSecret\n                                    \n                                \n                                \n                                    \n                                        clientSecret:     string\n\n                                    \n                                \n\n\n                                    \n                                        \n                                            Type :     string\n\n                                        \n                                    \n\n                                    \n                                        \n                                            Optional\n                                        \n                                    \n\n\n\n\n                        \n                    \n                    \n                        \n                                \n                                    \n                                        \n                                        redirectUri\n                                    \n                                \n                                \n                                    \n                                        redirectUri:     string\n\n                                    \n                                \n\n\n                                    \n                                        \n                                            Type :     string\n\n                                        \n                                    \n\n                                    \n                                        \n                                            Optional\n                                        \n                                    \n\n\n\n\n                        \n                    \n            \n    \n\n\n    \n        import {AxiosError, AxiosPromise, AxiosRequestConfig, AxiosResponse} from 'axios';\nimport * as crypto from 'crypto';\nimport * as querystring from 'querystring';\nimport * as stream from 'stream';\nimport * as messages from '../messages';\nimport {PemVerifier} from './../pemverifier';\nimport {BodyResponseCallback} from './../transporters';\nimport {AuthClient} from './authclient';\nimport {CredentialRequest, Credentials} from './credentials';\nimport {LoginTicket, TokenPayload} from './loginticket';\n\nexport type Certificates = {\n  [index: string]: string\n};\n\nexport type Headers = {\n  [index: string]: string\n};\n\nexport enum CodeChallengeMethod {\n  Plain = 'plain',\n  S256 = 'S256'\n}\n\nexport interface GetTokenOptions {\n  code: string;\n  codeVerifier?: string;\n  /**\n   * The client ID for your application. The value passed into the constructor\n   * will be used if not provided. Must match any client_id option passed to\n   * a corresponding call to generateAuthUrl.\n   */\n  client_id?: string;\n  /**\n   * Determines where the API server redirects the user after the user\n   * completes the authorization flow. The value passed into the constructor\n   * will be used if not provided. Must match any redirect_uri option passed to\n   * a corresponding call to generateAuthUrl.\n   */\n  redirect_uri?: string;\n}\n\nexport interface TokenInfo {\n  /**\n   * The application that is the intended user of the access token.\n   */\n  aud: string;\n\n  /**\n   * This value lets you correlate profile information from multiple Google\n   * APIs. It is only present in the response if you included the profile scope\n   * in your request in step 1. The field value is an immutable identifier for\n   * the logged-in user that can be used to create and manage user sessions in\n   * your application. The identifier is the same regardless of which client ID\n   * is used to retrieve it. This enables multiple applications in the same\n   * organization to correlate profile information.\n   */\n  user_id?: string;\n\n  /**\n   * An array of scopes that the user granted access to.\n   */\n  scopes: string[];\n\n  /**\n   * The datetime when the token becomes invalid.\n   */\n  expiry_date: number;\n\n  /**\n   * An identifier for the user, unique among all Google accounts and never\n   * reused. A Google account can have multiple emails at different points in\n   * time, but the sub value is never changed. Use sub within your application\n   * as the unique-identifier key for the user.\n   */\n  sub?: string;\n\n  /**\n   * The client_id of the authorized presenter. This claim is only needed when\n   * the party requesting the ID token is not the same as the audience of the ID\n   * token. This may be the case at Google for hybrid apps where a web\n   * application and Android app have a different client_id but share the same\n   * project.\n   */\n  azp?: string;\n\n  /**\n   * Indicates whether your application can refresh access tokens\n   * when the user is not present at the browser. Valid parameter values are\n   * 'online', which is the default value, and 'offline'. Set the value to\n   * 'offline' if your application needs to refresh access tokens when the user\n   * is not present at the browser. This value instructs the Google\n   * authorization server to return a refresh token and an access token the\n   * first time that your application exchanges an authorization code for\n   * tokens.\n   */\n  access_type?: string;\n}\n\ninterface TokenInfoRequest {\n  aud: string;\n  user_id?: string;\n  scope: string;\n  expires_in: number;\n  azp?: string;\n  sub?: string;\n  exp?: number;\n  access_type?: string;\n}\n\nexport interface GenerateAuthUrlOpts {\n  /**\n   * Recommended. Indicates whether your application can refresh access tokens\n   * when the user is not present at the browser. Valid parameter values are\n   * 'online', which is the default value, and 'offline'. Set the value to\n   * 'offline' if your application needs to refresh access tokens when the user\n   * is not present at the browser. This value instructs the Google\n   * authorization server to return a refresh token and an access token the\n   * first time that your application exchanges an authorization code for\n   * tokens.\n   */\n  access_type?: string;\n\n  /**\n   * The hd (hosted domain) parameter streamlines the login process for G Suite\n   * hosted accounts. By including the domain of the G Suite user (for example,\n   * mycollege.edu), you can indicate that the account selection UI should be\n   * optimized for accounts at that domain. To optimize for G Suite accounts\n   * generally instead of just one domain, use an asterisk: hd=*.\n   * Don't rely on this UI optimization to control who can access your app,\n   * as client-side requests can be modified. Be sure to validate that the\n   * returned ID token has an hd claim value that matches what you expect\n   * (e.g. mycolledge.edu). Unlike the request parameter, the ID token claim is\n   * contained within a security token from Google, so the value can be trusted.\n   */\n  hd?: string;\n\n  /**\n   * The 'response_type' will always be set to 'CODE'.\n   */\n  response_type?: string;\n\n  /**\n   * The client ID for your application. The value passed into the constructor\n   * will be used if not provided. You can find this value in the API Console.\n   */\n  client_id?: string;\n\n  /**\n   * Determines where the API server redirects the user after the user\n   * completes the authorization flow. The value must exactly match one of the\n   * 'redirect_uri' values listed for your project in the API Console. Note that\n   * the http or https scheme, case, and trailing slash ('/') must all match.\n   * The value passed into the constructor will be used if not provided.\n   */\n  redirect_uri?: string;\n\n  /**\n   * Required. A space-delimited list of scopes that identify the resources that\n   * your application could access on the user's behalf. These values inform the\n   * consent screen that Google displays to the user. Scopes enable your\n   * application to only request access to the resources that it needs while\n   * also enabling users to control the amount of access that they grant to your\n   * application. Thus, there is an inverse relationship between the number of\n   * scopes requested and the likelihood of obtaining user consent. The\n   * OAuth 2.0 API Scopes document provides a full list of scopes that you might\n   * use to access Google APIs. We recommend that your application request\n   * access to authorization scopes in context whenever possible. By requesting\n   * access to user data in context, via incremental authorization, you help\n   * users to more easily understand why your application needs the access it is\n   * requesting.\n   */\n  scope?: string[]|string;\n\n  /**\n   * Recommended. Specifies any string value that your application uses to\n   * maintain state between your authorization request and the authorization\n   * server's response. The server returns the exact value that you send as a\n   * name=value pair in the hash (#) fragment of the 'redirect_uri' after the\n   * user consents to or denies your application's access request. You can use\n   * this parameter for several purposes, such as directing the user to the\n   * correct resource in your application, sending nonces, and mitigating\n   * cross-site request forgery. Since your redirect_uri can be guessed, using a\n   * state value can increase your assurance that an incoming connection is the\n   * result of an authentication request. If you generate a random string or\n   * encode the hash of a cookie or another value that captures the client's\n   * state, you can validate the response to additionally ensure that the\n   * request and response originated in the same browser, providing protection\n   * against attacks such as cross-site request forgery. See the OpenID Connect\n   * documentation for an example of how to create and confirm a state token.\n   */\n  state?: string;\n\n  /**\n   * Optional. Enables applications to use incremental authorization to request\n   * access to additional scopes in context. If you set this parameter's value\n   * to true and the authorization request is granted, then the new access token\n   * will also cover any scopes to which the user previously granted the\n   * application access. See the incremental authorization section for examples.\n   */\n  include_granted_scopes?: boolean;\n\n  /**\n   * Optional. If your application knows which user is trying to authenticate,\n   * it can use this parameter to provide a hint to the Google Authentication\n   * Server. The server uses the hint to simplify the login flow either by\n   * prefilling the email field in the sign-in form or by selecting the\n   * appropriate multi-login session. Set the parameter value to an email\n   * address or sub identifier, which is equivalent to the user's Google ID.\n   */\n  login_hint?: string;\n\n  /**\n   * Optional. A space-delimited, case-sensitive list of prompts to present the\n   * user. If you don't specify this parameter, the user will be prompted only\n   * the first time your app requests access.  Possible values are:\n   *\n   * 'none' - Donot display any authentication or consent screens. Must not be\n   *        specified with other values.\n   * 'consent' - \tPrompt the user for consent.\n   * 'select_account' - Prompt the user to select an account.\n   */\n  prompt?: string;\n\n  /**\n   * Recommended. Specifies what method was used to encode a 'code_verifier'\n   * that will be used during authorization code exchange. This parameter must\n   * be used with the 'code_challenge' parameter. The value of the\n   * 'code_challenge_method' defaults to \"plain\" if not present in the request\n   * that includes a 'code_challenge'. The only supported values for this\n   * parameter are \"S256\" or \"plain\".\n   */\n  code_challenge_method?: CodeChallengeMethod;\n\n  /**\n   * Recommended. Specifies an encoded 'code_verifier' that will be used as a\n   * server-side challenge during authorization code exchange. This parameter\n   * must be used with the 'code_challenge' parameter described above.\n   */\n  code_challenge?: string;\n}\n\nexport interface GetTokenCallback {\n  (err: AxiosError|null, token?: Credentials|null,\n   res?: AxiosResponse|null): void;\n}\n\nexport interface GetTokenResponse {\n  tokens: Credentials;\n  res: AxiosResponse|null;\n}\n\nexport interface GetAccessTokenCallback {\n  (err: AxiosError|null, token?: string|null, res?: AxiosResponse|null): void;\n}\n\nexport interface GetAccessTokenResponse {\n  token?: string|null;\n  res?: AxiosResponse|null;\n}\n\nexport interface RefreshAccessTokenCallback {\n  (err: AxiosError|null, credentials?: Credentials|null,\n   res?: AxiosResponse|null): void;\n}\n\nexport interface RefreshAccessTokenResponse {\n  credentials: Credentials;\n  res: AxiosResponse|null;\n}\n\nexport interface RequestMetadataResponse {\n  headers: Headers;\n  res?: AxiosResponse|null;\n}\n\nexport interface RequestMetadataCallback {\n  (err: AxiosError|null, headers?: Headers,\n   res?: AxiosResponse|null): void;\n}\n\nexport interface GetFederatedSignonCertsCallback {\n  (err: AxiosError|null, certs?: Certificates,\n   response?: AxiosResponse|null): void;\n}\n\nexport interface FederatedSignonCertsResponse {\n  certs: Certificates;\n  res?: AxiosResponse|null;\n}\n\nexport interface RevokeCredentialsResult {\n  success: boolean;\n}\n\nexport interface VerifyIdTokenOptions {\n  idToken: string;\n  audience: string|string[];\n  maxExpiry?: number;\n}\n\nexport interface OAuth2ClientOptions extends RefreshOptions {\n  clientId?: string;\n  clientSecret?: string;\n  redirectUri?: string;\n}\n\nexport interface RefreshOptions {\n  // Eagerly refresh unexpired tokens when they are within this many\n  // milliseconds from expiring\".\n  // Defaults to a value of 300000 (5 minutes).\n  eagerRefreshThresholdMillis?: number;\n}\n\nexport class OAuth2Client extends AuthClient {\n  private redirectUri?: string;\n  private certificateCache?: Certificates;\n  private certificateExpiry: Date|null = null;\n  protected refreshTokenPromises = new Map>();\n\n  // TODO: refactor tests to make this private\n  _clientId?: string;\n\n  // TODO: refactor tests to make this private\n  _clientSecret?: string;\n\n  apiKey?: string;\n\n  projectId?: string;\n\n  eagerRefreshThresholdMillis: number;\n\n  /**\n   * Handles OAuth2 flow for Google APIs.\n   *\n   * @param clientId The authentication client ID.\n   * @param clientSecret The authentication client secret.\n   * @param redirectUri The URI to redirect to after completing the auth\n   * request.\n   * @param opts optional options for overriding the given parameters.\n   * @constructor\n   */\n  constructor(options?: OAuth2ClientOptions);\n  constructor(clientId?: string, clientSecret?: string, redirectUri?: string);\n  constructor(\n      optionsOrClientId?: string|OAuth2ClientOptions, clientSecret?: string,\n      redirectUri?: string) {\n    super();\n    const opts = (optionsOrClientId && typeof optionsOrClientId === 'object') ?\n        optionsOrClientId :\n        {clientId: optionsOrClientId, clientSecret, redirectUri};\n    this._clientId = opts.clientId;\n    this._clientSecret = opts.clientSecret;\n    this.redirectUri = opts.redirectUri;\n    this.eagerRefreshThresholdMillis =\n        opts.eagerRefreshThresholdMillis || 5 * 60 * 1000;\n  }\n\n  protected static readonly GOOGLE_TOKEN_INFO_URL =\n      'https://oauth2.googleapis.com/tokeninfo';\n\n  /**\n   * The base URL for auth endpoints.\n   */\n  private static readonly GOOGLE_OAUTH2_AUTH_BASE_URL_ =\n      'https://accounts.google.com/o/oauth2/v2/auth';\n\n  /**\n   * The base endpoint for token retrieval.\n   */\n  private static readonly GOOGLE_OAUTH2_TOKEN_URL_ =\n      'https://oauth2.googleapis.com/token';\n\n  /**\n   * The base endpoint to revoke tokens.\n   */\n  private static readonly GOOGLE_OAUTH2_REVOKE_URL_ =\n      'https://oauth2.googleapis.com/revoke';\n\n  /**\n   * Google Sign on certificates.\n   */\n  private static readonly GOOGLE_OAUTH2_FEDERATED_SIGNON_CERTS_URL_ =\n      'https://www.googleapis.com/oauth2/v1/certs';\n\n  /**\n   * Clock skew - five minutes in seconds\n   */\n  private static readonly CLOCK_SKEW_SECS_ = 300;\n\n  /**\n   * Max Token Lifetime is one day in seconds\n   */\n  private static readonly MAX_TOKEN_LIFETIME_SECS_ = 86400;\n\n  /**\n   * The allowed oauth token issuers.\n   */\n  private static readonly ISSUERS_ =\n      ['accounts.google.com', 'https://accounts.google.com'];\n\n  /**\n   * Generates URL for consent page landing.\n   * @param opts Options.\n   * @return URL to consent page.\n   */\n  generateAuthUrl(opts: GenerateAuthUrlOpts = {}) {\n    if (opts.code_challenge_method && !opts.code_challenge) {\n      throw new Error(\n          'If a code_challenge_method is provided, code_challenge must be included.');\n    }\n    opts.response_type = opts.response_type || 'code';\n    opts.client_id = opts.client_id || this._clientId;\n    opts.redirect_uri = opts.redirect_uri || this.redirectUri;\n    // Allow scopes to be passed either as array or a string\n    if (opts.scope instanceof Array) {\n      opts.scope = opts.scope.join(' ');\n    }\n    const rootUrl = OAuth2Client.GOOGLE_OAUTH2_AUTH_BASE_URL_;\n    return rootUrl + '?' + querystring.stringify(opts);\n  }\n\n  /**\n   * Convenience method to automatically generate a code_verifier, and it's\n   * resulting SHA256. If used, this must be paired with a S256\n   * code_challenge_method.\n   */\n  generateCodeVerifier() {\n    // base64 encoding uses 6 bits per character, and we want to generate128\n    // characters. 6*128/8 = 96.\n    const randomString = crypto.randomBytes(96).toString('base64');\n    // The valid characters in the code_verifier are [A-Z]/[a-z]/[0-9]/\n    // \"-\"/\".\"/\"_\"/\"~\". Base64 encoded strings are pretty close, so we're just\n    // swapping out a few chars.\n    const codeVerifier =\n        randomString.replace(/\\+/g, '~').replace(/=/g, '_').replace(/\\//g, '-');\n    // Generate the base64 encoded SHA256\n    const unencodedCodeChallenge =\n        crypto.createHash('sha256').update(codeVerifier).digest('base64');\n    // We need to use base64UrlEncoding instead of standard base64\n    const codeChallenge = unencodedCodeChallenge.split('=')[0]\n                              .replace(/\\+/g, '-')\n                              .replace(/\\//g, '_');\n    return {codeVerifier, codeChallenge};\n  }\n\n  /**\n   * Gets the access token for the given code.\n   * @param code The authorization code.\n   * @param callback Optional callback fn.\n   */\n  getToken(code: string): Promise;\n  getToken(options: GetTokenOptions): Promise;\n  getToken(code: string, callback: GetTokenCallback): void;\n  getToken(options: GetTokenOptions, callback: GetTokenCallback): void;\n  getToken(codeOrOptions: string|GetTokenOptions, callback?: GetTokenCallback):\n      Promise|void {\n    const options = (typeof codeOrOptions === 'string') ?\n        {code: codeOrOptions} :\n        codeOrOptions;\n    if (callback) {\n      this.getTokenAsync(options).then(\n          r => callback(null, r.tokens, r.res),\n          e => callback(e, null, e.response));\n    } else {\n      return this.getTokenAsync(options);\n    }\n  }\n\n  private async getTokenAsync(options: GetTokenOptions):\n      Promise {\n    const url = OAuth2Client.GOOGLE_OAUTH2_TOKEN_URL_;\n    const values = {\n      code: options.code,\n      client_id: options.client_id || this._clientId,\n      client_secret: this._clientSecret,\n      redirect_uri: options.redirect_uri || this.redirectUri,\n      grant_type: 'authorization_code',\n      code_verifier: options.codeVerifier\n    };\n    const res = await this.transporter.request({\n      method: 'POST',\n      url,\n      data: querystring.stringify(values),\n      headers: {'Content-Type': 'application/x-www-form-urlencoded'}\n    });\n    const tokens = res.data as Credentials;\n    if (res.data && res.data.expires_in) {\n      tokens.expiry_date =\n          ((new Date()).getTime() + (res.data.expires_in * 1000));\n      delete (tokens as CredentialRequest).expires_in;\n    }\n    this.emit('tokens', tokens);\n    return {tokens, res};\n  }\n\n  /**\n   * Refreshes the access token.\n   * @param refresh_token Existing refresh token.\n   * @private\n   */\n  protected async refreshToken(refreshToken?: string|\n                               null): Promise {\n    if (!refreshToken) {\n      return this.refreshTokenNoCache(refreshToken);\n    }\n    // If a request to refresh using the same token has started,\n    // return the same promise.\n    if (this.refreshTokenPromises.has(refreshToken)) {\n      return this.refreshTokenPromises.get(refreshToken)!;\n    }\n\n    const p = this.refreshTokenNoCache(refreshToken)\n                  .then(\n                      r => {\n                        this.refreshTokenPromises.delete(refreshToken);\n                        return r;\n                      },\n                      e => {\n                        this.refreshTokenPromises.delete(refreshToken);\n                        throw e;\n                      });\n    this.refreshTokenPromises.set(refreshToken, p);\n    return p;\n  }\n\n  protected async refreshTokenNoCache(refreshToken?: string|\n                                      null): Promise {\n    const url = OAuth2Client.GOOGLE_OAUTH2_TOKEN_URL_;\n    const data = {\n      refresh_token: refreshToken,\n      client_id: this._clientId,\n      client_secret: this._clientSecret,\n      grant_type: 'refresh_token'\n    };\n\n    // request for new token\n    const res = await this.transporter.request({\n      method: 'POST',\n      url,\n      data: querystring.stringify(data),\n      headers: {'Content-Type': 'application/x-www-form-urlencoded'}\n    });\n\n    const tokens = res.data as Credentials;\n    // TODO: de-duplicate this code from a few spots\n    if (res.data && res.data.expires_in) {\n      tokens.expiry_date =\n          ((new Date()).getTime() + (res.data.expires_in * 1000));\n      delete (tokens as CredentialRequest).expires_in;\n    }\n    this.emit('tokens', tokens);\n    return {tokens, res};\n  }\n\n  /**\n   * Retrieves the access token using refresh token\n   *\n   * @deprecated use getRequestHeaders instead.\n   * @param callback callback\n   */\n  refreshAccessToken(): Promise;\n  refreshAccessToken(callback: RefreshAccessTokenCallback): void;\n  refreshAccessToken(callback?: RefreshAccessTokenCallback):\n      Promise|void {\n    messages.warn(messages.REFRESH_ACCESS_TOKEN_DEPRECATED);\n    if (callback) {\n      this.refreshAccessTokenAsync().then(\n          r => callback(null, r.credentials, r.res), callback);\n    } else {\n      return this.refreshAccessTokenAsync();\n    }\n  }\n\n  private async refreshAccessTokenAsync() {\n    if (!this.credentials.refresh_token) {\n      throw new Error('No refresh token is set.');\n    }\n    const r = await this.refreshToken(this.credentials.refresh_token);\n    const tokens = r.tokens as Credentials;\n    tokens.refresh_token = this.credentials.refresh_token;\n    this.credentials = tokens;\n    return {credentials: this.credentials, res: r.res};\n  }\n\n  /**\n   * Get a non-expired access token, after refreshing if necessary\n   *\n   * @param callback Callback to call with the access token\n   */\n  getAccessToken(): Promise;\n  getAccessToken(callback: GetAccessTokenCallback): void;\n  getAccessToken(callback?: GetAccessTokenCallback):\n      Promise|void {\n    if (callback) {\n      this.getAccessTokenAsync().then(\n          r => callback(null, r.token, r.res), callback);\n    } else {\n      return this.getAccessTokenAsync();\n    }\n  }\n\n  private async getAccessTokenAsync(): Promise {\n    const shouldRefresh =\n        !this.credentials.access_token || this.isTokenExpiring();\n    if (shouldRefresh && this.credentials.refresh_token) {\n      if (!this.credentials.refresh_token) {\n        throw new Error('No refresh token is set.');\n      }\n\n      const r = await this.refreshAccessTokenAsync();\n      if (!r.credentials || (r.credentials && !r.credentials.access_token)) {\n        throw new Error('Could not refresh access token.');\n      }\n      return {token: r.credentials.access_token, res: r.res};\n    } else {\n      return {token: this.credentials.access_token};\n    }\n  }\n\n  /**\n   * Obtain the set of headers required to authenticate a request.\n   *\n   * @deprecated Use getRequestHeaders instead.\n   * @param url the Uri being authorized\n   * @param callback the func described above\n   */\n  getRequestMetadata(url?: string|null): Promise;\n  getRequestMetadata(url: string|null, callback: RequestMetadataCallback): void;\n  getRequestMetadata(url: string|null, callback?: RequestMetadataCallback):\n      Promise|void {\n    messages.warn(messages.OAUTH_GET_REQUEST_METADATA_DEPRECATED);\n    if (callback) {\n      this.getRequestMetadataAsync(url).then(\n          r => callback(null, r.headers, r.res), callback);\n    } else {\n      return this.getRequestMetadataAsync();\n    }\n  }\n\n  /**\n   * The main authentication interface.  It takes an optional url which when\n   * present is the endpoint being accessed, and returns a Promise which\n   * resolves with authorization header fields.\n   *\n   * In OAuth2Client, the result has the form:\n   * { Authorization: 'Bearer ' }\n   * @param url The optional url being authorized\n   */\n  async getRequestHeaders(url?: string): Promise {\n    const res = await this.getRequestMetadataAsync(url);\n    return res.headers;\n  }\n\n  protected async getRequestMetadataAsync(url?: string|null):\n      Promise {\n    const thisCreds = this.credentials;\n    if (!thisCreds.access_token && !thisCreds.refresh_token && !this.apiKey) {\n      throw new Error('No access, refresh token or API key is set.');\n    }\n\n    if (thisCreds.access_token && !this.isTokenExpiring()) {\n      thisCreds.token_type = thisCreds.token_type || 'Bearer';\n      const headers = {\n        Authorization: thisCreds.token_type + ' ' + thisCreds.access_token\n      };\n      return {headers};\n    }\n\n    if (this.apiKey) {\n      return {headers: {}};\n    }\n    let r: GetTokenResponse|null = null;\n    let tokens: Credentials|null = null;\n    try {\n      r = await this.refreshToken(thisCreds.refresh_token);\n      tokens = r.tokens;\n    } catch (err) {\n      const e = err as AxiosError;\n      if (e.response &&\n          (e.response.status === 403 || e.response.status === 404)) {\n        e.message = 'Could not refresh access token.';\n      }\n      throw e;\n    }\n\n    const credentials = this.credentials;\n    credentials.token_type = credentials.token_type || 'Bearer';\n    tokens.refresh_token = credentials.refresh_token;\n    this.credentials = tokens;\n    const headers = {\n      Authorization: credentials.token_type + ' ' + tokens.access_token\n    };\n    return {headers, res: r.res};\n  }\n\n  /**\n   * Revokes the access given to token.\n   * @param token The existing token to be revoked.\n   * @param callback Optional callback fn.\n   */\n  revokeToken(token: string): AxiosPromise;\n  revokeToken(\n      token: string,\n      callback: BodyResponseCallback): void;\n  revokeToken(\n      token: string, callback?: BodyResponseCallback):\n      AxiosPromise|void {\n    const opts = {\n      url: OAuth2Client.GOOGLE_OAUTH2_REVOKE_URL_ + '?' +\n          querystring.stringify({token}),\n      method: 'POST'\n    };\n    if (callback) {\n      this.transporter.request(opts).then(\n          r => callback(null, r), callback);\n    } else {\n      return this.transporter.request(opts);\n    }\n  }\n\n\n  /**\n   * Revokes access token and clears the credentials object\n   * @param callback callback\n   */\n  revokeCredentials(): AxiosPromise;\n  revokeCredentials(callback: BodyResponseCallback):\n      void;\n  revokeCredentials(callback?: BodyResponseCallback):\n      AxiosPromise|void {\n    if (callback) {\n      this.revokeCredentialsAsync().then(res => callback(null, res), callback);\n    } else {\n      return this.revokeCredentialsAsync();\n    }\n  }\n\n  private async revokeCredentialsAsync() {\n    const token = this.credentials.access_token;\n    this.credentials = {};\n    if (token) {\n      return this.revokeToken(token);\n    } else {\n      throw new Error('No access token to revoke.');\n    }\n  }\n\n  /**\n   * Provides a request implementation with OAuth 2.0 flow. If credentials have\n   * a refresh_token, in cases of HTTP 401 and 403 responses, it automatically\n   * asks for a new access token and replays the unsuccessful request.\n   * @param opts Request options.\n   * @param callback callback.\n   * @return Request object\n   */\n  request(opts: AxiosRequestConfig): AxiosPromise;\n  request(opts: AxiosRequestConfig, callback: BodyResponseCallback): void;\n  request(opts: AxiosRequestConfig, callback?: BodyResponseCallback):\n      AxiosPromise|void {\n    if (callback) {\n      this.requestAsync(opts).then(r => callback(null, r), e => {\n        return callback(e, e.response);\n      });\n    } else {\n      return this.requestAsync(opts);\n    }\n  }\n\n  protected async requestAsync(opts: AxiosRequestConfig, retry = false):\n      Promise> {\n    let r2: AxiosResponse;\n    try {\n      const r = await this.getRequestMetadataAsync(opts.url);\n      if (r.headers && r.headers.Authorization) {\n        opts.headers = opts.headers || {};\n        opts.headers.Authorization = r.headers.Authorization;\n      }\n\n      if (this.apiKey) {\n        opts.params = Object.assign(opts.params || {}, {key: this.apiKey});\n      }\n      r2 = await this.transporter.request(opts);\n    } catch (e) {\n      const res = (e as AxiosError).response;\n      if (res) {\n        const statusCode = res.status;\n        // Retry the request for metadata if the following criteria are true:\n        // - We haven't already retried.  It only makes sense to retry once.\n        // - The response was a 401 or a 403\n        // - The request didn't send a readableStream\n        // - An access_token and refresh_token were available, but no\n        //   expiry_date was availabe. This can happen when developers stash\n        //   the access_token and refresh_token for later use, but the\n        //   access_token fails on the first try because it's expired.\n        const mayRequireRefresh = this.credentials &&\n            this.credentials.access_token && this.credentials.refresh_token &&\n            !this.credentials.expiry_date;\n        const isReadableStream = res.config.data instanceof stream.Readable;\n        const isAuthErr = statusCode === 401 || statusCode === 403;\n        if (!retry && isAuthErr && !isReadableStream && mayRequireRefresh) {\n          await this.refreshAccessTokenAsync();\n          return this.requestAsync(opts, true);\n        }\n      }\n      throw e;\n    }\n    return r2;\n  }\n\n  /**\n   * Verify id token is token by checking the certs and audience\n   * @param options that contains all options.\n   * @param callback Callback supplying GoogleLogin if successful\n   */\n  verifyIdToken(options: VerifyIdTokenOptions): Promise;\n  verifyIdToken(\n      options: VerifyIdTokenOptions,\n      callback: (err: Error|null, login?: LoginTicket) => void): void;\n  verifyIdToken(\n      options: VerifyIdTokenOptions,\n      callback?: (err: Error|null, login?: LoginTicket) => void):\n      void|Promise {\n    // This function used to accept two arguments instead of an options object.\n    // Check the types to help users upgrade with less pain.\n    // This check can be removed after a 2.0 release.\n    if (callback && typeof callback !== 'function') {\n      throw new Error(\n          'This method accepts an options object as the first parameter, which includes the idToken, audience, and maxExpiry.');\n    }\n\n    if (callback) {\n      this.verifyIdTokenAsync(options).then(r => callback(null, r), callback);\n    } else {\n      return this.verifyIdTokenAsync(options);\n    }\n  }\n\n  private async verifyIdTokenAsync(options: VerifyIdTokenOptions):\n      Promise {\n    if (!options.idToken) {\n      throw new Error('The verifyIdToken method requires an ID Token');\n    }\n\n    const response = await this.getFederatedSignonCertsAsync();\n    const login = this.verifySignedJwtWithCerts(\n        options.idToken, response.certs, options.audience,\n        OAuth2Client.ISSUERS_, options.maxExpiry);\n\n    return login;\n  }\n\n  /**\n   * Obtains information about the provisioned access token.  Especially useful\n   * if you want to check the scopes that were provisioned to a given token.\n   *\n   * @param accessToken Required.  The Access Token for which you want to get\n   * user info.\n   */\n  async getTokenInfo(accessToken: string): Promise {\n    const {data} = await this.transporter.request({\n      method: 'GET',\n      url: OAuth2Client.GOOGLE_TOKEN_INFO_URL,\n      params: {access_token: accessToken}\n    });\n    const info = Object.assign(\n        {\n          expiry_date: ((new Date()).getTime() + (data.expires_in * 1000)),\n          scopes: data.scope.split(' ')\n        },\n        data);\n    delete info.expires_in;\n    delete info.scope;\n    return info;\n  }\n\n  /**\n   * Gets federated sign-on certificates to use for verifying identity tokens.\n   * Returns certs as array structure, where keys are key ids, and values\n   * are PEM encoded certificates.\n   * @param callback Callback supplying the certificates\n   */\n  getFederatedSignonCerts(): Promise;\n  getFederatedSignonCerts(callback: GetFederatedSignonCertsCallback): void;\n  getFederatedSignonCerts(callback?: GetFederatedSignonCertsCallback):\n      Promise|void {\n    if (callback) {\n      this.getFederatedSignonCertsAsync().then(\n          r => callback(null, r.certs, r.res), callback);\n    } else {\n      return this.getFederatedSignonCertsAsync();\n    }\n  }\n\n  async getFederatedSignonCertsAsync(): Promise {\n    const nowTime = (new Date()).getTime();\n    if (this.certificateExpiry &&\n        (nowTime = now + maxExpiry) {\n      throw new Error(\n          'Expiration time too far in future: ' + JSON.stringify(payload));\n    }\n\n    const earliest = iat - OAuth2Client.CLOCK_SKEW_SECS_;\n    const latest = exp + OAuth2Client.CLOCK_SKEW_SECS_;\n\n    if (now  latest) {\n      throw new Error(\n          'Token used too late, ' + now + ' > ' + latest + ': ' +\n          JSON.stringify(payload));\n    }\n\n    if (issuers && issuers.indexOf(payload.iss)  -1);\n      } else {\n        audVerified = (aud === requiredAudience);\n      }\n      if (!audVerified) {\n        throw new Error(\n            'Wrong recipient, payload audience != requiredAudience');\n      }\n    }\n    return new LoginTicket(envelope, payload);\n  }\n\n  /**\n   * This is a utils method to decode a base64 string\n   * @param b64String The string to base64 decode\n   * @return The decoded string\n   */\n  decodeBase64(b64String: string) {\n    const buffer = Buffer.from(b64String, 'base64');\n    return buffer.toString('utf8');\n  }\n\n  /**\n   * Returns true if a token is expired or will expire within\n   * eagerRefreshThresholdMillismilliseconds.\n   * If there is no expiry time, assumes the token is not expired or expiring.\n   */\n  protected isTokenExpiring(): boolean {\n    const expiryDate = this.credentials.expiry_date;\n    return expiryDate ? expiryDate \n    \n\n\n\n\n\n\n\n                   \n    \n         result-matching \"\"\n        \n    \n    \n        No results matching \"\"\n    \n\n"},"classes/PemVerifier.html":{"url":"classes/PemVerifier.html","title":"class - PemVerifier","body":"\n                   \n\n\n\n\n\n\n\n\n\n\n\n\n  Classes\n  PemVerifier\n\n\n\n        \n            Info\n        \n        \n            Source\n        \n\n\n\n    \n        \n            File\n        \n        \n            src/pemverifier.ts\n        \n\n\n\n\n\n            \n    Index\n    \n        \n\n                \n                    \n                        Methods\n                    \n                \n                \n                    \n                        \n                            \n                                verify\n                            \n                        \n                    \n                \n\n\n\n\n\n        \n    \n\n\n\n\n            \n    \n        \n            Methods\n        \n        \n            \n                \n                    \n                        \n                        \n                            \n                            verify\n                            \n                            \n                        \n                    \n                \n                \n                    \nverify(pubkey: string, data: string | Buffer, signature: string, encoding: crypto.HexBase64Latin1Encoding)\n                    \n                \n\n\n                        \n                            \n                                    Defined in src/pemverifier.ts:20\n                            \n                        \n\n\n                \n                    \n\n                            \n                                    Parameters :\n                                    \n                                        \n                                            \n                                                Name\n                                                    Type\n                                                Optional\n                                            \n                                        \n                                        \n                                                \n                                                        pubkey\n                                                        \n                                                                    string\n                                                        \n                                                    \n                                                    \n                                                            No\n                                                    \n                                                    \n\n                                                \n                                                \n                                                        data\n                                                        \n                                                                    string | Buffer\n                                                        \n                                                    \n                                                    \n                                                            No\n                                                    \n                                                    \n\n                                                \n                                                \n                                                        signature\n                                                        \n                                                                    string\n                                                        \n                                                    \n                                                    \n                                                            No\n                                                    \n                                                    \n\n                                                \n                                                \n                                                        encoding\n                                                        \n                                                                    crypto.HexBase64Latin1Encoding\n                                                        \n                                                    \n                                                    \n                                                            No\n                                                    \n                                                    \n\n                                                \n                                        \n                                    \n                            \n                            \n                            \n                            \n                                Returns :     any\n\n                            \n                                \n                                    \n                                \n                    \n                \n            \n        \n\n\n\n\n\n\n\n    \n\n\n    \n        import * as crypto from 'crypto';\n\nexport class PemVerifier {\n  verify(\n      pubkey: string, data: string|Buffer, signature: string,\n      encoding: crypto.HexBase64Latin1Encoding) {\n    const verifier = crypto.createVerify('sha256');\n    verifier.update(data);\n    return verifier.verify(pubkey, signature, encoding);\n  }\n}\n\n    \n\n\n\n\n\n\n\n\n                   \n    \n         result-matching \"\"\n        \n    \n    \n        No results matching \"\"\n    \n\n"},"interfaces/ProjectIdCallback.html":{"url":"interfaces/ProjectIdCallback.html","title":"interface - ProjectIdCallback","body":"\n                   \n\n\n\n\n\n\n\n\n\n\n\n\n\n  Interfaces\n  ProjectIdCallback\n\n\n\n        \n            Info\n        \n        \n            Source\n        \n\n\n\n    \n        \n            File\n        \n        \n            src/auth/googleauth.ts\n        \n\n\n\n        \n            Index\n            \n                \n                    \n                        \n                            Properties\n                        \n                    \n                    \n                        \n                            \n                                \n                                            Unamed property\n                                \n                            \n                        \n                    \n                \n            \n        \n\n\n\n            \n                Properties\n                    \n                        \n\n                                    \n                                        \n                                            Signature :\n                                            \n                                            \n                                                \n                                                    [err: Error | null, projectId: string | null]\n                                            \n                                        \n                                    \n\n\n                                    \n                                        \n                                            Returns :     void\n\n                                        \n                                    \n\n\n\n\n                        \n                    \n            \n    \n\n\n    \n        import {AxiosRequestConfig, AxiosResponse} from 'axios';\nimport {exec} from 'child_process';\nimport * as crypto from 'crypto';\nimport * as fs from 'fs';\nimport * as gcpMetadata from 'gcp-metadata';\nimport * as http from 'http';\nimport * as os from 'os';\nimport * as path from 'path';\nimport * as stream from 'stream';\nimport * as util from 'util';\n\nimport * as messages from '../messages';\nimport {DefaultTransporter, Transporter} from '../transporters';\n\nimport {Compute} from './computeclient';\nimport {CredentialBody, JWTInput} from './credentials';\nimport {GCPEnv, getEnv} from './envDetect';\nimport {JWT, JWTOptions} from './jwtclient';\nimport {Headers, OAuth2Client, RefreshOptions} from './oauth2client';\nimport {UserRefreshClient} from './refreshclient';\n\nexport interface ProjectIdCallback {\n  (err?: Error|null, projectId?: string|null): void;\n}\n\nexport interface CredentialCallback {\n  (err: Error|null, result?: UserRefreshClient|JWT): void;\n}\n\nexport interface ADCCallback {\n  (err: Error|null, credential?: OAuth2Client, projectId?: string|null): void;\n}\n\nexport interface ADCResponse {\n  credential: OAuth2Client;\n  projectId: string|null;\n}\n\nexport interface GoogleAuthOptions {\n  /**\n   * Path to a .json, .pem, or .p12 key file\n   */\n  keyFilename?: string;\n\n  /**\n   * Path to a .json, .pem, or .p12 key file\n   */\n  keyFile?: string;\n\n  /**\n   * Object containing client_email and private_key properties\n   */\n  credentials?: CredentialBody;\n\n  /**\n   * Required scopes for the desired API request\n   */\n  scopes?: string|string[];\n\n  /**\n   * Your project ID.\n   */\n  projectId?: string;\n}\n\nexport const CLOUD_SDK_CLIENT_ID =\n    '764086051850-6qr4p6gpi6hn506pt8ejuq83di341hur.apps.googleusercontent.com';\n\nexport class GoogleAuth {\n  transporter?: Transporter;\n\n  /**\n   * Caches a value indicating whether the auth layer is running on Google\n   * Compute Engine.\n   * @private\n   */\n  private checkIsGCE?: boolean = undefined;\n\n  // Note:  this properly is only public to satisify unit tests.\n  // https://github.com/Microsoft/TypeScript/issues/5228\n  get isGCE() {\n    return this.checkIsGCE;\n  }\n\n  private _getDefaultProjectIdPromise?: Promise;\n  private _cachedProjectId?: string|null;\n\n  // To save the contents of the JSON credential file\n  jsonContent: JWTInput|null = null;\n\n  cachedCredential: JWT|UserRefreshClient|Compute|null = null;\n\n  private keyFilename?: string;\n  private scopes?: string|string[];\n\n  /**\n   * Export DefaultTransporter as a static property of the class.\n   */\n  static DefaultTransporter = DefaultTransporter;\n\n  constructor(opts?: GoogleAuthOptions) {\n    opts = opts || {};\n    this._cachedProjectId = opts.projectId || null;\n    this.keyFilename = opts.keyFilename || opts.keyFile;\n    this.scopes = opts.scopes;\n    this.jsonContent = opts.credentials || null;\n  }\n\n  /**\n   * THIS METHOD HAS BEEN DEPRECATED.\n   * It will be removed in 3.0.  Please use getProjectId instead.\n   */\n  getDefaultProjectId(): Promise;\n  getDefaultProjectId(callback: ProjectIdCallback): void;\n  getDefaultProjectId(callback?: ProjectIdCallback): Promise|void {\n    messages.warn(messages.DEFAULT_PROJECT_ID_DEPRECATED);\n    if (callback) {\n      this.getProjectIdAsync().then(r => callback(null, r), callback);\n    } else {\n      return this.getProjectIdAsync();\n    }\n  }\n\n  /**\n   * Obtains the default project ID for the application.\n   * @param callback Optional callback\n   * @returns Promise that resolves with project Id (if used without callback)\n   */\n  getProjectId(): Promise;\n  getProjectId(callback: ProjectIdCallback): void;\n  getProjectId(callback?: ProjectIdCallback): Promise|void {\n    if (callback) {\n      this.getProjectIdAsync().then(r => callback(null, r), callback);\n    } else {\n      return this.getProjectIdAsync();\n    }\n  }\n\n  private getProjectIdAsync(): Promise {\n    if (this._cachedProjectId) {\n      return Promise.resolve(this._cachedProjectId);\n    }\n\n    // In implicit case, supports three environments. In order of precedence,\n    // the implicit environments are:\n    // - GCLOUD_PROJECT or GOOGLE_CLOUD_PROJECT environment variable\n    // - GOOGLE_APPLICATION_CREDENTIALS JSON file\n    // - Cloud SDK: `gcloud config config-helper --format json`\n    // - GCE project ID from metadata server)\n    if (!this._getDefaultProjectIdPromise) {\n      this._getDefaultProjectIdPromise =\n          new Promise(async (resolve, reject) => {\n            try {\n              const projectId = this.getProductionProjectId() ||\n                  await this.getFileProjectId() ||\n                  await this.getDefaultServiceProjectId() ||\n                  await this.getGCEProjectId();\n              this._cachedProjectId = projectId;\n              resolve(projectId);\n            } catch (e) {\n              reject(e);\n            }\n          });\n    }\n    return this._getDefaultProjectIdPromise;\n  }\n\n  /**\n   * Obtains the default service-level credentials for the application.\n   * @param callback Optional callback.\n   * @returns Promise that resolves with the ADCResponse (if no callback was\n   * passed).\n   */\n  getApplicationDefault(): Promise;\n  getApplicationDefault(callback: ADCCallback): void;\n  getApplicationDefault(options: RefreshOptions): Promise;\n  getApplicationDefault(options: RefreshOptions, callback: ADCCallback): void;\n  getApplicationDefault(\n      optionsOrCallback: ADCCallback|RefreshOptions = {},\n      callback?: ADCCallback): void|Promise {\n    let options: RefreshOptions|undefined;\n    if (typeof optionsOrCallback === 'function') {\n      callback = optionsOrCallback;\n    } else {\n      options = optionsOrCallback;\n    }\n    if (callback) {\n      this.getApplicationDefaultAsync(options).then(\n          r => callback!(null, r.credential, r.projectId), callback);\n    } else {\n      return this.getApplicationDefaultAsync(options);\n    }\n  }\n\n  private async getApplicationDefaultAsync(options?: RefreshOptions):\n      Promise {\n    // If we've already got a cached credential, just return it.\n    if (this.cachedCredential) {\n      return {\n        credential: this.cachedCredential as JWT | UserRefreshClient,\n        projectId: await this.getProjectIdAsync()\n      };\n    }\n\n    let credential: JWT|UserRefreshClient|null;\n    let projectId: string|null;\n    // Check for the existence of a local environment variable pointing to the\n    // location of the credential file. This is typically used in local\n    // developer scenarios.\n    credential =\n        await this._tryGetApplicationCredentialsFromEnvironmentVariable(\n            options);\n    if (credential) {\n      if (credential instanceof JWT) {\n        credential.scopes = this.scopes;\n      }\n      this.cachedCredential = credential;\n      projectId = await this.getProjectId();\n      return {credential, projectId};\n    }\n\n    // Look in the well-known credential file location.\n    credential =\n        await this._tryGetApplicationCredentialsFromWellKnownFile(options);\n    if (credential) {\n      if (credential instanceof JWT) {\n        credential.scopes = this.scopes;\n      }\n      this.cachedCredential = credential;\n      projectId = await this.getProjectId();\n      return {credential, projectId};\n    }\n\n    // Determine if we're running on GCE.\n    let isGCE;\n    try {\n      isGCE = await this._checkIsGCE();\n    } catch (e) {\n      throw new Error(\n          'Unexpected error determining execution environment: ' + e.message);\n    }\n\n    if (!isGCE) {\n      // We failed to find the default credentials. Bail out with an error.\n      throw new Error(\n          'Could not load the default credentials. Browse to https://cloud.google.com/docs/authentication/getting-started for more information.');\n    }\n\n    // For GCE, just return a default ComputeClient. It will take care of\n    // the rest.\n    this.cachedCredential = new Compute(options);\n    projectId = await this.getProjectId();\n    return {projectId, credential: this.cachedCredential};\n  }\n\n  /**\n   * Determines whether the auth layer is running on Google Compute Engine.\n   * @returns A promise that resolves with the boolean.\n   * @api private\n   */\n  async _checkIsGCE() {\n    if (this.checkIsGCE === undefined) {\n      this.checkIsGCE = await gcpMetadata.isAvailable();\n    }\n    return this.checkIsGCE;\n  }\n\n  /**\n   * Attempts to load default credentials from the environment variable path..\n   * @returns Promise that resolves with the OAuth2Client or null.\n   * @api private\n   */\n  async _tryGetApplicationCredentialsFromEnvironmentVariable(\n      options?: RefreshOptions): Promise {\n    const credentialsPath = process.env['GOOGLE_APPLICATION_CREDENTIALS'];\n    if (!credentialsPath || credentialsPath.length === 0) {\n      return null;\n    }\n    try {\n      return this._getApplicationCredentialsFromFilePath(\n          credentialsPath, options);\n    } catch (e) {\n      throw this.createError(\n          'Unable to read the credential file specified by the GOOGLE_APPLICATION_CREDENTIALS environment variable.',\n          e);\n    }\n  }\n\n  /**\n   * Attempts to load default credentials from a well-known file location\n   * @return Promise that resolves with the OAuth2Client or null.\n   * @api private\n   */\n  async _tryGetApplicationCredentialsFromWellKnownFile(\n      options?: RefreshOptions): Promise {\n    // First, figure out the location of the file, depending upon the OS type.\n    let location = null;\n    if (this._isWindows()) {\n      // Windows\n      location = process.env['APPDATA'];\n    } else {\n      // Linux or Mac\n      const home = process.env['HOME'];\n      if (home) {\n        location = this._pathJoin(home, '.config');\n      }\n    }\n    // If we found the root path, expand it.\n    if (location) {\n      location = this._pathJoin(location, 'gcloud');\n      location =\n          this._pathJoin(location, 'application_default_credentials.json');\n      location = this._mockWellKnownFilePath(location);\n      // Check whether the file exists.\n      if (!this._fileExists(location)) {\n        location = null;\n      }\n    }\n    // The file does not exist.\n    if (!location) {\n      return null;\n    }\n    // The file seems to exist. Try to use it.\n    const client =\n        await this._getApplicationCredentialsFromFilePath(location, options);\n    this.warnOnProblematicCredentials(client as JWT);\n    return client;\n  }\n\n  /**\n   * Attempts to load default credentials from a file at the given path..\n   * @param filePath The path to the file to read.\n   * @returns Promise that resolves with the OAuth2Client\n   * @api private\n   */\n  async _getApplicationCredentialsFromFilePath(\n      filePath: string,\n      options: RefreshOptions = {}): Promise {\n    // Make sure the path looks like a string.\n    if (!filePath || filePath.length === 0) {\n      throw new Error('The file path is invalid.');\n    }\n\n    // Make sure there is a file at the path. lstatSync will throw if there is\n    // nothing there.\n    try {\n      // Resolve path to actual file in case of symlink. Expect a thrown error\n      // if not resolvable.\n      filePath = fs.realpathSync(filePath);\n\n      if (!fs.lstatSync(filePath).isFile()) {\n        throw new Error();\n      }\n    } catch (err) {\n      throw this.createError(\n          util.format(\n              'The file at %s does not exist, or it is not a file.', filePath),\n          err);\n    }\n\n    // Now open a read stream on the file, and parse it.\n    try {\n      const readStream = this._createReadStream(filePath);\n      return this.fromStream(readStream, options);\n    } catch (err) {\n      throw this.createError(\n          util.format('Unable to read the file at %s.', filePath), err);\n    }\n  }\n\n  /**\n   * Credentials from the Cloud SDK that are associated with Cloud SDK's project\n   * are problematic because they may not have APIs enabled and have limited\n   * quota. If this is the case, warn about it.\n   */\n  protected warnOnProblematicCredentials(client: JWT) {\n    if (client.email === CLOUD_SDK_CLIENT_ID) {\n      messages.warn(messages.PROBLEMATIC_CREDENTIALS_WARNING);\n    }\n  }\n\n  /**\n   * Create a credentials instance using the given input options.\n   * @param json The input object.\n   * @returns JWT or UserRefresh Client with data\n   */\n  fromJSON(json: JWTInput, options?: RefreshOptions): JWT|UserRefreshClient {\n    let client: UserRefreshClient|JWT;\n    if (!json) {\n      throw new Error(\n          'Must pass in a JSON object containing the Google auth settings.');\n    }\n    this.jsonContent = json;\n    options = options || {};\n    if (json.type === 'authorized_user') {\n      client = new UserRefreshClient(options);\n    } else {\n      (options as JWTOptions).scopes = this.scopes;\n      client = new JWT(options);\n    }\n    client.fromJSON(json);\n    return client;\n  }\n\n  /**\n   * Create a credentials instance using the given input stream.\n   * @param inputStream The input stream.\n   * @param callback Optional callback.\n   */\n  fromStream(inputStream: stream.Readable): Promise;\n  fromStream(inputStream: stream.Readable, callback: CredentialCallback): void;\n  fromStream(inputStream: stream.Readable, options: RefreshOptions):\n      Promise;\n  fromStream(\n      inputStream: stream.Readable, options: RefreshOptions,\n      callback: CredentialCallback): void;\n  fromStream(\n      inputStream: stream.Readable,\n      optionsOrCallback: RefreshOptions|CredentialCallback = {},\n      callback?: CredentialCallback): Promise|void {\n    let options: RefreshOptions = {};\n    if (typeof optionsOrCallback === 'function') {\n      callback = optionsOrCallback;\n    } else {\n      options = optionsOrCallback;\n    }\n    if (callback) {\n      this.fromStreamAsync(inputStream, options)\n          .then(r => callback!(null, r), callback);\n    } else {\n      return this.fromStreamAsync(inputStream, options);\n    }\n  }\n\n  private fromStreamAsync(\n      inputStream: stream.Readable,\n      options?: RefreshOptions): Promise {\n    return new Promise((resolve, reject) => {\n      if (!inputStream) {\n        throw new Error(\n            'Must pass in a stream containing the Google auth settings.');\n      }\n      let s = '';\n      inputStream.setEncoding('utf8')\n          .on('error', reject)\n          .on('data', (chunk) => s += chunk)\n          .on('end', () => {\n            try {\n              const data = JSON.parse(s);\n              const r = this.fromJSON(data, options);\n              return resolve(r);\n            } catch (err) {\n              return reject(err);\n            }\n          });\n    });\n  }\n\n  /**\n   * Create a credentials instance using the given API key string.\n   * @param apiKey The API key string\n   * @param options An optional options object.\n   * @returns A JWT loaded from the key\n   */\n  fromAPIKey(apiKey: string, options?: RefreshOptions): JWT {\n    options = options || {};\n    const client = new JWT(options);\n    client.fromAPIKey(apiKey);\n    return client;\n  }\n\n  /**\n   * Determines whether the current operating system is Windows.\n   * @api private\n   */\n  private _isWindows() {\n    const sys = this._osPlatform();\n    if (sys && sys.length >= 3) {\n      if (sys.substring(0, 3).toLowerCase() === 'win') {\n        return true;\n      }\n    }\n    return false;\n  }\n\n  /**\n   * Creates a file stream. Allows mocking.\n   * @api private\n   */\n  _createReadStream(filePath: string) {\n    return fs.createReadStream(filePath);\n  }\n\n  /**\n   * Gets the current operating system platform. Allows mocking.\n   * @api private\n   */\n  _osPlatform() {\n    return os.platform();\n  }\n\n  /**\n   * Determines whether a file exists. Allows mocking.\n   * @api private\n   */\n  _fileExists(filePath: string) {\n    return fs.existsSync(filePath);\n  }\n\n  /**\n   * Joins two parts of a path. Allows mocking.\n   * @api private\n   */\n  _pathJoin(item1: string, item2: string) {\n    return path.join(item1, item2);\n  }\n\n  /**\n   * Allows mocking of the path to a well-known file.\n   * @api private\n   */\n  _mockWellKnownFilePath(filePath: string) {\n    return filePath;\n  }\n\n  // Creates an Error containing the given message, and includes the message\n  // from the optional err passed in.\n  private createError(message: string, err: Error) {\n    let s = message || '';\n    if (err) {\n      const errorMessage = String(err);\n      if (errorMessage && errorMessage.length > 0) {\n        if (s.length > 0) {\n          s += ' ';\n        }\n        s += errorMessage;\n      }\n    }\n    return Error(s);\n  }\n\n  /**\n   * Run the Google Cloud SDK command that prints the default project ID\n   */\n  private async getDefaultServiceProjectId(): Promise {\n    return new Promise(resolve => {\n      exec(\n          'gcloud config config-helper --format json',\n          (err, stdout, stderr) => {\n            if (!err && stdout) {\n              try {\n                const projectId =\n                    JSON.parse(stdout).configuration.properties.core.project;\n                resolve(projectId);\n                return;\n              } catch (e) {\n                // ignore errors\n              }\n            }\n            resolve(null);\n          });\n    });\n  }\n\n  /**\n   * Loads the project id from environment variables.\n   * @api private\n   */\n  private getProductionProjectId() {\n    return process.env['GCLOUD_PROJECT'] || process.env['GOOGLE_CLOUD_PROJECT'];\n  }\n\n  /**\n   * Loads the project id from the GOOGLE_APPLICATION_CREDENTIALS json file.\n   * @api private\n   */\n  private async getFileProjectId(): Promise {\n    if (this.cachedCredential) {\n      // Try to read the project ID from the cached credentials file\n      return this.cachedCredential.projectId;\n    }\n\n    // Try to load a credentials file and read its project ID\n    const r = await this._tryGetApplicationCredentialsFromEnvironmentVariable();\n    if (r) {\n      return r.projectId;\n    } else {\n      return null;\n    }\n  }\n\n  /**\n   * Gets the Compute Engine project ID if it can be inferred.\n   */\n  private async getGCEProjectId() {\n    try {\n      const r = await gcpMetadata.project('project-id');\n      return r.data;\n    } catch (e) {\n      // Ignore any errors\n      return null;\n    }\n  }\n\n  /**\n   * The callback function handles a credential object that contains the\n   * client_email and private_key (if exists).\n   * getCredentials checks for these values from the user JSON at first.\n   * If it doesn't exist, and the environment is on GCE, it gets the\n   * client_email from the cloud metadata server.\n   * @param callback Callback that handles the credential object that contains\n   * a client_email and optional private key, or the error.\n   * returned\n   */\n  getCredentials(): Promise;\n  getCredentials(\n      callback: (err: Error|null, credentials?: CredentialBody) => void): void;\n  getCredentials(\n      callback?: (err: Error|null, credentials?: CredentialBody) => void):\n      void|Promise {\n    if (callback) {\n      this.getCredentialsAsync().then(r => callback(null, r), callback);\n    } else {\n      return this.getCredentialsAsync();\n    }\n  }\n\n  private async getCredentialsAsync(): Promise {\n    if (this.jsonContent) {\n      const credential: CredentialBody = {\n        client_email: this.jsonContent.client_email,\n        private_key: this.jsonContent.private_key\n      };\n      return credential;\n    }\n\n    const isGCE = await this._checkIsGCE();\n    if (!isGCE) {\n      throw new Error('Unknown error.');\n    }\n\n    // For GCE, return the service account details from the metadata server\n    // NOTE: The trailing '/' at the end of service-accounts/ is very important!\n    // The GCF metadata server doesn't respect querystring params if this / is\n    // not included.\n    const {data} = await gcpMetadata.instance(\n        {property: 'service-accounts/', params: {recursive: true}});\n\n    if (!data || !data.default || !data.default.email) {\n      throw new Error('Failure from metadata server.');\n    }\n\n    return {client_email: data.default.email};\n  }\n\n  /**\n   * Automatically obtain a client based on the provided configuration.  If no\n   * options were passed, use Application Default Credentials.\n   */\n  async getClient(options?: GoogleAuthOptions) {\n    if (options) {\n      this.keyFilename =\n          options.keyFilename || options.keyFile || this.keyFilename;\n      this.scopes = options.scopes || this.scopes;\n      this.jsonContent = options.credentials || this.jsonContent;\n    }\n    if (!this.cachedCredential) {\n      if (this.jsonContent) {\n        this.cachedCredential = await this.fromJSON(this.jsonContent);\n      } else if (this.keyFilename) {\n        const filePath = path.resolve(this.keyFilename);\n        const stream = fs.createReadStream(filePath);\n        this.cachedCredential = await this.fromStreamAsync(stream);\n      } else {\n        await this.getApplicationDefaultAsync();\n      }\n    }\n    return this.cachedCredential!;\n  }\n\n  /**\n   * Automatically obtain application default credentials, and return\n   * an access token for making requests.\n   */\n  async getAccessToken() {\n    const client = await this.getClient();\n    return (await client.getAccessToken()).token;\n  }\n\n  /**\n   * Obtain the HTTP headers that will provide authorization for a given\n   * request.\n   */\n  async getRequestHeaders(url?: string) {\n    const client = await this.getClient();\n    return client.getRequestHeaders(url);\n  }\n\n  /**\n   * Obtain credentials for a request, then attach the appropriate headers to\n   * the request options.\n   * @param opts Axios or Request options on which to attach the headers\n   */\n  async authorizeRequest(opts:\n                             {url?: string, uri?: string, headers?: Headers}) {\n    opts = opts || {};\n    const url = opts.url || opts.uri;\n    const client = await this.getClient();\n    const headers = await client.getRequestHeaders(url);\n    opts.headers = Object.assign(opts.headers || {}, headers);\n    return opts;\n  }\n\n  /**\n   * Automatically obtain application default credentials, and make an\n   * HTTP request using the given options.\n   * @param opts Axios request options for the HTTP request.\n   */\n  // tslint:disable-next-line no-any\n  async request(opts: AxiosRequestConfig): Promise> {\n    const client = await this.getClient();\n    return client.request(opts);\n  }\n\n  /**\n   * Determine the compute environment in which the code is running.\n   */\n  getEnv(): Promise {\n    return getEnv();\n  }\n\n  /**\n   * Sign the given data with the current private key, or go out\n   * to the IAM API to sign it.\n   * @param data The data to be signed.\n   */\n  async sign(data: string): Promise {\n    const client = await this.getClient();\n    if (client instanceof JWT && client.key) {\n      const sign = crypto.createSign('RSA-SHA256');\n      sign.update(data);\n      return sign.sign(client.key, 'base64');\n    }\n\n    const projectId = await this.getProjectId();\n    if (!projectId) {\n      throw new Error('Cannot sign data without a project ID.');\n    }\n\n    const creds = await this.getCredentials();\n    if (!creds.client_email) {\n      throw new Error('Cannot sign data without `client_email`.');\n    }\n\n    const id = `projects/${projectId}/serviceAccounts/${creds.client_email}`;\n    const res = await this.request({\n      method: 'POST',\n      url: `https://iam.googleapis.com/v1/${id}:signBlob`,\n      data: {bytesToSign: Buffer.from(data).toString('base64')}\n    });\n    return res.data.signature;\n  }\n}\n\nexport interface SignBlobResponse {\n  signature: string;\n}\n\n    \n\n\n\n\n\n\n\n                   \n    \n         result-matching \"\"\n        \n    \n    \n        No results matching \"\"\n    \n\n"},"interfaces/RefreshAccessTokenCallback.html":{"url":"interfaces/RefreshAccessTokenCallback.html","title":"interface - RefreshAccessTokenCallback","body":"\n                   \n\n\n\n\n\n\n\n\n\n\n\n\n\n  Interfaces\n  RefreshAccessTokenCallback\n\n\n\n        \n            Info\n        \n        \n            Source\n        \n\n\n\n    \n        \n            File\n        \n        \n            src/auth/oauth2client.ts\n        \n\n\n\n        \n            Index\n            \n                \n                    \n                        \n                            Properties\n                        \n                    \n                    \n                        \n                            \n                                \n                                            Unamed property\n                                \n                            \n                        \n                    \n                \n            \n        \n\n\n\n            \n                Properties\n                    \n                        \n\n                                    \n                                        \n                                            Signature :\n                                            \n                                            \n                                                \n                                                    [err: AxiosError | null, credentials: Credentials | null, res: AxiosResponse | null]\n                                            \n                                        \n                                    \n\n\n                                    \n                                        \n                                            Returns :     void\n\n                                        \n                                    \n\n\n\n\n                        \n                    \n            \n    \n\n\n    \n        import {AxiosError, AxiosPromise, AxiosRequestConfig, AxiosResponse} from 'axios';\nimport * as crypto from 'crypto';\nimport * as querystring from 'querystring';\nimport * as stream from 'stream';\nimport * as messages from '../messages';\nimport {PemVerifier} from './../pemverifier';\nimport {BodyResponseCallback} from './../transporters';\nimport {AuthClient} from './authclient';\nimport {CredentialRequest, Credentials} from './credentials';\nimport {LoginTicket, TokenPayload} from './loginticket';\n\nexport type Certificates = {\n  [index: string]: string\n};\n\nexport type Headers = {\n  [index: string]: string\n};\n\nexport enum CodeChallengeMethod {\n  Plain = 'plain',\n  S256 = 'S256'\n}\n\nexport interface GetTokenOptions {\n  code: string;\n  codeVerifier?: string;\n  /**\n   * The client ID for your application. The value passed into the constructor\n   * will be used if not provided. Must match any client_id option passed to\n   * a corresponding call to generateAuthUrl.\n   */\n  client_id?: string;\n  /**\n   * Determines where the API server redirects the user after the user\n   * completes the authorization flow. The value passed into the constructor\n   * will be used if not provided. Must match any redirect_uri option passed to\n   * a corresponding call to generateAuthUrl.\n   */\n  redirect_uri?: string;\n}\n\nexport interface TokenInfo {\n  /**\n   * The application that is the intended user of the access token.\n   */\n  aud: string;\n\n  /**\n   * This value lets you correlate profile information from multiple Google\n   * APIs. It is only present in the response if you included the profile scope\n   * in your request in step 1. The field value is an immutable identifier for\n   * the logged-in user that can be used to create and manage user sessions in\n   * your application. The identifier is the same regardless of which client ID\n   * is used to retrieve it. This enables multiple applications in the same\n   * organization to correlate profile information.\n   */\n  user_id?: string;\n\n  /**\n   * An array of scopes that the user granted access to.\n   */\n  scopes: string[];\n\n  /**\n   * The datetime when the token becomes invalid.\n   */\n  expiry_date: number;\n\n  /**\n   * An identifier for the user, unique among all Google accounts and never\n   * reused. A Google account can have multiple emails at different points in\n   * time, but the sub value is never changed. Use sub within your application\n   * as the unique-identifier key for the user.\n   */\n  sub?: string;\n\n  /**\n   * The client_id of the authorized presenter. This claim is only needed when\n   * the party requesting the ID token is not the same as the audience of the ID\n   * token. This may be the case at Google for hybrid apps where a web\n   * application and Android app have a different client_id but share the same\n   * project.\n   */\n  azp?: string;\n\n  /**\n   * Indicates whether your application can refresh access tokens\n   * when the user is not present at the browser. Valid parameter values are\n   * 'online', which is the default value, and 'offline'. Set the value to\n   * 'offline' if your application needs to refresh access tokens when the user\n   * is not present at the browser. This value instructs the Google\n   * authorization server to return a refresh token and an access token the\n   * first time that your application exchanges an authorization code for\n   * tokens.\n   */\n  access_type?: string;\n}\n\ninterface TokenInfoRequest {\n  aud: string;\n  user_id?: string;\n  scope: string;\n  expires_in: number;\n  azp?: string;\n  sub?: string;\n  exp?: number;\n  access_type?: string;\n}\n\nexport interface GenerateAuthUrlOpts {\n  /**\n   * Recommended. Indicates whether your application can refresh access tokens\n   * when the user is not present at the browser. Valid parameter values are\n   * 'online', which is the default value, and 'offline'. Set the value to\n   * 'offline' if your application needs to refresh access tokens when the user\n   * is not present at the browser. This value instructs the Google\n   * authorization server to return a refresh token and an access token the\n   * first time that your application exchanges an authorization code for\n   * tokens.\n   */\n  access_type?: string;\n\n  /**\n   * The hd (hosted domain) parameter streamlines the login process for G Suite\n   * hosted accounts. By including the domain of the G Suite user (for example,\n   * mycollege.edu), you can indicate that the account selection UI should be\n   * optimized for accounts at that domain. To optimize for G Suite accounts\n   * generally instead of just one domain, use an asterisk: hd=*.\n   * Don't rely on this UI optimization to control who can access your app,\n   * as client-side requests can be modified. Be sure to validate that the\n   * returned ID token has an hd claim value that matches what you expect\n   * (e.g. mycolledge.edu). Unlike the request parameter, the ID token claim is\n   * contained within a security token from Google, so the value can be trusted.\n   */\n  hd?: string;\n\n  /**\n   * The 'response_type' will always be set to 'CODE'.\n   */\n  response_type?: string;\n\n  /**\n   * The client ID for your application. The value passed into the constructor\n   * will be used if not provided. You can find this value in the API Console.\n   */\n  client_id?: string;\n\n  /**\n   * Determines where the API server redirects the user after the user\n   * completes the authorization flow. The value must exactly match one of the\n   * 'redirect_uri' values listed for your project in the API Console. Note that\n   * the http or https scheme, case, and trailing slash ('/') must all match.\n   * The value passed into the constructor will be used if not provided.\n   */\n  redirect_uri?: string;\n\n  /**\n   * Required. A space-delimited list of scopes that identify the resources that\n   * your application could access on the user's behalf. These values inform the\n   * consent screen that Google displays to the user. Scopes enable your\n   * application to only request access to the resources that it needs while\n   * also enabling users to control the amount of access that they grant to your\n   * application. Thus, there is an inverse relationship between the number of\n   * scopes requested and the likelihood of obtaining user consent. The\n   * OAuth 2.0 API Scopes document provides a full list of scopes that you might\n   * use to access Google APIs. We recommend that your application request\n   * access to authorization scopes in context whenever possible. By requesting\n   * access to user data in context, via incremental authorization, you help\n   * users to more easily understand why your application needs the access it is\n   * requesting.\n   */\n  scope?: string[]|string;\n\n  /**\n   * Recommended. Specifies any string value that your application uses to\n   * maintain state between your authorization request and the authorization\n   * server's response. The server returns the exact value that you send as a\n   * name=value pair in the hash (#) fragment of the 'redirect_uri' after the\n   * user consents to or denies your application's access request. You can use\n   * this parameter for several purposes, such as directing the user to the\n   * correct resource in your application, sending nonces, and mitigating\n   * cross-site request forgery. Since your redirect_uri can be guessed, using a\n   * state value can increase your assurance that an incoming connection is the\n   * result of an authentication request. If you generate a random string or\n   * encode the hash of a cookie or another value that captures the client's\n   * state, you can validate the response to additionally ensure that the\n   * request and response originated in the same browser, providing protection\n   * against attacks such as cross-site request forgery. See the OpenID Connect\n   * documentation for an example of how to create and confirm a state token.\n   */\n  state?: string;\n\n  /**\n   * Optional. Enables applications to use incremental authorization to request\n   * access to additional scopes in context. If you set this parameter's value\n   * to true and the authorization request is granted, then the new access token\n   * will also cover any scopes to which the user previously granted the\n   * application access. See the incremental authorization section for examples.\n   */\n  include_granted_scopes?: boolean;\n\n  /**\n   * Optional. If your application knows which user is trying to authenticate,\n   * it can use this parameter to provide a hint to the Google Authentication\n   * Server. The server uses the hint to simplify the login flow either by\n   * prefilling the email field in the sign-in form or by selecting the\n   * appropriate multi-login session. Set the parameter value to an email\n   * address or sub identifier, which is equivalent to the user's Google ID.\n   */\n  login_hint?: string;\n\n  /**\n   * Optional. A space-delimited, case-sensitive list of prompts to present the\n   * user. If you don't specify this parameter, the user will be prompted only\n   * the first time your app requests access.  Possible values are:\n   *\n   * 'none' - Donot display any authentication or consent screens. Must not be\n   *        specified with other values.\n   * 'consent' - \tPrompt the user for consent.\n   * 'select_account' - Prompt the user to select an account.\n   */\n  prompt?: string;\n\n  /**\n   * Recommended. Specifies what method was used to encode a 'code_verifier'\n   * that will be used during authorization code exchange. This parameter must\n   * be used with the 'code_challenge' parameter. The value of the\n   * 'code_challenge_method' defaults to \"plain\" if not present in the request\n   * that includes a 'code_challenge'. The only supported values for this\n   * parameter are \"S256\" or \"plain\".\n   */\n  code_challenge_method?: CodeChallengeMethod;\n\n  /**\n   * Recommended. Specifies an encoded 'code_verifier' that will be used as a\n   * server-side challenge during authorization code exchange. This parameter\n   * must be used with the 'code_challenge' parameter described above.\n   */\n  code_challenge?: string;\n}\n\nexport interface GetTokenCallback {\n  (err: AxiosError|null, token?: Credentials|null,\n   res?: AxiosResponse|null): void;\n}\n\nexport interface GetTokenResponse {\n  tokens: Credentials;\n  res: AxiosResponse|null;\n}\n\nexport interface GetAccessTokenCallback {\n  (err: AxiosError|null, token?: string|null, res?: AxiosResponse|null): void;\n}\n\nexport interface GetAccessTokenResponse {\n  token?: string|null;\n  res?: AxiosResponse|null;\n}\n\nexport interface RefreshAccessTokenCallback {\n  (err: AxiosError|null, credentials?: Credentials|null,\n   res?: AxiosResponse|null): void;\n}\n\nexport interface RefreshAccessTokenResponse {\n  credentials: Credentials;\n  res: AxiosResponse|null;\n}\n\nexport interface RequestMetadataResponse {\n  headers: Headers;\n  res?: AxiosResponse|null;\n}\n\nexport interface RequestMetadataCallback {\n  (err: AxiosError|null, headers?: Headers,\n   res?: AxiosResponse|null): void;\n}\n\nexport interface GetFederatedSignonCertsCallback {\n  (err: AxiosError|null, certs?: Certificates,\n   response?: AxiosResponse|null): void;\n}\n\nexport interface FederatedSignonCertsResponse {\n  certs: Certificates;\n  res?: AxiosResponse|null;\n}\n\nexport interface RevokeCredentialsResult {\n  success: boolean;\n}\n\nexport interface VerifyIdTokenOptions {\n  idToken: string;\n  audience: string|string[];\n  maxExpiry?: number;\n}\n\nexport interface OAuth2ClientOptions extends RefreshOptions {\n  clientId?: string;\n  clientSecret?: string;\n  redirectUri?: string;\n}\n\nexport interface RefreshOptions {\n  // Eagerly refresh unexpired tokens when they are within this many\n  // milliseconds from expiring\".\n  // Defaults to a value of 300000 (5 minutes).\n  eagerRefreshThresholdMillis?: number;\n}\n\nexport class OAuth2Client extends AuthClient {\n  private redirectUri?: string;\n  private certificateCache?: Certificates;\n  private certificateExpiry: Date|null = null;\n  protected refreshTokenPromises = new Map>();\n\n  // TODO: refactor tests to make this private\n  _clientId?: string;\n\n  // TODO: refactor tests to make this private\n  _clientSecret?: string;\n\n  apiKey?: string;\n\n  projectId?: string;\n\n  eagerRefreshThresholdMillis: number;\n\n  /**\n   * Handles OAuth2 flow for Google APIs.\n   *\n   * @param clientId The authentication client ID.\n   * @param clientSecret The authentication client secret.\n   * @param redirectUri The URI to redirect to after completing the auth\n   * request.\n   * @param opts optional options for overriding the given parameters.\n   * @constructor\n   */\n  constructor(options?: OAuth2ClientOptions);\n  constructor(clientId?: string, clientSecret?: string, redirectUri?: string);\n  constructor(\n      optionsOrClientId?: string|OAuth2ClientOptions, clientSecret?: string,\n      redirectUri?: string) {\n    super();\n    const opts = (optionsOrClientId && typeof optionsOrClientId === 'object') ?\n        optionsOrClientId :\n        {clientId: optionsOrClientId, clientSecret, redirectUri};\n    this._clientId = opts.clientId;\n    this._clientSecret = opts.clientSecret;\n    this.redirectUri = opts.redirectUri;\n    this.eagerRefreshThresholdMillis =\n        opts.eagerRefreshThresholdMillis || 5 * 60 * 1000;\n  }\n\n  protected static readonly GOOGLE_TOKEN_INFO_URL =\n      'https://oauth2.googleapis.com/tokeninfo';\n\n  /**\n   * The base URL for auth endpoints.\n   */\n  private static readonly GOOGLE_OAUTH2_AUTH_BASE_URL_ =\n      'https://accounts.google.com/o/oauth2/v2/auth';\n\n  /**\n   * The base endpoint for token retrieval.\n   */\n  private static readonly GOOGLE_OAUTH2_TOKEN_URL_ =\n      'https://oauth2.googleapis.com/token';\n\n  /**\n   * The base endpoint to revoke tokens.\n   */\n  private static readonly GOOGLE_OAUTH2_REVOKE_URL_ =\n      'https://oauth2.googleapis.com/revoke';\n\n  /**\n   * Google Sign on certificates.\n   */\n  private static readonly GOOGLE_OAUTH2_FEDERATED_SIGNON_CERTS_URL_ =\n      'https://www.googleapis.com/oauth2/v1/certs';\n\n  /**\n   * Clock skew - five minutes in seconds\n   */\n  private static readonly CLOCK_SKEW_SECS_ = 300;\n\n  /**\n   * Max Token Lifetime is one day in seconds\n   */\n  private static readonly MAX_TOKEN_LIFETIME_SECS_ = 86400;\n\n  /**\n   * The allowed oauth token issuers.\n   */\n  private static readonly ISSUERS_ =\n      ['accounts.google.com', 'https://accounts.google.com'];\n\n  /**\n   * Generates URL for consent page landing.\n   * @param opts Options.\n   * @return URL to consent page.\n   */\n  generateAuthUrl(opts: GenerateAuthUrlOpts = {}) {\n    if (opts.code_challenge_method && !opts.code_challenge) {\n      throw new Error(\n          'If a code_challenge_method is provided, code_challenge must be included.');\n    }\n    opts.response_type = opts.response_type || 'code';\n    opts.client_id = opts.client_id || this._clientId;\n    opts.redirect_uri = opts.redirect_uri || this.redirectUri;\n    // Allow scopes to be passed either as array or a string\n    if (opts.scope instanceof Array) {\n      opts.scope = opts.scope.join(' ');\n    }\n    const rootUrl = OAuth2Client.GOOGLE_OAUTH2_AUTH_BASE_URL_;\n    return rootUrl + '?' + querystring.stringify(opts);\n  }\n\n  /**\n   * Convenience method to automatically generate a code_verifier, and it's\n   * resulting SHA256. If used, this must be paired with a S256\n   * code_challenge_method.\n   */\n  generateCodeVerifier() {\n    // base64 encoding uses 6 bits per character, and we want to generate128\n    // characters. 6*128/8 = 96.\n    const randomString = crypto.randomBytes(96).toString('base64');\n    // The valid characters in the code_verifier are [A-Z]/[a-z]/[0-9]/\n    // \"-\"/\".\"/\"_\"/\"~\". Base64 encoded strings are pretty close, so we're just\n    // swapping out a few chars.\n    const codeVerifier =\n        randomString.replace(/\\+/g, '~').replace(/=/g, '_').replace(/\\//g, '-');\n    // Generate the base64 encoded SHA256\n    const unencodedCodeChallenge =\n        crypto.createHash('sha256').update(codeVerifier).digest('base64');\n    // We need to use base64UrlEncoding instead of standard base64\n    const codeChallenge = unencodedCodeChallenge.split('=')[0]\n                              .replace(/\\+/g, '-')\n                              .replace(/\\//g, '_');\n    return {codeVerifier, codeChallenge};\n  }\n\n  /**\n   * Gets the access token for the given code.\n   * @param code The authorization code.\n   * @param callback Optional callback fn.\n   */\n  getToken(code: string): Promise;\n  getToken(options: GetTokenOptions): Promise;\n  getToken(code: string, callback: GetTokenCallback): void;\n  getToken(options: GetTokenOptions, callback: GetTokenCallback): void;\n  getToken(codeOrOptions: string|GetTokenOptions, callback?: GetTokenCallback):\n      Promise|void {\n    const options = (typeof codeOrOptions === 'string') ?\n        {code: codeOrOptions} :\n        codeOrOptions;\n    if (callback) {\n      this.getTokenAsync(options).then(\n          r => callback(null, r.tokens, r.res),\n          e => callback(e, null, e.response));\n    } else {\n      return this.getTokenAsync(options);\n    }\n  }\n\n  private async getTokenAsync(options: GetTokenOptions):\n      Promise {\n    const url = OAuth2Client.GOOGLE_OAUTH2_TOKEN_URL_;\n    const values = {\n      code: options.code,\n      client_id: options.client_id || this._clientId,\n      client_secret: this._clientSecret,\n      redirect_uri: options.redirect_uri || this.redirectUri,\n      grant_type: 'authorization_code',\n      code_verifier: options.codeVerifier\n    };\n    const res = await this.transporter.request({\n      method: 'POST',\n      url,\n      data: querystring.stringify(values),\n      headers: {'Content-Type': 'application/x-www-form-urlencoded'}\n    });\n    const tokens = res.data as Credentials;\n    if (res.data && res.data.expires_in) {\n      tokens.expiry_date =\n          ((new Date()).getTime() + (res.data.expires_in * 1000));\n      delete (tokens as CredentialRequest).expires_in;\n    }\n    this.emit('tokens', tokens);\n    return {tokens, res};\n  }\n\n  /**\n   * Refreshes the access token.\n   * @param refresh_token Existing refresh token.\n   * @private\n   */\n  protected async refreshToken(refreshToken?: string|\n                               null): Promise {\n    if (!refreshToken) {\n      return this.refreshTokenNoCache(refreshToken);\n    }\n    // If a request to refresh using the same token has started,\n    // return the same promise.\n    if (this.refreshTokenPromises.has(refreshToken)) {\n      return this.refreshTokenPromises.get(refreshToken)!;\n    }\n\n    const p = this.refreshTokenNoCache(refreshToken)\n                  .then(\n                      r => {\n                        this.refreshTokenPromises.delete(refreshToken);\n                        return r;\n                      },\n                      e => {\n                        this.refreshTokenPromises.delete(refreshToken);\n                        throw e;\n                      });\n    this.refreshTokenPromises.set(refreshToken, p);\n    return p;\n  }\n\n  protected async refreshTokenNoCache(refreshToken?: string|\n                                      null): Promise {\n    const url = OAuth2Client.GOOGLE_OAUTH2_TOKEN_URL_;\n    const data = {\n      refresh_token: refreshToken,\n      client_id: this._clientId,\n      client_secret: this._clientSecret,\n      grant_type: 'refresh_token'\n    };\n\n    // request for new token\n    const res = await this.transporter.request({\n      method: 'POST',\n      url,\n      data: querystring.stringify(data),\n      headers: {'Content-Type': 'application/x-www-form-urlencoded'}\n    });\n\n    const tokens = res.data as Credentials;\n    // TODO: de-duplicate this code from a few spots\n    if (res.data && res.data.expires_in) {\n      tokens.expiry_date =\n          ((new Date()).getTime() + (res.data.expires_in * 1000));\n      delete (tokens as CredentialRequest).expires_in;\n    }\n    this.emit('tokens', tokens);\n    return {tokens, res};\n  }\n\n  /**\n   * Retrieves the access token using refresh token\n   *\n   * @deprecated use getRequestHeaders instead.\n   * @param callback callback\n   */\n  refreshAccessToken(): Promise;\n  refreshAccessToken(callback: RefreshAccessTokenCallback): void;\n  refreshAccessToken(callback?: RefreshAccessTokenCallback):\n      Promise|void {\n    messages.warn(messages.REFRESH_ACCESS_TOKEN_DEPRECATED);\n    if (callback) {\n      this.refreshAccessTokenAsync().then(\n          r => callback(null, r.credentials, r.res), callback);\n    } else {\n      return this.refreshAccessTokenAsync();\n    }\n  }\n\n  private async refreshAccessTokenAsync() {\n    if (!this.credentials.refresh_token) {\n      throw new Error('No refresh token is set.');\n    }\n    const r = await this.refreshToken(this.credentials.refresh_token);\n    const tokens = r.tokens as Credentials;\n    tokens.refresh_token = this.credentials.refresh_token;\n    this.credentials = tokens;\n    return {credentials: this.credentials, res: r.res};\n  }\n\n  /**\n   * Get a non-expired access token, after refreshing if necessary\n   *\n   * @param callback Callback to call with the access token\n   */\n  getAccessToken(): Promise;\n  getAccessToken(callback: GetAccessTokenCallback): void;\n  getAccessToken(callback?: GetAccessTokenCallback):\n      Promise|void {\n    if (callback) {\n      this.getAccessTokenAsync().then(\n          r => callback(null, r.token, r.res), callback);\n    } else {\n      return this.getAccessTokenAsync();\n    }\n  }\n\n  private async getAccessTokenAsync(): Promise {\n    const shouldRefresh =\n        !this.credentials.access_token || this.isTokenExpiring();\n    if (shouldRefresh && this.credentials.refresh_token) {\n      if (!this.credentials.refresh_token) {\n        throw new Error('No refresh token is set.');\n      }\n\n      const r = await this.refreshAccessTokenAsync();\n      if (!r.credentials || (r.credentials && !r.credentials.access_token)) {\n        throw new Error('Could not refresh access token.');\n      }\n      return {token: r.credentials.access_token, res: r.res};\n    } else {\n      return {token: this.credentials.access_token};\n    }\n  }\n\n  /**\n   * Obtain the set of headers required to authenticate a request.\n   *\n   * @deprecated Use getRequestHeaders instead.\n   * @param url the Uri being authorized\n   * @param callback the func described above\n   */\n  getRequestMetadata(url?: string|null): Promise;\n  getRequestMetadata(url: string|null, callback: RequestMetadataCallback): void;\n  getRequestMetadata(url: string|null, callback?: RequestMetadataCallback):\n      Promise|void {\n    messages.warn(messages.OAUTH_GET_REQUEST_METADATA_DEPRECATED);\n    if (callback) {\n      this.getRequestMetadataAsync(url).then(\n          r => callback(null, r.headers, r.res), callback);\n    } else {\n      return this.getRequestMetadataAsync();\n    }\n  }\n\n  /**\n   * The main authentication interface.  It takes an optional url which when\n   * present is the endpoint being accessed, and returns a Promise which\n   * resolves with authorization header fields.\n   *\n   * In OAuth2Client, the result has the form:\n   * { Authorization: 'Bearer ' }\n   * @param url The optional url being authorized\n   */\n  async getRequestHeaders(url?: string): Promise {\n    const res = await this.getRequestMetadataAsync(url);\n    return res.headers;\n  }\n\n  protected async getRequestMetadataAsync(url?: string|null):\n      Promise {\n    const thisCreds = this.credentials;\n    if (!thisCreds.access_token && !thisCreds.refresh_token && !this.apiKey) {\n      throw new Error('No access, refresh token or API key is set.');\n    }\n\n    if (thisCreds.access_token && !this.isTokenExpiring()) {\n      thisCreds.token_type = thisCreds.token_type || 'Bearer';\n      const headers = {\n        Authorization: thisCreds.token_type + ' ' + thisCreds.access_token\n      };\n      return {headers};\n    }\n\n    if (this.apiKey) {\n      return {headers: {}};\n    }\n    let r: GetTokenResponse|null = null;\n    let tokens: Credentials|null = null;\n    try {\n      r = await this.refreshToken(thisCreds.refresh_token);\n      tokens = r.tokens;\n    } catch (err) {\n      const e = err as AxiosError;\n      if (e.response &&\n          (e.response.status === 403 || e.response.status === 404)) {\n        e.message = 'Could not refresh access token.';\n      }\n      throw e;\n    }\n\n    const credentials = this.credentials;\n    credentials.token_type = credentials.token_type || 'Bearer';\n    tokens.refresh_token = credentials.refresh_token;\n    this.credentials = tokens;\n    const headers = {\n      Authorization: credentials.token_type + ' ' + tokens.access_token\n    };\n    return {headers, res: r.res};\n  }\n\n  /**\n   * Revokes the access given to token.\n   * @param token The existing token to be revoked.\n   * @param callback Optional callback fn.\n   */\n  revokeToken(token: string): AxiosPromise;\n  revokeToken(\n      token: string,\n      callback: BodyResponseCallback): void;\n  revokeToken(\n      token: string, callback?: BodyResponseCallback):\n      AxiosPromise|void {\n    const opts = {\n      url: OAuth2Client.GOOGLE_OAUTH2_REVOKE_URL_ + '?' +\n          querystring.stringify({token}),\n      method: 'POST'\n    };\n    if (callback) {\n      this.transporter.request(opts).then(\n          r => callback(null, r), callback);\n    } else {\n      return this.transporter.request(opts);\n    }\n  }\n\n\n  /**\n   * Revokes access token and clears the credentials object\n   * @param callback callback\n   */\n  revokeCredentials(): AxiosPromise;\n  revokeCredentials(callback: BodyResponseCallback):\n      void;\n  revokeCredentials(callback?: BodyResponseCallback):\n      AxiosPromise|void {\n    if (callback) {\n      this.revokeCredentialsAsync().then(res => callback(null, res), callback);\n    } else {\n      return this.revokeCredentialsAsync();\n    }\n  }\n\n  private async revokeCredentialsAsync() {\n    const token = this.credentials.access_token;\n    this.credentials = {};\n    if (token) {\n      return this.revokeToken(token);\n    } else {\n      throw new Error('No access token to revoke.');\n    }\n  }\n\n  /**\n   * Provides a request implementation with OAuth 2.0 flow. If credentials have\n   * a refresh_token, in cases of HTTP 401 and 403 responses, it automatically\n   * asks for a new access token and replays the unsuccessful request.\n   * @param opts Request options.\n   * @param callback callback.\n   * @return Request object\n   */\n  request(opts: AxiosRequestConfig): AxiosPromise;\n  request(opts: AxiosRequestConfig, callback: BodyResponseCallback): void;\n  request(opts: AxiosRequestConfig, callback?: BodyResponseCallback):\n      AxiosPromise|void {\n    if (callback) {\n      this.requestAsync(opts).then(r => callback(null, r), e => {\n        return callback(e, e.response);\n      });\n    } else {\n      return this.requestAsync(opts);\n    }\n  }\n\n  protected async requestAsync(opts: AxiosRequestConfig, retry = false):\n      Promise> {\n    let r2: AxiosResponse;\n    try {\n      const r = await this.getRequestMetadataAsync(opts.url);\n      if (r.headers && r.headers.Authorization) {\n        opts.headers = opts.headers || {};\n        opts.headers.Authorization = r.headers.Authorization;\n      }\n\n      if (this.apiKey) {\n        opts.params = Object.assign(opts.params || {}, {key: this.apiKey});\n      }\n      r2 = await this.transporter.request(opts);\n    } catch (e) {\n      const res = (e as AxiosError).response;\n      if (res) {\n        const statusCode = res.status;\n        // Retry the request for metadata if the following criteria are true:\n        // - We haven't already retried.  It only makes sense to retry once.\n        // - The response was a 401 or a 403\n        // - The request didn't send a readableStream\n        // - An access_token and refresh_token were available, but no\n        //   expiry_date was availabe. This can happen when developers stash\n        //   the access_token and refresh_token for later use, but the\n        //   access_token fails on the first try because it's expired.\n        const mayRequireRefresh = this.credentials &&\n            this.credentials.access_token && this.credentials.refresh_token &&\n            !this.credentials.expiry_date;\n        const isReadableStream = res.config.data instanceof stream.Readable;\n        const isAuthErr = statusCode === 401 || statusCode === 403;\n        if (!retry && isAuthErr && !isReadableStream && mayRequireRefresh) {\n          await this.refreshAccessTokenAsync();\n          return this.requestAsync(opts, true);\n        }\n      }\n      throw e;\n    }\n    return r2;\n  }\n\n  /**\n   * Verify id token is token by checking the certs and audience\n   * @param options that contains all options.\n   * @param callback Callback supplying GoogleLogin if successful\n   */\n  verifyIdToken(options: VerifyIdTokenOptions): Promise;\n  verifyIdToken(\n      options: VerifyIdTokenOptions,\n      callback: (err: Error|null, login?: LoginTicket) => void): void;\n  verifyIdToken(\n      options: VerifyIdTokenOptions,\n      callback?: (err: Error|null, login?: LoginTicket) => void):\n      void|Promise {\n    // This function used to accept two arguments instead of an options object.\n    // Check the types to help users upgrade with less pain.\n    // This check can be removed after a 2.0 release.\n    if (callback && typeof callback !== 'function') {\n      throw new Error(\n          'This method accepts an options object as the first parameter, which includes the idToken, audience, and maxExpiry.');\n    }\n\n    if (callback) {\n      this.verifyIdTokenAsync(options).then(r => callback(null, r), callback);\n    } else {\n      return this.verifyIdTokenAsync(options);\n    }\n  }\n\n  private async verifyIdTokenAsync(options: VerifyIdTokenOptions):\n      Promise {\n    if (!options.idToken) {\n      throw new Error('The verifyIdToken method requires an ID Token');\n    }\n\n    const response = await this.getFederatedSignonCertsAsync();\n    const login = this.verifySignedJwtWithCerts(\n        options.idToken, response.certs, options.audience,\n        OAuth2Client.ISSUERS_, options.maxExpiry);\n\n    return login;\n  }\n\n  /**\n   * Obtains information about the provisioned access token.  Especially useful\n   * if you want to check the scopes that were provisioned to a given token.\n   *\n   * @param accessToken Required.  The Access Token for which you want to get\n   * user info.\n   */\n  async getTokenInfo(accessToken: string): Promise {\n    const {data} = await this.transporter.request({\n      method: 'GET',\n      url: OAuth2Client.GOOGLE_TOKEN_INFO_URL,\n      params: {access_token: accessToken}\n    });\n    const info = Object.assign(\n        {\n          expiry_date: ((new Date()).getTime() + (data.expires_in * 1000)),\n          scopes: data.scope.split(' ')\n        },\n        data);\n    delete info.expires_in;\n    delete info.scope;\n    return info;\n  }\n\n  /**\n   * Gets federated sign-on certificates to use for verifying identity tokens.\n   * Returns certs as array structure, where keys are key ids, and values\n   * are PEM encoded certificates.\n   * @param callback Callback supplying the certificates\n   */\n  getFederatedSignonCerts(): Promise;\n  getFederatedSignonCerts(callback: GetFederatedSignonCertsCallback): void;\n  getFederatedSignonCerts(callback?: GetFederatedSignonCertsCallback):\n      Promise|void {\n    if (callback) {\n      this.getFederatedSignonCertsAsync().then(\n          r => callback(null, r.certs, r.res), callback);\n    } else {\n      return this.getFederatedSignonCertsAsync();\n    }\n  }\n\n  async getFederatedSignonCertsAsync(): Promise {\n    const nowTime = (new Date()).getTime();\n    if (this.certificateExpiry &&\n        (nowTime = now + maxExpiry) {\n      throw new Error(\n          'Expiration time too far in future: ' + JSON.stringify(payload));\n    }\n\n    const earliest = iat - OAuth2Client.CLOCK_SKEW_SECS_;\n    const latest = exp + OAuth2Client.CLOCK_SKEW_SECS_;\n\n    if (now  latest) {\n      throw new Error(\n          'Token used too late, ' + now + ' > ' + latest + ': ' +\n          JSON.stringify(payload));\n    }\n\n    if (issuers && issuers.indexOf(payload.iss)  -1);\n      } else {\n        audVerified = (aud === requiredAudience);\n      }\n      if (!audVerified) {\n        throw new Error(\n            'Wrong recipient, payload audience != requiredAudience');\n      }\n    }\n    return new LoginTicket(envelope, payload);\n  }\n\n  /**\n   * This is a utils method to decode a base64 string\n   * @param b64String The string to base64 decode\n   * @return The decoded string\n   */\n  decodeBase64(b64String: string) {\n    const buffer = Buffer.from(b64String, 'base64');\n    return buffer.toString('utf8');\n  }\n\n  /**\n   * Returns true if a token is expired or will expire within\n   * eagerRefreshThresholdMillismilliseconds.\n   * If there is no expiry time, assumes the token is not expired or expiring.\n   */\n  protected isTokenExpiring(): boolean {\n    const expiryDate = this.credentials.expiry_date;\n    return expiryDate ? expiryDate \n    \n\n\n\n\n\n\n\n                   \n    \n         result-matching \"\"\n        \n    \n    \n        No results matching \"\"\n    \n\n"},"interfaces/RefreshAccessTokenResponse.html":{"url":"interfaces/RefreshAccessTokenResponse.html","title":"interface - RefreshAccessTokenResponse","body":"\n                   \n\n\n\n\n\n\n\n\n\n\n\n\n\n  Interfaces\n  RefreshAccessTokenResponse\n\n\n\n        \n            Info\n        \n        \n            Source\n        \n\n\n\n    \n        \n            File\n        \n        \n            src/auth/oauth2client.ts\n        \n\n\n\n        \n            Index\n            \n                \n                    \n                        \n                            Properties\n                        \n                    \n                    \n                        \n                            \n                                \n                                        credentials\n                                \n                                \n                                        res\n                                \n                            \n                        \n                    \n                \n            \n        \n\n\n\n            \n                Properties\n                    \n                        \n                                \n                                    \n                                        \n                                        credentials\n                                    \n                                \n                                \n                                    \n                                        credentials:     Credentials\n\n                                    \n                                \n\n\n                                    \n                                        \n                                            Type :     Credentials\n\n                                        \n                                    \n\n\n\n\n\n                        \n                    \n                    \n                        \n                                \n                                    \n                                        \n                                        res\n                                    \n                                \n                                \n                                    \n                                        res:     AxiosResponse | null\n\n                                    \n                                \n\n\n                                    \n                                        \n                                            Type :     AxiosResponse | null\n\n                                        \n                                    \n\n\n\n\n\n                        \n                    \n            \n    \n\n\n    \n        import {AxiosError, AxiosPromise, AxiosRequestConfig, AxiosResponse} from 'axios';\nimport * as crypto from 'crypto';\nimport * as querystring from 'querystring';\nimport * as stream from 'stream';\nimport * as messages from '../messages';\nimport {PemVerifier} from './../pemverifier';\nimport {BodyResponseCallback} from './../transporters';\nimport {AuthClient} from './authclient';\nimport {CredentialRequest, Credentials} from './credentials';\nimport {LoginTicket, TokenPayload} from './loginticket';\n\nexport type Certificates = {\n  [index: string]: string\n};\n\nexport type Headers = {\n  [index: string]: string\n};\n\nexport enum CodeChallengeMethod {\n  Plain = 'plain',\n  S256 = 'S256'\n}\n\nexport interface GetTokenOptions {\n  code: string;\n  codeVerifier?: string;\n  /**\n   * The client ID for your application. The value passed into the constructor\n   * will be used if not provided. Must match any client_id option passed to\n   * a corresponding call to generateAuthUrl.\n   */\n  client_id?: string;\n  /**\n   * Determines where the API server redirects the user after the user\n   * completes the authorization flow. The value passed into the constructor\n   * will be used if not provided. Must match any redirect_uri option passed to\n   * a corresponding call to generateAuthUrl.\n   */\n  redirect_uri?: string;\n}\n\nexport interface TokenInfo {\n  /**\n   * The application that is the intended user of the access token.\n   */\n  aud: string;\n\n  /**\n   * This value lets you correlate profile information from multiple Google\n   * APIs. It is only present in the response if you included the profile scope\n   * in your request in step 1. The field value is an immutable identifier for\n   * the logged-in user that can be used to create and manage user sessions in\n   * your application. The identifier is the same regardless of which client ID\n   * is used to retrieve it. This enables multiple applications in the same\n   * organization to correlate profile information.\n   */\n  user_id?: string;\n\n  /**\n   * An array of scopes that the user granted access to.\n   */\n  scopes: string[];\n\n  /**\n   * The datetime when the token becomes invalid.\n   */\n  expiry_date: number;\n\n  /**\n   * An identifier for the user, unique among all Google accounts and never\n   * reused. A Google account can have multiple emails at different points in\n   * time, but the sub value is never changed. Use sub within your application\n   * as the unique-identifier key for the user.\n   */\n  sub?: string;\n\n  /**\n   * The client_id of the authorized presenter. This claim is only needed when\n   * the party requesting the ID token is not the same as the audience of the ID\n   * token. This may be the case at Google for hybrid apps where a web\n   * application and Android app have a different client_id but share the same\n   * project.\n   */\n  azp?: string;\n\n  /**\n   * Indicates whether your application can refresh access tokens\n   * when the user is not present at the browser. Valid parameter values are\n   * 'online', which is the default value, and 'offline'. Set the value to\n   * 'offline' if your application needs to refresh access tokens when the user\n   * is not present at the browser. This value instructs the Google\n   * authorization server to return a refresh token and an access token the\n   * first time that your application exchanges an authorization code for\n   * tokens.\n   */\n  access_type?: string;\n}\n\ninterface TokenInfoRequest {\n  aud: string;\n  user_id?: string;\n  scope: string;\n  expires_in: number;\n  azp?: string;\n  sub?: string;\n  exp?: number;\n  access_type?: string;\n}\n\nexport interface GenerateAuthUrlOpts {\n  /**\n   * Recommended. Indicates whether your application can refresh access tokens\n   * when the user is not present at the browser. Valid parameter values are\n   * 'online', which is the default value, and 'offline'. Set the value to\n   * 'offline' if your application needs to refresh access tokens when the user\n   * is not present at the browser. This value instructs the Google\n   * authorization server to return a refresh token and an access token the\n   * first time that your application exchanges an authorization code for\n   * tokens.\n   */\n  access_type?: string;\n\n  /**\n   * The hd (hosted domain) parameter streamlines the login process for G Suite\n   * hosted accounts. By including the domain of the G Suite user (for example,\n   * mycollege.edu), you can indicate that the account selection UI should be\n   * optimized for accounts at that domain. To optimize for G Suite accounts\n   * generally instead of just one domain, use an asterisk: hd=*.\n   * Don't rely on this UI optimization to control who can access your app,\n   * as client-side requests can be modified. Be sure to validate that the\n   * returned ID token has an hd claim value that matches what you expect\n   * (e.g. mycolledge.edu). Unlike the request parameter, the ID token claim is\n   * contained within a security token from Google, so the value can be trusted.\n   */\n  hd?: string;\n\n  /**\n   * The 'response_type' will always be set to 'CODE'.\n   */\n  response_type?: string;\n\n  /**\n   * The client ID for your application. The value passed into the constructor\n   * will be used if not provided. You can find this value in the API Console.\n   */\n  client_id?: string;\n\n  /**\n   * Determines where the API server redirects the user after the user\n   * completes the authorization flow. The value must exactly match one of the\n   * 'redirect_uri' values listed for your project in the API Console. Note that\n   * the http or https scheme, case, and trailing slash ('/') must all match.\n   * The value passed into the constructor will be used if not provided.\n   */\n  redirect_uri?: string;\n\n  /**\n   * Required. A space-delimited list of scopes that identify the resources that\n   * your application could access on the user's behalf. These values inform the\n   * consent screen that Google displays to the user. Scopes enable your\n   * application to only request access to the resources that it needs while\n   * also enabling users to control the amount of access that they grant to your\n   * application. Thus, there is an inverse relationship between the number of\n   * scopes requested and the likelihood of obtaining user consent. The\n   * OAuth 2.0 API Scopes document provides a full list of scopes that you might\n   * use to access Google APIs. We recommend that your application request\n   * access to authorization scopes in context whenever possible. By requesting\n   * access to user data in context, via incremental authorization, you help\n   * users to more easily understand why your application needs the access it is\n   * requesting.\n   */\n  scope?: string[]|string;\n\n  /**\n   * Recommended. Specifies any string value that your application uses to\n   * maintain state between your authorization request and the authorization\n   * server's response. The server returns the exact value that you send as a\n   * name=value pair in the hash (#) fragment of the 'redirect_uri' after the\n   * user consents to or denies your application's access request. You can use\n   * this parameter for several purposes, such as directing the user to the\n   * correct resource in your application, sending nonces, and mitigating\n   * cross-site request forgery. Since your redirect_uri can be guessed, using a\n   * state value can increase your assurance that an incoming connection is the\n   * result of an authentication request. If you generate a random string or\n   * encode the hash of a cookie or another value that captures the client's\n   * state, you can validate the response to additionally ensure that the\n   * request and response originated in the same browser, providing protection\n   * against attacks such as cross-site request forgery. See the OpenID Connect\n   * documentation for an example of how to create and confirm a state token.\n   */\n  state?: string;\n\n  /**\n   * Optional. Enables applications to use incremental authorization to request\n   * access to additional scopes in context. If you set this parameter's value\n   * to true and the authorization request is granted, then the new access token\n   * will also cover any scopes to which the user previously granted the\n   * application access. See the incremental authorization section for examples.\n   */\n  include_granted_scopes?: boolean;\n\n  /**\n   * Optional. If your application knows which user is trying to authenticate,\n   * it can use this parameter to provide a hint to the Google Authentication\n   * Server. The server uses the hint to simplify the login flow either by\n   * prefilling the email field in the sign-in form or by selecting the\n   * appropriate multi-login session. Set the parameter value to an email\n   * address or sub identifier, which is equivalent to the user's Google ID.\n   */\n  login_hint?: string;\n\n  /**\n   * Optional. A space-delimited, case-sensitive list of prompts to present the\n   * user. If you don't specify this parameter, the user will be prompted only\n   * the first time your app requests access.  Possible values are:\n   *\n   * 'none' - Donot display any authentication or consent screens. Must not be\n   *        specified with other values.\n   * 'consent' - \tPrompt the user for consent.\n   * 'select_account' - Prompt the user to select an account.\n   */\n  prompt?: string;\n\n  /**\n   * Recommended. Specifies what method was used to encode a 'code_verifier'\n   * that will be used during authorization code exchange. This parameter must\n   * be used with the 'code_challenge' parameter. The value of the\n   * 'code_challenge_method' defaults to \"plain\" if not present in the request\n   * that includes a 'code_challenge'. The only supported values for this\n   * parameter are \"S256\" or \"plain\".\n   */\n  code_challenge_method?: CodeChallengeMethod;\n\n  /**\n   * Recommended. Specifies an encoded 'code_verifier' that will be used as a\n   * server-side challenge during authorization code exchange. This parameter\n   * must be used with the 'code_challenge' parameter described above.\n   */\n  code_challenge?: string;\n}\n\nexport interface GetTokenCallback {\n  (err: AxiosError|null, token?: Credentials|null,\n   res?: AxiosResponse|null): void;\n}\n\nexport interface GetTokenResponse {\n  tokens: Credentials;\n  res: AxiosResponse|null;\n}\n\nexport interface GetAccessTokenCallback {\n  (err: AxiosError|null, token?: string|null, res?: AxiosResponse|null): void;\n}\n\nexport interface GetAccessTokenResponse {\n  token?: string|null;\n  res?: AxiosResponse|null;\n}\n\nexport interface RefreshAccessTokenCallback {\n  (err: AxiosError|null, credentials?: Credentials|null,\n   res?: AxiosResponse|null): void;\n}\n\nexport interface RefreshAccessTokenResponse {\n  credentials: Credentials;\n  res: AxiosResponse|null;\n}\n\nexport interface RequestMetadataResponse {\n  headers: Headers;\n  res?: AxiosResponse|null;\n}\n\nexport interface RequestMetadataCallback {\n  (err: AxiosError|null, headers?: Headers,\n   res?: AxiosResponse|null): void;\n}\n\nexport interface GetFederatedSignonCertsCallback {\n  (err: AxiosError|null, certs?: Certificates,\n   response?: AxiosResponse|null): void;\n}\n\nexport interface FederatedSignonCertsResponse {\n  certs: Certificates;\n  res?: AxiosResponse|null;\n}\n\nexport interface RevokeCredentialsResult {\n  success: boolean;\n}\n\nexport interface VerifyIdTokenOptions {\n  idToken: string;\n  audience: string|string[];\n  maxExpiry?: number;\n}\n\nexport interface OAuth2ClientOptions extends RefreshOptions {\n  clientId?: string;\n  clientSecret?: string;\n  redirectUri?: string;\n}\n\nexport interface RefreshOptions {\n  // Eagerly refresh unexpired tokens when they are within this many\n  // milliseconds from expiring\".\n  // Defaults to a value of 300000 (5 minutes).\n  eagerRefreshThresholdMillis?: number;\n}\n\nexport class OAuth2Client extends AuthClient {\n  private redirectUri?: string;\n  private certificateCache?: Certificates;\n  private certificateExpiry: Date|null = null;\n  protected refreshTokenPromises = new Map>();\n\n  // TODO: refactor tests to make this private\n  _clientId?: string;\n\n  // TODO: refactor tests to make this private\n  _clientSecret?: string;\n\n  apiKey?: string;\n\n  projectId?: string;\n\n  eagerRefreshThresholdMillis: number;\n\n  /**\n   * Handles OAuth2 flow for Google APIs.\n   *\n   * @param clientId The authentication client ID.\n   * @param clientSecret The authentication client secret.\n   * @param redirectUri The URI to redirect to after completing the auth\n   * request.\n   * @param opts optional options for overriding the given parameters.\n   * @constructor\n   */\n  constructor(options?: OAuth2ClientOptions);\n  constructor(clientId?: string, clientSecret?: string, redirectUri?: string);\n  constructor(\n      optionsOrClientId?: string|OAuth2ClientOptions, clientSecret?: string,\n      redirectUri?: string) {\n    super();\n    const opts = (optionsOrClientId && typeof optionsOrClientId === 'object') ?\n        optionsOrClientId :\n        {clientId: optionsOrClientId, clientSecret, redirectUri};\n    this._clientId = opts.clientId;\n    this._clientSecret = opts.clientSecret;\n    this.redirectUri = opts.redirectUri;\n    this.eagerRefreshThresholdMillis =\n        opts.eagerRefreshThresholdMillis || 5 * 60 * 1000;\n  }\n\n  protected static readonly GOOGLE_TOKEN_INFO_URL =\n      'https://oauth2.googleapis.com/tokeninfo';\n\n  /**\n   * The base URL for auth endpoints.\n   */\n  private static readonly GOOGLE_OAUTH2_AUTH_BASE_URL_ =\n      'https://accounts.google.com/o/oauth2/v2/auth';\n\n  /**\n   * The base endpoint for token retrieval.\n   */\n  private static readonly GOOGLE_OAUTH2_TOKEN_URL_ =\n      'https://oauth2.googleapis.com/token';\n\n  /**\n   * The base endpoint to revoke tokens.\n   */\n  private static readonly GOOGLE_OAUTH2_REVOKE_URL_ =\n      'https://oauth2.googleapis.com/revoke';\n\n  /**\n   * Google Sign on certificates.\n   */\n  private static readonly GOOGLE_OAUTH2_FEDERATED_SIGNON_CERTS_URL_ =\n      'https://www.googleapis.com/oauth2/v1/certs';\n\n  /**\n   * Clock skew - five minutes in seconds\n   */\n  private static readonly CLOCK_SKEW_SECS_ = 300;\n\n  /**\n   * Max Token Lifetime is one day in seconds\n   */\n  private static readonly MAX_TOKEN_LIFETIME_SECS_ = 86400;\n\n  /**\n   * The allowed oauth token issuers.\n   */\n  private static readonly ISSUERS_ =\n      ['accounts.google.com', 'https://accounts.google.com'];\n\n  /**\n   * Generates URL for consent page landing.\n   * @param opts Options.\n   * @return URL to consent page.\n   */\n  generateAuthUrl(opts: GenerateAuthUrlOpts = {}) {\n    if (opts.code_challenge_method && !opts.code_challenge) {\n      throw new Error(\n          'If a code_challenge_method is provided, code_challenge must be included.');\n    }\n    opts.response_type = opts.response_type || 'code';\n    opts.client_id = opts.client_id || this._clientId;\n    opts.redirect_uri = opts.redirect_uri || this.redirectUri;\n    // Allow scopes to be passed either as array or a string\n    if (opts.scope instanceof Array) {\n      opts.scope = opts.scope.join(' ');\n    }\n    const rootUrl = OAuth2Client.GOOGLE_OAUTH2_AUTH_BASE_URL_;\n    return rootUrl + '?' + querystring.stringify(opts);\n  }\n\n  /**\n   * Convenience method to automatically generate a code_verifier, and it's\n   * resulting SHA256. If used, this must be paired with a S256\n   * code_challenge_method.\n   */\n  generateCodeVerifier() {\n    // base64 encoding uses 6 bits per character, and we want to generate128\n    // characters. 6*128/8 = 96.\n    const randomString = crypto.randomBytes(96).toString('base64');\n    // The valid characters in the code_verifier are [A-Z]/[a-z]/[0-9]/\n    // \"-\"/\".\"/\"_\"/\"~\". Base64 encoded strings are pretty close, so we're just\n    // swapping out a few chars.\n    const codeVerifier =\n        randomString.replace(/\\+/g, '~').replace(/=/g, '_').replace(/\\//g, '-');\n    // Generate the base64 encoded SHA256\n    const unencodedCodeChallenge =\n        crypto.createHash('sha256').update(codeVerifier).digest('base64');\n    // We need to use base64UrlEncoding instead of standard base64\n    const codeChallenge = unencodedCodeChallenge.split('=')[0]\n                              .replace(/\\+/g, '-')\n                              .replace(/\\//g, '_');\n    return {codeVerifier, codeChallenge};\n  }\n\n  /**\n   * Gets the access token for the given code.\n   * @param code The authorization code.\n   * @param callback Optional callback fn.\n   */\n  getToken(code: string): Promise;\n  getToken(options: GetTokenOptions): Promise;\n  getToken(code: string, callback: GetTokenCallback): void;\n  getToken(options: GetTokenOptions, callback: GetTokenCallback): void;\n  getToken(codeOrOptions: string|GetTokenOptions, callback?: GetTokenCallback):\n      Promise|void {\n    const options = (typeof codeOrOptions === 'string') ?\n        {code: codeOrOptions} :\n        codeOrOptions;\n    if (callback) {\n      this.getTokenAsync(options).then(\n          r => callback(null, r.tokens, r.res),\n          e => callback(e, null, e.response));\n    } else {\n      return this.getTokenAsync(options);\n    }\n  }\n\n  private async getTokenAsync(options: GetTokenOptions):\n      Promise {\n    const url = OAuth2Client.GOOGLE_OAUTH2_TOKEN_URL_;\n    const values = {\n      code: options.code,\n      client_id: options.client_id || this._clientId,\n      client_secret: this._clientSecret,\n      redirect_uri: options.redirect_uri || this.redirectUri,\n      grant_type: 'authorization_code',\n      code_verifier: options.codeVerifier\n    };\n    const res = await this.transporter.request({\n      method: 'POST',\n      url,\n      data: querystring.stringify(values),\n      headers: {'Content-Type': 'application/x-www-form-urlencoded'}\n    });\n    const tokens = res.data as Credentials;\n    if (res.data && res.data.expires_in) {\n      tokens.expiry_date =\n          ((new Date()).getTime() + (res.data.expires_in * 1000));\n      delete (tokens as CredentialRequest).expires_in;\n    }\n    this.emit('tokens', tokens);\n    return {tokens, res};\n  }\n\n  /**\n   * Refreshes the access token.\n   * @param refresh_token Existing refresh token.\n   * @private\n   */\n  protected async refreshToken(refreshToken?: string|\n                               null): Promise {\n    if (!refreshToken) {\n      return this.refreshTokenNoCache(refreshToken);\n    }\n    // If a request to refresh using the same token has started,\n    // return the same promise.\n    if (this.refreshTokenPromises.has(refreshToken)) {\n      return this.refreshTokenPromises.get(refreshToken)!;\n    }\n\n    const p = this.refreshTokenNoCache(refreshToken)\n                  .then(\n                      r => {\n                        this.refreshTokenPromises.delete(refreshToken);\n                        return r;\n                      },\n                      e => {\n                        this.refreshTokenPromises.delete(refreshToken);\n                        throw e;\n                      });\n    this.refreshTokenPromises.set(refreshToken, p);\n    return p;\n  }\n\n  protected async refreshTokenNoCache(refreshToken?: string|\n                                      null): Promise {\n    const url = OAuth2Client.GOOGLE_OAUTH2_TOKEN_URL_;\n    const data = {\n      refresh_token: refreshToken,\n      client_id: this._clientId,\n      client_secret: this._clientSecret,\n      grant_type: 'refresh_token'\n    };\n\n    // request for new token\n    const res = await this.transporter.request({\n      method: 'POST',\n      url,\n      data: querystring.stringify(data),\n      headers: {'Content-Type': 'application/x-www-form-urlencoded'}\n    });\n\n    const tokens = res.data as Credentials;\n    // TODO: de-duplicate this code from a few spots\n    if (res.data && res.data.expires_in) {\n      tokens.expiry_date =\n          ((new Date()).getTime() + (res.data.expires_in * 1000));\n      delete (tokens as CredentialRequest).expires_in;\n    }\n    this.emit('tokens', tokens);\n    return {tokens, res};\n  }\n\n  /**\n   * Retrieves the access token using refresh token\n   *\n   * @deprecated use getRequestHeaders instead.\n   * @param callback callback\n   */\n  refreshAccessToken(): Promise;\n  refreshAccessToken(callback: RefreshAccessTokenCallback): void;\n  refreshAccessToken(callback?: RefreshAccessTokenCallback):\n      Promise|void {\n    messages.warn(messages.REFRESH_ACCESS_TOKEN_DEPRECATED);\n    if (callback) {\n      this.refreshAccessTokenAsync().then(\n          r => callback(null, r.credentials, r.res), callback);\n    } else {\n      return this.refreshAccessTokenAsync();\n    }\n  }\n\n  private async refreshAccessTokenAsync() {\n    if (!this.credentials.refresh_token) {\n      throw new Error('No refresh token is set.');\n    }\n    const r = await this.refreshToken(this.credentials.refresh_token);\n    const tokens = r.tokens as Credentials;\n    tokens.refresh_token = this.credentials.refresh_token;\n    this.credentials = tokens;\n    return {credentials: this.credentials, res: r.res};\n  }\n\n  /**\n   * Get a non-expired access token, after refreshing if necessary\n   *\n   * @param callback Callback to call with the access token\n   */\n  getAccessToken(): Promise;\n  getAccessToken(callback: GetAccessTokenCallback): void;\n  getAccessToken(callback?: GetAccessTokenCallback):\n      Promise|void {\n    if (callback) {\n      this.getAccessTokenAsync().then(\n          r => callback(null, r.token, r.res), callback);\n    } else {\n      return this.getAccessTokenAsync();\n    }\n  }\n\n  private async getAccessTokenAsync(): Promise {\n    const shouldRefresh =\n        !this.credentials.access_token || this.isTokenExpiring();\n    if (shouldRefresh && this.credentials.refresh_token) {\n      if (!this.credentials.refresh_token) {\n        throw new Error('No refresh token is set.');\n      }\n\n      const r = await this.refreshAccessTokenAsync();\n      if (!r.credentials || (r.credentials && !r.credentials.access_token)) {\n        throw new Error('Could not refresh access token.');\n      }\n      return {token: r.credentials.access_token, res: r.res};\n    } else {\n      return {token: this.credentials.access_token};\n    }\n  }\n\n  /**\n   * Obtain the set of headers required to authenticate a request.\n   *\n   * @deprecated Use getRequestHeaders instead.\n   * @param url the Uri being authorized\n   * @param callback the func described above\n   */\n  getRequestMetadata(url?: string|null): Promise;\n  getRequestMetadata(url: string|null, callback: RequestMetadataCallback): void;\n  getRequestMetadata(url: string|null, callback?: RequestMetadataCallback):\n      Promise|void {\n    messages.warn(messages.OAUTH_GET_REQUEST_METADATA_DEPRECATED);\n    if (callback) {\n      this.getRequestMetadataAsync(url).then(\n          r => callback(null, r.headers, r.res), callback);\n    } else {\n      return this.getRequestMetadataAsync();\n    }\n  }\n\n  /**\n   * The main authentication interface.  It takes an optional url which when\n   * present is the endpoint being accessed, and returns a Promise which\n   * resolves with authorization header fields.\n   *\n   * In OAuth2Client, the result has the form:\n   * { Authorization: 'Bearer ' }\n   * @param url The optional url being authorized\n   */\n  async getRequestHeaders(url?: string): Promise {\n    const res = await this.getRequestMetadataAsync(url);\n    return res.headers;\n  }\n\n  protected async getRequestMetadataAsync(url?: string|null):\n      Promise {\n    const thisCreds = this.credentials;\n    if (!thisCreds.access_token && !thisCreds.refresh_token && !this.apiKey) {\n      throw new Error('No access, refresh token or API key is set.');\n    }\n\n    if (thisCreds.access_token && !this.isTokenExpiring()) {\n      thisCreds.token_type = thisCreds.token_type || 'Bearer';\n      const headers = {\n        Authorization: thisCreds.token_type + ' ' + thisCreds.access_token\n      };\n      return {headers};\n    }\n\n    if (this.apiKey) {\n      return {headers: {}};\n    }\n    let r: GetTokenResponse|null = null;\n    let tokens: Credentials|null = null;\n    try {\n      r = await this.refreshToken(thisCreds.refresh_token);\n      tokens = r.tokens;\n    } catch (err) {\n      const e = err as AxiosError;\n      if (e.response &&\n          (e.response.status === 403 || e.response.status === 404)) {\n        e.message = 'Could not refresh access token.';\n      }\n      throw e;\n    }\n\n    const credentials = this.credentials;\n    credentials.token_type = credentials.token_type || 'Bearer';\n    tokens.refresh_token = credentials.refresh_token;\n    this.credentials = tokens;\n    const headers = {\n      Authorization: credentials.token_type + ' ' + tokens.access_token\n    };\n    return {headers, res: r.res};\n  }\n\n  /**\n   * Revokes the access given to token.\n   * @param token The existing token to be revoked.\n   * @param callback Optional callback fn.\n   */\n  revokeToken(token: string): AxiosPromise;\n  revokeToken(\n      token: string,\n      callback: BodyResponseCallback): void;\n  revokeToken(\n      token: string, callback?: BodyResponseCallback):\n      AxiosPromise|void {\n    const opts = {\n      url: OAuth2Client.GOOGLE_OAUTH2_REVOKE_URL_ + '?' +\n          querystring.stringify({token}),\n      method: 'POST'\n    };\n    if (callback) {\n      this.transporter.request(opts).then(\n          r => callback(null, r), callback);\n    } else {\n      return this.transporter.request(opts);\n    }\n  }\n\n\n  /**\n   * Revokes access token and clears the credentials object\n   * @param callback callback\n   */\n  revokeCredentials(): AxiosPromise;\n  revokeCredentials(callback: BodyResponseCallback):\n      void;\n  revokeCredentials(callback?: BodyResponseCallback):\n      AxiosPromise|void {\n    if (callback) {\n      this.revokeCredentialsAsync().then(res => callback(null, res), callback);\n    } else {\n      return this.revokeCredentialsAsync();\n    }\n  }\n\n  private async revokeCredentialsAsync() {\n    const token = this.credentials.access_token;\n    this.credentials = {};\n    if (token) {\n      return this.revokeToken(token);\n    } else {\n      throw new Error('No access token to revoke.');\n    }\n  }\n\n  /**\n   * Provides a request implementation with OAuth 2.0 flow. If credentials have\n   * a refresh_token, in cases of HTTP 401 and 403 responses, it automatically\n   * asks for a new access token and replays the unsuccessful request.\n   * @param opts Request options.\n   * @param callback callback.\n   * @return Request object\n   */\n  request(opts: AxiosRequestConfig): AxiosPromise;\n  request(opts: AxiosRequestConfig, callback: BodyResponseCallback): void;\n  request(opts: AxiosRequestConfig, callback?: BodyResponseCallback):\n      AxiosPromise|void {\n    if (callback) {\n      this.requestAsync(opts).then(r => callback(null, r), e => {\n        return callback(e, e.response);\n      });\n    } else {\n      return this.requestAsync(opts);\n    }\n  }\n\n  protected async requestAsync(opts: AxiosRequestConfig, retry = false):\n      Promise> {\n    let r2: AxiosResponse;\n    try {\n      const r = await this.getRequestMetadataAsync(opts.url);\n      if (r.headers && r.headers.Authorization) {\n        opts.headers = opts.headers || {};\n        opts.headers.Authorization = r.headers.Authorization;\n      }\n\n      if (this.apiKey) {\n        opts.params = Object.assign(opts.params || {}, {key: this.apiKey});\n      }\n      r2 = await this.transporter.request(opts);\n    } catch (e) {\n      const res = (e as AxiosError).response;\n      if (res) {\n        const statusCode = res.status;\n        // Retry the request for metadata if the following criteria are true:\n        // - We haven't already retried.  It only makes sense to retry once.\n        // - The response was a 401 or a 403\n        // - The request didn't send a readableStream\n        // - An access_token and refresh_token were available, but no\n        //   expiry_date was availabe. This can happen when developers stash\n        //   the access_token and refresh_token for later use, but the\n        //   access_token fails on the first try because it's expired.\n        const mayRequireRefresh = this.credentials &&\n            this.credentials.access_token && this.credentials.refresh_token &&\n            !this.credentials.expiry_date;\n        const isReadableStream = res.config.data instanceof stream.Readable;\n        const isAuthErr = statusCode === 401 || statusCode === 403;\n        if (!retry && isAuthErr && !isReadableStream && mayRequireRefresh) {\n          await this.refreshAccessTokenAsync();\n          return this.requestAsync(opts, true);\n        }\n      }\n      throw e;\n    }\n    return r2;\n  }\n\n  /**\n   * Verify id token is token by checking the certs and audience\n   * @param options that contains all options.\n   * @param callback Callback supplying GoogleLogin if successful\n   */\n  verifyIdToken(options: VerifyIdTokenOptions): Promise;\n  verifyIdToken(\n      options: VerifyIdTokenOptions,\n      callback: (err: Error|null, login?: LoginTicket) => void): void;\n  verifyIdToken(\n      options: VerifyIdTokenOptions,\n      callback?: (err: Error|null, login?: LoginTicket) => void):\n      void|Promise {\n    // This function used to accept two arguments instead of an options object.\n    // Check the types to help users upgrade with less pain.\n    // This check can be removed after a 2.0 release.\n    if (callback && typeof callback !== 'function') {\n      throw new Error(\n          'This method accepts an options object as the first parameter, which includes the idToken, audience, and maxExpiry.');\n    }\n\n    if (callback) {\n      this.verifyIdTokenAsync(options).then(r => callback(null, r), callback);\n    } else {\n      return this.verifyIdTokenAsync(options);\n    }\n  }\n\n  private async verifyIdTokenAsync(options: VerifyIdTokenOptions):\n      Promise {\n    if (!options.idToken) {\n      throw new Error('The verifyIdToken method requires an ID Token');\n    }\n\n    const response = await this.getFederatedSignonCertsAsync();\n    const login = this.verifySignedJwtWithCerts(\n        options.idToken, response.certs, options.audience,\n        OAuth2Client.ISSUERS_, options.maxExpiry);\n\n    return login;\n  }\n\n  /**\n   * Obtains information about the provisioned access token.  Especially useful\n   * if you want to check the scopes that were provisioned to a given token.\n   *\n   * @param accessToken Required.  The Access Token for which you want to get\n   * user info.\n   */\n  async getTokenInfo(accessToken: string): Promise {\n    const {data} = await this.transporter.request({\n      method: 'GET',\n      url: OAuth2Client.GOOGLE_TOKEN_INFO_URL,\n      params: {access_token: accessToken}\n    });\n    const info = Object.assign(\n        {\n          expiry_date: ((new Date()).getTime() + (data.expires_in * 1000)),\n          scopes: data.scope.split(' ')\n        },\n        data);\n    delete info.expires_in;\n    delete info.scope;\n    return info;\n  }\n\n  /**\n   * Gets federated sign-on certificates to use for verifying identity tokens.\n   * Returns certs as array structure, where keys are key ids, and values\n   * are PEM encoded certificates.\n   * @param callback Callback supplying the certificates\n   */\n  getFederatedSignonCerts(): Promise;\n  getFederatedSignonCerts(callback: GetFederatedSignonCertsCallback): void;\n  getFederatedSignonCerts(callback?: GetFederatedSignonCertsCallback):\n      Promise|void {\n    if (callback) {\n      this.getFederatedSignonCertsAsync().then(\n          r => callback(null, r.certs, r.res), callback);\n    } else {\n      return this.getFederatedSignonCertsAsync();\n    }\n  }\n\n  async getFederatedSignonCertsAsync(): Promise {\n    const nowTime = (new Date()).getTime();\n    if (this.certificateExpiry &&\n        (nowTime = now + maxExpiry) {\n      throw new Error(\n          'Expiration time too far in future: ' + JSON.stringify(payload));\n    }\n\n    const earliest = iat - OAuth2Client.CLOCK_SKEW_SECS_;\n    const latest = exp + OAuth2Client.CLOCK_SKEW_SECS_;\n\n    if (now  latest) {\n      throw new Error(\n          'Token used too late, ' + now + ' > ' + latest + ': ' +\n          JSON.stringify(payload));\n    }\n\n    if (issuers && issuers.indexOf(payload.iss)  -1);\n      } else {\n        audVerified = (aud === requiredAudience);\n      }\n      if (!audVerified) {\n        throw new Error(\n            'Wrong recipient, payload audience != requiredAudience');\n      }\n    }\n    return new LoginTicket(envelope, payload);\n  }\n\n  /**\n   * This is a utils method to decode a base64 string\n   * @param b64String The string to base64 decode\n   * @return The decoded string\n   */\n  decodeBase64(b64String: string) {\n    const buffer = Buffer.from(b64String, 'base64');\n    return buffer.toString('utf8');\n  }\n\n  /**\n   * Returns true if a token is expired or will expire within\n   * eagerRefreshThresholdMillismilliseconds.\n   * If there is no expiry time, assumes the token is not expired or expiring.\n   */\n  protected isTokenExpiring(): boolean {\n    const expiryDate = this.credentials.expiry_date;\n    return expiryDate ? expiryDate \n    \n\n\n\n\n\n\n\n                   \n    \n         result-matching \"\"\n        \n    \n    \n        No results matching \"\"\n    \n\n"},"interfaces/RefreshOptions.html":{"url":"interfaces/RefreshOptions.html","title":"interface - RefreshOptions","body":"\n                   \n\n\n\n\n\n\n\n\n\n\n\n\n\n  Interfaces\n  RefreshOptions\n\n\n\n        \n            Info\n        \n        \n            Source\n        \n\n\n\n    \n        \n            File\n        \n        \n            src/auth/oauth2client.ts\n        \n\n\n\n        \n            Index\n            \n                \n                    \n                        \n                            Properties\n                        \n                    \n                    \n                        \n                            \n                                \n                                            Optional\n                                        eagerRefreshThresholdMillis\n                                \n                            \n                        \n                    \n                \n            \n        \n\n\n\n            \n                Properties\n                    \n                        \n                                \n                                    \n                                        \n                                        eagerRefreshThresholdMillis\n                                    \n                                \n                                \n                                    \n                                        eagerRefreshThresholdMillis:     number\n\n                                    \n                                \n\n\n                                    \n                                        \n                                            Type :     number\n\n                                        \n                                    \n\n                                    \n                                        \n                                            Optional\n                                        \n                                    \n\n\n\n\n                        \n                    \n            \n    \n\n\n    \n        import {AxiosError, AxiosPromise, AxiosRequestConfig, AxiosResponse} from 'axios';\nimport * as crypto from 'crypto';\nimport * as querystring from 'querystring';\nimport * as stream from 'stream';\nimport * as messages from '../messages';\nimport {PemVerifier} from './../pemverifier';\nimport {BodyResponseCallback} from './../transporters';\nimport {AuthClient} from './authclient';\nimport {CredentialRequest, Credentials} from './credentials';\nimport {LoginTicket, TokenPayload} from './loginticket';\n\nexport type Certificates = {\n  [index: string]: string\n};\n\nexport type Headers = {\n  [index: string]: string\n};\n\nexport enum CodeChallengeMethod {\n  Plain = 'plain',\n  S256 = 'S256'\n}\n\nexport interface GetTokenOptions {\n  code: string;\n  codeVerifier?: string;\n  /**\n   * The client ID for your application. The value passed into the constructor\n   * will be used if not provided. Must match any client_id option passed to\n   * a corresponding call to generateAuthUrl.\n   */\n  client_id?: string;\n  /**\n   * Determines where the API server redirects the user after the user\n   * completes the authorization flow. The value passed into the constructor\n   * will be used if not provided. Must match any redirect_uri option passed to\n   * a corresponding call to generateAuthUrl.\n   */\n  redirect_uri?: string;\n}\n\nexport interface TokenInfo {\n  /**\n   * The application that is the intended user of the access token.\n   */\n  aud: string;\n\n  /**\n   * This value lets you correlate profile information from multiple Google\n   * APIs. It is only present in the response if you included the profile scope\n   * in your request in step 1. The field value is an immutable identifier for\n   * the logged-in user that can be used to create and manage user sessions in\n   * your application. The identifier is the same regardless of which client ID\n   * is used to retrieve it. This enables multiple applications in the same\n   * organization to correlate profile information.\n   */\n  user_id?: string;\n\n  /**\n   * An array of scopes that the user granted access to.\n   */\n  scopes: string[];\n\n  /**\n   * The datetime when the token becomes invalid.\n   */\n  expiry_date: number;\n\n  /**\n   * An identifier for the user, unique among all Google accounts and never\n   * reused. A Google account can have multiple emails at different points in\n   * time, but the sub value is never changed. Use sub within your application\n   * as the unique-identifier key for the user.\n   */\n  sub?: string;\n\n  /**\n   * The client_id of the authorized presenter. This claim is only needed when\n   * the party requesting the ID token is not the same as the audience of the ID\n   * token. This may be the case at Google for hybrid apps where a web\n   * application and Android app have a different client_id but share the same\n   * project.\n   */\n  azp?: string;\n\n  /**\n   * Indicates whether your application can refresh access tokens\n   * when the user is not present at the browser. Valid parameter values are\n   * 'online', which is the default value, and 'offline'. Set the value to\n   * 'offline' if your application needs to refresh access tokens when the user\n   * is not present at the browser. This value instructs the Google\n   * authorization server to return a refresh token and an access token the\n   * first time that your application exchanges an authorization code for\n   * tokens.\n   */\n  access_type?: string;\n}\n\ninterface TokenInfoRequest {\n  aud: string;\n  user_id?: string;\n  scope: string;\n  expires_in: number;\n  azp?: string;\n  sub?: string;\n  exp?: number;\n  access_type?: string;\n}\n\nexport interface GenerateAuthUrlOpts {\n  /**\n   * Recommended. Indicates whether your application can refresh access tokens\n   * when the user is not present at the browser. Valid parameter values are\n   * 'online', which is the default value, and 'offline'. Set the value to\n   * 'offline' if your application needs to refresh access tokens when the user\n   * is not present at the browser. This value instructs the Google\n   * authorization server to return a refresh token and an access token the\n   * first time that your application exchanges an authorization code for\n   * tokens.\n   */\n  access_type?: string;\n\n  /**\n   * The hd (hosted domain) parameter streamlines the login process for G Suite\n   * hosted accounts. By including the domain of the G Suite user (for example,\n   * mycollege.edu), you can indicate that the account selection UI should be\n   * optimized for accounts at that domain. To optimize for G Suite accounts\n   * generally instead of just one domain, use an asterisk: hd=*.\n   * Don't rely on this UI optimization to control who can access your app,\n   * as client-side requests can be modified. Be sure to validate that the\n   * returned ID token has an hd claim value that matches what you expect\n   * (e.g. mycolledge.edu). Unlike the request parameter, the ID token claim is\n   * contained within a security token from Google, so the value can be trusted.\n   */\n  hd?: string;\n\n  /**\n   * The 'response_type' will always be set to 'CODE'.\n   */\n  response_type?: string;\n\n  /**\n   * The client ID for your application. The value passed into the constructor\n   * will be used if not provided. You can find this value in the API Console.\n   */\n  client_id?: string;\n\n  /**\n   * Determines where the API server redirects the user after the user\n   * completes the authorization flow. The value must exactly match one of the\n   * 'redirect_uri' values listed for your project in the API Console. Note that\n   * the http or https scheme, case, and trailing slash ('/') must all match.\n   * The value passed into the constructor will be used if not provided.\n   */\n  redirect_uri?: string;\n\n  /**\n   * Required. A space-delimited list of scopes that identify the resources that\n   * your application could access on the user's behalf. These values inform the\n   * consent screen that Google displays to the user. Scopes enable your\n   * application to only request access to the resources that it needs while\n   * also enabling users to control the amount of access that they grant to your\n   * application. Thus, there is an inverse relationship between the number of\n   * scopes requested and the likelihood of obtaining user consent. The\n   * OAuth 2.0 API Scopes document provides a full list of scopes that you might\n   * use to access Google APIs. We recommend that your application request\n   * access to authorization scopes in context whenever possible. By requesting\n   * access to user data in context, via incremental authorization, you help\n   * users to more easily understand why your application needs the access it is\n   * requesting.\n   */\n  scope?: string[]|string;\n\n  /**\n   * Recommended. Specifies any string value that your application uses to\n   * maintain state between your authorization request and the authorization\n   * server's response. The server returns the exact value that you send as a\n   * name=value pair in the hash (#) fragment of the 'redirect_uri' after the\n   * user consents to or denies your application's access request. You can use\n   * this parameter for several purposes, such as directing the user to the\n   * correct resource in your application, sending nonces, and mitigating\n   * cross-site request forgery. Since your redirect_uri can be guessed, using a\n   * state value can increase your assurance that an incoming connection is the\n   * result of an authentication request. If you generate a random string or\n   * encode the hash of a cookie or another value that captures the client's\n   * state, you can validate the response to additionally ensure that the\n   * request and response originated in the same browser, providing protection\n   * against attacks such as cross-site request forgery. See the OpenID Connect\n   * documentation for an example of how to create and confirm a state token.\n   */\n  state?: string;\n\n  /**\n   * Optional. Enables applications to use incremental authorization to request\n   * access to additional scopes in context. If you set this parameter's value\n   * to true and the authorization request is granted, then the new access token\n   * will also cover any scopes to which the user previously granted the\n   * application access. See the incremental authorization section for examples.\n   */\n  include_granted_scopes?: boolean;\n\n  /**\n   * Optional. If your application knows which user is trying to authenticate,\n   * it can use this parameter to provide a hint to the Google Authentication\n   * Server. The server uses the hint to simplify the login flow either by\n   * prefilling the email field in the sign-in form or by selecting the\n   * appropriate multi-login session. Set the parameter value to an email\n   * address or sub identifier, which is equivalent to the user's Google ID.\n   */\n  login_hint?: string;\n\n  /**\n   * Optional. A space-delimited, case-sensitive list of prompts to present the\n   * user. If you don't specify this parameter, the user will be prompted only\n   * the first time your app requests access.  Possible values are:\n   *\n   * 'none' - Donot display any authentication or consent screens. Must not be\n   *        specified with other values.\n   * 'consent' - \tPrompt the user for consent.\n   * 'select_account' - Prompt the user to select an account.\n   */\n  prompt?: string;\n\n  /**\n   * Recommended. Specifies what method was used to encode a 'code_verifier'\n   * that will be used during authorization code exchange. This parameter must\n   * be used with the 'code_challenge' parameter. The value of the\n   * 'code_challenge_method' defaults to \"plain\" if not present in the request\n   * that includes a 'code_challenge'. The only supported values for this\n   * parameter are \"S256\" or \"plain\".\n   */\n  code_challenge_method?: CodeChallengeMethod;\n\n  /**\n   * Recommended. Specifies an encoded 'code_verifier' that will be used as a\n   * server-side challenge during authorization code exchange. This parameter\n   * must be used with the 'code_challenge' parameter described above.\n   */\n  code_challenge?: string;\n}\n\nexport interface GetTokenCallback {\n  (err: AxiosError|null, token?: Credentials|null,\n   res?: AxiosResponse|null): void;\n}\n\nexport interface GetTokenResponse {\n  tokens: Credentials;\n  res: AxiosResponse|null;\n}\n\nexport interface GetAccessTokenCallback {\n  (err: AxiosError|null, token?: string|null, res?: AxiosResponse|null): void;\n}\n\nexport interface GetAccessTokenResponse {\n  token?: string|null;\n  res?: AxiosResponse|null;\n}\n\nexport interface RefreshAccessTokenCallback {\n  (err: AxiosError|null, credentials?: Credentials|null,\n   res?: AxiosResponse|null): void;\n}\n\nexport interface RefreshAccessTokenResponse {\n  credentials: Credentials;\n  res: AxiosResponse|null;\n}\n\nexport interface RequestMetadataResponse {\n  headers: Headers;\n  res?: AxiosResponse|null;\n}\n\nexport interface RequestMetadataCallback {\n  (err: AxiosError|null, headers?: Headers,\n   res?: AxiosResponse|null): void;\n}\n\nexport interface GetFederatedSignonCertsCallback {\n  (err: AxiosError|null, certs?: Certificates,\n   response?: AxiosResponse|null): void;\n}\n\nexport interface FederatedSignonCertsResponse {\n  certs: Certificates;\n  res?: AxiosResponse|null;\n}\n\nexport interface RevokeCredentialsResult {\n  success: boolean;\n}\n\nexport interface VerifyIdTokenOptions {\n  idToken: string;\n  audience: string|string[];\n  maxExpiry?: number;\n}\n\nexport interface OAuth2ClientOptions extends RefreshOptions {\n  clientId?: string;\n  clientSecret?: string;\n  redirectUri?: string;\n}\n\nexport interface RefreshOptions {\n  // Eagerly refresh unexpired tokens when they are within this many\n  // milliseconds from expiring\".\n  // Defaults to a value of 300000 (5 minutes).\n  eagerRefreshThresholdMillis?: number;\n}\n\nexport class OAuth2Client extends AuthClient {\n  private redirectUri?: string;\n  private certificateCache?: Certificates;\n  private certificateExpiry: Date|null = null;\n  protected refreshTokenPromises = new Map>();\n\n  // TODO: refactor tests to make this private\n  _clientId?: string;\n\n  // TODO: refactor tests to make this private\n  _clientSecret?: string;\n\n  apiKey?: string;\n\n  projectId?: string;\n\n  eagerRefreshThresholdMillis: number;\n\n  /**\n   * Handles OAuth2 flow for Google APIs.\n   *\n   * @param clientId The authentication client ID.\n   * @param clientSecret The authentication client secret.\n   * @param redirectUri The URI to redirect to after completing the auth\n   * request.\n   * @param opts optional options for overriding the given parameters.\n   * @constructor\n   */\n  constructor(options?: OAuth2ClientOptions);\n  constructor(clientId?: string, clientSecret?: string, redirectUri?: string);\n  constructor(\n      optionsOrClientId?: string|OAuth2ClientOptions, clientSecret?: string,\n      redirectUri?: string) {\n    super();\n    const opts = (optionsOrClientId && typeof optionsOrClientId === 'object') ?\n        optionsOrClientId :\n        {clientId: optionsOrClientId, clientSecret, redirectUri};\n    this._clientId = opts.clientId;\n    this._clientSecret = opts.clientSecret;\n    this.redirectUri = opts.redirectUri;\n    this.eagerRefreshThresholdMillis =\n        opts.eagerRefreshThresholdMillis || 5 * 60 * 1000;\n  }\n\n  protected static readonly GOOGLE_TOKEN_INFO_URL =\n      'https://oauth2.googleapis.com/tokeninfo';\n\n  /**\n   * The base URL for auth endpoints.\n   */\n  private static readonly GOOGLE_OAUTH2_AUTH_BASE_URL_ =\n      'https://accounts.google.com/o/oauth2/v2/auth';\n\n  /**\n   * The base endpoint for token retrieval.\n   */\n  private static readonly GOOGLE_OAUTH2_TOKEN_URL_ =\n      'https://oauth2.googleapis.com/token';\n\n  /**\n   * The base endpoint to revoke tokens.\n   */\n  private static readonly GOOGLE_OAUTH2_REVOKE_URL_ =\n      'https://oauth2.googleapis.com/revoke';\n\n  /**\n   * Google Sign on certificates.\n   */\n  private static readonly GOOGLE_OAUTH2_FEDERATED_SIGNON_CERTS_URL_ =\n      'https://www.googleapis.com/oauth2/v1/certs';\n\n  /**\n   * Clock skew - five minutes in seconds\n   */\n  private static readonly CLOCK_SKEW_SECS_ = 300;\n\n  /**\n   * Max Token Lifetime is one day in seconds\n   */\n  private static readonly MAX_TOKEN_LIFETIME_SECS_ = 86400;\n\n  /**\n   * The allowed oauth token issuers.\n   */\n  private static readonly ISSUERS_ =\n      ['accounts.google.com', 'https://accounts.google.com'];\n\n  /**\n   * Generates URL for consent page landing.\n   * @param opts Options.\n   * @return URL to consent page.\n   */\n  generateAuthUrl(opts: GenerateAuthUrlOpts = {}) {\n    if (opts.code_challenge_method && !opts.code_challenge) {\n      throw new Error(\n          'If a code_challenge_method is provided, code_challenge must be included.');\n    }\n    opts.response_type = opts.response_type || 'code';\n    opts.client_id = opts.client_id || this._clientId;\n    opts.redirect_uri = opts.redirect_uri || this.redirectUri;\n    // Allow scopes to be passed either as array or a string\n    if (opts.scope instanceof Array) {\n      opts.scope = opts.scope.join(' ');\n    }\n    const rootUrl = OAuth2Client.GOOGLE_OAUTH2_AUTH_BASE_URL_;\n    return rootUrl + '?' + querystring.stringify(opts);\n  }\n\n  /**\n   * Convenience method to automatically generate a code_verifier, and it's\n   * resulting SHA256. If used, this must be paired with a S256\n   * code_challenge_method.\n   */\n  generateCodeVerifier() {\n    // base64 encoding uses 6 bits per character, and we want to generate128\n    // characters. 6*128/8 = 96.\n    const randomString = crypto.randomBytes(96).toString('base64');\n    // The valid characters in the code_verifier are [A-Z]/[a-z]/[0-9]/\n    // \"-\"/\".\"/\"_\"/\"~\". Base64 encoded strings are pretty close, so we're just\n    // swapping out a few chars.\n    const codeVerifier =\n        randomString.replace(/\\+/g, '~').replace(/=/g, '_').replace(/\\//g, '-');\n    // Generate the base64 encoded SHA256\n    const unencodedCodeChallenge =\n        crypto.createHash('sha256').update(codeVerifier).digest('base64');\n    // We need to use base64UrlEncoding instead of standard base64\n    const codeChallenge = unencodedCodeChallenge.split('=')[0]\n                              .replace(/\\+/g, '-')\n                              .replace(/\\//g, '_');\n    return {codeVerifier, codeChallenge};\n  }\n\n  /**\n   * Gets the access token for the given code.\n   * @param code The authorization code.\n   * @param callback Optional callback fn.\n   */\n  getToken(code: string): Promise;\n  getToken(options: GetTokenOptions): Promise;\n  getToken(code: string, callback: GetTokenCallback): void;\n  getToken(options: GetTokenOptions, callback: GetTokenCallback): void;\n  getToken(codeOrOptions: string|GetTokenOptions, callback?: GetTokenCallback):\n      Promise|void {\n    const options = (typeof codeOrOptions === 'string') ?\n        {code: codeOrOptions} :\n        codeOrOptions;\n    if (callback) {\n      this.getTokenAsync(options).then(\n          r => callback(null, r.tokens, r.res),\n          e => callback(e, null, e.response));\n    } else {\n      return this.getTokenAsync(options);\n    }\n  }\n\n  private async getTokenAsync(options: GetTokenOptions):\n      Promise {\n    const url = OAuth2Client.GOOGLE_OAUTH2_TOKEN_URL_;\n    const values = {\n      code: options.code,\n      client_id: options.client_id || this._clientId,\n      client_secret: this._clientSecret,\n      redirect_uri: options.redirect_uri || this.redirectUri,\n      grant_type: 'authorization_code',\n      code_verifier: options.codeVerifier\n    };\n    const res = await this.transporter.request({\n      method: 'POST',\n      url,\n      data: querystring.stringify(values),\n      headers: {'Content-Type': 'application/x-www-form-urlencoded'}\n    });\n    const tokens = res.data as Credentials;\n    if (res.data && res.data.expires_in) {\n      tokens.expiry_date =\n          ((new Date()).getTime() + (res.data.expires_in * 1000));\n      delete (tokens as CredentialRequest).expires_in;\n    }\n    this.emit('tokens', tokens);\n    return {tokens, res};\n  }\n\n  /**\n   * Refreshes the access token.\n   * @param refresh_token Existing refresh token.\n   * @private\n   */\n  protected async refreshToken(refreshToken?: string|\n                               null): Promise {\n    if (!refreshToken) {\n      return this.refreshTokenNoCache(refreshToken);\n    }\n    // If a request to refresh using the same token has started,\n    // return the same promise.\n    if (this.refreshTokenPromises.has(refreshToken)) {\n      return this.refreshTokenPromises.get(refreshToken)!;\n    }\n\n    const p = this.refreshTokenNoCache(refreshToken)\n                  .then(\n                      r => {\n                        this.refreshTokenPromises.delete(refreshToken);\n                        return r;\n                      },\n                      e => {\n                        this.refreshTokenPromises.delete(refreshToken);\n                        throw e;\n                      });\n    this.refreshTokenPromises.set(refreshToken, p);\n    return p;\n  }\n\n  protected async refreshTokenNoCache(refreshToken?: string|\n                                      null): Promise {\n    const url = OAuth2Client.GOOGLE_OAUTH2_TOKEN_URL_;\n    const data = {\n      refresh_token: refreshToken,\n      client_id: this._clientId,\n      client_secret: this._clientSecret,\n      grant_type: 'refresh_token'\n    };\n\n    // request for new token\n    const res = await this.transporter.request({\n      method: 'POST',\n      url,\n      data: querystring.stringify(data),\n      headers: {'Content-Type': 'application/x-www-form-urlencoded'}\n    });\n\n    const tokens = res.data as Credentials;\n    // TODO: de-duplicate this code from a few spots\n    if (res.data && res.data.expires_in) {\n      tokens.expiry_date =\n          ((new Date()).getTime() + (res.data.expires_in * 1000));\n      delete (tokens as CredentialRequest).expires_in;\n    }\n    this.emit('tokens', tokens);\n    return {tokens, res};\n  }\n\n  /**\n   * Retrieves the access token using refresh token\n   *\n   * @deprecated use getRequestHeaders instead.\n   * @param callback callback\n   */\n  refreshAccessToken(): Promise;\n  refreshAccessToken(callback: RefreshAccessTokenCallback): void;\n  refreshAccessToken(callback?: RefreshAccessTokenCallback):\n      Promise|void {\n    messages.warn(messages.REFRESH_ACCESS_TOKEN_DEPRECATED);\n    if (callback) {\n      this.refreshAccessTokenAsync().then(\n          r => callback(null, r.credentials, r.res), callback);\n    } else {\n      return this.refreshAccessTokenAsync();\n    }\n  }\n\n  private async refreshAccessTokenAsync() {\n    if (!this.credentials.refresh_token) {\n      throw new Error('No refresh token is set.');\n    }\n    const r = await this.refreshToken(this.credentials.refresh_token);\n    const tokens = r.tokens as Credentials;\n    tokens.refresh_token = this.credentials.refresh_token;\n    this.credentials = tokens;\n    return {credentials: this.credentials, res: r.res};\n  }\n\n  /**\n   * Get a non-expired access token, after refreshing if necessary\n   *\n   * @param callback Callback to call with the access token\n   */\n  getAccessToken(): Promise;\n  getAccessToken(callback: GetAccessTokenCallback): void;\n  getAccessToken(callback?: GetAccessTokenCallback):\n      Promise|void {\n    if (callback) {\n      this.getAccessTokenAsync().then(\n          r => callback(null, r.token, r.res), callback);\n    } else {\n      return this.getAccessTokenAsync();\n    }\n  }\n\n  private async getAccessTokenAsync(): Promise {\n    const shouldRefresh =\n        !this.credentials.access_token || this.isTokenExpiring();\n    if (shouldRefresh && this.credentials.refresh_token) {\n      if (!this.credentials.refresh_token) {\n        throw new Error('No refresh token is set.');\n      }\n\n      const r = await this.refreshAccessTokenAsync();\n      if (!r.credentials || (r.credentials && !r.credentials.access_token)) {\n        throw new Error('Could not refresh access token.');\n      }\n      return {token: r.credentials.access_token, res: r.res};\n    } else {\n      return {token: this.credentials.access_token};\n    }\n  }\n\n  /**\n   * Obtain the set of headers required to authenticate a request.\n   *\n   * @deprecated Use getRequestHeaders instead.\n   * @param url the Uri being authorized\n   * @param callback the func described above\n   */\n  getRequestMetadata(url?: string|null): Promise;\n  getRequestMetadata(url: string|null, callback: RequestMetadataCallback): void;\n  getRequestMetadata(url: string|null, callback?: RequestMetadataCallback):\n      Promise|void {\n    messages.warn(messages.OAUTH_GET_REQUEST_METADATA_DEPRECATED);\n    if (callback) {\n      this.getRequestMetadataAsync(url).then(\n          r => callback(null, r.headers, r.res), callback);\n    } else {\n      return this.getRequestMetadataAsync();\n    }\n  }\n\n  /**\n   * The main authentication interface.  It takes an optional url which when\n   * present is the endpoint being accessed, and returns a Promise which\n   * resolves with authorization header fields.\n   *\n   * In OAuth2Client, the result has the form:\n   * { Authorization: 'Bearer ' }\n   * @param url The optional url being authorized\n   */\n  async getRequestHeaders(url?: string): Promise {\n    const res = await this.getRequestMetadataAsync(url);\n    return res.headers;\n  }\n\n  protected async getRequestMetadataAsync(url?: string|null):\n      Promise {\n    const thisCreds = this.credentials;\n    if (!thisCreds.access_token && !thisCreds.refresh_token && !this.apiKey) {\n      throw new Error('No access, refresh token or API key is set.');\n    }\n\n    if (thisCreds.access_token && !this.isTokenExpiring()) {\n      thisCreds.token_type = thisCreds.token_type || 'Bearer';\n      const headers = {\n        Authorization: thisCreds.token_type + ' ' + thisCreds.access_token\n      };\n      return {headers};\n    }\n\n    if (this.apiKey) {\n      return {headers: {}};\n    }\n    let r: GetTokenResponse|null = null;\n    let tokens: Credentials|null = null;\n    try {\n      r = await this.refreshToken(thisCreds.refresh_token);\n      tokens = r.tokens;\n    } catch (err) {\n      const e = err as AxiosError;\n      if (e.response &&\n          (e.response.status === 403 || e.response.status === 404)) {\n        e.message = 'Could not refresh access token.';\n      }\n      throw e;\n    }\n\n    const credentials = this.credentials;\n    credentials.token_type = credentials.token_type || 'Bearer';\n    tokens.refresh_token = credentials.refresh_token;\n    this.credentials = tokens;\n    const headers = {\n      Authorization: credentials.token_type + ' ' + tokens.access_token\n    };\n    return {headers, res: r.res};\n  }\n\n  /**\n   * Revokes the access given to token.\n   * @param token The existing token to be revoked.\n   * @param callback Optional callback fn.\n   */\n  revokeToken(token: string): AxiosPromise;\n  revokeToken(\n      token: string,\n      callback: BodyResponseCallback): void;\n  revokeToken(\n      token: string, callback?: BodyResponseCallback):\n      AxiosPromise|void {\n    const opts = {\n      url: OAuth2Client.GOOGLE_OAUTH2_REVOKE_URL_ + '?' +\n          querystring.stringify({token}),\n      method: 'POST'\n    };\n    if (callback) {\n      this.transporter.request(opts).then(\n          r => callback(null, r), callback);\n    } else {\n      return this.transporter.request(opts);\n    }\n  }\n\n\n  /**\n   * Revokes access token and clears the credentials object\n   * @param callback callback\n   */\n  revokeCredentials(): AxiosPromise;\n  revokeCredentials(callback: BodyResponseCallback):\n      void;\n  revokeCredentials(callback?: BodyResponseCallback):\n      AxiosPromise|void {\n    if (callback) {\n      this.revokeCredentialsAsync().then(res => callback(null, res), callback);\n    } else {\n      return this.revokeCredentialsAsync();\n    }\n  }\n\n  private async revokeCredentialsAsync() {\n    const token = this.credentials.access_token;\n    this.credentials = {};\n    if (token) {\n      return this.revokeToken(token);\n    } else {\n      throw new Error('No access token to revoke.');\n    }\n  }\n\n  /**\n   * Provides a request implementation with OAuth 2.0 flow. If credentials have\n   * a refresh_token, in cases of HTTP 401 and 403 responses, it automatically\n   * asks for a new access token and replays the unsuccessful request.\n   * @param opts Request options.\n   * @param callback callback.\n   * @return Request object\n   */\n  request(opts: AxiosRequestConfig): AxiosPromise;\n  request(opts: AxiosRequestConfig, callback: BodyResponseCallback): void;\n  request(opts: AxiosRequestConfig, callback?: BodyResponseCallback):\n      AxiosPromise|void {\n    if (callback) {\n      this.requestAsync(opts).then(r => callback(null, r), e => {\n        return callback(e, e.response);\n      });\n    } else {\n      return this.requestAsync(opts);\n    }\n  }\n\n  protected async requestAsync(opts: AxiosRequestConfig, retry = false):\n      Promise> {\n    let r2: AxiosResponse;\n    try {\n      const r = await this.getRequestMetadataAsync(opts.url);\n      if (r.headers && r.headers.Authorization) {\n        opts.headers = opts.headers || {};\n        opts.headers.Authorization = r.headers.Authorization;\n      }\n\n      if (this.apiKey) {\n        opts.params = Object.assign(opts.params || {}, {key: this.apiKey});\n      }\n      r2 = await this.transporter.request(opts);\n    } catch (e) {\n      const res = (e as AxiosError).response;\n      if (res) {\n        const statusCode = res.status;\n        // Retry the request for metadata if the following criteria are true:\n        // - We haven't already retried.  It only makes sense to retry once.\n        // - The response was a 401 or a 403\n        // - The request didn't send a readableStream\n        // - An access_token and refresh_token were available, but no\n        //   expiry_date was availabe. This can happen when developers stash\n        //   the access_token and refresh_token for later use, but the\n        //   access_token fails on the first try because it's expired.\n        const mayRequireRefresh = this.credentials &&\n            this.credentials.access_token && this.credentials.refresh_token &&\n            !this.credentials.expiry_date;\n        const isReadableStream = res.config.data instanceof stream.Readable;\n        const isAuthErr = statusCode === 401 || statusCode === 403;\n        if (!retry && isAuthErr && !isReadableStream && mayRequireRefresh) {\n          await this.refreshAccessTokenAsync();\n          return this.requestAsync(opts, true);\n        }\n      }\n      throw e;\n    }\n    return r2;\n  }\n\n  /**\n   * Verify id token is token by checking the certs and audience\n   * @param options that contains all options.\n   * @param callback Callback supplying GoogleLogin if successful\n   */\n  verifyIdToken(options: VerifyIdTokenOptions): Promise;\n  verifyIdToken(\n      options: VerifyIdTokenOptions,\n      callback: (err: Error|null, login?: LoginTicket) => void): void;\n  verifyIdToken(\n      options: VerifyIdTokenOptions,\n      callback?: (err: Error|null, login?: LoginTicket) => void):\n      void|Promise {\n    // This function used to accept two arguments instead of an options object.\n    // Check the types to help users upgrade with less pain.\n    // This check can be removed after a 2.0 release.\n    if (callback && typeof callback !== 'function') {\n      throw new Error(\n          'This method accepts an options object as the first parameter, which includes the idToken, audience, and maxExpiry.');\n    }\n\n    if (callback) {\n      this.verifyIdTokenAsync(options).then(r => callback(null, r), callback);\n    } else {\n      return this.verifyIdTokenAsync(options);\n    }\n  }\n\n  private async verifyIdTokenAsync(options: VerifyIdTokenOptions):\n      Promise {\n    if (!options.idToken) {\n      throw new Error('The verifyIdToken method requires an ID Token');\n    }\n\n    const response = await this.getFederatedSignonCertsAsync();\n    const login = this.verifySignedJwtWithCerts(\n        options.idToken, response.certs, options.audience,\n        OAuth2Client.ISSUERS_, options.maxExpiry);\n\n    return login;\n  }\n\n  /**\n   * Obtains information about the provisioned access token.  Especially useful\n   * if you want to check the scopes that were provisioned to a given token.\n   *\n   * @param accessToken Required.  The Access Token for which you want to get\n   * user info.\n   */\n  async getTokenInfo(accessToken: string): Promise {\n    const {data} = await this.transporter.request({\n      method: 'GET',\n      url: OAuth2Client.GOOGLE_TOKEN_INFO_URL,\n      params: {access_token: accessToken}\n    });\n    const info = Object.assign(\n        {\n          expiry_date: ((new Date()).getTime() + (data.expires_in * 1000)),\n          scopes: data.scope.split(' ')\n        },\n        data);\n    delete info.expires_in;\n    delete info.scope;\n    return info;\n  }\n\n  /**\n   * Gets federated sign-on certificates to use for verifying identity tokens.\n   * Returns certs as array structure, where keys are key ids, and values\n   * are PEM encoded certificates.\n   * @param callback Callback supplying the certificates\n   */\n  getFederatedSignonCerts(): Promise;\n  getFederatedSignonCerts(callback: GetFederatedSignonCertsCallback): void;\n  getFederatedSignonCerts(callback?: GetFederatedSignonCertsCallback):\n      Promise|void {\n    if (callback) {\n      this.getFederatedSignonCertsAsync().then(\n          r => callback(null, r.certs, r.res), callback);\n    } else {\n      return this.getFederatedSignonCertsAsync();\n    }\n  }\n\n  async getFederatedSignonCertsAsync(): Promise {\n    const nowTime = (new Date()).getTime();\n    if (this.certificateExpiry &&\n        (nowTime = now + maxExpiry) {\n      throw new Error(\n          'Expiration time too far in future: ' + JSON.stringify(payload));\n    }\n\n    const earliest = iat - OAuth2Client.CLOCK_SKEW_SECS_;\n    const latest = exp + OAuth2Client.CLOCK_SKEW_SECS_;\n\n    if (now  latest) {\n      throw new Error(\n          'Token used too late, ' + now + ' > ' + latest + ': ' +\n          JSON.stringify(payload));\n    }\n\n    if (issuers && issuers.indexOf(payload.iss)  -1);\n      } else {\n        audVerified = (aud === requiredAudience);\n      }\n      if (!audVerified) {\n        throw new Error(\n            'Wrong recipient, payload audience != requiredAudience');\n      }\n    }\n    return new LoginTicket(envelope, payload);\n  }\n\n  /**\n   * This is a utils method to decode a base64 string\n   * @param b64String The string to base64 decode\n   * @return The decoded string\n   */\n  decodeBase64(b64String: string) {\n    const buffer = Buffer.from(b64String, 'base64');\n    return buffer.toString('utf8');\n  }\n\n  /**\n   * Returns true if a token is expired or will expire within\n   * eagerRefreshThresholdMillismilliseconds.\n   * If there is no expiry time, assumes the token is not expired or expiring.\n   */\n  protected isTokenExpiring(): boolean {\n    const expiryDate = this.credentials.expiry_date;\n    return expiryDate ? expiryDate \n    \n\n\n\n\n\n\n\n                   \n    \n         result-matching \"\"\n        \n    \n    \n        No results matching \"\"\n    \n\n"},"interfaces/RequestError.html":{"url":"interfaces/RequestError.html","title":"interface - RequestError","body":"\n                   \n\n\n\n\n\n\n\n\n\n\n\n\n\n  Interfaces\n  RequestError\n\n\n\n        \n            Info\n        \n        \n            Source\n        \n\n\n\n    \n        \n            File\n        \n        \n            src/transporters.ts\n        \n\n\n            \n                Extends\n            \n            \n                    AxiosError\n            \n\n        \n            Index\n            \n                \n                    \n                        \n                            Properties\n                        \n                    \n                    \n                        \n                            \n                                \n                                        errors\n                                \n                            \n                        \n                    \n                \n            \n        \n\n\n\n            \n                Properties\n                    \n                        \n                                \n                                    \n                                        \n                                        errors\n                                    \n                                \n                                \n                                    \n                                        errors:     Error[]\n\n                                    \n                                \n\n\n                                    \n                                        \n                                            Type :     Error[]\n\n                                        \n                                    \n\n\n\n\n\n                        \n                    \n            \n    \n\n\n    \n        import axios, {AxiosError, AxiosPromise, AxiosRequestConfig, AxiosResponse} from 'axios';\nimport {validate} from './options';\n\n// tslint:disable-next-line variable-name\nconst HttpsProxyAgent = require('https-proxy-agent');\n\n// tslint:disable-next-line no-var-requires\nconst pkg = require('../../package.json');\nconst PRODUCT_NAME = 'google-api-nodejs-client';\n\nexport interface Transporter {\n  request(opts: AxiosRequestConfig): AxiosPromise;\n  request(opts: AxiosRequestConfig, callback?: BodyResponseCallback):\n      void;\n  request(opts: AxiosRequestConfig, callback?: BodyResponseCallback):\n      AxiosPromise|void;\n}\n\nexport interface BodyResponseCallback {\n  // The `body` object is a truly dynamic type.  It must be `any`.\n  (err: Error|null, res?: AxiosResponse|null): void;\n}\n\nexport interface RequestError extends AxiosError {\n  errors: Error[];\n}\n\n/**\n * Axios will use XHR if it is available. In the case of Electron,\n * since XHR is there it will try to use that. This leads to OPTIONS\n * preflight requests which googleapis DOES NOT like. This line of\n * code pins the adapter to ensure it uses node.\n * https://github.com/google/google-api-nodejs-client/issues/1083\n */\naxios.defaults.adapter = require('axios/lib/adapters/http');\n\nexport class DefaultTransporter {\n  /**\n   * Default user agent.\n   */\n  static readonly USER_AGENT = `${PRODUCT_NAME}/${pkg.version}`;\n\n  /**\n   * Configures request options before making a request.\n   * @param opts AxiosRequestConfig options.\n   * @return Configured options.\n   */\n  configure(opts: AxiosRequestConfig = {}): AxiosRequestConfig {\n    // set transporter user agent\n    opts.headers = opts.headers || {};\n    const uaValue: string = opts.headers['User-Agent'];\n    if (!uaValue) {\n      opts.headers['User-Agent'] = DefaultTransporter.USER_AGENT;\n    } else if (!uaValue.includes(`${PRODUCT_NAME}/`)) {\n      opts.headers['User-Agent'] =\n          `${uaValue} ${DefaultTransporter.USER_AGENT}`;\n    }\n    return opts;\n  }\n\n  /**\n   * Makes a request using Axios with given options.\n   * @param opts AxiosRequestConfig options.\n   * @param callback optional callback that contains AxiosResponse object.\n   * @return AxiosPromise, assuming no callback is passed.\n   */\n  request(opts: AxiosRequestConfig): AxiosPromise;\n  request(opts: AxiosRequestConfig, callback?: BodyResponseCallback):\n      void;\n  request(opts: AxiosRequestConfig, callback?: BodyResponseCallback):\n      AxiosPromise|void {\n    // ensure the user isn't passing in request-style options\n    opts = this.configure(opts);\n    try {\n      validate(opts);\n    } catch (e) {\n      if (callback) {\n        return callback(e);\n      } else {\n        throw e;\n      }\n    }\n\n    // If the user configured an `HTTPS_PROXY` environment variable, create\n    // a custom agent to proxy the request.\n    const proxy = process.env.HTTPS_PROXY || process.env.https_proxy;\n    if (proxy) {\n      opts.httpsAgent = new HttpsProxyAgent(proxy);\n      opts.proxy = false;\n    }\n\n    if (callback) {\n      axios(opts).then(\n          r => {\n            callback(null, r);\n          },\n          e => {\n            callback(this.processError(e));\n          });\n    } else {\n      return axios(opts).catch(e => {\n        throw this.processError(e);\n      });\n    }\n  }\n\n  /**\n   * Changes the error to include details from the body.\n   */\n  private processError(e: AxiosError): RequestError {\n    const res = e.response;\n    const err = e as RequestError;\n    const body = res ? res.data : null;\n    if (res && body && body.error && res.status !== 200) {\n      if (typeof body.error === 'string') {\n        err.message = body.error;\n        err.code = res.status.toString();\n      } else if (Array.isArray(body.error.errors)) {\n        err.message =\n            body.error.errors.map((err2: Error) => err2.message).join('\\n');\n        err.code = body.error.code;\n        err.errors = body.error.errors;\n      } else {\n        err.message = body.error.message;\n        err.code = body.error.code || res.status;\n      }\n    } else if (res && res.status >= 400) {\n      // Consider all 4xx and 5xx responses errors.\n      err.message = body;\n      err.code = res.status.toString();\n    }\n    return err;\n  }\n}\n\n    \n\n\n\n\n\n\n\n                   \n    \n         result-matching \"\"\n        \n    \n    \n        No results matching \"\"\n    \n\n"},"interfaces/RequestMetadata.html":{"url":"interfaces/RequestMetadata.html","title":"interface - RequestMetadata","body":"\n                   \n\n\n\n\n\n\n\n\n\n\n\n\n\n  Interfaces\n  RequestMetadata\n\n\n\n        \n            Info\n        \n        \n            Source\n        \n\n\n\n    \n        \n            File\n        \n        \n            src/auth/iam.ts\n        \n\n\n\n        \n            Index\n            \n                \n                    \n                        \n                            Properties\n                        \n                    \n                    \n                        \n                            \n                                \n                                        x-goog-iam-authority-selector\n                                \n                                \n                                        x-goog-iam-authorization-token\n                                \n                            \n                        \n                    \n                \n            \n        \n\n\n\n            \n                Properties\n                    \n                        \n                                \n                                    \n                                        \n                                        x-goog-iam-authority-selector\n                                    \n                                \n                                \n                                    \n                                        x-goog-iam-authority-selector:     string\n\n                                    \n                                \n\n\n                                    \n                                        \n                                            Type :     string\n\n                                        \n                                    \n\n\n\n\n\n                        \n                    \n                    \n                        \n                                \n                                    \n                                        \n                                        x-goog-iam-authorization-token\n                                    \n                                \n                                \n                                    \n                                        x-goog-iam-authorization-token:     string\n\n                                    \n                                \n\n\n                                    \n                                        \n                                            Type :     string\n\n                                        \n                                    \n\n\n\n\n\n                        \n                    \n            \n    \n\n\n    \n        import * as messages from '../messages';\n\nexport interface RequestMetadata {\n  'x-goog-iam-authority-selector': string;\n  'x-goog-iam-authorization-token': string;\n}\n\nexport class IAMAuth {\n  /**\n   * IAM credentials.\n   *\n   * @param selector the iam authority selector\n   * @param token the token\n   * @constructor\n   */\n  constructor(public selector: string, public token: string) {\n    this.selector = selector;\n    this.token = token;\n  }\n\n  /**\n   * Indicates whether the credential requires scopes to be created by calling\n   * createdScoped before use.\n   * @deprecated\n   * @return always false\n   */\n  createScopedRequired() {\n    // IAM authorization does not use scopes.\n    messages.warn(messages.IAM_CREATE_SCOPED_DEPRECATED);\n    return false;\n  }\n\n  /**\n   * Pass the selector and token to the metadataFn callback.\n   * @deprecated\n   * @param unused_uri is required of the credentials interface\n   * @param metadataFn a callback invoked with object containing request\n   * metadata.\n   */\n  getRequestMetadata(\n      unusedUri: string|null,\n      metadataFn: (err: Error|null, metadata?: RequestMetadata) => void) {\n    messages.warn(messages.IAM_GET_REQUEST_METADATA_DEPRECATED);\n    metadataFn(null, this.getRequestHeaders());\n  }\n\n  /**\n   * Acquire the HTTP headers required to make an authenticated request.\n   */\n  getRequestHeaders() {\n    return {\n      'x-goog-iam-authority-selector': this.selector,\n      'x-goog-iam-authorization-token': this.token\n    };\n  }\n}\n\n    \n\n\n\n\n\n\n\n                   \n    \n         result-matching \"\"\n        \n    \n    \n        No results matching \"\"\n    \n\n"},"interfaces/RequestMetadataCallback.html":{"url":"interfaces/RequestMetadataCallback.html","title":"interface - RequestMetadataCallback","body":"\n                   \n\n\n\n\n\n\n\n\n\n\n\n\n\n  Interfaces\n  RequestMetadataCallback\n\n\n\n        \n            Info\n        \n        \n            Source\n        \n\n\n\n    \n        \n            File\n        \n        \n            src/auth/oauth2client.ts\n        \n\n\n\n        \n            Index\n            \n                \n                    \n                        \n                            Properties\n                        \n                    \n                    \n                        \n                            \n                                \n                                            Unamed property\n                                \n                            \n                        \n                    \n                \n            \n        \n\n\n\n            \n                Properties\n                    \n                        \n\n                                    \n                                        \n                                            Signature :\n                                            \n                                            \n                                                \n                                                    [err: AxiosError | null, headers: Headers, res: AxiosResponse | null]\n                                            \n                                        \n                                    \n\n\n                                    \n                                        \n                                            Returns :     void\n\n                                        \n                                    \n\n\n\n\n                        \n                    \n            \n    \n\n\n    \n        import {AxiosError, AxiosPromise, AxiosRequestConfig, AxiosResponse} from 'axios';\nimport * as crypto from 'crypto';\nimport * as querystring from 'querystring';\nimport * as stream from 'stream';\nimport * as messages from '../messages';\nimport {PemVerifier} from './../pemverifier';\nimport {BodyResponseCallback} from './../transporters';\nimport {AuthClient} from './authclient';\nimport {CredentialRequest, Credentials} from './credentials';\nimport {LoginTicket, TokenPayload} from './loginticket';\n\nexport type Certificates = {\n  [index: string]: string\n};\n\nexport type Headers = {\n  [index: string]: string\n};\n\nexport enum CodeChallengeMethod {\n  Plain = 'plain',\n  S256 = 'S256'\n}\n\nexport interface GetTokenOptions {\n  code: string;\n  codeVerifier?: string;\n  /**\n   * The client ID for your application. The value passed into the constructor\n   * will be used if not provided. Must match any client_id option passed to\n   * a corresponding call to generateAuthUrl.\n   */\n  client_id?: string;\n  /**\n   * Determines where the API server redirects the user after the user\n   * completes the authorization flow. The value passed into the constructor\n   * will be used if not provided. Must match any redirect_uri option passed to\n   * a corresponding call to generateAuthUrl.\n   */\n  redirect_uri?: string;\n}\n\nexport interface TokenInfo {\n  /**\n   * The application that is the intended user of the access token.\n   */\n  aud: string;\n\n  /**\n   * This value lets you correlate profile information from multiple Google\n   * APIs. It is only present in the response if you included the profile scope\n   * in your request in step 1. The field value is an immutable identifier for\n   * the logged-in user that can be used to create and manage user sessions in\n   * your application. The identifier is the same regardless of which client ID\n   * is used to retrieve it. This enables multiple applications in the same\n   * organization to correlate profile information.\n   */\n  user_id?: string;\n\n  /**\n   * An array of scopes that the user granted access to.\n   */\n  scopes: string[];\n\n  /**\n   * The datetime when the token becomes invalid.\n   */\n  expiry_date: number;\n\n  /**\n   * An identifier for the user, unique among all Google accounts and never\n   * reused. A Google account can have multiple emails at different points in\n   * time, but the sub value is never changed. Use sub within your application\n   * as the unique-identifier key for the user.\n   */\n  sub?: string;\n\n  /**\n   * The client_id of the authorized presenter. This claim is only needed when\n   * the party requesting the ID token is not the same as the audience of the ID\n   * token. This may be the case at Google for hybrid apps where a web\n   * application and Android app have a different client_id but share the same\n   * project.\n   */\n  azp?: string;\n\n  /**\n   * Indicates whether your application can refresh access tokens\n   * when the user is not present at the browser. Valid parameter values are\n   * 'online', which is the default value, and 'offline'. Set the value to\n   * 'offline' if your application needs to refresh access tokens when the user\n   * is not present at the browser. This value instructs the Google\n   * authorization server to return a refresh token and an access token the\n   * first time that your application exchanges an authorization code for\n   * tokens.\n   */\n  access_type?: string;\n}\n\ninterface TokenInfoRequest {\n  aud: string;\n  user_id?: string;\n  scope: string;\n  expires_in: number;\n  azp?: string;\n  sub?: string;\n  exp?: number;\n  access_type?: string;\n}\n\nexport interface GenerateAuthUrlOpts {\n  /**\n   * Recommended. Indicates whether your application can refresh access tokens\n   * when the user is not present at the browser. Valid parameter values are\n   * 'online', which is the default value, and 'offline'. Set the value to\n   * 'offline' if your application needs to refresh access tokens when the user\n   * is not present at the browser. This value instructs the Google\n   * authorization server to return a refresh token and an access token the\n   * first time that your application exchanges an authorization code for\n   * tokens.\n   */\n  access_type?: string;\n\n  /**\n   * The hd (hosted domain) parameter streamlines the login process for G Suite\n   * hosted accounts. By including the domain of the G Suite user (for example,\n   * mycollege.edu), you can indicate that the account selection UI should be\n   * optimized for accounts at that domain. To optimize for G Suite accounts\n   * generally instead of just one domain, use an asterisk: hd=*.\n   * Don't rely on this UI optimization to control who can access your app,\n   * as client-side requests can be modified. Be sure to validate that the\n   * returned ID token has an hd claim value that matches what you expect\n   * (e.g. mycolledge.edu). Unlike the request parameter, the ID token claim is\n   * contained within a security token from Google, so the value can be trusted.\n   */\n  hd?: string;\n\n  /**\n   * The 'response_type' will always be set to 'CODE'.\n   */\n  response_type?: string;\n\n  /**\n   * The client ID for your application. The value passed into the constructor\n   * will be used if not provided. You can find this value in the API Console.\n   */\n  client_id?: string;\n\n  /**\n   * Determines where the API server redirects the user after the user\n   * completes the authorization flow. The value must exactly match one of the\n   * 'redirect_uri' values listed for your project in the API Console. Note that\n   * the http or https scheme, case, and trailing slash ('/') must all match.\n   * The value passed into the constructor will be used if not provided.\n   */\n  redirect_uri?: string;\n\n  /**\n   * Required. A space-delimited list of scopes that identify the resources that\n   * your application could access on the user's behalf. These values inform the\n   * consent screen that Google displays to the user. Scopes enable your\n   * application to only request access to the resources that it needs while\n   * also enabling users to control the amount of access that they grant to your\n   * application. Thus, there is an inverse relationship between the number of\n   * scopes requested and the likelihood of obtaining user consent. The\n   * OAuth 2.0 API Scopes document provides a full list of scopes that you might\n   * use to access Google APIs. We recommend that your application request\n   * access to authorization scopes in context whenever possible. By requesting\n   * access to user data in context, via incremental authorization, you help\n   * users to more easily understand why your application needs the access it is\n   * requesting.\n   */\n  scope?: string[]|string;\n\n  /**\n   * Recommended. Specifies any string value that your application uses to\n   * maintain state between your authorization request and the authorization\n   * server's response. The server returns the exact value that you send as a\n   * name=value pair in the hash (#) fragment of the 'redirect_uri' after the\n   * user consents to or denies your application's access request. You can use\n   * this parameter for several purposes, such as directing the user to the\n   * correct resource in your application, sending nonces, and mitigating\n   * cross-site request forgery. Since your redirect_uri can be guessed, using a\n   * state value can increase your assurance that an incoming connection is the\n   * result of an authentication request. If you generate a random string or\n   * encode the hash of a cookie or another value that captures the client's\n   * state, you can validate the response to additionally ensure that the\n   * request and response originated in the same browser, providing protection\n   * against attacks such as cross-site request forgery. See the OpenID Connect\n   * documentation for an example of how to create and confirm a state token.\n   */\n  state?: string;\n\n  /**\n   * Optional. Enables applications to use incremental authorization to request\n   * access to additional scopes in context. If you set this parameter's value\n   * to true and the authorization request is granted, then the new access token\n   * will also cover any scopes to which the user previously granted the\n   * application access. See the incremental authorization section for examples.\n   */\n  include_granted_scopes?: boolean;\n\n  /**\n   * Optional. If your application knows which user is trying to authenticate,\n   * it can use this parameter to provide a hint to the Google Authentication\n   * Server. The server uses the hint to simplify the login flow either by\n   * prefilling the email field in the sign-in form or by selecting the\n   * appropriate multi-login session. Set the parameter value to an email\n   * address or sub identifier, which is equivalent to the user's Google ID.\n   */\n  login_hint?: string;\n\n  /**\n   * Optional. A space-delimited, case-sensitive list of prompts to present the\n   * user. If you don't specify this parameter, the user will be prompted only\n   * the first time your app requests access.  Possible values are:\n   *\n   * 'none' - Donot display any authentication or consent screens. Must not be\n   *        specified with other values.\n   * 'consent' - \tPrompt the user for consent.\n   * 'select_account' - Prompt the user to select an account.\n   */\n  prompt?: string;\n\n  /**\n   * Recommended. Specifies what method was used to encode a 'code_verifier'\n   * that will be used during authorization code exchange. This parameter must\n   * be used with the 'code_challenge' parameter. The value of the\n   * 'code_challenge_method' defaults to \"plain\" if not present in the request\n   * that includes a 'code_challenge'. The only supported values for this\n   * parameter are \"S256\" or \"plain\".\n   */\n  code_challenge_method?: CodeChallengeMethod;\n\n  /**\n   * Recommended. Specifies an encoded 'code_verifier' that will be used as a\n   * server-side challenge during authorization code exchange. This parameter\n   * must be used with the 'code_challenge' parameter described above.\n   */\n  code_challenge?: string;\n}\n\nexport interface GetTokenCallback {\n  (err: AxiosError|null, token?: Credentials|null,\n   res?: AxiosResponse|null): void;\n}\n\nexport interface GetTokenResponse {\n  tokens: Credentials;\n  res: AxiosResponse|null;\n}\n\nexport interface GetAccessTokenCallback {\n  (err: AxiosError|null, token?: string|null, res?: AxiosResponse|null): void;\n}\n\nexport interface GetAccessTokenResponse {\n  token?: string|null;\n  res?: AxiosResponse|null;\n}\n\nexport interface RefreshAccessTokenCallback {\n  (err: AxiosError|null, credentials?: Credentials|null,\n   res?: AxiosResponse|null): void;\n}\n\nexport interface RefreshAccessTokenResponse {\n  credentials: Credentials;\n  res: AxiosResponse|null;\n}\n\nexport interface RequestMetadataResponse {\n  headers: Headers;\n  res?: AxiosResponse|null;\n}\n\nexport interface RequestMetadataCallback {\n  (err: AxiosError|null, headers?: Headers,\n   res?: AxiosResponse|null): void;\n}\n\nexport interface GetFederatedSignonCertsCallback {\n  (err: AxiosError|null, certs?: Certificates,\n   response?: AxiosResponse|null): void;\n}\n\nexport interface FederatedSignonCertsResponse {\n  certs: Certificates;\n  res?: AxiosResponse|null;\n}\n\nexport interface RevokeCredentialsResult {\n  success: boolean;\n}\n\nexport interface VerifyIdTokenOptions {\n  idToken: string;\n  audience: string|string[];\n  maxExpiry?: number;\n}\n\nexport interface OAuth2ClientOptions extends RefreshOptions {\n  clientId?: string;\n  clientSecret?: string;\n  redirectUri?: string;\n}\n\nexport interface RefreshOptions {\n  // Eagerly refresh unexpired tokens when they are within this many\n  // milliseconds from expiring\".\n  // Defaults to a value of 300000 (5 minutes).\n  eagerRefreshThresholdMillis?: number;\n}\n\nexport class OAuth2Client extends AuthClient {\n  private redirectUri?: string;\n  private certificateCache?: Certificates;\n  private certificateExpiry: Date|null = null;\n  protected refreshTokenPromises = new Map>();\n\n  // TODO: refactor tests to make this private\n  _clientId?: string;\n\n  // TODO: refactor tests to make this private\n  _clientSecret?: string;\n\n  apiKey?: string;\n\n  projectId?: string;\n\n  eagerRefreshThresholdMillis: number;\n\n  /**\n   * Handles OAuth2 flow for Google APIs.\n   *\n   * @param clientId The authentication client ID.\n   * @param clientSecret The authentication client secret.\n   * @param redirectUri The URI to redirect to after completing the auth\n   * request.\n   * @param opts optional options for overriding the given parameters.\n   * @constructor\n   */\n  constructor(options?: OAuth2ClientOptions);\n  constructor(clientId?: string, clientSecret?: string, redirectUri?: string);\n  constructor(\n      optionsOrClientId?: string|OAuth2ClientOptions, clientSecret?: string,\n      redirectUri?: string) {\n    super();\n    const opts = (optionsOrClientId && typeof optionsOrClientId === 'object') ?\n        optionsOrClientId :\n        {clientId: optionsOrClientId, clientSecret, redirectUri};\n    this._clientId = opts.clientId;\n    this._clientSecret = opts.clientSecret;\n    this.redirectUri = opts.redirectUri;\n    this.eagerRefreshThresholdMillis =\n        opts.eagerRefreshThresholdMillis || 5 * 60 * 1000;\n  }\n\n  protected static readonly GOOGLE_TOKEN_INFO_URL =\n      'https://oauth2.googleapis.com/tokeninfo';\n\n  /**\n   * The base URL for auth endpoints.\n   */\n  private static readonly GOOGLE_OAUTH2_AUTH_BASE_URL_ =\n      'https://accounts.google.com/o/oauth2/v2/auth';\n\n  /**\n   * The base endpoint for token retrieval.\n   */\n  private static readonly GOOGLE_OAUTH2_TOKEN_URL_ =\n      'https://oauth2.googleapis.com/token';\n\n  /**\n   * The base endpoint to revoke tokens.\n   */\n  private static readonly GOOGLE_OAUTH2_REVOKE_URL_ =\n      'https://oauth2.googleapis.com/revoke';\n\n  /**\n   * Google Sign on certificates.\n   */\n  private static readonly GOOGLE_OAUTH2_FEDERATED_SIGNON_CERTS_URL_ =\n      'https://www.googleapis.com/oauth2/v1/certs';\n\n  /**\n   * Clock skew - five minutes in seconds\n   */\n  private static readonly CLOCK_SKEW_SECS_ = 300;\n\n  /**\n   * Max Token Lifetime is one day in seconds\n   */\n  private static readonly MAX_TOKEN_LIFETIME_SECS_ = 86400;\n\n  /**\n   * The allowed oauth token issuers.\n   */\n  private static readonly ISSUERS_ =\n      ['accounts.google.com', 'https://accounts.google.com'];\n\n  /**\n   * Generates URL for consent page landing.\n   * @param opts Options.\n   * @return URL to consent page.\n   */\n  generateAuthUrl(opts: GenerateAuthUrlOpts = {}) {\n    if (opts.code_challenge_method && !opts.code_challenge) {\n      throw new Error(\n          'If a code_challenge_method is provided, code_challenge must be included.');\n    }\n    opts.response_type = opts.response_type || 'code';\n    opts.client_id = opts.client_id || this._clientId;\n    opts.redirect_uri = opts.redirect_uri || this.redirectUri;\n    // Allow scopes to be passed either as array or a string\n    if (opts.scope instanceof Array) {\n      opts.scope = opts.scope.join(' ');\n    }\n    const rootUrl = OAuth2Client.GOOGLE_OAUTH2_AUTH_BASE_URL_;\n    return rootUrl + '?' + querystring.stringify(opts);\n  }\n\n  /**\n   * Convenience method to automatically generate a code_verifier, and it's\n   * resulting SHA256. If used, this must be paired with a S256\n   * code_challenge_method.\n   */\n  generateCodeVerifier() {\n    // base64 encoding uses 6 bits per character, and we want to generate128\n    // characters. 6*128/8 = 96.\n    const randomString = crypto.randomBytes(96).toString('base64');\n    // The valid characters in the code_verifier are [A-Z]/[a-z]/[0-9]/\n    // \"-\"/\".\"/\"_\"/\"~\". Base64 encoded strings are pretty close, so we're just\n    // swapping out a few chars.\n    const codeVerifier =\n        randomString.replace(/\\+/g, '~').replace(/=/g, '_').replace(/\\//g, '-');\n    // Generate the base64 encoded SHA256\n    const unencodedCodeChallenge =\n        crypto.createHash('sha256').update(codeVerifier).digest('base64');\n    // We need to use base64UrlEncoding instead of standard base64\n    const codeChallenge = unencodedCodeChallenge.split('=')[0]\n                              .replace(/\\+/g, '-')\n                              .replace(/\\//g, '_');\n    return {codeVerifier, codeChallenge};\n  }\n\n  /**\n   * Gets the access token for the given code.\n   * @param code The authorization code.\n   * @param callback Optional callback fn.\n   */\n  getToken(code: string): Promise;\n  getToken(options: GetTokenOptions): Promise;\n  getToken(code: string, callback: GetTokenCallback): void;\n  getToken(options: GetTokenOptions, callback: GetTokenCallback): void;\n  getToken(codeOrOptions: string|GetTokenOptions, callback?: GetTokenCallback):\n      Promise|void {\n    const options = (typeof codeOrOptions === 'string') ?\n        {code: codeOrOptions} :\n        codeOrOptions;\n    if (callback) {\n      this.getTokenAsync(options).then(\n          r => callback(null, r.tokens, r.res),\n          e => callback(e, null, e.response));\n    } else {\n      return this.getTokenAsync(options);\n    }\n  }\n\n  private async getTokenAsync(options: GetTokenOptions):\n      Promise {\n    const url = OAuth2Client.GOOGLE_OAUTH2_TOKEN_URL_;\n    const values = {\n      code: options.code,\n      client_id: options.client_id || this._clientId,\n      client_secret: this._clientSecret,\n      redirect_uri: options.redirect_uri || this.redirectUri,\n      grant_type: 'authorization_code',\n      code_verifier: options.codeVerifier\n    };\n    const res = await this.transporter.request({\n      method: 'POST',\n      url,\n      data: querystring.stringify(values),\n      headers: {'Content-Type': 'application/x-www-form-urlencoded'}\n    });\n    const tokens = res.data as Credentials;\n    if (res.data && res.data.expires_in) {\n      tokens.expiry_date =\n          ((new Date()).getTime() + (res.data.expires_in * 1000));\n      delete (tokens as CredentialRequest).expires_in;\n    }\n    this.emit('tokens', tokens);\n    return {tokens, res};\n  }\n\n  /**\n   * Refreshes the access token.\n   * @param refresh_token Existing refresh token.\n   * @private\n   */\n  protected async refreshToken(refreshToken?: string|\n                               null): Promise {\n    if (!refreshToken) {\n      return this.refreshTokenNoCache(refreshToken);\n    }\n    // If a request to refresh using the same token has started,\n    // return the same promise.\n    if (this.refreshTokenPromises.has(refreshToken)) {\n      return this.refreshTokenPromises.get(refreshToken)!;\n    }\n\n    const p = this.refreshTokenNoCache(refreshToken)\n                  .then(\n                      r => {\n                        this.refreshTokenPromises.delete(refreshToken);\n                        return r;\n                      },\n                      e => {\n                        this.refreshTokenPromises.delete(refreshToken);\n                        throw e;\n                      });\n    this.refreshTokenPromises.set(refreshToken, p);\n    return p;\n  }\n\n  protected async refreshTokenNoCache(refreshToken?: string|\n                                      null): Promise {\n    const url = OAuth2Client.GOOGLE_OAUTH2_TOKEN_URL_;\n    const data = {\n      refresh_token: refreshToken,\n      client_id: this._clientId,\n      client_secret: this._clientSecret,\n      grant_type: 'refresh_token'\n    };\n\n    // request for new token\n    const res = await this.transporter.request({\n      method: 'POST',\n      url,\n      data: querystring.stringify(data),\n      headers: {'Content-Type': 'application/x-www-form-urlencoded'}\n    });\n\n    const tokens = res.data as Credentials;\n    // TODO: de-duplicate this code from a few spots\n    if (res.data && res.data.expires_in) {\n      tokens.expiry_date =\n          ((new Date()).getTime() + (res.data.expires_in * 1000));\n      delete (tokens as CredentialRequest).expires_in;\n    }\n    this.emit('tokens', tokens);\n    return {tokens, res};\n  }\n\n  /**\n   * Retrieves the access token using refresh token\n   *\n   * @deprecated use getRequestHeaders instead.\n   * @param callback callback\n   */\n  refreshAccessToken(): Promise;\n  refreshAccessToken(callback: RefreshAccessTokenCallback): void;\n  refreshAccessToken(callback?: RefreshAccessTokenCallback):\n      Promise|void {\n    messages.warn(messages.REFRESH_ACCESS_TOKEN_DEPRECATED);\n    if (callback) {\n      this.refreshAccessTokenAsync().then(\n          r => callback(null, r.credentials, r.res), callback);\n    } else {\n      return this.refreshAccessTokenAsync();\n    }\n  }\n\n  private async refreshAccessTokenAsync() {\n    if (!this.credentials.refresh_token) {\n      throw new Error('No refresh token is set.');\n    }\n    const r = await this.refreshToken(this.credentials.refresh_token);\n    const tokens = r.tokens as Credentials;\n    tokens.refresh_token = this.credentials.refresh_token;\n    this.credentials = tokens;\n    return {credentials: this.credentials, res: r.res};\n  }\n\n  /**\n   * Get a non-expired access token, after refreshing if necessary\n   *\n   * @param callback Callback to call with the access token\n   */\n  getAccessToken(): Promise;\n  getAccessToken(callback: GetAccessTokenCallback): void;\n  getAccessToken(callback?: GetAccessTokenCallback):\n      Promise|void {\n    if (callback) {\n      this.getAccessTokenAsync().then(\n          r => callback(null, r.token, r.res), callback);\n    } else {\n      return this.getAccessTokenAsync();\n    }\n  }\n\n  private async getAccessTokenAsync(): Promise {\n    const shouldRefresh =\n        !this.credentials.access_token || this.isTokenExpiring();\n    if (shouldRefresh && this.credentials.refresh_token) {\n      if (!this.credentials.refresh_token) {\n        throw new Error('No refresh token is set.');\n      }\n\n      const r = await this.refreshAccessTokenAsync();\n      if (!r.credentials || (r.credentials && !r.credentials.access_token)) {\n        throw new Error('Could not refresh access token.');\n      }\n      return {token: r.credentials.access_token, res: r.res};\n    } else {\n      return {token: this.credentials.access_token};\n    }\n  }\n\n  /**\n   * Obtain the set of headers required to authenticate a request.\n   *\n   * @deprecated Use getRequestHeaders instead.\n   * @param url the Uri being authorized\n   * @param callback the func described above\n   */\n  getRequestMetadata(url?: string|null): Promise;\n  getRequestMetadata(url: string|null, callback: RequestMetadataCallback): void;\n  getRequestMetadata(url: string|null, callback?: RequestMetadataCallback):\n      Promise|void {\n    messages.warn(messages.OAUTH_GET_REQUEST_METADATA_DEPRECATED);\n    if (callback) {\n      this.getRequestMetadataAsync(url).then(\n          r => callback(null, r.headers, r.res), callback);\n    } else {\n      return this.getRequestMetadataAsync();\n    }\n  }\n\n  /**\n   * The main authentication interface.  It takes an optional url which when\n   * present is the endpoint being accessed, and returns a Promise which\n   * resolves with authorization header fields.\n   *\n   * In OAuth2Client, the result has the form:\n   * { Authorization: 'Bearer ' }\n   * @param url The optional url being authorized\n   */\n  async getRequestHeaders(url?: string): Promise {\n    const res = await this.getRequestMetadataAsync(url);\n    return res.headers;\n  }\n\n  protected async getRequestMetadataAsync(url?: string|null):\n      Promise {\n    const thisCreds = this.credentials;\n    if (!thisCreds.access_token && !thisCreds.refresh_token && !this.apiKey) {\n      throw new Error('No access, refresh token or API key is set.');\n    }\n\n    if (thisCreds.access_token && !this.isTokenExpiring()) {\n      thisCreds.token_type = thisCreds.token_type || 'Bearer';\n      const headers = {\n        Authorization: thisCreds.token_type + ' ' + thisCreds.access_token\n      };\n      return {headers};\n    }\n\n    if (this.apiKey) {\n      return {headers: {}};\n    }\n    let r: GetTokenResponse|null = null;\n    let tokens: Credentials|null = null;\n    try {\n      r = await this.refreshToken(thisCreds.refresh_token);\n      tokens = r.tokens;\n    } catch (err) {\n      const e = err as AxiosError;\n      if (e.response &&\n          (e.response.status === 403 || e.response.status === 404)) {\n        e.message = 'Could not refresh access token.';\n      }\n      throw e;\n    }\n\n    const credentials = this.credentials;\n    credentials.token_type = credentials.token_type || 'Bearer';\n    tokens.refresh_token = credentials.refresh_token;\n    this.credentials = tokens;\n    const headers = {\n      Authorization: credentials.token_type + ' ' + tokens.access_token\n    };\n    return {headers, res: r.res};\n  }\n\n  /**\n   * Revokes the access given to token.\n   * @param token The existing token to be revoked.\n   * @param callback Optional callback fn.\n   */\n  revokeToken(token: string): AxiosPromise;\n  revokeToken(\n      token: string,\n      callback: BodyResponseCallback): void;\n  revokeToken(\n      token: string, callback?: BodyResponseCallback):\n      AxiosPromise|void {\n    const opts = {\n      url: OAuth2Client.GOOGLE_OAUTH2_REVOKE_URL_ + '?' +\n          querystring.stringify({token}),\n      method: 'POST'\n    };\n    if (callback) {\n      this.transporter.request(opts).then(\n          r => callback(null, r), callback);\n    } else {\n      return this.transporter.request(opts);\n    }\n  }\n\n\n  /**\n   * Revokes access token and clears the credentials object\n   * @param callback callback\n   */\n  revokeCredentials(): AxiosPromise;\n  revokeCredentials(callback: BodyResponseCallback):\n      void;\n  revokeCredentials(callback?: BodyResponseCallback):\n      AxiosPromise|void {\n    if (callback) {\n      this.revokeCredentialsAsync().then(res => callback(null, res), callback);\n    } else {\n      return this.revokeCredentialsAsync();\n    }\n  }\n\n  private async revokeCredentialsAsync() {\n    const token = this.credentials.access_token;\n    this.credentials = {};\n    if (token) {\n      return this.revokeToken(token);\n    } else {\n      throw new Error('No access token to revoke.');\n    }\n  }\n\n  /**\n   * Provides a request implementation with OAuth 2.0 flow. If credentials have\n   * a refresh_token, in cases of HTTP 401 and 403 responses, it automatically\n   * asks for a new access token and replays the unsuccessful request.\n   * @param opts Request options.\n   * @param callback callback.\n   * @return Request object\n   */\n  request(opts: AxiosRequestConfig): AxiosPromise;\n  request(opts: AxiosRequestConfig, callback: BodyResponseCallback): void;\n  request(opts: AxiosRequestConfig, callback?: BodyResponseCallback):\n      AxiosPromise|void {\n    if (callback) {\n      this.requestAsync(opts).then(r => callback(null, r), e => {\n        return callback(e, e.response);\n      });\n    } else {\n      return this.requestAsync(opts);\n    }\n  }\n\n  protected async requestAsync(opts: AxiosRequestConfig, retry = false):\n      Promise> {\n    let r2: AxiosResponse;\n    try {\n      const r = await this.getRequestMetadataAsync(opts.url);\n      if (r.headers && r.headers.Authorization) {\n        opts.headers = opts.headers || {};\n        opts.headers.Authorization = r.headers.Authorization;\n      }\n\n      if (this.apiKey) {\n        opts.params = Object.assign(opts.params || {}, {key: this.apiKey});\n      }\n      r2 = await this.transporter.request(opts);\n    } catch (e) {\n      const res = (e as AxiosError).response;\n      if (res) {\n        const statusCode = res.status;\n        // Retry the request for metadata if the following criteria are true:\n        // - We haven't already retried.  It only makes sense to retry once.\n        // - The response was a 401 or a 403\n        // - The request didn't send a readableStream\n        // - An access_token and refresh_token were available, but no\n        //   expiry_date was availabe. This can happen when developers stash\n        //   the access_token and refresh_token for later use, but the\n        //   access_token fails on the first try because it's expired.\n        const mayRequireRefresh = this.credentials &&\n            this.credentials.access_token && this.credentials.refresh_token &&\n            !this.credentials.expiry_date;\n        const isReadableStream = res.config.data instanceof stream.Readable;\n        const isAuthErr = statusCode === 401 || statusCode === 403;\n        if (!retry && isAuthErr && !isReadableStream && mayRequireRefresh) {\n          await this.refreshAccessTokenAsync();\n          return this.requestAsync(opts, true);\n        }\n      }\n      throw e;\n    }\n    return r2;\n  }\n\n  /**\n   * Verify id token is token by checking the certs and audience\n   * @param options that contains all options.\n   * @param callback Callback supplying GoogleLogin if successful\n   */\n  verifyIdToken(options: VerifyIdTokenOptions): Promise;\n  verifyIdToken(\n      options: VerifyIdTokenOptions,\n      callback: (err: Error|null, login?: LoginTicket) => void): void;\n  verifyIdToken(\n      options: VerifyIdTokenOptions,\n      callback?: (err: Error|null, login?: LoginTicket) => void):\n      void|Promise {\n    // This function used to accept two arguments instead of an options object.\n    // Check the types to help users upgrade with less pain.\n    // This check can be removed after a 2.0 release.\n    if (callback && typeof callback !== 'function') {\n      throw new Error(\n          'This method accepts an options object as the first parameter, which includes the idToken, audience, and maxExpiry.');\n    }\n\n    if (callback) {\n      this.verifyIdTokenAsync(options).then(r => callback(null, r), callback);\n    } else {\n      return this.verifyIdTokenAsync(options);\n    }\n  }\n\n  private async verifyIdTokenAsync(options: VerifyIdTokenOptions):\n      Promise {\n    if (!options.idToken) {\n      throw new Error('The verifyIdToken method requires an ID Token');\n    }\n\n    const response = await this.getFederatedSignonCertsAsync();\n    const login = this.verifySignedJwtWithCerts(\n        options.idToken, response.certs, options.audience,\n        OAuth2Client.ISSUERS_, options.maxExpiry);\n\n    return login;\n  }\n\n  /**\n   * Obtains information about the provisioned access token.  Especially useful\n   * if you want to check the scopes that were provisioned to a given token.\n   *\n   * @param accessToken Required.  The Access Token for which you want to get\n   * user info.\n   */\n  async getTokenInfo(accessToken: string): Promise {\n    const {data} = await this.transporter.request({\n      method: 'GET',\n      url: OAuth2Client.GOOGLE_TOKEN_INFO_URL,\n      params: {access_token: accessToken}\n    });\n    const info = Object.assign(\n        {\n          expiry_date: ((new Date()).getTime() + (data.expires_in * 1000)),\n          scopes: data.scope.split(' ')\n        },\n        data);\n    delete info.expires_in;\n    delete info.scope;\n    return info;\n  }\n\n  /**\n   * Gets federated sign-on certificates to use for verifying identity tokens.\n   * Returns certs as array structure, where keys are key ids, and values\n   * are PEM encoded certificates.\n   * @param callback Callback supplying the certificates\n   */\n  getFederatedSignonCerts(): Promise;\n  getFederatedSignonCerts(callback: GetFederatedSignonCertsCallback): void;\n  getFederatedSignonCerts(callback?: GetFederatedSignonCertsCallback):\n      Promise|void {\n    if (callback) {\n      this.getFederatedSignonCertsAsync().then(\n          r => callback(null, r.certs, r.res), callback);\n    } else {\n      return this.getFederatedSignonCertsAsync();\n    }\n  }\n\n  async getFederatedSignonCertsAsync(): Promise {\n    const nowTime = (new Date()).getTime();\n    if (this.certificateExpiry &&\n        (nowTime = now + maxExpiry) {\n      throw new Error(\n          'Expiration time too far in future: ' + JSON.stringify(payload));\n    }\n\n    const earliest = iat - OAuth2Client.CLOCK_SKEW_SECS_;\n    const latest = exp + OAuth2Client.CLOCK_SKEW_SECS_;\n\n    if (now  latest) {\n      throw new Error(\n          'Token used too late, ' + now + ' > ' + latest + ': ' +\n          JSON.stringify(payload));\n    }\n\n    if (issuers && issuers.indexOf(payload.iss)  -1);\n      } else {\n        audVerified = (aud === requiredAudience);\n      }\n      if (!audVerified) {\n        throw new Error(\n            'Wrong recipient, payload audience != requiredAudience');\n      }\n    }\n    return new LoginTicket(envelope, payload);\n  }\n\n  /**\n   * This is a utils method to decode a base64 string\n   * @param b64String The string to base64 decode\n   * @return The decoded string\n   */\n  decodeBase64(b64String: string) {\n    const buffer = Buffer.from(b64String, 'base64');\n    return buffer.toString('utf8');\n  }\n\n  /**\n   * Returns true if a token is expired or will expire within\n   * eagerRefreshThresholdMillismilliseconds.\n   * If there is no expiry time, assumes the token is not expired or expiring.\n   */\n  protected isTokenExpiring(): boolean {\n    const expiryDate = this.credentials.expiry_date;\n    return expiryDate ? expiryDate \n    \n\n\n\n\n\n\n\n                   \n    \n         result-matching \"\"\n        \n    \n    \n        No results matching \"\"\n    \n\n"},"interfaces/RequestMetadataResponse.html":{"url":"interfaces/RequestMetadataResponse.html","title":"interface - RequestMetadataResponse","body":"\n                   \n\n\n\n\n\n\n\n\n\n\n\n\n\n  Interfaces\n  RequestMetadataResponse\n\n\n\n        \n            Info\n        \n        \n            Source\n        \n\n\n\n    \n        \n            File\n        \n        \n            src/auth/oauth2client.ts\n        \n\n\n\n        \n            Index\n            \n                \n                    \n                        \n                            Properties\n                        \n                    \n                    \n                        \n                            \n                                \n                                        headers\n                                \n                                \n                                            Optional\n                                        res\n                                \n                            \n                        \n                    \n                \n            \n        \n\n\n\n            \n                Properties\n                    \n                        \n                                \n                                    \n                                        \n                                        headers\n                                    \n                                \n                                \n                                    \n                                        headers:     Headers\n\n                                    \n                                \n\n\n                                    \n                                        \n                                            Type :     Headers\n\n                                        \n                                    \n\n\n\n\n\n                        \n                    \n                    \n                        \n                                \n                                    \n                                        \n                                        res\n                                    \n                                \n                                \n                                    \n                                        res:     AxiosResponse | null\n\n                                    \n                                \n\n\n                                    \n                                        \n                                            Type :     AxiosResponse | null\n\n                                        \n                                    \n\n                                    \n                                        \n                                            Optional\n                                        \n                                    \n\n\n\n\n                        \n                    \n            \n    \n\n\n    \n        import {AxiosError, AxiosPromise, AxiosRequestConfig, AxiosResponse} from 'axios';\nimport * as crypto from 'crypto';\nimport * as querystring from 'querystring';\nimport * as stream from 'stream';\nimport * as messages from '../messages';\nimport {PemVerifier} from './../pemverifier';\nimport {BodyResponseCallback} from './../transporters';\nimport {AuthClient} from './authclient';\nimport {CredentialRequest, Credentials} from './credentials';\nimport {LoginTicket, TokenPayload} from './loginticket';\n\nexport type Certificates = {\n  [index: string]: string\n};\n\nexport type Headers = {\n  [index: string]: string\n};\n\nexport enum CodeChallengeMethod {\n  Plain = 'plain',\n  S256 = 'S256'\n}\n\nexport interface GetTokenOptions {\n  code: string;\n  codeVerifier?: string;\n  /**\n   * The client ID for your application. The value passed into the constructor\n   * will be used if not provided. Must match any client_id option passed to\n   * a corresponding call to generateAuthUrl.\n   */\n  client_id?: string;\n  /**\n   * Determines where the API server redirects the user after the user\n   * completes the authorization flow. The value passed into the constructor\n   * will be used if not provided. Must match any redirect_uri option passed to\n   * a corresponding call to generateAuthUrl.\n   */\n  redirect_uri?: string;\n}\n\nexport interface TokenInfo {\n  /**\n   * The application that is the intended user of the access token.\n   */\n  aud: string;\n\n  /**\n   * This value lets you correlate profile information from multiple Google\n   * APIs. It is only present in the response if you included the profile scope\n   * in your request in step 1. The field value is an immutable identifier for\n   * the logged-in user that can be used to create and manage user sessions in\n   * your application. The identifier is the same regardless of which client ID\n   * is used to retrieve it. This enables multiple applications in the same\n   * organization to correlate profile information.\n   */\n  user_id?: string;\n\n  /**\n   * An array of scopes that the user granted access to.\n   */\n  scopes: string[];\n\n  /**\n   * The datetime when the token becomes invalid.\n   */\n  expiry_date: number;\n\n  /**\n   * An identifier for the user, unique among all Google accounts and never\n   * reused. A Google account can have multiple emails at different points in\n   * time, but the sub value is never changed. Use sub within your application\n   * as the unique-identifier key for the user.\n   */\n  sub?: string;\n\n  /**\n   * The client_id of the authorized presenter. This claim is only needed when\n   * the party requesting the ID token is not the same as the audience of the ID\n   * token. This may be the case at Google for hybrid apps where a web\n   * application and Android app have a different client_id but share the same\n   * project.\n   */\n  azp?: string;\n\n  /**\n   * Indicates whether your application can refresh access tokens\n   * when the user is not present at the browser. Valid parameter values are\n   * 'online', which is the default value, and 'offline'. Set the value to\n   * 'offline' if your application needs to refresh access tokens when the user\n   * is not present at the browser. This value instructs the Google\n   * authorization server to return a refresh token and an access token the\n   * first time that your application exchanges an authorization code for\n   * tokens.\n   */\n  access_type?: string;\n}\n\ninterface TokenInfoRequest {\n  aud: string;\n  user_id?: string;\n  scope: string;\n  expires_in: number;\n  azp?: string;\n  sub?: string;\n  exp?: number;\n  access_type?: string;\n}\n\nexport interface GenerateAuthUrlOpts {\n  /**\n   * Recommended. Indicates whether your application can refresh access tokens\n   * when the user is not present at the browser. Valid parameter values are\n   * 'online', which is the default value, and 'offline'. Set the value to\n   * 'offline' if your application needs to refresh access tokens when the user\n   * is not present at the browser. This value instructs the Google\n   * authorization server to return a refresh token and an access token the\n   * first time that your application exchanges an authorization code for\n   * tokens.\n   */\n  access_type?: string;\n\n  /**\n   * The hd (hosted domain) parameter streamlines the login process for G Suite\n   * hosted accounts. By including the domain of the G Suite user (for example,\n   * mycollege.edu), you can indicate that the account selection UI should be\n   * optimized for accounts at that domain. To optimize for G Suite accounts\n   * generally instead of just one domain, use an asterisk: hd=*.\n   * Don't rely on this UI optimization to control who can access your app,\n   * as client-side requests can be modified. Be sure to validate that the\n   * returned ID token has an hd claim value that matches what you expect\n   * (e.g. mycolledge.edu). Unlike the request parameter, the ID token claim is\n   * contained within a security token from Google, so the value can be trusted.\n   */\n  hd?: string;\n\n  /**\n   * The 'response_type' will always be set to 'CODE'.\n   */\n  response_type?: string;\n\n  /**\n   * The client ID for your application. The value passed into the constructor\n   * will be used if not provided. You can find this value in the API Console.\n   */\n  client_id?: string;\n\n  /**\n   * Determines where the API server redirects the user after the user\n   * completes the authorization flow. The value must exactly match one of the\n   * 'redirect_uri' values listed for your project in the API Console. Note that\n   * the http or https scheme, case, and trailing slash ('/') must all match.\n   * The value passed into the constructor will be used if not provided.\n   */\n  redirect_uri?: string;\n\n  /**\n   * Required. A space-delimited list of scopes that identify the resources that\n   * your application could access on the user's behalf. These values inform the\n   * consent screen that Google displays to the user. Scopes enable your\n   * application to only request access to the resources that it needs while\n   * also enabling users to control the amount of access that they grant to your\n   * application. Thus, there is an inverse relationship between the number of\n   * scopes requested and the likelihood of obtaining user consent. The\n   * OAuth 2.0 API Scopes document provides a full list of scopes that you might\n   * use to access Google APIs. We recommend that your application request\n   * access to authorization scopes in context whenever possible. By requesting\n   * access to user data in context, via incremental authorization, you help\n   * users to more easily understand why your application needs the access it is\n   * requesting.\n   */\n  scope?: string[]|string;\n\n  /**\n   * Recommended. Specifies any string value that your application uses to\n   * maintain state between your authorization request and the authorization\n   * server's response. The server returns the exact value that you send as a\n   * name=value pair in the hash (#) fragment of the 'redirect_uri' after the\n   * user consents to or denies your application's access request. You can use\n   * this parameter for several purposes, such as directing the user to the\n   * correct resource in your application, sending nonces, and mitigating\n   * cross-site request forgery. Since your redirect_uri can be guessed, using a\n   * state value can increase your assurance that an incoming connection is the\n   * result of an authentication request. If you generate a random string or\n   * encode the hash of a cookie or another value that captures the client's\n   * state, you can validate the response to additionally ensure that the\n   * request and response originated in the same browser, providing protection\n   * against attacks such as cross-site request forgery. See the OpenID Connect\n   * documentation for an example of how to create and confirm a state token.\n   */\n  state?: string;\n\n  /**\n   * Optional. Enables applications to use incremental authorization to request\n   * access to additional scopes in context. If you set this parameter's value\n   * to true and the authorization request is granted, then the new access token\n   * will also cover any scopes to which the user previously granted the\n   * application access. See the incremental authorization section for examples.\n   */\n  include_granted_scopes?: boolean;\n\n  /**\n   * Optional. If your application knows which user is trying to authenticate,\n   * it can use this parameter to provide a hint to the Google Authentication\n   * Server. The server uses the hint to simplify the login flow either by\n   * prefilling the email field in the sign-in form or by selecting the\n   * appropriate multi-login session. Set the parameter value to an email\n   * address or sub identifier, which is equivalent to the user's Google ID.\n   */\n  login_hint?: string;\n\n  /**\n   * Optional. A space-delimited, case-sensitive list of prompts to present the\n   * user. If you don't specify this parameter, the user will be prompted only\n   * the first time your app requests access.  Possible values are:\n   *\n   * 'none' - Donot display any authentication or consent screens. Must not be\n   *        specified with other values.\n   * 'consent' - \tPrompt the user for consent.\n   * 'select_account' - Prompt the user to select an account.\n   */\n  prompt?: string;\n\n  /**\n   * Recommended. Specifies what method was used to encode a 'code_verifier'\n   * that will be used during authorization code exchange. This parameter must\n   * be used with the 'code_challenge' parameter. The value of the\n   * 'code_challenge_method' defaults to \"plain\" if not present in the request\n   * that includes a 'code_challenge'. The only supported values for this\n   * parameter are \"S256\" or \"plain\".\n   */\n  code_challenge_method?: CodeChallengeMethod;\n\n  /**\n   * Recommended. Specifies an encoded 'code_verifier' that will be used as a\n   * server-side challenge during authorization code exchange. This parameter\n   * must be used with the 'code_challenge' parameter described above.\n   */\n  code_challenge?: string;\n}\n\nexport interface GetTokenCallback {\n  (err: AxiosError|null, token?: Credentials|null,\n   res?: AxiosResponse|null): void;\n}\n\nexport interface GetTokenResponse {\n  tokens: Credentials;\n  res: AxiosResponse|null;\n}\n\nexport interface GetAccessTokenCallback {\n  (err: AxiosError|null, token?: string|null, res?: AxiosResponse|null): void;\n}\n\nexport interface GetAccessTokenResponse {\n  token?: string|null;\n  res?: AxiosResponse|null;\n}\n\nexport interface RefreshAccessTokenCallback {\n  (err: AxiosError|null, credentials?: Credentials|null,\n   res?: AxiosResponse|null): void;\n}\n\nexport interface RefreshAccessTokenResponse {\n  credentials: Credentials;\n  res: AxiosResponse|null;\n}\n\nexport interface RequestMetadataResponse {\n  headers: Headers;\n  res?: AxiosResponse|null;\n}\n\nexport interface RequestMetadataCallback {\n  (err: AxiosError|null, headers?: Headers,\n   res?: AxiosResponse|null): void;\n}\n\nexport interface GetFederatedSignonCertsCallback {\n  (err: AxiosError|null, certs?: Certificates,\n   response?: AxiosResponse|null): void;\n}\n\nexport interface FederatedSignonCertsResponse {\n  certs: Certificates;\n  res?: AxiosResponse|null;\n}\n\nexport interface RevokeCredentialsResult {\n  success: boolean;\n}\n\nexport interface VerifyIdTokenOptions {\n  idToken: string;\n  audience: string|string[];\n  maxExpiry?: number;\n}\n\nexport interface OAuth2ClientOptions extends RefreshOptions {\n  clientId?: string;\n  clientSecret?: string;\n  redirectUri?: string;\n}\n\nexport interface RefreshOptions {\n  // Eagerly refresh unexpired tokens when they are within this many\n  // milliseconds from expiring\".\n  // Defaults to a value of 300000 (5 minutes).\n  eagerRefreshThresholdMillis?: number;\n}\n\nexport class OAuth2Client extends AuthClient {\n  private redirectUri?: string;\n  private certificateCache?: Certificates;\n  private certificateExpiry: Date|null = null;\n  protected refreshTokenPromises = new Map>();\n\n  // TODO: refactor tests to make this private\n  _clientId?: string;\n\n  // TODO: refactor tests to make this private\n  _clientSecret?: string;\n\n  apiKey?: string;\n\n  projectId?: string;\n\n  eagerRefreshThresholdMillis: number;\n\n  /**\n   * Handles OAuth2 flow for Google APIs.\n   *\n   * @param clientId The authentication client ID.\n   * @param clientSecret The authentication client secret.\n   * @param redirectUri The URI to redirect to after completing the auth\n   * request.\n   * @param opts optional options for overriding the given parameters.\n   * @constructor\n   */\n  constructor(options?: OAuth2ClientOptions);\n  constructor(clientId?: string, clientSecret?: string, redirectUri?: string);\n  constructor(\n      optionsOrClientId?: string|OAuth2ClientOptions, clientSecret?: string,\n      redirectUri?: string) {\n    super();\n    const opts = (optionsOrClientId && typeof optionsOrClientId === 'object') ?\n        optionsOrClientId :\n        {clientId: optionsOrClientId, clientSecret, redirectUri};\n    this._clientId = opts.clientId;\n    this._clientSecret = opts.clientSecret;\n    this.redirectUri = opts.redirectUri;\n    this.eagerRefreshThresholdMillis =\n        opts.eagerRefreshThresholdMillis || 5 * 60 * 1000;\n  }\n\n  protected static readonly GOOGLE_TOKEN_INFO_URL =\n      'https://oauth2.googleapis.com/tokeninfo';\n\n  /**\n   * The base URL for auth endpoints.\n   */\n  private static readonly GOOGLE_OAUTH2_AUTH_BASE_URL_ =\n      'https://accounts.google.com/o/oauth2/v2/auth';\n\n  /**\n   * The base endpoint for token retrieval.\n   */\n  private static readonly GOOGLE_OAUTH2_TOKEN_URL_ =\n      'https://oauth2.googleapis.com/token';\n\n  /**\n   * The base endpoint to revoke tokens.\n   */\n  private static readonly GOOGLE_OAUTH2_REVOKE_URL_ =\n      'https://oauth2.googleapis.com/revoke';\n\n  /**\n   * Google Sign on certificates.\n   */\n  private static readonly GOOGLE_OAUTH2_FEDERATED_SIGNON_CERTS_URL_ =\n      'https://www.googleapis.com/oauth2/v1/certs';\n\n  /**\n   * Clock skew - five minutes in seconds\n   */\n  private static readonly CLOCK_SKEW_SECS_ = 300;\n\n  /**\n   * Max Token Lifetime is one day in seconds\n   */\n  private static readonly MAX_TOKEN_LIFETIME_SECS_ = 86400;\n\n  /**\n   * The allowed oauth token issuers.\n   */\n  private static readonly ISSUERS_ =\n      ['accounts.google.com', 'https://accounts.google.com'];\n\n  /**\n   * Generates URL for consent page landing.\n   * @param opts Options.\n   * @return URL to consent page.\n   */\n  generateAuthUrl(opts: GenerateAuthUrlOpts = {}) {\n    if (opts.code_challenge_method && !opts.code_challenge) {\n      throw new Error(\n          'If a code_challenge_method is provided, code_challenge must be included.');\n    }\n    opts.response_type = opts.response_type || 'code';\n    opts.client_id = opts.client_id || this._clientId;\n    opts.redirect_uri = opts.redirect_uri || this.redirectUri;\n    // Allow scopes to be passed either as array or a string\n    if (opts.scope instanceof Array) {\n      opts.scope = opts.scope.join(' ');\n    }\n    const rootUrl = OAuth2Client.GOOGLE_OAUTH2_AUTH_BASE_URL_;\n    return rootUrl + '?' + querystring.stringify(opts);\n  }\n\n  /**\n   * Convenience method to automatically generate a code_verifier, and it's\n   * resulting SHA256. If used, this must be paired with a S256\n   * code_challenge_method.\n   */\n  generateCodeVerifier() {\n    // base64 encoding uses 6 bits per character, and we want to generate128\n    // characters. 6*128/8 = 96.\n    const randomString = crypto.randomBytes(96).toString('base64');\n    // The valid characters in the code_verifier are [A-Z]/[a-z]/[0-9]/\n    // \"-\"/\".\"/\"_\"/\"~\". Base64 encoded strings are pretty close, so we're just\n    // swapping out a few chars.\n    const codeVerifier =\n        randomString.replace(/\\+/g, '~').replace(/=/g, '_').replace(/\\//g, '-');\n    // Generate the base64 encoded SHA256\n    const unencodedCodeChallenge =\n        crypto.createHash('sha256').update(codeVerifier).digest('base64');\n    // We need to use base64UrlEncoding instead of standard base64\n    const codeChallenge = unencodedCodeChallenge.split('=')[0]\n                              .replace(/\\+/g, '-')\n                              .replace(/\\//g, '_');\n    return {codeVerifier, codeChallenge};\n  }\n\n  /**\n   * Gets the access token for the given code.\n   * @param code The authorization code.\n   * @param callback Optional callback fn.\n   */\n  getToken(code: string): Promise;\n  getToken(options: GetTokenOptions): Promise;\n  getToken(code: string, callback: GetTokenCallback): void;\n  getToken(options: GetTokenOptions, callback: GetTokenCallback): void;\n  getToken(codeOrOptions: string|GetTokenOptions, callback?: GetTokenCallback):\n      Promise|void {\n    const options = (typeof codeOrOptions === 'string') ?\n        {code: codeOrOptions} :\n        codeOrOptions;\n    if (callback) {\n      this.getTokenAsync(options).then(\n          r => callback(null, r.tokens, r.res),\n          e => callback(e, null, e.response));\n    } else {\n      return this.getTokenAsync(options);\n    }\n  }\n\n  private async getTokenAsync(options: GetTokenOptions):\n      Promise {\n    const url = OAuth2Client.GOOGLE_OAUTH2_TOKEN_URL_;\n    const values = {\n      code: options.code,\n      client_id: options.client_id || this._clientId,\n      client_secret: this._clientSecret,\n      redirect_uri: options.redirect_uri || this.redirectUri,\n      grant_type: 'authorization_code',\n      code_verifier: options.codeVerifier\n    };\n    const res = await this.transporter.request({\n      method: 'POST',\n      url,\n      data: querystring.stringify(values),\n      headers: {'Content-Type': 'application/x-www-form-urlencoded'}\n    });\n    const tokens = res.data as Credentials;\n    if (res.data && res.data.expires_in) {\n      tokens.expiry_date =\n          ((new Date()).getTime() + (res.data.expires_in * 1000));\n      delete (tokens as CredentialRequest).expires_in;\n    }\n    this.emit('tokens', tokens);\n    return {tokens, res};\n  }\n\n  /**\n   * Refreshes the access token.\n   * @param refresh_token Existing refresh token.\n   * @private\n   */\n  protected async refreshToken(refreshToken?: string|\n                               null): Promise {\n    if (!refreshToken) {\n      return this.refreshTokenNoCache(refreshToken);\n    }\n    // If a request to refresh using the same token has started,\n    // return the same promise.\n    if (this.refreshTokenPromises.has(refreshToken)) {\n      return this.refreshTokenPromises.get(refreshToken)!;\n    }\n\n    const p = this.refreshTokenNoCache(refreshToken)\n                  .then(\n                      r => {\n                        this.refreshTokenPromises.delete(refreshToken);\n                        return r;\n                      },\n                      e => {\n                        this.refreshTokenPromises.delete(refreshToken);\n                        throw e;\n                      });\n    this.refreshTokenPromises.set(refreshToken, p);\n    return p;\n  }\n\n  protected async refreshTokenNoCache(refreshToken?: string|\n                                      null): Promise {\n    const url = OAuth2Client.GOOGLE_OAUTH2_TOKEN_URL_;\n    const data = {\n      refresh_token: refreshToken,\n      client_id: this._clientId,\n      client_secret: this._clientSecret,\n      grant_type: 'refresh_token'\n    };\n\n    // request for new token\n    const res = await this.transporter.request({\n      method: 'POST',\n      url,\n      data: querystring.stringify(data),\n      headers: {'Content-Type': 'application/x-www-form-urlencoded'}\n    });\n\n    const tokens = res.data as Credentials;\n    // TODO: de-duplicate this code from a few spots\n    if (res.data && res.data.expires_in) {\n      tokens.expiry_date =\n          ((new Date()).getTime() + (res.data.expires_in * 1000));\n      delete (tokens as CredentialRequest).expires_in;\n    }\n    this.emit('tokens', tokens);\n    return {tokens, res};\n  }\n\n  /**\n   * Retrieves the access token using refresh token\n   *\n   * @deprecated use getRequestHeaders instead.\n   * @param callback callback\n   */\n  refreshAccessToken(): Promise;\n  refreshAccessToken(callback: RefreshAccessTokenCallback): void;\n  refreshAccessToken(callback?: RefreshAccessTokenCallback):\n      Promise|void {\n    messages.warn(messages.REFRESH_ACCESS_TOKEN_DEPRECATED);\n    if (callback) {\n      this.refreshAccessTokenAsync().then(\n          r => callback(null, r.credentials, r.res), callback);\n    } else {\n      return this.refreshAccessTokenAsync();\n    }\n  }\n\n  private async refreshAccessTokenAsync() {\n    if (!this.credentials.refresh_token) {\n      throw new Error('No refresh token is set.');\n    }\n    const r = await this.refreshToken(this.credentials.refresh_token);\n    const tokens = r.tokens as Credentials;\n    tokens.refresh_token = this.credentials.refresh_token;\n    this.credentials = tokens;\n    return {credentials: this.credentials, res: r.res};\n  }\n\n  /**\n   * Get a non-expired access token, after refreshing if necessary\n   *\n   * @param callback Callback to call with the access token\n   */\n  getAccessToken(): Promise;\n  getAccessToken(callback: GetAccessTokenCallback): void;\n  getAccessToken(callback?: GetAccessTokenCallback):\n      Promise|void {\n    if (callback) {\n      this.getAccessTokenAsync().then(\n          r => callback(null, r.token, r.res), callback);\n    } else {\n      return this.getAccessTokenAsync();\n    }\n  }\n\n  private async getAccessTokenAsync(): Promise {\n    const shouldRefresh =\n        !this.credentials.access_token || this.isTokenExpiring();\n    if (shouldRefresh && this.credentials.refresh_token) {\n      if (!this.credentials.refresh_token) {\n        throw new Error('No refresh token is set.');\n      }\n\n      const r = await this.refreshAccessTokenAsync();\n      if (!r.credentials || (r.credentials && !r.credentials.access_token)) {\n        throw new Error('Could not refresh access token.');\n      }\n      return {token: r.credentials.access_token, res: r.res};\n    } else {\n      return {token: this.credentials.access_token};\n    }\n  }\n\n  /**\n   * Obtain the set of headers required to authenticate a request.\n   *\n   * @deprecated Use getRequestHeaders instead.\n   * @param url the Uri being authorized\n   * @param callback the func described above\n   */\n  getRequestMetadata(url?: string|null): Promise;\n  getRequestMetadata(url: string|null, callback: RequestMetadataCallback): void;\n  getRequestMetadata(url: string|null, callback?: RequestMetadataCallback):\n      Promise|void {\n    messages.warn(messages.OAUTH_GET_REQUEST_METADATA_DEPRECATED);\n    if (callback) {\n      this.getRequestMetadataAsync(url).then(\n          r => callback(null, r.headers, r.res), callback);\n    } else {\n      return this.getRequestMetadataAsync();\n    }\n  }\n\n  /**\n   * The main authentication interface.  It takes an optional url which when\n   * present is the endpoint being accessed, and returns a Promise which\n   * resolves with authorization header fields.\n   *\n   * In OAuth2Client, the result has the form:\n   * { Authorization: 'Bearer ' }\n   * @param url The optional url being authorized\n   */\n  async getRequestHeaders(url?: string): Promise {\n    const res = await this.getRequestMetadataAsync(url);\n    return res.headers;\n  }\n\n  protected async getRequestMetadataAsync(url?: string|null):\n      Promise {\n    const thisCreds = this.credentials;\n    if (!thisCreds.access_token && !thisCreds.refresh_token && !this.apiKey) {\n      throw new Error('No access, refresh token or API key is set.');\n    }\n\n    if (thisCreds.access_token && !this.isTokenExpiring()) {\n      thisCreds.token_type = thisCreds.token_type || 'Bearer';\n      const headers = {\n        Authorization: thisCreds.token_type + ' ' + thisCreds.access_token\n      };\n      return {headers};\n    }\n\n    if (this.apiKey) {\n      return {headers: {}};\n    }\n    let r: GetTokenResponse|null = null;\n    let tokens: Credentials|null = null;\n    try {\n      r = await this.refreshToken(thisCreds.refresh_token);\n      tokens = r.tokens;\n    } catch (err) {\n      const e = err as AxiosError;\n      if (e.response &&\n          (e.response.status === 403 || e.response.status === 404)) {\n        e.message = 'Could not refresh access token.';\n      }\n      throw e;\n    }\n\n    const credentials = this.credentials;\n    credentials.token_type = credentials.token_type || 'Bearer';\n    tokens.refresh_token = credentials.refresh_token;\n    this.credentials = tokens;\n    const headers = {\n      Authorization: credentials.token_type + ' ' + tokens.access_token\n    };\n    return {headers, res: r.res};\n  }\n\n  /**\n   * Revokes the access given to token.\n   * @param token The existing token to be revoked.\n   * @param callback Optional callback fn.\n   */\n  revokeToken(token: string): AxiosPromise;\n  revokeToken(\n      token: string,\n      callback: BodyResponseCallback): void;\n  revokeToken(\n      token: string, callback?: BodyResponseCallback):\n      AxiosPromise|void {\n    const opts = {\n      url: OAuth2Client.GOOGLE_OAUTH2_REVOKE_URL_ + '?' +\n          querystring.stringify({token}),\n      method: 'POST'\n    };\n    if (callback) {\n      this.transporter.request(opts).then(\n          r => callback(null, r), callback);\n    } else {\n      return this.transporter.request(opts);\n    }\n  }\n\n\n  /**\n   * Revokes access token and clears the credentials object\n   * @param callback callback\n   */\n  revokeCredentials(): AxiosPromise;\n  revokeCredentials(callback: BodyResponseCallback):\n      void;\n  revokeCredentials(callback?: BodyResponseCallback):\n      AxiosPromise|void {\n    if (callback) {\n      this.revokeCredentialsAsync().then(res => callback(null, res), callback);\n    } else {\n      return this.revokeCredentialsAsync();\n    }\n  }\n\n  private async revokeCredentialsAsync() {\n    const token = this.credentials.access_token;\n    this.credentials = {};\n    if (token) {\n      return this.revokeToken(token);\n    } else {\n      throw new Error('No access token to revoke.');\n    }\n  }\n\n  /**\n   * Provides a request implementation with OAuth 2.0 flow. If credentials have\n   * a refresh_token, in cases of HTTP 401 and 403 responses, it automatically\n   * asks for a new access token and replays the unsuccessful request.\n   * @param opts Request options.\n   * @param callback callback.\n   * @return Request object\n   */\n  request(opts: AxiosRequestConfig): AxiosPromise;\n  request(opts: AxiosRequestConfig, callback: BodyResponseCallback): void;\n  request(opts: AxiosRequestConfig, callback?: BodyResponseCallback):\n      AxiosPromise|void {\n    if (callback) {\n      this.requestAsync(opts).then(r => callback(null, r), e => {\n        return callback(e, e.response);\n      });\n    } else {\n      return this.requestAsync(opts);\n    }\n  }\n\n  protected async requestAsync(opts: AxiosRequestConfig, retry = false):\n      Promise> {\n    let r2: AxiosResponse;\n    try {\n      const r = await this.getRequestMetadataAsync(opts.url);\n      if (r.headers && r.headers.Authorization) {\n        opts.headers = opts.headers || {};\n        opts.headers.Authorization = r.headers.Authorization;\n      }\n\n      if (this.apiKey) {\n        opts.params = Object.assign(opts.params || {}, {key: this.apiKey});\n      }\n      r2 = await this.transporter.request(opts);\n    } catch (e) {\n      const res = (e as AxiosError).response;\n      if (res) {\n        const statusCode = res.status;\n        // Retry the request for metadata if the following criteria are true:\n        // - We haven't already retried.  It only makes sense to retry once.\n        // - The response was a 401 or a 403\n        // - The request didn't send a readableStream\n        // - An access_token and refresh_token were available, but no\n        //   expiry_date was availabe. This can happen when developers stash\n        //   the access_token and refresh_token for later use, but the\n        //   access_token fails on the first try because it's expired.\n        const mayRequireRefresh = this.credentials &&\n            this.credentials.access_token && this.credentials.refresh_token &&\n            !this.credentials.expiry_date;\n        const isReadableStream = res.config.data instanceof stream.Readable;\n        const isAuthErr = statusCode === 401 || statusCode === 403;\n        if (!retry && isAuthErr && !isReadableStream && mayRequireRefresh) {\n          await this.refreshAccessTokenAsync();\n          return this.requestAsync(opts, true);\n        }\n      }\n      throw e;\n    }\n    return r2;\n  }\n\n  /**\n   * Verify id token is token by checking the certs and audience\n   * @param options that contains all options.\n   * @param callback Callback supplying GoogleLogin if successful\n   */\n  verifyIdToken(options: VerifyIdTokenOptions): Promise;\n  verifyIdToken(\n      options: VerifyIdTokenOptions,\n      callback: (err: Error|null, login?: LoginTicket) => void): void;\n  verifyIdToken(\n      options: VerifyIdTokenOptions,\n      callback?: (err: Error|null, login?: LoginTicket) => void):\n      void|Promise {\n    // This function used to accept two arguments instead of an options object.\n    // Check the types to help users upgrade with less pain.\n    // This check can be removed after a 2.0 release.\n    if (callback && typeof callback !== 'function') {\n      throw new Error(\n          'This method accepts an options object as the first parameter, which includes the idToken, audience, and maxExpiry.');\n    }\n\n    if (callback) {\n      this.verifyIdTokenAsync(options).then(r => callback(null, r), callback);\n    } else {\n      return this.verifyIdTokenAsync(options);\n    }\n  }\n\n  private async verifyIdTokenAsync(options: VerifyIdTokenOptions):\n      Promise {\n    if (!options.idToken) {\n      throw new Error('The verifyIdToken method requires an ID Token');\n    }\n\n    const response = await this.getFederatedSignonCertsAsync();\n    const login = this.verifySignedJwtWithCerts(\n        options.idToken, response.certs, options.audience,\n        OAuth2Client.ISSUERS_, options.maxExpiry);\n\n    return login;\n  }\n\n  /**\n   * Obtains information about the provisioned access token.  Especially useful\n   * if you want to check the scopes that were provisioned to a given token.\n   *\n   * @param accessToken Required.  The Access Token for which you want to get\n   * user info.\n   */\n  async getTokenInfo(accessToken: string): Promise {\n    const {data} = await this.transporter.request({\n      method: 'GET',\n      url: OAuth2Client.GOOGLE_TOKEN_INFO_URL,\n      params: {access_token: accessToken}\n    });\n    const info = Object.assign(\n        {\n          expiry_date: ((new Date()).getTime() + (data.expires_in * 1000)),\n          scopes: data.scope.split(' ')\n        },\n        data);\n    delete info.expires_in;\n    delete info.scope;\n    return info;\n  }\n\n  /**\n   * Gets federated sign-on certificates to use for verifying identity tokens.\n   * Returns certs as array structure, where keys are key ids, and values\n   * are PEM encoded certificates.\n   * @param callback Callback supplying the certificates\n   */\n  getFederatedSignonCerts(): Promise;\n  getFederatedSignonCerts(callback: GetFederatedSignonCertsCallback): void;\n  getFederatedSignonCerts(callback?: GetFederatedSignonCertsCallback):\n      Promise|void {\n    if (callback) {\n      this.getFederatedSignonCertsAsync().then(\n          r => callback(null, r.certs, r.res), callback);\n    } else {\n      return this.getFederatedSignonCertsAsync();\n    }\n  }\n\n  async getFederatedSignonCertsAsync(): Promise {\n    const nowTime = (new Date()).getTime();\n    if (this.certificateExpiry &&\n        (nowTime = now + maxExpiry) {\n      throw new Error(\n          'Expiration time too far in future: ' + JSON.stringify(payload));\n    }\n\n    const earliest = iat - OAuth2Client.CLOCK_SKEW_SECS_;\n    const latest = exp + OAuth2Client.CLOCK_SKEW_SECS_;\n\n    if (now  latest) {\n      throw new Error(\n          'Token used too late, ' + now + ' > ' + latest + ': ' +\n          JSON.stringify(payload));\n    }\n\n    if (issuers && issuers.indexOf(payload.iss)  -1);\n      } else {\n        audVerified = (aud === requiredAudience);\n      }\n      if (!audVerified) {\n        throw new Error(\n            'Wrong recipient, payload audience != requiredAudience');\n      }\n    }\n    return new LoginTicket(envelope, payload);\n  }\n\n  /**\n   * This is a utils method to decode a base64 string\n   * @param b64String The string to base64 decode\n   * @return The decoded string\n   */\n  decodeBase64(b64String: string) {\n    const buffer = Buffer.from(b64String, 'base64');\n    return buffer.toString('utf8');\n  }\n\n  /**\n   * Returns true if a token is expired or will expire within\n   * eagerRefreshThresholdMillismilliseconds.\n   * If there is no expiry time, assumes the token is not expired or expiring.\n   */\n  protected isTokenExpiring(): boolean {\n    const expiryDate = this.credentials.expiry_date;\n    return expiryDate ? expiryDate \n    \n\n\n\n\n\n\n\n                   \n    \n         result-matching \"\"\n        \n    \n    \n        No results matching \"\"\n    \n\n"},"interfaces/RevokeCredentialsResult.html":{"url":"interfaces/RevokeCredentialsResult.html","title":"interface - RevokeCredentialsResult","body":"\n                   \n\n\n\n\n\n\n\n\n\n\n\n\n\n  Interfaces\n  RevokeCredentialsResult\n\n\n\n        \n            Info\n        \n        \n            Source\n        \n\n\n\n    \n        \n            File\n        \n        \n            src/auth/oauth2client.ts\n        \n\n\n\n        \n            Index\n            \n                \n                    \n                        \n                            Properties\n                        \n                    \n                    \n                        \n                            \n                                \n                                        success\n                                \n                            \n                        \n                    \n                \n            \n        \n\n\n\n            \n                Properties\n                    \n                        \n                                \n                                    \n                                        \n                                        success\n                                    \n                                \n                                \n                                    \n                                        success:     boolean\n\n                                    \n                                \n\n\n                                    \n                                        \n                                            Type :     boolean\n\n                                        \n                                    \n\n\n\n\n\n                        \n                    \n            \n    \n\n\n    \n        import {AxiosError, AxiosPromise, AxiosRequestConfig, AxiosResponse} from 'axios';\nimport * as crypto from 'crypto';\nimport * as querystring from 'querystring';\nimport * as stream from 'stream';\nimport * as messages from '../messages';\nimport {PemVerifier} from './../pemverifier';\nimport {BodyResponseCallback} from './../transporters';\nimport {AuthClient} from './authclient';\nimport {CredentialRequest, Credentials} from './credentials';\nimport {LoginTicket, TokenPayload} from './loginticket';\n\nexport type Certificates = {\n  [index: string]: string\n};\n\nexport type Headers = {\n  [index: string]: string\n};\n\nexport enum CodeChallengeMethod {\n  Plain = 'plain',\n  S256 = 'S256'\n}\n\nexport interface GetTokenOptions {\n  code: string;\n  codeVerifier?: string;\n  /**\n   * The client ID for your application. The value passed into the constructor\n   * will be used if not provided. Must match any client_id option passed to\n   * a corresponding call to generateAuthUrl.\n   */\n  client_id?: string;\n  /**\n   * Determines where the API server redirects the user after the user\n   * completes the authorization flow. The value passed into the constructor\n   * will be used if not provided. Must match any redirect_uri option passed to\n   * a corresponding call to generateAuthUrl.\n   */\n  redirect_uri?: string;\n}\n\nexport interface TokenInfo {\n  /**\n   * The application that is the intended user of the access token.\n   */\n  aud: string;\n\n  /**\n   * This value lets you correlate profile information from multiple Google\n   * APIs. It is only present in the response if you included the profile scope\n   * in your request in step 1. The field value is an immutable identifier for\n   * the logged-in user that can be used to create and manage user sessions in\n   * your application. The identifier is the same regardless of which client ID\n   * is used to retrieve it. This enables multiple applications in the same\n   * organization to correlate profile information.\n   */\n  user_id?: string;\n\n  /**\n   * An array of scopes that the user granted access to.\n   */\n  scopes: string[];\n\n  /**\n   * The datetime when the token becomes invalid.\n   */\n  expiry_date: number;\n\n  /**\n   * An identifier for the user, unique among all Google accounts and never\n   * reused. A Google account can have multiple emails at different points in\n   * time, but the sub value is never changed. Use sub within your application\n   * as the unique-identifier key for the user.\n   */\n  sub?: string;\n\n  /**\n   * The client_id of the authorized presenter. This claim is only needed when\n   * the party requesting the ID token is not the same as the audience of the ID\n   * token. This may be the case at Google for hybrid apps where a web\n   * application and Android app have a different client_id but share the same\n   * project.\n   */\n  azp?: string;\n\n  /**\n   * Indicates whether your application can refresh access tokens\n   * when the user is not present at the browser. Valid parameter values are\n   * 'online', which is the default value, and 'offline'. Set the value to\n   * 'offline' if your application needs to refresh access tokens when the user\n   * is not present at the browser. This value instructs the Google\n   * authorization server to return a refresh token and an access token the\n   * first time that your application exchanges an authorization code for\n   * tokens.\n   */\n  access_type?: string;\n}\n\ninterface TokenInfoRequest {\n  aud: string;\n  user_id?: string;\n  scope: string;\n  expires_in: number;\n  azp?: string;\n  sub?: string;\n  exp?: number;\n  access_type?: string;\n}\n\nexport interface GenerateAuthUrlOpts {\n  /**\n   * Recommended. Indicates whether your application can refresh access tokens\n   * when the user is not present at the browser. Valid parameter values are\n   * 'online', which is the default value, and 'offline'. Set the value to\n   * 'offline' if your application needs to refresh access tokens when the user\n   * is not present at the browser. This value instructs the Google\n   * authorization server to return a refresh token and an access token the\n   * first time that your application exchanges an authorization code for\n   * tokens.\n   */\n  access_type?: string;\n\n  /**\n   * The hd (hosted domain) parameter streamlines the login process for G Suite\n   * hosted accounts. By including the domain of the G Suite user (for example,\n   * mycollege.edu), you can indicate that the account selection UI should be\n   * optimized for accounts at that domain. To optimize for G Suite accounts\n   * generally instead of just one domain, use an asterisk: hd=*.\n   * Don't rely on this UI optimization to control who can access your app,\n   * as client-side requests can be modified. Be sure to validate that the\n   * returned ID token has an hd claim value that matches what you expect\n   * (e.g. mycolledge.edu). Unlike the request parameter, the ID token claim is\n   * contained within a security token from Google, so the value can be trusted.\n   */\n  hd?: string;\n\n  /**\n   * The 'response_type' will always be set to 'CODE'.\n   */\n  response_type?: string;\n\n  /**\n   * The client ID for your application. The value passed into the constructor\n   * will be used if not provided. You can find this value in the API Console.\n   */\n  client_id?: string;\n\n  /**\n   * Determines where the API server redirects the user after the user\n   * completes the authorization flow. The value must exactly match one of the\n   * 'redirect_uri' values listed for your project in the API Console. Note that\n   * the http or https scheme, case, and trailing slash ('/') must all match.\n   * The value passed into the constructor will be used if not provided.\n   */\n  redirect_uri?: string;\n\n  /**\n   * Required. A space-delimited list of scopes that identify the resources that\n   * your application could access on the user's behalf. These values inform the\n   * consent screen that Google displays to the user. Scopes enable your\n   * application to only request access to the resources that it needs while\n   * also enabling users to control the amount of access that they grant to your\n   * application. Thus, there is an inverse relationship between the number of\n   * scopes requested and the likelihood of obtaining user consent. The\n   * OAuth 2.0 API Scopes document provides a full list of scopes that you might\n   * use to access Google APIs. We recommend that your application request\n   * access to authorization scopes in context whenever possible. By requesting\n   * access to user data in context, via incremental authorization, you help\n   * users to more easily understand why your application needs the access it is\n   * requesting.\n   */\n  scope?: string[]|string;\n\n  /**\n   * Recommended. Specifies any string value that your application uses to\n   * maintain state between your authorization request and the authorization\n   * server's response. The server returns the exact value that you send as a\n   * name=value pair in the hash (#) fragment of the 'redirect_uri' after the\n   * user consents to or denies your application's access request. You can use\n   * this parameter for several purposes, such as directing the user to the\n   * correct resource in your application, sending nonces, and mitigating\n   * cross-site request forgery. Since your redirect_uri can be guessed, using a\n   * state value can increase your assurance that an incoming connection is the\n   * result of an authentication request. If you generate a random string or\n   * encode the hash of a cookie or another value that captures the client's\n   * state, you can validate the response to additionally ensure that the\n   * request and response originated in the same browser, providing protection\n   * against attacks such as cross-site request forgery. See the OpenID Connect\n   * documentation for an example of how to create and confirm a state token.\n   */\n  state?: string;\n\n  /**\n   * Optional. Enables applications to use incremental authorization to request\n   * access to additional scopes in context. If you set this parameter's value\n   * to true and the authorization request is granted, then the new access token\n   * will also cover any scopes to which the user previously granted the\n   * application access. See the incremental authorization section for examples.\n   */\n  include_granted_scopes?: boolean;\n\n  /**\n   * Optional. If your application knows which user is trying to authenticate,\n   * it can use this parameter to provide a hint to the Google Authentication\n   * Server. The server uses the hint to simplify the login flow either by\n   * prefilling the email field in the sign-in form or by selecting the\n   * appropriate multi-login session. Set the parameter value to an email\n   * address or sub identifier, which is equivalent to the user's Google ID.\n   */\n  login_hint?: string;\n\n  /**\n   * Optional. A space-delimited, case-sensitive list of prompts to present the\n   * user. If you don't specify this parameter, the user will be prompted only\n   * the first time your app requests access.  Possible values are:\n   *\n   * 'none' - Donot display any authentication or consent screens. Must not be\n   *        specified with other values.\n   * 'consent' - \tPrompt the user for consent.\n   * 'select_account' - Prompt the user to select an account.\n   */\n  prompt?: string;\n\n  /**\n   * Recommended. Specifies what method was used to encode a 'code_verifier'\n   * that will be used during authorization code exchange. This parameter must\n   * be used with the 'code_challenge' parameter. The value of the\n   * 'code_challenge_method' defaults to \"plain\" if not present in the request\n   * that includes a 'code_challenge'. The only supported values for this\n   * parameter are \"S256\" or \"plain\".\n   */\n  code_challenge_method?: CodeChallengeMethod;\n\n  /**\n   * Recommended. Specifies an encoded 'code_verifier' that will be used as a\n   * server-side challenge during authorization code exchange. This parameter\n   * must be used with the 'code_challenge' parameter described above.\n   */\n  code_challenge?: string;\n}\n\nexport interface GetTokenCallback {\n  (err: AxiosError|null, token?: Credentials|null,\n   res?: AxiosResponse|null): void;\n}\n\nexport interface GetTokenResponse {\n  tokens: Credentials;\n  res: AxiosResponse|null;\n}\n\nexport interface GetAccessTokenCallback {\n  (err: AxiosError|null, token?: string|null, res?: AxiosResponse|null): void;\n}\n\nexport interface GetAccessTokenResponse {\n  token?: string|null;\n  res?: AxiosResponse|null;\n}\n\nexport interface RefreshAccessTokenCallback {\n  (err: AxiosError|null, credentials?: Credentials|null,\n   res?: AxiosResponse|null): void;\n}\n\nexport interface RefreshAccessTokenResponse {\n  credentials: Credentials;\n  res: AxiosResponse|null;\n}\n\nexport interface RequestMetadataResponse {\n  headers: Headers;\n  res?: AxiosResponse|null;\n}\n\nexport interface RequestMetadataCallback {\n  (err: AxiosError|null, headers?: Headers,\n   res?: AxiosResponse|null): void;\n}\n\nexport interface GetFederatedSignonCertsCallback {\n  (err: AxiosError|null, certs?: Certificates,\n   response?: AxiosResponse|null): void;\n}\n\nexport interface FederatedSignonCertsResponse {\n  certs: Certificates;\n  res?: AxiosResponse|null;\n}\n\nexport interface RevokeCredentialsResult {\n  success: boolean;\n}\n\nexport interface VerifyIdTokenOptions {\n  idToken: string;\n  audience: string|string[];\n  maxExpiry?: number;\n}\n\nexport interface OAuth2ClientOptions extends RefreshOptions {\n  clientId?: string;\n  clientSecret?: string;\n  redirectUri?: string;\n}\n\nexport interface RefreshOptions {\n  // Eagerly refresh unexpired tokens when they are within this many\n  // milliseconds from expiring\".\n  // Defaults to a value of 300000 (5 minutes).\n  eagerRefreshThresholdMillis?: number;\n}\n\nexport class OAuth2Client extends AuthClient {\n  private redirectUri?: string;\n  private certificateCache?: Certificates;\n  private certificateExpiry: Date|null = null;\n  protected refreshTokenPromises = new Map>();\n\n  // TODO: refactor tests to make this private\n  _clientId?: string;\n\n  // TODO: refactor tests to make this private\n  _clientSecret?: string;\n\n  apiKey?: string;\n\n  projectId?: string;\n\n  eagerRefreshThresholdMillis: number;\n\n  /**\n   * Handles OAuth2 flow for Google APIs.\n   *\n   * @param clientId The authentication client ID.\n   * @param clientSecret The authentication client secret.\n   * @param redirectUri The URI to redirect to after completing the auth\n   * request.\n   * @param opts optional options for overriding the given parameters.\n   * @constructor\n   */\n  constructor(options?: OAuth2ClientOptions);\n  constructor(clientId?: string, clientSecret?: string, redirectUri?: string);\n  constructor(\n      optionsOrClientId?: string|OAuth2ClientOptions, clientSecret?: string,\n      redirectUri?: string) {\n    super();\n    const opts = (optionsOrClientId && typeof optionsOrClientId === 'object') ?\n        optionsOrClientId :\n        {clientId: optionsOrClientId, clientSecret, redirectUri};\n    this._clientId = opts.clientId;\n    this._clientSecret = opts.clientSecret;\n    this.redirectUri = opts.redirectUri;\n    this.eagerRefreshThresholdMillis =\n        opts.eagerRefreshThresholdMillis || 5 * 60 * 1000;\n  }\n\n  protected static readonly GOOGLE_TOKEN_INFO_URL =\n      'https://oauth2.googleapis.com/tokeninfo';\n\n  /**\n   * The base URL for auth endpoints.\n   */\n  private static readonly GOOGLE_OAUTH2_AUTH_BASE_URL_ =\n      'https://accounts.google.com/o/oauth2/v2/auth';\n\n  /**\n   * The base endpoint for token retrieval.\n   */\n  private static readonly GOOGLE_OAUTH2_TOKEN_URL_ =\n      'https://oauth2.googleapis.com/token';\n\n  /**\n   * The base endpoint to revoke tokens.\n   */\n  private static readonly GOOGLE_OAUTH2_REVOKE_URL_ =\n      'https://oauth2.googleapis.com/revoke';\n\n  /**\n   * Google Sign on certificates.\n   */\n  private static readonly GOOGLE_OAUTH2_FEDERATED_SIGNON_CERTS_URL_ =\n      'https://www.googleapis.com/oauth2/v1/certs';\n\n  /**\n   * Clock skew - five minutes in seconds\n   */\n  private static readonly CLOCK_SKEW_SECS_ = 300;\n\n  /**\n   * Max Token Lifetime is one day in seconds\n   */\n  private static readonly MAX_TOKEN_LIFETIME_SECS_ = 86400;\n\n  /**\n   * The allowed oauth token issuers.\n   */\n  private static readonly ISSUERS_ =\n      ['accounts.google.com', 'https://accounts.google.com'];\n\n  /**\n   * Generates URL for consent page landing.\n   * @param opts Options.\n   * @return URL to consent page.\n   */\n  generateAuthUrl(opts: GenerateAuthUrlOpts = {}) {\n    if (opts.code_challenge_method && !opts.code_challenge) {\n      throw new Error(\n          'If a code_challenge_method is provided, code_challenge must be included.');\n    }\n    opts.response_type = opts.response_type || 'code';\n    opts.client_id = opts.client_id || this._clientId;\n    opts.redirect_uri = opts.redirect_uri || this.redirectUri;\n    // Allow scopes to be passed either as array or a string\n    if (opts.scope instanceof Array) {\n      opts.scope = opts.scope.join(' ');\n    }\n    const rootUrl = OAuth2Client.GOOGLE_OAUTH2_AUTH_BASE_URL_;\n    return rootUrl + '?' + querystring.stringify(opts);\n  }\n\n  /**\n   * Convenience method to automatically generate a code_verifier, and it's\n   * resulting SHA256. If used, this must be paired with a S256\n   * code_challenge_method.\n   */\n  generateCodeVerifier() {\n    // base64 encoding uses 6 bits per character, and we want to generate128\n    // characters. 6*128/8 = 96.\n    const randomString = crypto.randomBytes(96).toString('base64');\n    // The valid characters in the code_verifier are [A-Z]/[a-z]/[0-9]/\n    // \"-\"/\".\"/\"_\"/\"~\". Base64 encoded strings are pretty close, so we're just\n    // swapping out a few chars.\n    const codeVerifier =\n        randomString.replace(/\\+/g, '~').replace(/=/g, '_').replace(/\\//g, '-');\n    // Generate the base64 encoded SHA256\n    const unencodedCodeChallenge =\n        crypto.createHash('sha256').update(codeVerifier).digest('base64');\n    // We need to use base64UrlEncoding instead of standard base64\n    const codeChallenge = unencodedCodeChallenge.split('=')[0]\n                              .replace(/\\+/g, '-')\n                              .replace(/\\//g, '_');\n    return {codeVerifier, codeChallenge};\n  }\n\n  /**\n   * Gets the access token for the given code.\n   * @param code The authorization code.\n   * @param callback Optional callback fn.\n   */\n  getToken(code: string): Promise;\n  getToken(options: GetTokenOptions): Promise;\n  getToken(code: string, callback: GetTokenCallback): void;\n  getToken(options: GetTokenOptions, callback: GetTokenCallback): void;\n  getToken(codeOrOptions: string|GetTokenOptions, callback?: GetTokenCallback):\n      Promise|void {\n    const options = (typeof codeOrOptions === 'string') ?\n        {code: codeOrOptions} :\n        codeOrOptions;\n    if (callback) {\n      this.getTokenAsync(options).then(\n          r => callback(null, r.tokens, r.res),\n          e => callback(e, null, e.response));\n    } else {\n      return this.getTokenAsync(options);\n    }\n  }\n\n  private async getTokenAsync(options: GetTokenOptions):\n      Promise {\n    const url = OAuth2Client.GOOGLE_OAUTH2_TOKEN_URL_;\n    const values = {\n      code: options.code,\n      client_id: options.client_id || this._clientId,\n      client_secret: this._clientSecret,\n      redirect_uri: options.redirect_uri || this.redirectUri,\n      grant_type: 'authorization_code',\n      code_verifier: options.codeVerifier\n    };\n    const res = await this.transporter.request({\n      method: 'POST',\n      url,\n      data: querystring.stringify(values),\n      headers: {'Content-Type': 'application/x-www-form-urlencoded'}\n    });\n    const tokens = res.data as Credentials;\n    if (res.data && res.data.expires_in) {\n      tokens.expiry_date =\n          ((new Date()).getTime() + (res.data.expires_in * 1000));\n      delete (tokens as CredentialRequest).expires_in;\n    }\n    this.emit('tokens', tokens);\n    return {tokens, res};\n  }\n\n  /**\n   * Refreshes the access token.\n   * @param refresh_token Existing refresh token.\n   * @private\n   */\n  protected async refreshToken(refreshToken?: string|\n                               null): Promise {\n    if (!refreshToken) {\n      return this.refreshTokenNoCache(refreshToken);\n    }\n    // If a request to refresh using the same token has started,\n    // return the same promise.\n    if (this.refreshTokenPromises.has(refreshToken)) {\n      return this.refreshTokenPromises.get(refreshToken)!;\n    }\n\n    const p = this.refreshTokenNoCache(refreshToken)\n                  .then(\n                      r => {\n                        this.refreshTokenPromises.delete(refreshToken);\n                        return r;\n                      },\n                      e => {\n                        this.refreshTokenPromises.delete(refreshToken);\n                        throw e;\n                      });\n    this.refreshTokenPromises.set(refreshToken, p);\n    return p;\n  }\n\n  protected async refreshTokenNoCache(refreshToken?: string|\n                                      null): Promise {\n    const url = OAuth2Client.GOOGLE_OAUTH2_TOKEN_URL_;\n    const data = {\n      refresh_token: refreshToken,\n      client_id: this._clientId,\n      client_secret: this._clientSecret,\n      grant_type: 'refresh_token'\n    };\n\n    // request for new token\n    const res = await this.transporter.request({\n      method: 'POST',\n      url,\n      data: querystring.stringify(data),\n      headers: {'Content-Type': 'application/x-www-form-urlencoded'}\n    });\n\n    const tokens = res.data as Credentials;\n    // TODO: de-duplicate this code from a few spots\n    if (res.data && res.data.expires_in) {\n      tokens.expiry_date =\n          ((new Date()).getTime() + (res.data.expires_in * 1000));\n      delete (tokens as CredentialRequest).expires_in;\n    }\n    this.emit('tokens', tokens);\n    return {tokens, res};\n  }\n\n  /**\n   * Retrieves the access token using refresh token\n   *\n   * @deprecated use getRequestHeaders instead.\n   * @param callback callback\n   */\n  refreshAccessToken(): Promise;\n  refreshAccessToken(callback: RefreshAccessTokenCallback): void;\n  refreshAccessToken(callback?: RefreshAccessTokenCallback):\n      Promise|void {\n    messages.warn(messages.REFRESH_ACCESS_TOKEN_DEPRECATED);\n    if (callback) {\n      this.refreshAccessTokenAsync().then(\n          r => callback(null, r.credentials, r.res), callback);\n    } else {\n      return this.refreshAccessTokenAsync();\n    }\n  }\n\n  private async refreshAccessTokenAsync() {\n    if (!this.credentials.refresh_token) {\n      throw new Error('No refresh token is set.');\n    }\n    const r = await this.refreshToken(this.credentials.refresh_token);\n    const tokens = r.tokens as Credentials;\n    tokens.refresh_token = this.credentials.refresh_token;\n    this.credentials = tokens;\n    return {credentials: this.credentials, res: r.res};\n  }\n\n  /**\n   * Get a non-expired access token, after refreshing if necessary\n   *\n   * @param callback Callback to call with the access token\n   */\n  getAccessToken(): Promise;\n  getAccessToken(callback: GetAccessTokenCallback): void;\n  getAccessToken(callback?: GetAccessTokenCallback):\n      Promise|void {\n    if (callback) {\n      this.getAccessTokenAsync().then(\n          r => callback(null, r.token, r.res), callback);\n    } else {\n      return this.getAccessTokenAsync();\n    }\n  }\n\n  private async getAccessTokenAsync(): Promise {\n    const shouldRefresh =\n        !this.credentials.access_token || this.isTokenExpiring();\n    if (shouldRefresh && this.credentials.refresh_token) {\n      if (!this.credentials.refresh_token) {\n        throw new Error('No refresh token is set.');\n      }\n\n      const r = await this.refreshAccessTokenAsync();\n      if (!r.credentials || (r.credentials && !r.credentials.access_token)) {\n        throw new Error('Could not refresh access token.');\n      }\n      return {token: r.credentials.access_token, res: r.res};\n    } else {\n      return {token: this.credentials.access_token};\n    }\n  }\n\n  /**\n   * Obtain the set of headers required to authenticate a request.\n   *\n   * @deprecated Use getRequestHeaders instead.\n   * @param url the Uri being authorized\n   * @param callback the func described above\n   */\n  getRequestMetadata(url?: string|null): Promise;\n  getRequestMetadata(url: string|null, callback: RequestMetadataCallback): void;\n  getRequestMetadata(url: string|null, callback?: RequestMetadataCallback):\n      Promise|void {\n    messages.warn(messages.OAUTH_GET_REQUEST_METADATA_DEPRECATED);\n    if (callback) {\n      this.getRequestMetadataAsync(url).then(\n          r => callback(null, r.headers, r.res), callback);\n    } else {\n      return this.getRequestMetadataAsync();\n    }\n  }\n\n  /**\n   * The main authentication interface.  It takes an optional url which when\n   * present is the endpoint being accessed, and returns a Promise which\n   * resolves with authorization header fields.\n   *\n   * In OAuth2Client, the result has the form:\n   * { Authorization: 'Bearer ' }\n   * @param url The optional url being authorized\n   */\n  async getRequestHeaders(url?: string): Promise {\n    const res = await this.getRequestMetadataAsync(url);\n    return res.headers;\n  }\n\n  protected async getRequestMetadataAsync(url?: string|null):\n      Promise {\n    const thisCreds = this.credentials;\n    if (!thisCreds.access_token && !thisCreds.refresh_token && !this.apiKey) {\n      throw new Error('No access, refresh token or API key is set.');\n    }\n\n    if (thisCreds.access_token && !this.isTokenExpiring()) {\n      thisCreds.token_type = thisCreds.token_type || 'Bearer';\n      const headers = {\n        Authorization: thisCreds.token_type + ' ' + thisCreds.access_token\n      };\n      return {headers};\n    }\n\n    if (this.apiKey) {\n      return {headers: {}};\n    }\n    let r: GetTokenResponse|null = null;\n    let tokens: Credentials|null = null;\n    try {\n      r = await this.refreshToken(thisCreds.refresh_token);\n      tokens = r.tokens;\n    } catch (err) {\n      const e = err as AxiosError;\n      if (e.response &&\n          (e.response.status === 403 || e.response.status === 404)) {\n        e.message = 'Could not refresh access token.';\n      }\n      throw e;\n    }\n\n    const credentials = this.credentials;\n    credentials.token_type = credentials.token_type || 'Bearer';\n    tokens.refresh_token = credentials.refresh_token;\n    this.credentials = tokens;\n    const headers = {\n      Authorization: credentials.token_type + ' ' + tokens.access_token\n    };\n    return {headers, res: r.res};\n  }\n\n  /**\n   * Revokes the access given to token.\n   * @param token The existing token to be revoked.\n   * @param callback Optional callback fn.\n   */\n  revokeToken(token: string): AxiosPromise;\n  revokeToken(\n      token: string,\n      callback: BodyResponseCallback): void;\n  revokeToken(\n      token: string, callback?: BodyResponseCallback):\n      AxiosPromise|void {\n    const opts = {\n      url: OAuth2Client.GOOGLE_OAUTH2_REVOKE_URL_ + '?' +\n          querystring.stringify({token}),\n      method: 'POST'\n    };\n    if (callback) {\n      this.transporter.request(opts).then(\n          r => callback(null, r), callback);\n    } else {\n      return this.transporter.request(opts);\n    }\n  }\n\n\n  /**\n   * Revokes access token and clears the credentials object\n   * @param callback callback\n   */\n  revokeCredentials(): AxiosPromise;\n  revokeCredentials(callback: BodyResponseCallback):\n      void;\n  revokeCredentials(callback?: BodyResponseCallback):\n      AxiosPromise|void {\n    if (callback) {\n      this.revokeCredentialsAsync().then(res => callback(null, res), callback);\n    } else {\n      return this.revokeCredentialsAsync();\n    }\n  }\n\n  private async revokeCredentialsAsync() {\n    const token = this.credentials.access_token;\n    this.credentials = {};\n    if (token) {\n      return this.revokeToken(token);\n    } else {\n      throw new Error('No access token to revoke.');\n    }\n  }\n\n  /**\n   * Provides a request implementation with OAuth 2.0 flow. If credentials have\n   * a refresh_token, in cases of HTTP 401 and 403 responses, it automatically\n   * asks for a new access token and replays the unsuccessful request.\n   * @param opts Request options.\n   * @param callback callback.\n   * @return Request object\n   */\n  request(opts: AxiosRequestConfig): AxiosPromise;\n  request(opts: AxiosRequestConfig, callback: BodyResponseCallback): void;\n  request(opts: AxiosRequestConfig, callback?: BodyResponseCallback):\n      AxiosPromise|void {\n    if (callback) {\n      this.requestAsync(opts).then(r => callback(null, r), e => {\n        return callback(e, e.response);\n      });\n    } else {\n      return this.requestAsync(opts);\n    }\n  }\n\n  protected async requestAsync(opts: AxiosRequestConfig, retry = false):\n      Promise> {\n    let r2: AxiosResponse;\n    try {\n      const r = await this.getRequestMetadataAsync(opts.url);\n      if (r.headers && r.headers.Authorization) {\n        opts.headers = opts.headers || {};\n        opts.headers.Authorization = r.headers.Authorization;\n      }\n\n      if (this.apiKey) {\n        opts.params = Object.assign(opts.params || {}, {key: this.apiKey});\n      }\n      r2 = await this.transporter.request(opts);\n    } catch (e) {\n      const res = (e as AxiosError).response;\n      if (res) {\n        const statusCode = res.status;\n        // Retry the request for metadata if the following criteria are true:\n        // - We haven't already retried.  It only makes sense to retry once.\n        // - The response was a 401 or a 403\n        // - The request didn't send a readableStream\n        // - An access_token and refresh_token were available, but no\n        //   expiry_date was availabe. This can happen when developers stash\n        //   the access_token and refresh_token for later use, but the\n        //   access_token fails on the first try because it's expired.\n        const mayRequireRefresh = this.credentials &&\n            this.credentials.access_token && this.credentials.refresh_token &&\n            !this.credentials.expiry_date;\n        const isReadableStream = res.config.data instanceof stream.Readable;\n        const isAuthErr = statusCode === 401 || statusCode === 403;\n        if (!retry && isAuthErr && !isReadableStream && mayRequireRefresh) {\n          await this.refreshAccessTokenAsync();\n          return this.requestAsync(opts, true);\n        }\n      }\n      throw e;\n    }\n    return r2;\n  }\n\n  /**\n   * Verify id token is token by checking the certs and audience\n   * @param options that contains all options.\n   * @param callback Callback supplying GoogleLogin if successful\n   */\n  verifyIdToken(options: VerifyIdTokenOptions): Promise;\n  verifyIdToken(\n      options: VerifyIdTokenOptions,\n      callback: (err: Error|null, login?: LoginTicket) => void): void;\n  verifyIdToken(\n      options: VerifyIdTokenOptions,\n      callback?: (err: Error|null, login?: LoginTicket) => void):\n      void|Promise {\n    // This function used to accept two arguments instead of an options object.\n    // Check the types to help users upgrade with less pain.\n    // This check can be removed after a 2.0 release.\n    if (callback && typeof callback !== 'function') {\n      throw new Error(\n          'This method accepts an options object as the first parameter, which includes the idToken, audience, and maxExpiry.');\n    }\n\n    if (callback) {\n      this.verifyIdTokenAsync(options).then(r => callback(null, r), callback);\n    } else {\n      return this.verifyIdTokenAsync(options);\n    }\n  }\n\n  private async verifyIdTokenAsync(options: VerifyIdTokenOptions):\n      Promise {\n    if (!options.idToken) {\n      throw new Error('The verifyIdToken method requires an ID Token');\n    }\n\n    const response = await this.getFederatedSignonCertsAsync();\n    const login = this.verifySignedJwtWithCerts(\n        options.idToken, response.certs, options.audience,\n        OAuth2Client.ISSUERS_, options.maxExpiry);\n\n    return login;\n  }\n\n  /**\n   * Obtains information about the provisioned access token.  Especially useful\n   * if you want to check the scopes that were provisioned to a given token.\n   *\n   * @param accessToken Required.  The Access Token for which you want to get\n   * user info.\n   */\n  async getTokenInfo(accessToken: string): Promise {\n    const {data} = await this.transporter.request({\n      method: 'GET',\n      url: OAuth2Client.GOOGLE_TOKEN_INFO_URL,\n      params: {access_token: accessToken}\n    });\n    const info = Object.assign(\n        {\n          expiry_date: ((new Date()).getTime() + (data.expires_in * 1000)),\n          scopes: data.scope.split(' ')\n        },\n        data);\n    delete info.expires_in;\n    delete info.scope;\n    return info;\n  }\n\n  /**\n   * Gets federated sign-on certificates to use for verifying identity tokens.\n   * Returns certs as array structure, where keys are key ids, and values\n   * are PEM encoded certificates.\n   * @param callback Callback supplying the certificates\n   */\n  getFederatedSignonCerts(): Promise;\n  getFederatedSignonCerts(callback: GetFederatedSignonCertsCallback): void;\n  getFederatedSignonCerts(callback?: GetFederatedSignonCertsCallback):\n      Promise|void {\n    if (callback) {\n      this.getFederatedSignonCertsAsync().then(\n          r => callback(null, r.certs, r.res), callback);\n    } else {\n      return this.getFederatedSignonCertsAsync();\n    }\n  }\n\n  async getFederatedSignonCertsAsync(): Promise {\n    const nowTime = (new Date()).getTime();\n    if (this.certificateExpiry &&\n        (nowTime = now + maxExpiry) {\n      throw new Error(\n          'Expiration time too far in future: ' + JSON.stringify(payload));\n    }\n\n    const earliest = iat - OAuth2Client.CLOCK_SKEW_SECS_;\n    const latest = exp + OAuth2Client.CLOCK_SKEW_SECS_;\n\n    if (now  latest) {\n      throw new Error(\n          'Token used too late, ' + now + ' > ' + latest + ': ' +\n          JSON.stringify(payload));\n    }\n\n    if (issuers && issuers.indexOf(payload.iss)  -1);\n      } else {\n        audVerified = (aud === requiredAudience);\n      }\n      if (!audVerified) {\n        throw new Error(\n            'Wrong recipient, payload audience != requiredAudience');\n      }\n    }\n    return new LoginTicket(envelope, payload);\n  }\n\n  /**\n   * This is a utils method to decode a base64 string\n   * @param b64String The string to base64 decode\n   * @return The decoded string\n   */\n  decodeBase64(b64String: string) {\n    const buffer = Buffer.from(b64String, 'base64');\n    return buffer.toString('utf8');\n  }\n\n  /**\n   * Returns true if a token is expired or will expire within\n   * eagerRefreshThresholdMillismilliseconds.\n   * If there is no expiry time, assumes the token is not expired or expiring.\n   */\n  protected isTokenExpiring(): boolean {\n    const expiryDate = this.credentials.expiry_date;\n    return expiryDate ? expiryDate \n    \n\n\n\n\n\n\n\n                   \n    \n         result-matching \"\"\n        \n    \n    \n        No results matching \"\"\n    \n\n"},"interfaces/SignBlobResponse.html":{"url":"interfaces/SignBlobResponse.html","title":"interface - SignBlobResponse","body":"\n                   \n\n\n\n\n\n\n\n\n\n\n\n\n\n  Interfaces\n  SignBlobResponse\n\n\n\n        \n            Info\n        \n        \n            Source\n        \n\n\n\n    \n        \n            File\n        \n        \n            src/auth/googleauth.ts\n        \n\n\n\n        \n            Index\n            \n                \n                    \n                        \n                            Properties\n                        \n                    \n                    \n                        \n                            \n                                \n                                        signature\n                                \n                            \n                        \n                    \n                \n            \n        \n\n\n\n            \n                Properties\n                    \n                        \n                                \n                                    \n                                        \n                                        signature\n                                    \n                                \n                                \n                                    \n                                        signature:     string\n\n                                    \n                                \n\n\n                                    \n                                        \n                                            Type :     string\n\n                                        \n                                    \n\n\n\n\n\n                        \n                    \n            \n    \n\n\n    \n        import {AxiosRequestConfig, AxiosResponse} from 'axios';\nimport {exec} from 'child_process';\nimport * as crypto from 'crypto';\nimport * as fs from 'fs';\nimport * as gcpMetadata from 'gcp-metadata';\nimport * as http from 'http';\nimport * as os from 'os';\nimport * as path from 'path';\nimport * as stream from 'stream';\nimport * as util from 'util';\n\nimport * as messages from '../messages';\nimport {DefaultTransporter, Transporter} from '../transporters';\n\nimport {Compute} from './computeclient';\nimport {CredentialBody, JWTInput} from './credentials';\nimport {GCPEnv, getEnv} from './envDetect';\nimport {JWT, JWTOptions} from './jwtclient';\nimport {Headers, OAuth2Client, RefreshOptions} from './oauth2client';\nimport {UserRefreshClient} from './refreshclient';\n\nexport interface ProjectIdCallback {\n  (err?: Error|null, projectId?: string|null): void;\n}\n\nexport interface CredentialCallback {\n  (err: Error|null, result?: UserRefreshClient|JWT): void;\n}\n\nexport interface ADCCallback {\n  (err: Error|null, credential?: OAuth2Client, projectId?: string|null): void;\n}\n\nexport interface ADCResponse {\n  credential: OAuth2Client;\n  projectId: string|null;\n}\n\nexport interface GoogleAuthOptions {\n  /**\n   * Path to a .json, .pem, or .p12 key file\n   */\n  keyFilename?: string;\n\n  /**\n   * Path to a .json, .pem, or .p12 key file\n   */\n  keyFile?: string;\n\n  /**\n   * Object containing client_email and private_key properties\n   */\n  credentials?: CredentialBody;\n\n  /**\n   * Required scopes for the desired API request\n   */\n  scopes?: string|string[];\n\n  /**\n   * Your project ID.\n   */\n  projectId?: string;\n}\n\nexport const CLOUD_SDK_CLIENT_ID =\n    '764086051850-6qr4p6gpi6hn506pt8ejuq83di341hur.apps.googleusercontent.com';\n\nexport class GoogleAuth {\n  transporter?: Transporter;\n\n  /**\n   * Caches a value indicating whether the auth layer is running on Google\n   * Compute Engine.\n   * @private\n   */\n  private checkIsGCE?: boolean = undefined;\n\n  // Note:  this properly is only public to satisify unit tests.\n  // https://github.com/Microsoft/TypeScript/issues/5228\n  get isGCE() {\n    return this.checkIsGCE;\n  }\n\n  private _getDefaultProjectIdPromise?: Promise;\n  private _cachedProjectId?: string|null;\n\n  // To save the contents of the JSON credential file\n  jsonContent: JWTInput|null = null;\n\n  cachedCredential: JWT|UserRefreshClient|Compute|null = null;\n\n  private keyFilename?: string;\n  private scopes?: string|string[];\n\n  /**\n   * Export DefaultTransporter as a static property of the class.\n   */\n  static DefaultTransporter = DefaultTransporter;\n\n  constructor(opts?: GoogleAuthOptions) {\n    opts = opts || {};\n    this._cachedProjectId = opts.projectId || null;\n    this.keyFilename = opts.keyFilename || opts.keyFile;\n    this.scopes = opts.scopes;\n    this.jsonContent = opts.credentials || null;\n  }\n\n  /**\n   * THIS METHOD HAS BEEN DEPRECATED.\n   * It will be removed in 3.0.  Please use getProjectId instead.\n   */\n  getDefaultProjectId(): Promise;\n  getDefaultProjectId(callback: ProjectIdCallback): void;\n  getDefaultProjectId(callback?: ProjectIdCallback): Promise|void {\n    messages.warn(messages.DEFAULT_PROJECT_ID_DEPRECATED);\n    if (callback) {\n      this.getProjectIdAsync().then(r => callback(null, r), callback);\n    } else {\n      return this.getProjectIdAsync();\n    }\n  }\n\n  /**\n   * Obtains the default project ID for the application.\n   * @param callback Optional callback\n   * @returns Promise that resolves with project Id (if used without callback)\n   */\n  getProjectId(): Promise;\n  getProjectId(callback: ProjectIdCallback): void;\n  getProjectId(callback?: ProjectIdCallback): Promise|void {\n    if (callback) {\n      this.getProjectIdAsync().then(r => callback(null, r), callback);\n    } else {\n      return this.getProjectIdAsync();\n    }\n  }\n\n  private getProjectIdAsync(): Promise {\n    if (this._cachedProjectId) {\n      return Promise.resolve(this._cachedProjectId);\n    }\n\n    // In implicit case, supports three environments. In order of precedence,\n    // the implicit environments are:\n    // - GCLOUD_PROJECT or GOOGLE_CLOUD_PROJECT environment variable\n    // - GOOGLE_APPLICATION_CREDENTIALS JSON file\n    // - Cloud SDK: `gcloud config config-helper --format json`\n    // - GCE project ID from metadata server)\n    if (!this._getDefaultProjectIdPromise) {\n      this._getDefaultProjectIdPromise =\n          new Promise(async (resolve, reject) => {\n            try {\n              const projectId = this.getProductionProjectId() ||\n                  await this.getFileProjectId() ||\n                  await this.getDefaultServiceProjectId() ||\n                  await this.getGCEProjectId();\n              this._cachedProjectId = projectId;\n              resolve(projectId);\n            } catch (e) {\n              reject(e);\n            }\n          });\n    }\n    return this._getDefaultProjectIdPromise;\n  }\n\n  /**\n   * Obtains the default service-level credentials for the application.\n   * @param callback Optional callback.\n   * @returns Promise that resolves with the ADCResponse (if no callback was\n   * passed).\n   */\n  getApplicationDefault(): Promise;\n  getApplicationDefault(callback: ADCCallback): void;\n  getApplicationDefault(options: RefreshOptions): Promise;\n  getApplicationDefault(options: RefreshOptions, callback: ADCCallback): void;\n  getApplicationDefault(\n      optionsOrCallback: ADCCallback|RefreshOptions = {},\n      callback?: ADCCallback): void|Promise {\n    let options: RefreshOptions|undefined;\n    if (typeof optionsOrCallback === 'function') {\n      callback = optionsOrCallback;\n    } else {\n      options = optionsOrCallback;\n    }\n    if (callback) {\n      this.getApplicationDefaultAsync(options).then(\n          r => callback!(null, r.credential, r.projectId), callback);\n    } else {\n      return this.getApplicationDefaultAsync(options);\n    }\n  }\n\n  private async getApplicationDefaultAsync(options?: RefreshOptions):\n      Promise {\n    // If we've already got a cached credential, just return it.\n    if (this.cachedCredential) {\n      return {\n        credential: this.cachedCredential as JWT | UserRefreshClient,\n        projectId: await this.getProjectIdAsync()\n      };\n    }\n\n    let credential: JWT|UserRefreshClient|null;\n    let projectId: string|null;\n    // Check for the existence of a local environment variable pointing to the\n    // location of the credential file. This is typically used in local\n    // developer scenarios.\n    credential =\n        await this._tryGetApplicationCredentialsFromEnvironmentVariable(\n            options);\n    if (credential) {\n      if (credential instanceof JWT) {\n        credential.scopes = this.scopes;\n      }\n      this.cachedCredential = credential;\n      projectId = await this.getProjectId();\n      return {credential, projectId};\n    }\n\n    // Look in the well-known credential file location.\n    credential =\n        await this._tryGetApplicationCredentialsFromWellKnownFile(options);\n    if (credential) {\n      if (credential instanceof JWT) {\n        credential.scopes = this.scopes;\n      }\n      this.cachedCredential = credential;\n      projectId = await this.getProjectId();\n      return {credential, projectId};\n    }\n\n    // Determine if we're running on GCE.\n    let isGCE;\n    try {\n      isGCE = await this._checkIsGCE();\n    } catch (e) {\n      throw new Error(\n          'Unexpected error determining execution environment: ' + e.message);\n    }\n\n    if (!isGCE) {\n      // We failed to find the default credentials. Bail out with an error.\n      throw new Error(\n          'Could not load the default credentials. Browse to https://cloud.google.com/docs/authentication/getting-started for more information.');\n    }\n\n    // For GCE, just return a default ComputeClient. It will take care of\n    // the rest.\n    this.cachedCredential = new Compute(options);\n    projectId = await this.getProjectId();\n    return {projectId, credential: this.cachedCredential};\n  }\n\n  /**\n   * Determines whether the auth layer is running on Google Compute Engine.\n   * @returns A promise that resolves with the boolean.\n   * @api private\n   */\n  async _checkIsGCE() {\n    if (this.checkIsGCE === undefined) {\n      this.checkIsGCE = await gcpMetadata.isAvailable();\n    }\n    return this.checkIsGCE;\n  }\n\n  /**\n   * Attempts to load default credentials from the environment variable path..\n   * @returns Promise that resolves with the OAuth2Client or null.\n   * @api private\n   */\n  async _tryGetApplicationCredentialsFromEnvironmentVariable(\n      options?: RefreshOptions): Promise {\n    const credentialsPath = process.env['GOOGLE_APPLICATION_CREDENTIALS'];\n    if (!credentialsPath || credentialsPath.length === 0) {\n      return null;\n    }\n    try {\n      return this._getApplicationCredentialsFromFilePath(\n          credentialsPath, options);\n    } catch (e) {\n      throw this.createError(\n          'Unable to read the credential file specified by the GOOGLE_APPLICATION_CREDENTIALS environment variable.',\n          e);\n    }\n  }\n\n  /**\n   * Attempts to load default credentials from a well-known file location\n   * @return Promise that resolves with the OAuth2Client or null.\n   * @api private\n   */\n  async _tryGetApplicationCredentialsFromWellKnownFile(\n      options?: RefreshOptions): Promise {\n    // First, figure out the location of the file, depending upon the OS type.\n    let location = null;\n    if (this._isWindows()) {\n      // Windows\n      location = process.env['APPDATA'];\n    } else {\n      // Linux or Mac\n      const home = process.env['HOME'];\n      if (home) {\n        location = this._pathJoin(home, '.config');\n      }\n    }\n    // If we found the root path, expand it.\n    if (location) {\n      location = this._pathJoin(location, 'gcloud');\n      location =\n          this._pathJoin(location, 'application_default_credentials.json');\n      location = this._mockWellKnownFilePath(location);\n      // Check whether the file exists.\n      if (!this._fileExists(location)) {\n        location = null;\n      }\n    }\n    // The file does not exist.\n    if (!location) {\n      return null;\n    }\n    // The file seems to exist. Try to use it.\n    const client =\n        await this._getApplicationCredentialsFromFilePath(location, options);\n    this.warnOnProblematicCredentials(client as JWT);\n    return client;\n  }\n\n  /**\n   * Attempts to load default credentials from a file at the given path..\n   * @param filePath The path to the file to read.\n   * @returns Promise that resolves with the OAuth2Client\n   * @api private\n   */\n  async _getApplicationCredentialsFromFilePath(\n      filePath: string,\n      options: RefreshOptions = {}): Promise {\n    // Make sure the path looks like a string.\n    if (!filePath || filePath.length === 0) {\n      throw new Error('The file path is invalid.');\n    }\n\n    // Make sure there is a file at the path. lstatSync will throw if there is\n    // nothing there.\n    try {\n      // Resolve path to actual file in case of symlink. Expect a thrown error\n      // if not resolvable.\n      filePath = fs.realpathSync(filePath);\n\n      if (!fs.lstatSync(filePath).isFile()) {\n        throw new Error();\n      }\n    } catch (err) {\n      throw this.createError(\n          util.format(\n              'The file at %s does not exist, or it is not a file.', filePath),\n          err);\n    }\n\n    // Now open a read stream on the file, and parse it.\n    try {\n      const readStream = this._createReadStream(filePath);\n      return this.fromStream(readStream, options);\n    } catch (err) {\n      throw this.createError(\n          util.format('Unable to read the file at %s.', filePath), err);\n    }\n  }\n\n  /**\n   * Credentials from the Cloud SDK that are associated with Cloud SDK's project\n   * are problematic because they may not have APIs enabled and have limited\n   * quota. If this is the case, warn about it.\n   */\n  protected warnOnProblematicCredentials(client: JWT) {\n    if (client.email === CLOUD_SDK_CLIENT_ID) {\n      messages.warn(messages.PROBLEMATIC_CREDENTIALS_WARNING);\n    }\n  }\n\n  /**\n   * Create a credentials instance using the given input options.\n   * @param json The input object.\n   * @returns JWT or UserRefresh Client with data\n   */\n  fromJSON(json: JWTInput, options?: RefreshOptions): JWT|UserRefreshClient {\n    let client: UserRefreshClient|JWT;\n    if (!json) {\n      throw new Error(\n          'Must pass in a JSON object containing the Google auth settings.');\n    }\n    this.jsonContent = json;\n    options = options || {};\n    if (json.type === 'authorized_user') {\n      client = new UserRefreshClient(options);\n    } else {\n      (options as JWTOptions).scopes = this.scopes;\n      client = new JWT(options);\n    }\n    client.fromJSON(json);\n    return client;\n  }\n\n  /**\n   * Create a credentials instance using the given input stream.\n   * @param inputStream The input stream.\n   * @param callback Optional callback.\n   */\n  fromStream(inputStream: stream.Readable): Promise;\n  fromStream(inputStream: stream.Readable, callback: CredentialCallback): void;\n  fromStream(inputStream: stream.Readable, options: RefreshOptions):\n      Promise;\n  fromStream(\n      inputStream: stream.Readable, options: RefreshOptions,\n      callback: CredentialCallback): void;\n  fromStream(\n      inputStream: stream.Readable,\n      optionsOrCallback: RefreshOptions|CredentialCallback = {},\n      callback?: CredentialCallback): Promise|void {\n    let options: RefreshOptions = {};\n    if (typeof optionsOrCallback === 'function') {\n      callback = optionsOrCallback;\n    } else {\n      options = optionsOrCallback;\n    }\n    if (callback) {\n      this.fromStreamAsync(inputStream, options)\n          .then(r => callback!(null, r), callback);\n    } else {\n      return this.fromStreamAsync(inputStream, options);\n    }\n  }\n\n  private fromStreamAsync(\n      inputStream: stream.Readable,\n      options?: RefreshOptions): Promise {\n    return new Promise((resolve, reject) => {\n      if (!inputStream) {\n        throw new Error(\n            'Must pass in a stream containing the Google auth settings.');\n      }\n      let s = '';\n      inputStream.setEncoding('utf8')\n          .on('error', reject)\n          .on('data', (chunk) => s += chunk)\n          .on('end', () => {\n            try {\n              const data = JSON.parse(s);\n              const r = this.fromJSON(data, options);\n              return resolve(r);\n            } catch (err) {\n              return reject(err);\n            }\n          });\n    });\n  }\n\n  /**\n   * Create a credentials instance using the given API key string.\n   * @param apiKey The API key string\n   * @param options An optional options object.\n   * @returns A JWT loaded from the key\n   */\n  fromAPIKey(apiKey: string, options?: RefreshOptions): JWT {\n    options = options || {};\n    const client = new JWT(options);\n    client.fromAPIKey(apiKey);\n    return client;\n  }\n\n  /**\n   * Determines whether the current operating system is Windows.\n   * @api private\n   */\n  private _isWindows() {\n    const sys = this._osPlatform();\n    if (sys && sys.length >= 3) {\n      if (sys.substring(0, 3).toLowerCase() === 'win') {\n        return true;\n      }\n    }\n    return false;\n  }\n\n  /**\n   * Creates a file stream. Allows mocking.\n   * @api private\n   */\n  _createReadStream(filePath: string) {\n    return fs.createReadStream(filePath);\n  }\n\n  /**\n   * Gets the current operating system platform. Allows mocking.\n   * @api private\n   */\n  _osPlatform() {\n    return os.platform();\n  }\n\n  /**\n   * Determines whether a file exists. Allows mocking.\n   * @api private\n   */\n  _fileExists(filePath: string) {\n    return fs.existsSync(filePath);\n  }\n\n  /**\n   * Joins two parts of a path. Allows mocking.\n   * @api private\n   */\n  _pathJoin(item1: string, item2: string) {\n    return path.join(item1, item2);\n  }\n\n  /**\n   * Allows mocking of the path to a well-known file.\n   * @api private\n   */\n  _mockWellKnownFilePath(filePath: string) {\n    return filePath;\n  }\n\n  // Creates an Error containing the given message, and includes the message\n  // from the optional err passed in.\n  private createError(message: string, err: Error) {\n    let s = message || '';\n    if (err) {\n      const errorMessage = String(err);\n      if (errorMessage && errorMessage.length > 0) {\n        if (s.length > 0) {\n          s += ' ';\n        }\n        s += errorMessage;\n      }\n    }\n    return Error(s);\n  }\n\n  /**\n   * Run the Google Cloud SDK command that prints the default project ID\n   */\n  private async getDefaultServiceProjectId(): Promise {\n    return new Promise(resolve => {\n      exec(\n          'gcloud config config-helper --format json',\n          (err, stdout, stderr) => {\n            if (!err && stdout) {\n              try {\n                const projectId =\n                    JSON.parse(stdout).configuration.properties.core.project;\n                resolve(projectId);\n                return;\n              } catch (e) {\n                // ignore errors\n              }\n            }\n            resolve(null);\n          });\n    });\n  }\n\n  /**\n   * Loads the project id from environment variables.\n   * @api private\n   */\n  private getProductionProjectId() {\n    return process.env['GCLOUD_PROJECT'] || process.env['GOOGLE_CLOUD_PROJECT'];\n  }\n\n  /**\n   * Loads the project id from the GOOGLE_APPLICATION_CREDENTIALS json file.\n   * @api private\n   */\n  private async getFileProjectId(): Promise {\n    if (this.cachedCredential) {\n      // Try to read the project ID from the cached credentials file\n      return this.cachedCredential.projectId;\n    }\n\n    // Try to load a credentials file and read its project ID\n    const r = await this._tryGetApplicationCredentialsFromEnvironmentVariable();\n    if (r) {\n      return r.projectId;\n    } else {\n      return null;\n    }\n  }\n\n  /**\n   * Gets the Compute Engine project ID if it can be inferred.\n   */\n  private async getGCEProjectId() {\n    try {\n      const r = await gcpMetadata.project('project-id');\n      return r.data;\n    } catch (e) {\n      // Ignore any errors\n      return null;\n    }\n  }\n\n  /**\n   * The callback function handles a credential object that contains the\n   * client_email and private_key (if exists).\n   * getCredentials checks for these values from the user JSON at first.\n   * If it doesn't exist, and the environment is on GCE, it gets the\n   * client_email from the cloud metadata server.\n   * @param callback Callback that handles the credential object that contains\n   * a client_email and optional private key, or the error.\n   * returned\n   */\n  getCredentials(): Promise;\n  getCredentials(\n      callback: (err: Error|null, credentials?: CredentialBody) => void): void;\n  getCredentials(\n      callback?: (err: Error|null, credentials?: CredentialBody) => void):\n      void|Promise {\n    if (callback) {\n      this.getCredentialsAsync().then(r => callback(null, r), callback);\n    } else {\n      return this.getCredentialsAsync();\n    }\n  }\n\n  private async getCredentialsAsync(): Promise {\n    if (this.jsonContent) {\n      const credential: CredentialBody = {\n        client_email: this.jsonContent.client_email,\n        private_key: this.jsonContent.private_key\n      };\n      return credential;\n    }\n\n    const isGCE = await this._checkIsGCE();\n    if (!isGCE) {\n      throw new Error('Unknown error.');\n    }\n\n    // For GCE, return the service account details from the metadata server\n    // NOTE: The trailing '/' at the end of service-accounts/ is very important!\n    // The GCF metadata server doesn't respect querystring params if this / is\n    // not included.\n    const {data} = await gcpMetadata.instance(\n        {property: 'service-accounts/', params: {recursive: true}});\n\n    if (!data || !data.default || !data.default.email) {\n      throw new Error('Failure from metadata server.');\n    }\n\n    return {client_email: data.default.email};\n  }\n\n  /**\n   * Automatically obtain a client based on the provided configuration.  If no\n   * options were passed, use Application Default Credentials.\n   */\n  async getClient(options?: GoogleAuthOptions) {\n    if (options) {\n      this.keyFilename =\n          options.keyFilename || options.keyFile || this.keyFilename;\n      this.scopes = options.scopes || this.scopes;\n      this.jsonContent = options.credentials || this.jsonContent;\n    }\n    if (!this.cachedCredential) {\n      if (this.jsonContent) {\n        this.cachedCredential = await this.fromJSON(this.jsonContent);\n      } else if (this.keyFilename) {\n        const filePath = path.resolve(this.keyFilename);\n        const stream = fs.createReadStream(filePath);\n        this.cachedCredential = await this.fromStreamAsync(stream);\n      } else {\n        await this.getApplicationDefaultAsync();\n      }\n    }\n    return this.cachedCredential!;\n  }\n\n  /**\n   * Automatically obtain application default credentials, and return\n   * an access token for making requests.\n   */\n  async getAccessToken() {\n    const client = await this.getClient();\n    return (await client.getAccessToken()).token;\n  }\n\n  /**\n   * Obtain the HTTP headers that will provide authorization for a given\n   * request.\n   */\n  async getRequestHeaders(url?: string) {\n    const client = await this.getClient();\n    return client.getRequestHeaders(url);\n  }\n\n  /**\n   * Obtain credentials for a request, then attach the appropriate headers to\n   * the request options.\n   * @param opts Axios or Request options on which to attach the headers\n   */\n  async authorizeRequest(opts:\n                             {url?: string, uri?: string, headers?: Headers}) {\n    opts = opts || {};\n    const url = opts.url || opts.uri;\n    const client = await this.getClient();\n    const headers = await client.getRequestHeaders(url);\n    opts.headers = Object.assign(opts.headers || {}, headers);\n    return opts;\n  }\n\n  /**\n   * Automatically obtain application default credentials, and make an\n   * HTTP request using the given options.\n   * @param opts Axios request options for the HTTP request.\n   */\n  // tslint:disable-next-line no-any\n  async request(opts: AxiosRequestConfig): Promise> {\n    const client = await this.getClient();\n    return client.request(opts);\n  }\n\n  /**\n   * Determine the compute environment in which the code is running.\n   */\n  getEnv(): Promise {\n    return getEnv();\n  }\n\n  /**\n   * Sign the given data with the current private key, or go out\n   * to the IAM API to sign it.\n   * @param data The data to be signed.\n   */\n  async sign(data: string): Promise {\n    const client = await this.getClient();\n    if (client instanceof JWT && client.key) {\n      const sign = crypto.createSign('RSA-SHA256');\n      sign.update(data);\n      return sign.sign(client.key, 'base64');\n    }\n\n    const projectId = await this.getProjectId();\n    if (!projectId) {\n      throw new Error('Cannot sign data without a project ID.');\n    }\n\n    const creds = await this.getCredentials();\n    if (!creds.client_email) {\n      throw new Error('Cannot sign data without `client_email`.');\n    }\n\n    const id = `projects/${projectId}/serviceAccounts/${creds.client_email}`;\n    const res = await this.request({\n      method: 'POST',\n      url: `https://iam.googleapis.com/v1/${id}:signBlob`,\n      data: {bytesToSign: Buffer.from(data).toString('base64')}\n    });\n    return res.data.signature;\n  }\n}\n\nexport interface SignBlobResponse {\n  signature: string;\n}\n\n    \n\n\n\n\n\n\n\n                   \n    \n         result-matching \"\"\n        \n    \n    \n        No results matching \"\"\n    \n\n"},"interfaces/TokenInfo.html":{"url":"interfaces/TokenInfo.html","title":"interface - TokenInfo","body":"\n                   \n\n\n\n\n\n\n\n\n\n\n\n\n\n  Interfaces\n  TokenInfo\n\n\n\n        \n            Info\n        \n        \n            Source\n        \n\n\n\n    \n        \n            File\n        \n        \n            src/auth/oauth2client.ts\n        \n\n\n\n        \n            Index\n            \n                \n                    \n                        \n                            Properties\n                        \n                    \n                    \n                        \n                            \n                                \n                                            Optional\n                                        access_type\n                                \n                                \n                                        aud\n                                \n                                \n                                            Optional\n                                        azp\n                                \n                                \n                                        expiry_date\n                                \n                                \n                                        scopes\n                                \n                                \n                                            Optional\n                                        sub\n                                \n                                \n                                            Optional\n                                        user_id\n                                \n                            \n                        \n                    \n                \n            \n        \n\n\n\n            \n                Properties\n                    \n                        \n                                \n                                    \n                                        \n                                        access_type\n                                    \n                                \n                                \n                                    \n                                        access_type:     string\n\n                                    \n                                \n\n\n                                    \n                                        \n                                            Type :     string\n\n                                        \n                                    \n\n                                    \n                                        \n                                            Optional\n                                        \n                                    \n\n\n\n\n                            \n                                \n                                    Indicates whether your application can refresh access tokens\nwhen the user is not present at the browser. Valid parameter values are\n'online', which is the default value, and 'offline'. Set the value to\n'offline' if your application needs to refresh access tokens when the user\nis not present at the browser. This value instructs the Google\nauthorization server to return a refresh token and an access token the\nfirst time that your application exchanges an authorization code for\ntokens.\n\n                                \n                            \n                        \n                    \n                    \n                        \n                                \n                                    \n                                        \n                                        aud\n                                    \n                                \n                                \n                                    \n                                        aud:     string\n\n                                    \n                                \n\n\n                                    \n                                        \n                                            Type :     string\n\n                                        \n                                    \n\n\n\n\n\n                            \n                                \n                                    The application that is the intended user of the access token.\n\n                                \n                            \n                        \n                    \n                    \n                        \n                                \n                                    \n                                        \n                                        azp\n                                    \n                                \n                                \n                                    \n                                        azp:     string\n\n                                    \n                                \n\n\n                                    \n                                        \n                                            Type :     string\n\n                                        \n                                    \n\n                                    \n                                        \n                                            Optional\n                                        \n                                    \n\n\n\n\n                            \n                                \n                                    The client_id of the authorized presenter. This claim is only needed when\nthe party requesting the ID token is not the same as the audience of the ID\ntoken. This may be the case at Google for hybrid apps where a web\napplication and Android app have a different client_id but share the same\nproject.\n\n                                \n                            \n                        \n                    \n                    \n                        \n                                \n                                    \n                                        \n                                        expiry_date\n                                    \n                                \n                                \n                                    \n                                        expiry_date:     number\n\n                                    \n                                \n\n\n                                    \n                                        \n                                            Type :     number\n\n                                        \n                                    \n\n\n\n\n\n                            \n                                \n                                    The datetime when the token becomes invalid.\n\n                                \n                            \n                        \n                    \n                    \n                        \n                                \n                                    \n                                        \n                                        scopes\n                                    \n                                \n                                \n                                    \n                                        scopes:     string[]\n\n                                    \n                                \n\n\n                                    \n                                        \n                                            Type :     string[]\n\n                                        \n                                    \n\n\n\n\n\n                            \n                                \n                                    An array of scopes that the user granted access to.\n\n                                \n                            \n                        \n                    \n                    \n                        \n                                \n                                    \n                                        \n                                        sub\n                                    \n                                \n                                \n                                    \n                                        sub:     string\n\n                                    \n                                \n\n\n                                    \n                                        \n                                            Type :     string\n\n                                        \n                                    \n\n                                    \n                                        \n                                            Optional\n                                        \n                                    \n\n\n\n\n                            \n                                \n                                    An identifier for the user, unique among all Google accounts and never\nreused. A Google account can have multiple emails at different points in\ntime, but the sub value is never changed. Use sub within your application\nas the unique-identifier key for the user.\n\n                                \n                            \n                        \n                    \n                    \n                        \n                                \n                                    \n                                        \n                                        user_id\n                                    \n                                \n                                \n                                    \n                                        user_id:     string\n\n                                    \n                                \n\n\n                                    \n                                        \n                                            Type :     string\n\n                                        \n                                    \n\n                                    \n                                        \n                                            Optional\n                                        \n                                    \n\n\n\n\n                            \n                                \n                                    This value lets you correlate profile information from multiple Google\nAPIs. It is only present in the response if you included the profile scope\nin your request in step 1. The field value is an immutable identifier for\nthe logged-in user that can be used to create and manage user sessions in\nyour application. The identifier is the same regardless of which client ID\nis used to retrieve it. This enables multiple applications in the same\norganization to correlate profile information.\n\n                                \n                            \n                        \n                    \n            \n    \n\n\n    \n        import {AxiosError, AxiosPromise, AxiosRequestConfig, AxiosResponse} from 'axios';\nimport * as crypto from 'crypto';\nimport * as querystring from 'querystring';\nimport * as stream from 'stream';\nimport * as messages from '../messages';\nimport {PemVerifier} from './../pemverifier';\nimport {BodyResponseCallback} from './../transporters';\nimport {AuthClient} from './authclient';\nimport {CredentialRequest, Credentials} from './credentials';\nimport {LoginTicket, TokenPayload} from './loginticket';\n\nexport type Certificates = {\n  [index: string]: string\n};\n\nexport type Headers = {\n  [index: string]: string\n};\n\nexport enum CodeChallengeMethod {\n  Plain = 'plain',\n  S256 = 'S256'\n}\n\nexport interface GetTokenOptions {\n  code: string;\n  codeVerifier?: string;\n  /**\n   * The client ID for your application. The value passed into the constructor\n   * will be used if not provided. Must match any client_id option passed to\n   * a corresponding call to generateAuthUrl.\n   */\n  client_id?: string;\n  /**\n   * Determines where the API server redirects the user after the user\n   * completes the authorization flow. The value passed into the constructor\n   * will be used if not provided. Must match any redirect_uri option passed to\n   * a corresponding call to generateAuthUrl.\n   */\n  redirect_uri?: string;\n}\n\nexport interface TokenInfo {\n  /**\n   * The application that is the intended user of the access token.\n   */\n  aud: string;\n\n  /**\n   * This value lets you correlate profile information from multiple Google\n   * APIs. It is only present in the response if you included the profile scope\n   * in your request in step 1. The field value is an immutable identifier for\n   * the logged-in user that can be used to create and manage user sessions in\n   * your application. The identifier is the same regardless of which client ID\n   * is used to retrieve it. This enables multiple applications in the same\n   * organization to correlate profile information.\n   */\n  user_id?: string;\n\n  /**\n   * An array of scopes that the user granted access to.\n   */\n  scopes: string[];\n\n  /**\n   * The datetime when the token becomes invalid.\n   */\n  expiry_date: number;\n\n  /**\n   * An identifier for the user, unique among all Google accounts and never\n   * reused. A Google account can have multiple emails at different points in\n   * time, but the sub value is never changed. Use sub within your application\n   * as the unique-identifier key for the user.\n   */\n  sub?: string;\n\n  /**\n   * The client_id of the authorized presenter. This claim is only needed when\n   * the party requesting the ID token is not the same as the audience of the ID\n   * token. This may be the case at Google for hybrid apps where a web\n   * application and Android app have a different client_id but share the same\n   * project.\n   */\n  azp?: string;\n\n  /**\n   * Indicates whether your application can refresh access tokens\n   * when the user is not present at the browser. Valid parameter values are\n   * 'online', which is the default value, and 'offline'. Set the value to\n   * 'offline' if your application needs to refresh access tokens when the user\n   * is not present at the browser. This value instructs the Google\n   * authorization server to return a refresh token and an access token the\n   * first time that your application exchanges an authorization code for\n   * tokens.\n   */\n  access_type?: string;\n}\n\ninterface TokenInfoRequest {\n  aud: string;\n  user_id?: string;\n  scope: string;\n  expires_in: number;\n  azp?: string;\n  sub?: string;\n  exp?: number;\n  access_type?: string;\n}\n\nexport interface GenerateAuthUrlOpts {\n  /**\n   * Recommended. Indicates whether your application can refresh access tokens\n   * when the user is not present at the browser. Valid parameter values are\n   * 'online', which is the default value, and 'offline'. Set the value to\n   * 'offline' if your application needs to refresh access tokens when the user\n   * is not present at the browser. This value instructs the Google\n   * authorization server to return a refresh token and an access token the\n   * first time that your application exchanges an authorization code for\n   * tokens.\n   */\n  access_type?: string;\n\n  /**\n   * The hd (hosted domain) parameter streamlines the login process for G Suite\n   * hosted accounts. By including the domain of the G Suite user (for example,\n   * mycollege.edu), you can indicate that the account selection UI should be\n   * optimized for accounts at that domain. To optimize for G Suite accounts\n   * generally instead of just one domain, use an asterisk: hd=*.\n   * Don't rely on this UI optimization to control who can access your app,\n   * as client-side requests can be modified. Be sure to validate that the\n   * returned ID token has an hd claim value that matches what you expect\n   * (e.g. mycolledge.edu). Unlike the request parameter, the ID token claim is\n   * contained within a security token from Google, so the value can be trusted.\n   */\n  hd?: string;\n\n  /**\n   * The 'response_type' will always be set to 'CODE'.\n   */\n  response_type?: string;\n\n  /**\n   * The client ID for your application. The value passed into the constructor\n   * will be used if not provided. You can find this value in the API Console.\n   */\n  client_id?: string;\n\n  /**\n   * Determines where the API server redirects the user after the user\n   * completes the authorization flow. The value must exactly match one of the\n   * 'redirect_uri' values listed for your project in the API Console. Note that\n   * the http or https scheme, case, and trailing slash ('/') must all match.\n   * The value passed into the constructor will be used if not provided.\n   */\n  redirect_uri?: string;\n\n  /**\n   * Required. A space-delimited list of scopes that identify the resources that\n   * your application could access on the user's behalf. These values inform the\n   * consent screen that Google displays to the user. Scopes enable your\n   * application to only request access to the resources that it needs while\n   * also enabling users to control the amount of access that they grant to your\n   * application. Thus, there is an inverse relationship between the number of\n   * scopes requested and the likelihood of obtaining user consent. The\n   * OAuth 2.0 API Scopes document provides a full list of scopes that you might\n   * use to access Google APIs. We recommend that your application request\n   * access to authorization scopes in context whenever possible. By requesting\n   * access to user data in context, via incremental authorization, you help\n   * users to more easily understand why your application needs the access it is\n   * requesting.\n   */\n  scope?: string[]|string;\n\n  /**\n   * Recommended. Specifies any string value that your application uses to\n   * maintain state between your authorization request and the authorization\n   * server's response. The server returns the exact value that you send as a\n   * name=value pair in the hash (#) fragment of the 'redirect_uri' after the\n   * user consents to or denies your application's access request. You can use\n   * this parameter for several purposes, such as directing the user to the\n   * correct resource in your application, sending nonces, and mitigating\n   * cross-site request forgery. Since your redirect_uri can be guessed, using a\n   * state value can increase your assurance that an incoming connection is the\n   * result of an authentication request. If you generate a random string or\n   * encode the hash of a cookie or another value that captures the client's\n   * state, you can validate the response to additionally ensure that the\n   * request and response originated in the same browser, providing protection\n   * against attacks such as cross-site request forgery. See the OpenID Connect\n   * documentation for an example of how to create and confirm a state token.\n   */\n  state?: string;\n\n  /**\n   * Optional. Enables applications to use incremental authorization to request\n   * access to additional scopes in context. If you set this parameter's value\n   * to true and the authorization request is granted, then the new access token\n   * will also cover any scopes to which the user previously granted the\n   * application access. See the incremental authorization section for examples.\n   */\n  include_granted_scopes?: boolean;\n\n  /**\n   * Optional. If your application knows which user is trying to authenticate,\n   * it can use this parameter to provide a hint to the Google Authentication\n   * Server. The server uses the hint to simplify the login flow either by\n   * prefilling the email field in the sign-in form or by selecting the\n   * appropriate multi-login session. Set the parameter value to an email\n   * address or sub identifier, which is equivalent to the user's Google ID.\n   */\n  login_hint?: string;\n\n  /**\n   * Optional. A space-delimited, case-sensitive list of prompts to present the\n   * user. If you don't specify this parameter, the user will be prompted only\n   * the first time your app requests access.  Possible values are:\n   *\n   * 'none' - Donot display any authentication or consent screens. Must not be\n   *        specified with other values.\n   * 'consent' - \tPrompt the user for consent.\n   * 'select_account' - Prompt the user to select an account.\n   */\n  prompt?: string;\n\n  /**\n   * Recommended. Specifies what method was used to encode a 'code_verifier'\n   * that will be used during authorization code exchange. This parameter must\n   * be used with the 'code_challenge' parameter. The value of the\n   * 'code_challenge_method' defaults to \"plain\" if not present in the request\n   * that includes a 'code_challenge'. The only supported values for this\n   * parameter are \"S256\" or \"plain\".\n   */\n  code_challenge_method?: CodeChallengeMethod;\n\n  /**\n   * Recommended. Specifies an encoded 'code_verifier' that will be used as a\n   * server-side challenge during authorization code exchange. This parameter\n   * must be used with the 'code_challenge' parameter described above.\n   */\n  code_challenge?: string;\n}\n\nexport interface GetTokenCallback {\n  (err: AxiosError|null, token?: Credentials|null,\n   res?: AxiosResponse|null): void;\n}\n\nexport interface GetTokenResponse {\n  tokens: Credentials;\n  res: AxiosResponse|null;\n}\n\nexport interface GetAccessTokenCallback {\n  (err: AxiosError|null, token?: string|null, res?: AxiosResponse|null): void;\n}\n\nexport interface GetAccessTokenResponse {\n  token?: string|null;\n  res?: AxiosResponse|null;\n}\n\nexport interface RefreshAccessTokenCallback {\n  (err: AxiosError|null, credentials?: Credentials|null,\n   res?: AxiosResponse|null): void;\n}\n\nexport interface RefreshAccessTokenResponse {\n  credentials: Credentials;\n  res: AxiosResponse|null;\n}\n\nexport interface RequestMetadataResponse {\n  headers: Headers;\n  res?: AxiosResponse|null;\n}\n\nexport interface RequestMetadataCallback {\n  (err: AxiosError|null, headers?: Headers,\n   res?: AxiosResponse|null): void;\n}\n\nexport interface GetFederatedSignonCertsCallback {\n  (err: AxiosError|null, certs?: Certificates,\n   response?: AxiosResponse|null): void;\n}\n\nexport interface FederatedSignonCertsResponse {\n  certs: Certificates;\n  res?: AxiosResponse|null;\n}\n\nexport interface RevokeCredentialsResult {\n  success: boolean;\n}\n\nexport interface VerifyIdTokenOptions {\n  idToken: string;\n  audience: string|string[];\n  maxExpiry?: number;\n}\n\nexport interface OAuth2ClientOptions extends RefreshOptions {\n  clientId?: string;\n  clientSecret?: string;\n  redirectUri?: string;\n}\n\nexport interface RefreshOptions {\n  // Eagerly refresh unexpired tokens when they are within this many\n  // milliseconds from expiring\".\n  // Defaults to a value of 300000 (5 minutes).\n  eagerRefreshThresholdMillis?: number;\n}\n\nexport class OAuth2Client extends AuthClient {\n  private redirectUri?: string;\n  private certificateCache?: Certificates;\n  private certificateExpiry: Date|null = null;\n  protected refreshTokenPromises = new Map>();\n\n  // TODO: refactor tests to make this private\n  _clientId?: string;\n\n  // TODO: refactor tests to make this private\n  _clientSecret?: string;\n\n  apiKey?: string;\n\n  projectId?: string;\n\n  eagerRefreshThresholdMillis: number;\n\n  /**\n   * Handles OAuth2 flow for Google APIs.\n   *\n   * @param clientId The authentication client ID.\n   * @param clientSecret The authentication client secret.\n   * @param redirectUri The URI to redirect to after completing the auth\n   * request.\n   * @param opts optional options for overriding the given parameters.\n   * @constructor\n   */\n  constructor(options?: OAuth2ClientOptions);\n  constructor(clientId?: string, clientSecret?: string, redirectUri?: string);\n  constructor(\n      optionsOrClientId?: string|OAuth2ClientOptions, clientSecret?: string,\n      redirectUri?: string) {\n    super();\n    const opts = (optionsOrClientId && typeof optionsOrClientId === 'object') ?\n        optionsOrClientId :\n        {clientId: optionsOrClientId, clientSecret, redirectUri};\n    this._clientId = opts.clientId;\n    this._clientSecret = opts.clientSecret;\n    this.redirectUri = opts.redirectUri;\n    this.eagerRefreshThresholdMillis =\n        opts.eagerRefreshThresholdMillis || 5 * 60 * 1000;\n  }\n\n  protected static readonly GOOGLE_TOKEN_INFO_URL =\n      'https://oauth2.googleapis.com/tokeninfo';\n\n  /**\n   * The base URL for auth endpoints.\n   */\n  private static readonly GOOGLE_OAUTH2_AUTH_BASE_URL_ =\n      'https://accounts.google.com/o/oauth2/v2/auth';\n\n  /**\n   * The base endpoint for token retrieval.\n   */\n  private static readonly GOOGLE_OAUTH2_TOKEN_URL_ =\n      'https://oauth2.googleapis.com/token';\n\n  /**\n   * The base endpoint to revoke tokens.\n   */\n  private static readonly GOOGLE_OAUTH2_REVOKE_URL_ =\n      'https://oauth2.googleapis.com/revoke';\n\n  /**\n   * Google Sign on certificates.\n   */\n  private static readonly GOOGLE_OAUTH2_FEDERATED_SIGNON_CERTS_URL_ =\n      'https://www.googleapis.com/oauth2/v1/certs';\n\n  /**\n   * Clock skew - five minutes in seconds\n   */\n  private static readonly CLOCK_SKEW_SECS_ = 300;\n\n  /**\n   * Max Token Lifetime is one day in seconds\n   */\n  private static readonly MAX_TOKEN_LIFETIME_SECS_ = 86400;\n\n  /**\n   * The allowed oauth token issuers.\n   */\n  private static readonly ISSUERS_ =\n      ['accounts.google.com', 'https://accounts.google.com'];\n\n  /**\n   * Generates URL for consent page landing.\n   * @param opts Options.\n   * @return URL to consent page.\n   */\n  generateAuthUrl(opts: GenerateAuthUrlOpts = {}) {\n    if (opts.code_challenge_method && !opts.code_challenge) {\n      throw new Error(\n          'If a code_challenge_method is provided, code_challenge must be included.');\n    }\n    opts.response_type = opts.response_type || 'code';\n    opts.client_id = opts.client_id || this._clientId;\n    opts.redirect_uri = opts.redirect_uri || this.redirectUri;\n    // Allow scopes to be passed either as array or a string\n    if (opts.scope instanceof Array) {\n      opts.scope = opts.scope.join(' ');\n    }\n    const rootUrl = OAuth2Client.GOOGLE_OAUTH2_AUTH_BASE_URL_;\n    return rootUrl + '?' + querystring.stringify(opts);\n  }\n\n  /**\n   * Convenience method to automatically generate a code_verifier, and it's\n   * resulting SHA256. If used, this must be paired with a S256\n   * code_challenge_method.\n   */\n  generateCodeVerifier() {\n    // base64 encoding uses 6 bits per character, and we want to generate128\n    // characters. 6*128/8 = 96.\n    const randomString = crypto.randomBytes(96).toString('base64');\n    // The valid characters in the code_verifier are [A-Z]/[a-z]/[0-9]/\n    // \"-\"/\".\"/\"_\"/\"~\". Base64 encoded strings are pretty close, so we're just\n    // swapping out a few chars.\n    const codeVerifier =\n        randomString.replace(/\\+/g, '~').replace(/=/g, '_').replace(/\\//g, '-');\n    // Generate the base64 encoded SHA256\n    const unencodedCodeChallenge =\n        crypto.createHash('sha256').update(codeVerifier).digest('base64');\n    // We need to use base64UrlEncoding instead of standard base64\n    const codeChallenge = unencodedCodeChallenge.split('=')[0]\n                              .replace(/\\+/g, '-')\n                              .replace(/\\//g, '_');\n    return {codeVerifier, codeChallenge};\n  }\n\n  /**\n   * Gets the access token for the given code.\n   * @param code The authorization code.\n   * @param callback Optional callback fn.\n   */\n  getToken(code: string): Promise;\n  getToken(options: GetTokenOptions): Promise;\n  getToken(code: string, callback: GetTokenCallback): void;\n  getToken(options: GetTokenOptions, callback: GetTokenCallback): void;\n  getToken(codeOrOptions: string|GetTokenOptions, callback?: GetTokenCallback):\n      Promise|void {\n    const options = (typeof codeOrOptions === 'string') ?\n        {code: codeOrOptions} :\n        codeOrOptions;\n    if (callback) {\n      this.getTokenAsync(options).then(\n          r => callback(null, r.tokens, r.res),\n          e => callback(e, null, e.response));\n    } else {\n      return this.getTokenAsync(options);\n    }\n  }\n\n  private async getTokenAsync(options: GetTokenOptions):\n      Promise {\n    const url = OAuth2Client.GOOGLE_OAUTH2_TOKEN_URL_;\n    const values = {\n      code: options.code,\n      client_id: options.client_id || this._clientId,\n      client_secret: this._clientSecret,\n      redirect_uri: options.redirect_uri || this.redirectUri,\n      grant_type: 'authorization_code',\n      code_verifier: options.codeVerifier\n    };\n    const res = await this.transporter.request({\n      method: 'POST',\n      url,\n      data: querystring.stringify(values),\n      headers: {'Content-Type': 'application/x-www-form-urlencoded'}\n    });\n    const tokens = res.data as Credentials;\n    if (res.data && res.data.expires_in) {\n      tokens.expiry_date =\n          ((new Date()).getTime() + (res.data.expires_in * 1000));\n      delete (tokens as CredentialRequest).expires_in;\n    }\n    this.emit('tokens', tokens);\n    return {tokens, res};\n  }\n\n  /**\n   * Refreshes the access token.\n   * @param refresh_token Existing refresh token.\n   * @private\n   */\n  protected async refreshToken(refreshToken?: string|\n                               null): Promise {\n    if (!refreshToken) {\n      return this.refreshTokenNoCache(refreshToken);\n    }\n    // If a request to refresh using the same token has started,\n    // return the same promise.\n    if (this.refreshTokenPromises.has(refreshToken)) {\n      return this.refreshTokenPromises.get(refreshToken)!;\n    }\n\n    const p = this.refreshTokenNoCache(refreshToken)\n                  .then(\n                      r => {\n                        this.refreshTokenPromises.delete(refreshToken);\n                        return r;\n                      },\n                      e => {\n                        this.refreshTokenPromises.delete(refreshToken);\n                        throw e;\n                      });\n    this.refreshTokenPromises.set(refreshToken, p);\n    return p;\n  }\n\n  protected async refreshTokenNoCache(refreshToken?: string|\n                                      null): Promise {\n    const url = OAuth2Client.GOOGLE_OAUTH2_TOKEN_URL_;\n    const data = {\n      refresh_token: refreshToken,\n      client_id: this._clientId,\n      client_secret: this._clientSecret,\n      grant_type: 'refresh_token'\n    };\n\n    // request for new token\n    const res = await this.transporter.request({\n      method: 'POST',\n      url,\n      data: querystring.stringify(data),\n      headers: {'Content-Type': 'application/x-www-form-urlencoded'}\n    });\n\n    const tokens = res.data as Credentials;\n    // TODO: de-duplicate this code from a few spots\n    if (res.data && res.data.expires_in) {\n      tokens.expiry_date =\n          ((new Date()).getTime() + (res.data.expires_in * 1000));\n      delete (tokens as CredentialRequest).expires_in;\n    }\n    this.emit('tokens', tokens);\n    return {tokens, res};\n  }\n\n  /**\n   * Retrieves the access token using refresh token\n   *\n   * @deprecated use getRequestHeaders instead.\n   * @param callback callback\n   */\n  refreshAccessToken(): Promise;\n  refreshAccessToken(callback: RefreshAccessTokenCallback): void;\n  refreshAccessToken(callback?: RefreshAccessTokenCallback):\n      Promise|void {\n    messages.warn(messages.REFRESH_ACCESS_TOKEN_DEPRECATED);\n    if (callback) {\n      this.refreshAccessTokenAsync().then(\n          r => callback(null, r.credentials, r.res), callback);\n    } else {\n      return this.refreshAccessTokenAsync();\n    }\n  }\n\n  private async refreshAccessTokenAsync() {\n    if (!this.credentials.refresh_token) {\n      throw new Error('No refresh token is set.');\n    }\n    const r = await this.refreshToken(this.credentials.refresh_token);\n    const tokens = r.tokens as Credentials;\n    tokens.refresh_token = this.credentials.refresh_token;\n    this.credentials = tokens;\n    return {credentials: this.credentials, res: r.res};\n  }\n\n  /**\n   * Get a non-expired access token, after refreshing if necessary\n   *\n   * @param callback Callback to call with the access token\n   */\n  getAccessToken(): Promise;\n  getAccessToken(callback: GetAccessTokenCallback): void;\n  getAccessToken(callback?: GetAccessTokenCallback):\n      Promise|void {\n    if (callback) {\n      this.getAccessTokenAsync().then(\n          r => callback(null, r.token, r.res), callback);\n    } else {\n      return this.getAccessTokenAsync();\n    }\n  }\n\n  private async getAccessTokenAsync(): Promise {\n    const shouldRefresh =\n        !this.credentials.access_token || this.isTokenExpiring();\n    if (shouldRefresh && this.credentials.refresh_token) {\n      if (!this.credentials.refresh_token) {\n        throw new Error('No refresh token is set.');\n      }\n\n      const r = await this.refreshAccessTokenAsync();\n      if (!r.credentials || (r.credentials && !r.credentials.access_token)) {\n        throw new Error('Could not refresh access token.');\n      }\n      return {token: r.credentials.access_token, res: r.res};\n    } else {\n      return {token: this.credentials.access_token};\n    }\n  }\n\n  /**\n   * Obtain the set of headers required to authenticate a request.\n   *\n   * @deprecated Use getRequestHeaders instead.\n   * @param url the Uri being authorized\n   * @param callback the func described above\n   */\n  getRequestMetadata(url?: string|null): Promise;\n  getRequestMetadata(url: string|null, callback: RequestMetadataCallback): void;\n  getRequestMetadata(url: string|null, callback?: RequestMetadataCallback):\n      Promise|void {\n    messages.warn(messages.OAUTH_GET_REQUEST_METADATA_DEPRECATED);\n    if (callback) {\n      this.getRequestMetadataAsync(url).then(\n          r => callback(null, r.headers, r.res), callback);\n    } else {\n      return this.getRequestMetadataAsync();\n    }\n  }\n\n  /**\n   * The main authentication interface.  It takes an optional url which when\n   * present is the endpoint being accessed, and returns a Promise which\n   * resolves with authorization header fields.\n   *\n   * In OAuth2Client, the result has the form:\n   * { Authorization: 'Bearer ' }\n   * @param url The optional url being authorized\n   */\n  async getRequestHeaders(url?: string): Promise {\n    const res = await this.getRequestMetadataAsync(url);\n    return res.headers;\n  }\n\n  protected async getRequestMetadataAsync(url?: string|null):\n      Promise {\n    const thisCreds = this.credentials;\n    if (!thisCreds.access_token && !thisCreds.refresh_token && !this.apiKey) {\n      throw new Error('No access, refresh token or API key is set.');\n    }\n\n    if (thisCreds.access_token && !this.isTokenExpiring()) {\n      thisCreds.token_type = thisCreds.token_type || 'Bearer';\n      const headers = {\n        Authorization: thisCreds.token_type + ' ' + thisCreds.access_token\n      };\n      return {headers};\n    }\n\n    if (this.apiKey) {\n      return {headers: {}};\n    }\n    let r: GetTokenResponse|null = null;\n    let tokens: Credentials|null = null;\n    try {\n      r = await this.refreshToken(thisCreds.refresh_token);\n      tokens = r.tokens;\n    } catch (err) {\n      const e = err as AxiosError;\n      if (e.response &&\n          (e.response.status === 403 || e.response.status === 404)) {\n        e.message = 'Could not refresh access token.';\n      }\n      throw e;\n    }\n\n    const credentials = this.credentials;\n    credentials.token_type = credentials.token_type || 'Bearer';\n    tokens.refresh_token = credentials.refresh_token;\n    this.credentials = tokens;\n    const headers = {\n      Authorization: credentials.token_type + ' ' + tokens.access_token\n    };\n    return {headers, res: r.res};\n  }\n\n  /**\n   * Revokes the access given to token.\n   * @param token The existing token to be revoked.\n   * @param callback Optional callback fn.\n   */\n  revokeToken(token: string): AxiosPromise;\n  revokeToken(\n      token: string,\n      callback: BodyResponseCallback): void;\n  revokeToken(\n      token: string, callback?: BodyResponseCallback):\n      AxiosPromise|void {\n    const opts = {\n      url: OAuth2Client.GOOGLE_OAUTH2_REVOKE_URL_ + '?' +\n          querystring.stringify({token}),\n      method: 'POST'\n    };\n    if (callback) {\n      this.transporter.request(opts).then(\n          r => callback(null, r), callback);\n    } else {\n      return this.transporter.request(opts);\n    }\n  }\n\n\n  /**\n   * Revokes access token and clears the credentials object\n   * @param callback callback\n   */\n  revokeCredentials(): AxiosPromise;\n  revokeCredentials(callback: BodyResponseCallback):\n      void;\n  revokeCredentials(callback?: BodyResponseCallback):\n      AxiosPromise|void {\n    if (callback) {\n      this.revokeCredentialsAsync().then(res => callback(null, res), callback);\n    } else {\n      return this.revokeCredentialsAsync();\n    }\n  }\n\n  private async revokeCredentialsAsync() {\n    const token = this.credentials.access_token;\n    this.credentials = {};\n    if (token) {\n      return this.revokeToken(token);\n    } else {\n      throw new Error('No access token to revoke.');\n    }\n  }\n\n  /**\n   * Provides a request implementation with OAuth 2.0 flow. If credentials have\n   * a refresh_token, in cases of HTTP 401 and 403 responses, it automatically\n   * asks for a new access token and replays the unsuccessful request.\n   * @param opts Request options.\n   * @param callback callback.\n   * @return Request object\n   */\n  request(opts: AxiosRequestConfig): AxiosPromise;\n  request(opts: AxiosRequestConfig, callback: BodyResponseCallback): void;\n  request(opts: AxiosRequestConfig, callback?: BodyResponseCallback):\n      AxiosPromise|void {\n    if (callback) {\n      this.requestAsync(opts).then(r => callback(null, r), e => {\n        return callback(e, e.response);\n      });\n    } else {\n      return this.requestAsync(opts);\n    }\n  }\n\n  protected async requestAsync(opts: AxiosRequestConfig, retry = false):\n      Promise> {\n    let r2: AxiosResponse;\n    try {\n      const r = await this.getRequestMetadataAsync(opts.url);\n      if (r.headers && r.headers.Authorization) {\n        opts.headers = opts.headers || {};\n        opts.headers.Authorization = r.headers.Authorization;\n      }\n\n      if (this.apiKey) {\n        opts.params = Object.assign(opts.params || {}, {key: this.apiKey});\n      }\n      r2 = await this.transporter.request(opts);\n    } catch (e) {\n      const res = (e as AxiosError).response;\n      if (res) {\n        const statusCode = res.status;\n        // Retry the request for metadata if the following criteria are true:\n        // - We haven't already retried.  It only makes sense to retry once.\n        // - The response was a 401 or a 403\n        // - The request didn't send a readableStream\n        // - An access_token and refresh_token were available, but no\n        //   expiry_date was availabe. This can happen when developers stash\n        //   the access_token and refresh_token for later use, but the\n        //   access_token fails on the first try because it's expired.\n        const mayRequireRefresh = this.credentials &&\n            this.credentials.access_token && this.credentials.refresh_token &&\n            !this.credentials.expiry_date;\n        const isReadableStream = res.config.data instanceof stream.Readable;\n        const isAuthErr = statusCode === 401 || statusCode === 403;\n        if (!retry && isAuthErr && !isReadableStream && mayRequireRefresh) {\n          await this.refreshAccessTokenAsync();\n          return this.requestAsync(opts, true);\n        }\n      }\n      throw e;\n    }\n    return r2;\n  }\n\n  /**\n   * Verify id token is token by checking the certs and audience\n   * @param options that contains all options.\n   * @param callback Callback supplying GoogleLogin if successful\n   */\n  verifyIdToken(options: VerifyIdTokenOptions): Promise;\n  verifyIdToken(\n      options: VerifyIdTokenOptions,\n      callback: (err: Error|null, login?: LoginTicket) => void): void;\n  verifyIdToken(\n      options: VerifyIdTokenOptions,\n      callback?: (err: Error|null, login?: LoginTicket) => void):\n      void|Promise {\n    // This function used to accept two arguments instead of an options object.\n    // Check the types to help users upgrade with less pain.\n    // This check can be removed after a 2.0 release.\n    if (callback && typeof callback !== 'function') {\n      throw new Error(\n          'This method accepts an options object as the first parameter, which includes the idToken, audience, and maxExpiry.');\n    }\n\n    if (callback) {\n      this.verifyIdTokenAsync(options).then(r => callback(null, r), callback);\n    } else {\n      return this.verifyIdTokenAsync(options);\n    }\n  }\n\n  private async verifyIdTokenAsync(options: VerifyIdTokenOptions):\n      Promise {\n    if (!options.idToken) {\n      throw new Error('The verifyIdToken method requires an ID Token');\n    }\n\n    const response = await this.getFederatedSignonCertsAsync();\n    const login = this.verifySignedJwtWithCerts(\n        options.idToken, response.certs, options.audience,\n        OAuth2Client.ISSUERS_, options.maxExpiry);\n\n    return login;\n  }\n\n  /**\n   * Obtains information about the provisioned access token.  Especially useful\n   * if you want to check the scopes that were provisioned to a given token.\n   *\n   * @param accessToken Required.  The Access Token for which you want to get\n   * user info.\n   */\n  async getTokenInfo(accessToken: string): Promise {\n    const {data} = await this.transporter.request({\n      method: 'GET',\n      url: OAuth2Client.GOOGLE_TOKEN_INFO_URL,\n      params: {access_token: accessToken}\n    });\n    const info = Object.assign(\n        {\n          expiry_date: ((new Date()).getTime() + (data.expires_in * 1000)),\n          scopes: data.scope.split(' ')\n        },\n        data);\n    delete info.expires_in;\n    delete info.scope;\n    return info;\n  }\n\n  /**\n   * Gets federated sign-on certificates to use for verifying identity tokens.\n   * Returns certs as array structure, where keys are key ids, and values\n   * are PEM encoded certificates.\n   * @param callback Callback supplying the certificates\n   */\n  getFederatedSignonCerts(): Promise;\n  getFederatedSignonCerts(callback: GetFederatedSignonCertsCallback): void;\n  getFederatedSignonCerts(callback?: GetFederatedSignonCertsCallback):\n      Promise|void {\n    if (callback) {\n      this.getFederatedSignonCertsAsync().then(\n          r => callback(null, r.certs, r.res), callback);\n    } else {\n      return this.getFederatedSignonCertsAsync();\n    }\n  }\n\n  async getFederatedSignonCertsAsync(): Promise {\n    const nowTime = (new Date()).getTime();\n    if (this.certificateExpiry &&\n        (nowTime = now + maxExpiry) {\n      throw new Error(\n          'Expiration time too far in future: ' + JSON.stringify(payload));\n    }\n\n    const earliest = iat - OAuth2Client.CLOCK_SKEW_SECS_;\n    const latest = exp + OAuth2Client.CLOCK_SKEW_SECS_;\n\n    if (now  latest) {\n      throw new Error(\n          'Token used too late, ' + now + ' > ' + latest + ': ' +\n          JSON.stringify(payload));\n    }\n\n    if (issuers && issuers.indexOf(payload.iss)  -1);\n      } else {\n        audVerified = (aud === requiredAudience);\n      }\n      if (!audVerified) {\n        throw new Error(\n            'Wrong recipient, payload audience != requiredAudience');\n      }\n    }\n    return new LoginTicket(envelope, payload);\n  }\n\n  /**\n   * This is a utils method to decode a base64 string\n   * @param b64String The string to base64 decode\n   * @return The decoded string\n   */\n  decodeBase64(b64String: string) {\n    const buffer = Buffer.from(b64String, 'base64');\n    return buffer.toString('utf8');\n  }\n\n  /**\n   * Returns true if a token is expired or will expire within\n   * eagerRefreshThresholdMillismilliseconds.\n   * If there is no expiry time, assumes the token is not expired or expiring.\n   */\n  protected isTokenExpiring(): boolean {\n    const expiryDate = this.credentials.expiry_date;\n    return expiryDate ? expiryDate \n    \n\n\n\n\n\n\n\n                   \n    \n         result-matching \"\"\n        \n    \n    \n        No results matching \"\"\n    \n\n"},"interfaces/TokenInfoRequest.html":{"url":"interfaces/TokenInfoRequest.html","title":"interface - TokenInfoRequest","body":"\n                   \n\n\n\n\n\n\n\n\n\n\n\n\n\n  Interfaces\n  TokenInfoRequest\n\n\n\n        \n            Info\n        \n        \n            Source\n        \n\n\n\n    \n        \n            File\n        \n        \n            src/auth/oauth2client.ts\n        \n\n\n\n        \n            Index\n            \n                \n                    \n                        \n                            Properties\n                        \n                    \n                    \n                        \n                            \n                                \n                                            Optional\n                                        access_type\n                                \n                                \n                                        aud\n                                \n                                \n                                            Optional\n                                        azp\n                                \n                                \n                                            Optional\n                                        exp\n                                \n                                \n                                        expires_in\n                                \n                                \n                                        scope\n                                \n                                \n                                            Optional\n                                        sub\n                                \n                                \n                                            Optional\n                                        user_id\n                                \n                            \n                        \n                    \n                \n            \n        \n\n\n\n            \n                Properties\n                    \n                        \n                                \n                                    \n                                        \n                                        access_type\n                                    \n                                \n                                \n                                    \n                                        access_type:     string\n\n                                    \n                                \n\n\n                                    \n                                        \n                                            Type :     string\n\n                                        \n                                    \n\n                                    \n                                        \n                                            Optional\n                                        \n                                    \n\n\n\n\n                        \n                    \n                    \n                        \n                                \n                                    \n                                        \n                                        aud\n                                    \n                                \n                                \n                                    \n                                        aud:     string\n\n                                    \n                                \n\n\n                                    \n                                        \n                                            Type :     string\n\n                                        \n                                    \n\n\n\n\n\n                        \n                    \n                    \n                        \n                                \n                                    \n                                        \n                                        azp\n                                    \n                                \n                                \n                                    \n                                        azp:     string\n\n                                    \n                                \n\n\n                                    \n                                        \n                                            Type :     string\n\n                                        \n                                    \n\n                                    \n                                        \n                                            Optional\n                                        \n                                    \n\n\n\n\n                        \n                    \n                    \n                        \n                                \n                                    \n                                        \n                                        exp\n                                    \n                                \n                                \n                                    \n                                        exp:     number\n\n                                    \n                                \n\n\n                                    \n                                        \n                                            Type :     number\n\n                                        \n                                    \n\n                                    \n                                        \n                                            Optional\n                                        \n                                    \n\n\n\n\n                        \n                    \n                    \n                        \n                                \n                                    \n                                        \n                                        expires_in\n                                    \n                                \n                                \n                                    \n                                        expires_in:     number\n\n                                    \n                                \n\n\n                                    \n                                        \n                                            Type :     number\n\n                                        \n                                    \n\n\n\n\n\n                        \n                    \n                    \n                        \n                                \n                                    \n                                        \n                                        scope\n                                    \n                                \n                                \n                                    \n                                        scope:     string\n\n                                    \n                                \n\n\n                                    \n                                        \n                                            Type :     string\n\n                                        \n                                    \n\n\n\n\n\n                        \n                    \n                    \n                        \n                                \n                                    \n                                        \n                                        sub\n                                    \n                                \n                                \n                                    \n                                        sub:     string\n\n                                    \n                                \n\n\n                                    \n                                        \n                                            Type :     string\n\n                                        \n                                    \n\n                                    \n                                        \n                                            Optional\n                                        \n                                    \n\n\n\n\n                        \n                    \n                    \n                        \n                                \n                                    \n                                        \n                                        user_id\n                                    \n                                \n                                \n                                    \n                                        user_id:     string\n\n                                    \n                                \n\n\n                                    \n                                        \n                                            Type :     string\n\n                                        \n                                    \n\n                                    \n                                        \n                                            Optional\n                                        \n                                    \n\n\n\n\n                        \n                    \n            \n    \n\n\n    \n        import {AxiosError, AxiosPromise, AxiosRequestConfig, AxiosResponse} from 'axios';\nimport * as crypto from 'crypto';\nimport * as querystring from 'querystring';\nimport * as stream from 'stream';\nimport * as messages from '../messages';\nimport {PemVerifier} from './../pemverifier';\nimport {BodyResponseCallback} from './../transporters';\nimport {AuthClient} from './authclient';\nimport {CredentialRequest, Credentials} from './credentials';\nimport {LoginTicket, TokenPayload} from './loginticket';\n\nexport type Certificates = {\n  [index: string]: string\n};\n\nexport type Headers = {\n  [index: string]: string\n};\n\nexport enum CodeChallengeMethod {\n  Plain = 'plain',\n  S256 = 'S256'\n}\n\nexport interface GetTokenOptions {\n  code: string;\n  codeVerifier?: string;\n  /**\n   * The client ID for your application. The value passed into the constructor\n   * will be used if not provided. Must match any client_id option passed to\n   * a corresponding call to generateAuthUrl.\n   */\n  client_id?: string;\n  /**\n   * Determines where the API server redirects the user after the user\n   * completes the authorization flow. The value passed into the constructor\n   * will be used if not provided. Must match any redirect_uri option passed to\n   * a corresponding call to generateAuthUrl.\n   */\n  redirect_uri?: string;\n}\n\nexport interface TokenInfo {\n  /**\n   * The application that is the intended user of the access token.\n   */\n  aud: string;\n\n  /**\n   * This value lets you correlate profile information from multiple Google\n   * APIs. It is only present in the response if you included the profile scope\n   * in your request in step 1. The field value is an immutable identifier for\n   * the logged-in user that can be used to create and manage user sessions in\n   * your application. The identifier is the same regardless of which client ID\n   * is used to retrieve it. This enables multiple applications in the same\n   * organization to correlate profile information.\n   */\n  user_id?: string;\n\n  /**\n   * An array of scopes that the user granted access to.\n   */\n  scopes: string[];\n\n  /**\n   * The datetime when the token becomes invalid.\n   */\n  expiry_date: number;\n\n  /**\n   * An identifier for the user, unique among all Google accounts and never\n   * reused. A Google account can have multiple emails at different points in\n   * time, but the sub value is never changed. Use sub within your application\n   * as the unique-identifier key for the user.\n   */\n  sub?: string;\n\n  /**\n   * The client_id of the authorized presenter. This claim is only needed when\n   * the party requesting the ID token is not the same as the audience of the ID\n   * token. This may be the case at Google for hybrid apps where a web\n   * application and Android app have a different client_id but share the same\n   * project.\n   */\n  azp?: string;\n\n  /**\n   * Indicates whether your application can refresh access tokens\n   * when the user is not present at the browser. Valid parameter values are\n   * 'online', which is the default value, and 'offline'. Set the value to\n   * 'offline' if your application needs to refresh access tokens when the user\n   * is not present at the browser. This value instructs the Google\n   * authorization server to return a refresh token and an access token the\n   * first time that your application exchanges an authorization code for\n   * tokens.\n   */\n  access_type?: string;\n}\n\ninterface TokenInfoRequest {\n  aud: string;\n  user_id?: string;\n  scope: string;\n  expires_in: number;\n  azp?: string;\n  sub?: string;\n  exp?: number;\n  access_type?: string;\n}\n\nexport interface GenerateAuthUrlOpts {\n  /**\n   * Recommended. Indicates whether your application can refresh access tokens\n   * when the user is not present at the browser. Valid parameter values are\n   * 'online', which is the default value, and 'offline'. Set the value to\n   * 'offline' if your application needs to refresh access tokens when the user\n   * is not present at the browser. This value instructs the Google\n   * authorization server to return a refresh token and an access token the\n   * first time that your application exchanges an authorization code for\n   * tokens.\n   */\n  access_type?: string;\n\n  /**\n   * The hd (hosted domain) parameter streamlines the login process for G Suite\n   * hosted accounts. By including the domain of the G Suite user (for example,\n   * mycollege.edu), you can indicate that the account selection UI should be\n   * optimized for accounts at that domain. To optimize for G Suite accounts\n   * generally instead of just one domain, use an asterisk: hd=*.\n   * Don't rely on this UI optimization to control who can access your app,\n   * as client-side requests can be modified. Be sure to validate that the\n   * returned ID token has an hd claim value that matches what you expect\n   * (e.g. mycolledge.edu). Unlike the request parameter, the ID token claim is\n   * contained within a security token from Google, so the value can be trusted.\n   */\n  hd?: string;\n\n  /**\n   * The 'response_type' will always be set to 'CODE'.\n   */\n  response_type?: string;\n\n  /**\n   * The client ID for your application. The value passed into the constructor\n   * will be used if not provided. You can find this value in the API Console.\n   */\n  client_id?: string;\n\n  /**\n   * Determines where the API server redirects the user after the user\n   * completes the authorization flow. The value must exactly match one of the\n   * 'redirect_uri' values listed for your project in the API Console. Note that\n   * the http or https scheme, case, and trailing slash ('/') must all match.\n   * The value passed into the constructor will be used if not provided.\n   */\n  redirect_uri?: string;\n\n  /**\n   * Required. A space-delimited list of scopes that identify the resources that\n   * your application could access on the user's behalf. These values inform the\n   * consent screen that Google displays to the user. Scopes enable your\n   * application to only request access to the resources that it needs while\n   * also enabling users to control the amount of access that they grant to your\n   * application. Thus, there is an inverse relationship between the number of\n   * scopes requested and the likelihood of obtaining user consent. The\n   * OAuth 2.0 API Scopes document provides a full list of scopes that you might\n   * use to access Google APIs. We recommend that your application request\n   * access to authorization scopes in context whenever possible. By requesting\n   * access to user data in context, via incremental authorization, you help\n   * users to more easily understand why your application needs the access it is\n   * requesting.\n   */\n  scope?: string[]|string;\n\n  /**\n   * Recommended. Specifies any string value that your application uses to\n   * maintain state between your authorization request and the authorization\n   * server's response. The server returns the exact value that you send as a\n   * name=value pair in the hash (#) fragment of the 'redirect_uri' after the\n   * user consents to or denies your application's access request. You can use\n   * this parameter for several purposes, such as directing the user to the\n   * correct resource in your application, sending nonces, and mitigating\n   * cross-site request forgery. Since your redirect_uri can be guessed, using a\n   * state value can increase your assurance that an incoming connection is the\n   * result of an authentication request. If you generate a random string or\n   * encode the hash of a cookie or another value that captures the client's\n   * state, you can validate the response to additionally ensure that the\n   * request and response originated in the same browser, providing protection\n   * against attacks such as cross-site request forgery. See the OpenID Connect\n   * documentation for an example of how to create and confirm a state token.\n   */\n  state?: string;\n\n  /**\n   * Optional. Enables applications to use incremental authorization to request\n   * access to additional scopes in context. If you set this parameter's value\n   * to true and the authorization request is granted, then the new access token\n   * will also cover any scopes to which the user previously granted the\n   * application access. See the incremental authorization section for examples.\n   */\n  include_granted_scopes?: boolean;\n\n  /**\n   * Optional. If your application knows which user is trying to authenticate,\n   * it can use this parameter to provide a hint to the Google Authentication\n   * Server. The server uses the hint to simplify the login flow either by\n   * prefilling the email field in the sign-in form or by selecting the\n   * appropriate multi-login session. Set the parameter value to an email\n   * address or sub identifier, which is equivalent to the user's Google ID.\n   */\n  login_hint?: string;\n\n  /**\n   * Optional. A space-delimited, case-sensitive list of prompts to present the\n   * user. If you don't specify this parameter, the user will be prompted only\n   * the first time your app requests access.  Possible values are:\n   *\n   * 'none' - Donot display any authentication or consent screens. Must not be\n   *        specified with other values.\n   * 'consent' - \tPrompt the user for consent.\n   * 'select_account' - Prompt the user to select an account.\n   */\n  prompt?: string;\n\n  /**\n   * Recommended. Specifies what method was used to encode a 'code_verifier'\n   * that will be used during authorization code exchange. This parameter must\n   * be used with the 'code_challenge' parameter. The value of the\n   * 'code_challenge_method' defaults to \"plain\" if not present in the request\n   * that includes a 'code_challenge'. The only supported values for this\n   * parameter are \"S256\" or \"plain\".\n   */\n  code_challenge_method?: CodeChallengeMethod;\n\n  /**\n   * Recommended. Specifies an encoded 'code_verifier' that will be used as a\n   * server-side challenge during authorization code exchange. This parameter\n   * must be used with the 'code_challenge' parameter described above.\n   */\n  code_challenge?: string;\n}\n\nexport interface GetTokenCallback {\n  (err: AxiosError|null, token?: Credentials|null,\n   res?: AxiosResponse|null): void;\n}\n\nexport interface GetTokenResponse {\n  tokens: Credentials;\n  res: AxiosResponse|null;\n}\n\nexport interface GetAccessTokenCallback {\n  (err: AxiosError|null, token?: string|null, res?: AxiosResponse|null): void;\n}\n\nexport interface GetAccessTokenResponse {\n  token?: string|null;\n  res?: AxiosResponse|null;\n}\n\nexport interface RefreshAccessTokenCallback {\n  (err: AxiosError|null, credentials?: Credentials|null,\n   res?: AxiosResponse|null): void;\n}\n\nexport interface RefreshAccessTokenResponse {\n  credentials: Credentials;\n  res: AxiosResponse|null;\n}\n\nexport interface RequestMetadataResponse {\n  headers: Headers;\n  res?: AxiosResponse|null;\n}\n\nexport interface RequestMetadataCallback {\n  (err: AxiosError|null, headers?: Headers,\n   res?: AxiosResponse|null): void;\n}\n\nexport interface GetFederatedSignonCertsCallback {\n  (err: AxiosError|null, certs?: Certificates,\n   response?: AxiosResponse|null): void;\n}\n\nexport interface FederatedSignonCertsResponse {\n  certs: Certificates;\n  res?: AxiosResponse|null;\n}\n\nexport interface RevokeCredentialsResult {\n  success: boolean;\n}\n\nexport interface VerifyIdTokenOptions {\n  idToken: string;\n  audience: string|string[];\n  maxExpiry?: number;\n}\n\nexport interface OAuth2ClientOptions extends RefreshOptions {\n  clientId?: string;\n  clientSecret?: string;\n  redirectUri?: string;\n}\n\nexport interface RefreshOptions {\n  // Eagerly refresh unexpired tokens when they are within this many\n  // milliseconds from expiring\".\n  // Defaults to a value of 300000 (5 minutes).\n  eagerRefreshThresholdMillis?: number;\n}\n\nexport class OAuth2Client extends AuthClient {\n  private redirectUri?: string;\n  private certificateCache?: Certificates;\n  private certificateExpiry: Date|null = null;\n  protected refreshTokenPromises = new Map>();\n\n  // TODO: refactor tests to make this private\n  _clientId?: string;\n\n  // TODO: refactor tests to make this private\n  _clientSecret?: string;\n\n  apiKey?: string;\n\n  projectId?: string;\n\n  eagerRefreshThresholdMillis: number;\n\n  /**\n   * Handles OAuth2 flow for Google APIs.\n   *\n   * @param clientId The authentication client ID.\n   * @param clientSecret The authentication client secret.\n   * @param redirectUri The URI to redirect to after completing the auth\n   * request.\n   * @param opts optional options for overriding the given parameters.\n   * @constructor\n   */\n  constructor(options?: OAuth2ClientOptions);\n  constructor(clientId?: string, clientSecret?: string, redirectUri?: string);\n  constructor(\n      optionsOrClientId?: string|OAuth2ClientOptions, clientSecret?: string,\n      redirectUri?: string) {\n    super();\n    const opts = (optionsOrClientId && typeof optionsOrClientId === 'object') ?\n        optionsOrClientId :\n        {clientId: optionsOrClientId, clientSecret, redirectUri};\n    this._clientId = opts.clientId;\n    this._clientSecret = opts.clientSecret;\n    this.redirectUri = opts.redirectUri;\n    this.eagerRefreshThresholdMillis =\n        opts.eagerRefreshThresholdMillis || 5 * 60 * 1000;\n  }\n\n  protected static readonly GOOGLE_TOKEN_INFO_URL =\n      'https://oauth2.googleapis.com/tokeninfo';\n\n  /**\n   * The base URL for auth endpoints.\n   */\n  private static readonly GOOGLE_OAUTH2_AUTH_BASE_URL_ =\n      'https://accounts.google.com/o/oauth2/v2/auth';\n\n  /**\n   * The base endpoint for token retrieval.\n   */\n  private static readonly GOOGLE_OAUTH2_TOKEN_URL_ =\n      'https://oauth2.googleapis.com/token';\n\n  /**\n   * The base endpoint to revoke tokens.\n   */\n  private static readonly GOOGLE_OAUTH2_REVOKE_URL_ =\n      'https://oauth2.googleapis.com/revoke';\n\n  /**\n   * Google Sign on certificates.\n   */\n  private static readonly GOOGLE_OAUTH2_FEDERATED_SIGNON_CERTS_URL_ =\n      'https://www.googleapis.com/oauth2/v1/certs';\n\n  /**\n   * Clock skew - five minutes in seconds\n   */\n  private static readonly CLOCK_SKEW_SECS_ = 300;\n\n  /**\n   * Max Token Lifetime is one day in seconds\n   */\n  private static readonly MAX_TOKEN_LIFETIME_SECS_ = 86400;\n\n  /**\n   * The allowed oauth token issuers.\n   */\n  private static readonly ISSUERS_ =\n      ['accounts.google.com', 'https://accounts.google.com'];\n\n  /**\n   * Generates URL for consent page landing.\n   * @param opts Options.\n   * @return URL to consent page.\n   */\n  generateAuthUrl(opts: GenerateAuthUrlOpts = {}) {\n    if (opts.code_challenge_method && !opts.code_challenge) {\n      throw new Error(\n          'If a code_challenge_method is provided, code_challenge must be included.');\n    }\n    opts.response_type = opts.response_type || 'code';\n    opts.client_id = opts.client_id || this._clientId;\n    opts.redirect_uri = opts.redirect_uri || this.redirectUri;\n    // Allow scopes to be passed either as array or a string\n    if (opts.scope instanceof Array) {\n      opts.scope = opts.scope.join(' ');\n    }\n    const rootUrl = OAuth2Client.GOOGLE_OAUTH2_AUTH_BASE_URL_;\n    return rootUrl + '?' + querystring.stringify(opts);\n  }\n\n  /**\n   * Convenience method to automatically generate a code_verifier, and it's\n   * resulting SHA256. If used, this must be paired with a S256\n   * code_challenge_method.\n   */\n  generateCodeVerifier() {\n    // base64 encoding uses 6 bits per character, and we want to generate128\n    // characters. 6*128/8 = 96.\n    const randomString = crypto.randomBytes(96).toString('base64');\n    // The valid characters in the code_verifier are [A-Z]/[a-z]/[0-9]/\n    // \"-\"/\".\"/\"_\"/\"~\". Base64 encoded strings are pretty close, so we're just\n    // swapping out a few chars.\n    const codeVerifier =\n        randomString.replace(/\\+/g, '~').replace(/=/g, '_').replace(/\\//g, '-');\n    // Generate the base64 encoded SHA256\n    const unencodedCodeChallenge =\n        crypto.createHash('sha256').update(codeVerifier).digest('base64');\n    // We need to use base64UrlEncoding instead of standard base64\n    const codeChallenge = unencodedCodeChallenge.split('=')[0]\n                              .replace(/\\+/g, '-')\n                              .replace(/\\//g, '_');\n    return {codeVerifier, codeChallenge};\n  }\n\n  /**\n   * Gets the access token for the given code.\n   * @param code The authorization code.\n   * @param callback Optional callback fn.\n   */\n  getToken(code: string): Promise;\n  getToken(options: GetTokenOptions): Promise;\n  getToken(code: string, callback: GetTokenCallback): void;\n  getToken(options: GetTokenOptions, callback: GetTokenCallback): void;\n  getToken(codeOrOptions: string|GetTokenOptions, callback?: GetTokenCallback):\n      Promise|void {\n    const options = (typeof codeOrOptions === 'string') ?\n        {code: codeOrOptions} :\n        codeOrOptions;\n    if (callback) {\n      this.getTokenAsync(options).then(\n          r => callback(null, r.tokens, r.res),\n          e => callback(e, null, e.response));\n    } else {\n      return this.getTokenAsync(options);\n    }\n  }\n\n  private async getTokenAsync(options: GetTokenOptions):\n      Promise {\n    const url = OAuth2Client.GOOGLE_OAUTH2_TOKEN_URL_;\n    const values = {\n      code: options.code,\n      client_id: options.client_id || this._clientId,\n      client_secret: this._clientSecret,\n      redirect_uri: options.redirect_uri || this.redirectUri,\n      grant_type: 'authorization_code',\n      code_verifier: options.codeVerifier\n    };\n    const res = await this.transporter.request({\n      method: 'POST',\n      url,\n      data: querystring.stringify(values),\n      headers: {'Content-Type': 'application/x-www-form-urlencoded'}\n    });\n    const tokens = res.data as Credentials;\n    if (res.data && res.data.expires_in) {\n      tokens.expiry_date =\n          ((new Date()).getTime() + (res.data.expires_in * 1000));\n      delete (tokens as CredentialRequest).expires_in;\n    }\n    this.emit('tokens', tokens);\n    return {tokens, res};\n  }\n\n  /**\n   * Refreshes the access token.\n   * @param refresh_token Existing refresh token.\n   * @private\n   */\n  protected async refreshToken(refreshToken?: string|\n                               null): Promise {\n    if (!refreshToken) {\n      return this.refreshTokenNoCache(refreshToken);\n    }\n    // If a request to refresh using the same token has started,\n    // return the same promise.\n    if (this.refreshTokenPromises.has(refreshToken)) {\n      return this.refreshTokenPromises.get(refreshToken)!;\n    }\n\n    const p = this.refreshTokenNoCache(refreshToken)\n                  .then(\n                      r => {\n                        this.refreshTokenPromises.delete(refreshToken);\n                        return r;\n                      },\n                      e => {\n                        this.refreshTokenPromises.delete(refreshToken);\n                        throw e;\n                      });\n    this.refreshTokenPromises.set(refreshToken, p);\n    return p;\n  }\n\n  protected async refreshTokenNoCache(refreshToken?: string|\n                                      null): Promise {\n    const url = OAuth2Client.GOOGLE_OAUTH2_TOKEN_URL_;\n    const data = {\n      refresh_token: refreshToken,\n      client_id: this._clientId,\n      client_secret: this._clientSecret,\n      grant_type: 'refresh_token'\n    };\n\n    // request for new token\n    const res = await this.transporter.request({\n      method: 'POST',\n      url,\n      data: querystring.stringify(data),\n      headers: {'Content-Type': 'application/x-www-form-urlencoded'}\n    });\n\n    const tokens = res.data as Credentials;\n    // TODO: de-duplicate this code from a few spots\n    if (res.data && res.data.expires_in) {\n      tokens.expiry_date =\n          ((new Date()).getTime() + (res.data.expires_in * 1000));\n      delete (tokens as CredentialRequest).expires_in;\n    }\n    this.emit('tokens', tokens);\n    return {tokens, res};\n  }\n\n  /**\n   * Retrieves the access token using refresh token\n   *\n   * @deprecated use getRequestHeaders instead.\n   * @param callback callback\n   */\n  refreshAccessToken(): Promise;\n  refreshAccessToken(callback: RefreshAccessTokenCallback): void;\n  refreshAccessToken(callback?: RefreshAccessTokenCallback):\n      Promise|void {\n    messages.warn(messages.REFRESH_ACCESS_TOKEN_DEPRECATED);\n    if (callback) {\n      this.refreshAccessTokenAsync().then(\n          r => callback(null, r.credentials, r.res), callback);\n    } else {\n      return this.refreshAccessTokenAsync();\n    }\n  }\n\n  private async refreshAccessTokenAsync() {\n    if (!this.credentials.refresh_token) {\n      throw new Error('No refresh token is set.');\n    }\n    const r = await this.refreshToken(this.credentials.refresh_token);\n    const tokens = r.tokens as Credentials;\n    tokens.refresh_token = this.credentials.refresh_token;\n    this.credentials = tokens;\n    return {credentials: this.credentials, res: r.res};\n  }\n\n  /**\n   * Get a non-expired access token, after refreshing if necessary\n   *\n   * @param callback Callback to call with the access token\n   */\n  getAccessToken(): Promise;\n  getAccessToken(callback: GetAccessTokenCallback): void;\n  getAccessToken(callback?: GetAccessTokenCallback):\n      Promise|void {\n    if (callback) {\n      this.getAccessTokenAsync().then(\n          r => callback(null, r.token, r.res), callback);\n    } else {\n      return this.getAccessTokenAsync();\n    }\n  }\n\n  private async getAccessTokenAsync(): Promise {\n    const shouldRefresh =\n        !this.credentials.access_token || this.isTokenExpiring();\n    if (shouldRefresh && this.credentials.refresh_token) {\n      if (!this.credentials.refresh_token) {\n        throw new Error('No refresh token is set.');\n      }\n\n      const r = await this.refreshAccessTokenAsync();\n      if (!r.credentials || (r.credentials && !r.credentials.access_token)) {\n        throw new Error('Could not refresh access token.');\n      }\n      return {token: r.credentials.access_token, res: r.res};\n    } else {\n      return {token: this.credentials.access_token};\n    }\n  }\n\n  /**\n   * Obtain the set of headers required to authenticate a request.\n   *\n   * @deprecated Use getRequestHeaders instead.\n   * @param url the Uri being authorized\n   * @param callback the func described above\n   */\n  getRequestMetadata(url?: string|null): Promise;\n  getRequestMetadata(url: string|null, callback: RequestMetadataCallback): void;\n  getRequestMetadata(url: string|null, callback?: RequestMetadataCallback):\n      Promise|void {\n    messages.warn(messages.OAUTH_GET_REQUEST_METADATA_DEPRECATED);\n    if (callback) {\n      this.getRequestMetadataAsync(url).then(\n          r => callback(null, r.headers, r.res), callback);\n    } else {\n      return this.getRequestMetadataAsync();\n    }\n  }\n\n  /**\n   * The main authentication interface.  It takes an optional url which when\n   * present is the endpoint being accessed, and returns a Promise which\n   * resolves with authorization header fields.\n   *\n   * In OAuth2Client, the result has the form:\n   * { Authorization: 'Bearer ' }\n   * @param url The optional url being authorized\n   */\n  async getRequestHeaders(url?: string): Promise {\n    const res = await this.getRequestMetadataAsync(url);\n    return res.headers;\n  }\n\n  protected async getRequestMetadataAsync(url?: string|null):\n      Promise {\n    const thisCreds = this.credentials;\n    if (!thisCreds.access_token && !thisCreds.refresh_token && !this.apiKey) {\n      throw new Error('No access, refresh token or API key is set.');\n    }\n\n    if (thisCreds.access_token && !this.isTokenExpiring()) {\n      thisCreds.token_type = thisCreds.token_type || 'Bearer';\n      const headers = {\n        Authorization: thisCreds.token_type + ' ' + thisCreds.access_token\n      };\n      return {headers};\n    }\n\n    if (this.apiKey) {\n      return {headers: {}};\n    }\n    let r: GetTokenResponse|null = null;\n    let tokens: Credentials|null = null;\n    try {\n      r = await this.refreshToken(thisCreds.refresh_token);\n      tokens = r.tokens;\n    } catch (err) {\n      const e = err as AxiosError;\n      if (e.response &&\n          (e.response.status === 403 || e.response.status === 404)) {\n        e.message = 'Could not refresh access token.';\n      }\n      throw e;\n    }\n\n    const credentials = this.credentials;\n    credentials.token_type = credentials.token_type || 'Bearer';\n    tokens.refresh_token = credentials.refresh_token;\n    this.credentials = tokens;\n    const headers = {\n      Authorization: credentials.token_type + ' ' + tokens.access_token\n    };\n    return {headers, res: r.res};\n  }\n\n  /**\n   * Revokes the access given to token.\n   * @param token The existing token to be revoked.\n   * @param callback Optional callback fn.\n   */\n  revokeToken(token: string): AxiosPromise;\n  revokeToken(\n      token: string,\n      callback: BodyResponseCallback): void;\n  revokeToken(\n      token: string, callback?: BodyResponseCallback):\n      AxiosPromise|void {\n    const opts = {\n      url: OAuth2Client.GOOGLE_OAUTH2_REVOKE_URL_ + '?' +\n          querystring.stringify({token}),\n      method: 'POST'\n    };\n    if (callback) {\n      this.transporter.request(opts).then(\n          r => callback(null, r), callback);\n    } else {\n      return this.transporter.request(opts);\n    }\n  }\n\n\n  /**\n   * Revokes access token and clears the credentials object\n   * @param callback callback\n   */\n  revokeCredentials(): AxiosPromise;\n  revokeCredentials(callback: BodyResponseCallback):\n      void;\n  revokeCredentials(callback?: BodyResponseCallback):\n      AxiosPromise|void {\n    if (callback) {\n      this.revokeCredentialsAsync().then(res => callback(null, res), callback);\n    } else {\n      return this.revokeCredentialsAsync();\n    }\n  }\n\n  private async revokeCredentialsAsync() {\n    const token = this.credentials.access_token;\n    this.credentials = {};\n    if (token) {\n      return this.revokeToken(token);\n    } else {\n      throw new Error('No access token to revoke.');\n    }\n  }\n\n  /**\n   * Provides a request implementation with OAuth 2.0 flow. If credentials have\n   * a refresh_token, in cases of HTTP 401 and 403 responses, it automatically\n   * asks for a new access token and replays the unsuccessful request.\n   * @param opts Request options.\n   * @param callback callback.\n   * @return Request object\n   */\n  request(opts: AxiosRequestConfig): AxiosPromise;\n  request(opts: AxiosRequestConfig, callback: BodyResponseCallback): void;\n  request(opts: AxiosRequestConfig, callback?: BodyResponseCallback):\n      AxiosPromise|void {\n    if (callback) {\n      this.requestAsync(opts).then(r => callback(null, r), e => {\n        return callback(e, e.response);\n      });\n    } else {\n      return this.requestAsync(opts);\n    }\n  }\n\n  protected async requestAsync(opts: AxiosRequestConfig, retry = false):\n      Promise> {\n    let r2: AxiosResponse;\n    try {\n      const r = await this.getRequestMetadataAsync(opts.url);\n      if (r.headers && r.headers.Authorization) {\n        opts.headers = opts.headers || {};\n        opts.headers.Authorization = r.headers.Authorization;\n      }\n\n      if (this.apiKey) {\n        opts.params = Object.assign(opts.params || {}, {key: this.apiKey});\n      }\n      r2 = await this.transporter.request(opts);\n    } catch (e) {\n      const res = (e as AxiosError).response;\n      if (res) {\n        const statusCode = res.status;\n        // Retry the request for metadata if the following criteria are true:\n        // - We haven't already retried.  It only makes sense to retry once.\n        // - The response was a 401 or a 403\n        // - The request didn't send a readableStream\n        // - An access_token and refresh_token were available, but no\n        //   expiry_date was availabe. This can happen when developers stash\n        //   the access_token and refresh_token for later use, but the\n        //   access_token fails on the first try because it's expired.\n        const mayRequireRefresh = this.credentials &&\n            this.credentials.access_token && this.credentials.refresh_token &&\n            !this.credentials.expiry_date;\n        const isReadableStream = res.config.data instanceof stream.Readable;\n        const isAuthErr = statusCode === 401 || statusCode === 403;\n        if (!retry && isAuthErr && !isReadableStream && mayRequireRefresh) {\n          await this.refreshAccessTokenAsync();\n          return this.requestAsync(opts, true);\n        }\n      }\n      throw e;\n    }\n    return r2;\n  }\n\n  /**\n   * Verify id token is token by checking the certs and audience\n   * @param options that contains all options.\n   * @param callback Callback supplying GoogleLogin if successful\n   */\n  verifyIdToken(options: VerifyIdTokenOptions): Promise;\n  verifyIdToken(\n      options: VerifyIdTokenOptions,\n      callback: (err: Error|null, login?: LoginTicket) => void): void;\n  verifyIdToken(\n      options: VerifyIdTokenOptions,\n      callback?: (err: Error|null, login?: LoginTicket) => void):\n      void|Promise {\n    // This function used to accept two arguments instead of an options object.\n    // Check the types to help users upgrade with less pain.\n    // This check can be removed after a 2.0 release.\n    if (callback && typeof callback !== 'function') {\n      throw new Error(\n          'This method accepts an options object as the first parameter, which includes the idToken, audience, and maxExpiry.');\n    }\n\n    if (callback) {\n      this.verifyIdTokenAsync(options).then(r => callback(null, r), callback);\n    } else {\n      return this.verifyIdTokenAsync(options);\n    }\n  }\n\n  private async verifyIdTokenAsync(options: VerifyIdTokenOptions):\n      Promise {\n    if (!options.idToken) {\n      throw new Error('The verifyIdToken method requires an ID Token');\n    }\n\n    const response = await this.getFederatedSignonCertsAsync();\n    const login = this.verifySignedJwtWithCerts(\n        options.idToken, response.certs, options.audience,\n        OAuth2Client.ISSUERS_, options.maxExpiry);\n\n    return login;\n  }\n\n  /**\n   * Obtains information about the provisioned access token.  Especially useful\n   * if you want to check the scopes that were provisioned to a given token.\n   *\n   * @param accessToken Required.  The Access Token for which you want to get\n   * user info.\n   */\n  async getTokenInfo(accessToken: string): Promise {\n    const {data} = await this.transporter.request({\n      method: 'GET',\n      url: OAuth2Client.GOOGLE_TOKEN_INFO_URL,\n      params: {access_token: accessToken}\n    });\n    const info = Object.assign(\n        {\n          expiry_date: ((new Date()).getTime() + (data.expires_in * 1000)),\n          scopes: data.scope.split(' ')\n        },\n        data);\n    delete info.expires_in;\n    delete info.scope;\n    return info;\n  }\n\n  /**\n   * Gets federated sign-on certificates to use for verifying identity tokens.\n   * Returns certs as array structure, where keys are key ids, and values\n   * are PEM encoded certificates.\n   * @param callback Callback supplying the certificates\n   */\n  getFederatedSignonCerts(): Promise;\n  getFederatedSignonCerts(callback: GetFederatedSignonCertsCallback): void;\n  getFederatedSignonCerts(callback?: GetFederatedSignonCertsCallback):\n      Promise|void {\n    if (callback) {\n      this.getFederatedSignonCertsAsync().then(\n          r => callback(null, r.certs, r.res), callback);\n    } else {\n      return this.getFederatedSignonCertsAsync();\n    }\n  }\n\n  async getFederatedSignonCertsAsync(): Promise {\n    const nowTime = (new Date()).getTime();\n    if (this.certificateExpiry &&\n        (nowTime = now + maxExpiry) {\n      throw new Error(\n          'Expiration time too far in future: ' + JSON.stringify(payload));\n    }\n\n    const earliest = iat - OAuth2Client.CLOCK_SKEW_SECS_;\n    const latest = exp + OAuth2Client.CLOCK_SKEW_SECS_;\n\n    if (now  latest) {\n      throw new Error(\n          'Token used too late, ' + now + ' > ' + latest + ': ' +\n          JSON.stringify(payload));\n    }\n\n    if (issuers && issuers.indexOf(payload.iss)  -1);\n      } else {\n        audVerified = (aud === requiredAudience);\n      }\n      if (!audVerified) {\n        throw new Error(\n            'Wrong recipient, payload audience != requiredAudience');\n      }\n    }\n    return new LoginTicket(envelope, payload);\n  }\n\n  /**\n   * This is a utils method to decode a base64 string\n   * @param b64String The string to base64 decode\n   * @return The decoded string\n   */\n  decodeBase64(b64String: string) {\n    const buffer = Buffer.from(b64String, 'base64');\n    return buffer.toString('utf8');\n  }\n\n  /**\n   * Returns true if a token is expired or will expire within\n   * eagerRefreshThresholdMillismilliseconds.\n   * If there is no expiry time, assumes the token is not expired or expiring.\n   */\n  protected isTokenExpiring(): boolean {\n    const expiryDate = this.credentials.expiry_date;\n    return expiryDate ? expiryDate \n    \n\n\n\n\n\n\n\n                   \n    \n         result-matching \"\"\n        \n    \n    \n        No results matching \"\"\n    \n\n"},"interfaces/TokenPayload.html":{"url":"interfaces/TokenPayload.html","title":"interface - TokenPayload","body":"\n                   \n\n\n\n\n\n\n\n\n\n\n\n\n\n  Interfaces\n  TokenPayload\n\n\n\n        \n            Info\n        \n        \n            Source\n        \n\n\n\n    \n        \n            File\n        \n        \n            src/auth/loginticket.ts\n        \n\n\n\n        \n            Index\n            \n                \n                    \n                        \n                            Properties\n                        \n                    \n                    \n                        \n                            \n                                \n                                            Optional\n                                        at_hash\n                                \n                                \n                                        aud\n                                \n                                \n                                            Optional\n                                        azp\n                                \n                                \n                                            Optional\n                                        email\n                                \n                                \n                                            Optional\n                                        email_verified\n                                \n                                \n                                        exp\n                                \n                                \n                                            Optional\n                                        family_name\n                                \n                                \n                                            Optional\n                                        given_name\n                                \n                                \n                                            Optional\n                                        hd\n                                \n                                \n                                        iat\n                                \n                                \n                                        iss\n                                \n                                \n                                            Optional\n                                        name\n                                \n                                \n                                            Optional\n                                        nonce\n                                \n                                \n                                            Optional\n                                        picture\n                                \n                                \n                                            Optional\n                                        profile\n                                \n                                \n                                        sub\n                                \n                            \n                        \n                    \n                \n            \n        \n\n\n\n            \n                Properties\n                    \n                        \n                                \n                                    \n                                        \n                                        at_hash\n                                    \n                                \n                                \n                                    \n                                        at_hash:     string\n\n                                    \n                                \n\n\n                                    \n                                        \n                                            Type :     string\n\n                                        \n                                    \n\n                                    \n                                        \n                                            Optional\n                                        \n                                    \n\n\n\n\n                            \n                                \n                                    Access token hash. Provides validation that the access token is tied to the\nidentity token. If the ID token is issued with an access token in the\nserver flow, this is always included. This can be used as an alternate\nmechanism to protect against cross-site request forgery attacks, but if you\nfollow Step 1 and Step 3 it is not necessary to verify the access token.\n\n                                \n                            \n                        \n                    \n                    \n                        \n                                \n                                    \n                                        \n                                        aud\n                                    \n                                \n                                \n                                    \n                                        aud:     string\n\n                                    \n                                \n\n\n                                    \n                                        \n                                            Type :     string\n\n                                        \n                                    \n\n\n\n\n\n                            \n                                \n                                    Identifies the audience that this ID token is intended for. It must be one\nof the OAuth 2.0 client IDs of your application.\n\n                                \n                            \n                        \n                    \n                    \n                        \n                                \n                                    \n                                        \n                                        azp\n                                    \n                                \n                                \n                                    \n                                        azp:     string\n\n                                    \n                                \n\n\n                                    \n                                        \n                                            Type :     string\n\n                                        \n                                    \n\n                                    \n                                        \n                                            Optional\n                                        \n                                    \n\n\n\n\n                            \n                                \n                                    The client_id of the authorized presenter. This claim is only needed when\nthe party requesting the ID token is not the same as the audience of the ID\ntoken. This may be the case at Google for hybrid apps where a web\napplication and Android app have a different client_id but share the same\nproject.\n\n                                \n                            \n                        \n                    \n                    \n                        \n                                \n                                    \n                                        \n                                        email\n                                    \n                                \n                                \n                                    \n                                        email:     string\n\n                                    \n                                \n\n\n                                    \n                                        \n                                            Type :     string\n\n                                        \n                                    \n\n                                    \n                                        \n                                            Optional\n                                        \n                                    \n\n\n\n\n                            \n                                \n                                    The user's email address. This may not be unique and is not suitable for\nuse as a primary key. Provided only if your scope included the string\n\"email\".\n\n                                \n                            \n                        \n                    \n                    \n                        \n                                \n                                    \n                                        \n                                        email_verified\n                                    \n                                \n                                \n                                    \n                                        email_verified:     boolean\n\n                                    \n                                \n\n\n                                    \n                                        \n                                            Type :     boolean\n\n                                        \n                                    \n\n                                    \n                                        \n                                            Optional\n                                        \n                                    \n\n\n\n\n                            \n                                \n                                    True if the user's e-mail address has been verified; otherwise false.\n\n                                \n                            \n                        \n                    \n                    \n                        \n                                \n                                    \n                                        \n                                        exp\n                                    \n                                \n                                \n                                    \n                                        exp:     number\n\n                                    \n                                \n\n\n                                    \n                                        \n                                            Type :     number\n\n                                        \n                                    \n\n\n\n\n\n                            \n                                \n                                    The time the ID token expires, represented in Unix time (integer seconds).\n\n                                \n                            \n                        \n                    \n                    \n                        \n                                \n                                    \n                                        \n                                        family_name\n                                    \n                                \n                                \n                                    \n                                        family_name:     string\n\n                                    \n                                \n\n\n                                    \n                                        \n                                            Type :     string\n\n                                        \n                                    \n\n                                    \n                                        \n                                            Optional\n                                        \n                                    \n\n\n\n\n                            \n                                \n                                    The user's family name, in a displayable form. Might be provided when:\n\nThe request scope included the string \"profile\"\nThe ID token is returned from a token refresh\nWhen name claims are present, you can use them to update your app's user\nrecords. Note that this claim is never guaranteed to be present.\n\n\n                                \n                            \n                        \n                    \n                    \n                        \n                                \n                                    \n                                        \n                                        given_name\n                                    \n                                \n                                \n                                    \n                                        given_name:     string\n\n                                    \n                                \n\n\n                                    \n                                        \n                                            Type :     string\n\n                                        \n                                    \n\n                                    \n                                        \n                                            Optional\n                                        \n                                    \n\n\n\n\n                            \n                                \n                                    The user's given name, in a displayable form. Might be provided when:\n\nThe request scope included the string \"profile\"\nThe ID token is returned from a token refresh\nWhen name claims are present, you can use them to update your app's user\nrecords. Note that this claim is never guaranteed to be present.\n\n\n                                \n                            \n                        \n                    \n                    \n                        \n                                \n                                    \n                                        \n                                        hd\n                                    \n                                \n                                \n                                    \n                                        hd:     string\n\n                                    \n                                \n\n\n                                    \n                                        \n                                            Type :     string\n\n                                        \n                                    \n\n                                    \n                                        \n                                            Optional\n                                        \n                                    \n\n\n\n\n                            \n                                \n                                    The hosted G Suite domain of the user. Provided only if the user belongs to\na hosted domain.\n\n                                \n                            \n                        \n                    \n                    \n                        \n                                \n                                    \n                                        \n                                        iat\n                                    \n                                \n                                \n                                    \n                                        iat:     number\n\n                                    \n                                \n\n\n                                    \n                                        \n                                            Type :     number\n\n                                        \n                                    \n\n\n\n\n\n                            \n                                \n                                    The time the ID token was issued, represented in Unix time (integer\nseconds).\n\n                                \n                            \n                        \n                    \n                    \n                        \n                                \n                                    \n                                        \n                                        iss\n                                    \n                                \n                                \n                                    \n                                        iss:     string\n\n                                    \n                                \n\n\n                                    \n                                        \n                                            Type :     string\n\n                                        \n                                    \n\n\n\n\n\n                            \n                                \n                                    The Issuer Identifier for the Issuer of the response. Always\nhttps://accounts.google.com or accounts.google.com for Google ID tokens.\n\n                                \n                            \n                        \n                    \n                    \n                        \n                                \n                                    \n                                        \n                                        name\n                                    \n                                \n                                \n                                    \n                                        name:     string\n\n                                    \n                                \n\n\n                                    \n                                        \n                                            Type :     string\n\n                                        \n                                    \n\n                                    \n                                        \n                                            Optional\n                                        \n                                    \n\n\n\n\n                            \n                                \n                                    The user's full name, in a displayable form. Might be provided when:\n\nThe request scope included the string \"profile\"\nThe ID token is returned from a token refresh\nWhen name claims are present, you can use them to update your app's user\nrecords. Note that this claim is never guaranteed to be present.\n\n\n                                \n                            \n                        \n                    \n                    \n                        \n                                \n                                    \n                                        \n                                        nonce\n                                    \n                                \n                                \n                                    \n                                        nonce:     string\n\n                                    \n                                \n\n\n                                    \n                                        \n                                            Type :     string\n\n                                        \n                                    \n\n                                    \n                                        \n                                            Optional\n                                        \n                                    \n\n\n\n\n                            \n                                \n                                    The value of the nonce supplied by your app in the authentication request.\nYou should enforce protection against replay attacks by ensuring it is\npresented only once.\n\n                                \n                            \n                        \n                    \n                    \n                        \n                                \n                                    \n                                        \n                                        picture\n                                    \n                                \n                                \n                                    \n                                        picture:     string\n\n                                    \n                                \n\n\n                                    \n                                        \n                                            Type :     string\n\n                                        \n                                    \n\n                                    \n                                        \n                                            Optional\n                                        \n                                    \n\n\n\n\n                            \n                                \n                                    The URL of the user's profile picture. Might be provided when:\n\nThe request scope included the string \"profile\"\nThe ID token is returned from a token refresh\nWhen picture claims are present, you can use them to update your app's\nuser records. Note that this claim is never guaranteed to be present.\n\n\n                                \n                            \n                        \n                    \n                    \n                        \n                                \n                                    \n                                        \n                                        profile\n                                    \n                                \n                                \n                                    \n                                        profile:     string\n\n                                    \n                                \n\n\n                                    \n                                        \n                                            Type :     string\n\n                                        \n                                    \n\n                                    \n                                        \n                                            Optional\n                                        \n                                    \n\n\n\n\n                            \n                                \n                                    The URL of the user's profile page. Might be provided when:\n\nThe request scope included the string \"profile\"\nThe ID token is returned from a token refresh\nWhen profile claims are present, you can use them to update your app's\nuser records. Note that this claim is never guaranteed to be present.\n\n\n                                \n                            \n                        \n                    \n                    \n                        \n                                \n                                    \n                                        \n                                        sub\n                                    \n                                \n                                \n                                    \n                                        sub:     string\n\n                                    \n                                \n\n\n                                    \n                                        \n                                            Type :     string\n\n                                        \n                                    \n\n\n\n\n\n                            \n                                \n                                    An identifier for the user, unique among all Google accounts and never\nreused. A Google account can have multiple emails at different points in\ntime, but the sub value is never changed. Use sub within your application\nas the unique-identifier key for the user.\n\n                                \n                            \n                        \n                    \n            \n    \n\n\n    \n        export class LoginTicket {\n  private envelope?: string;\n  private payload?: TokenPayload;\n\n  /**\n   * Create a simple class to extract user ID from an ID Token\n   *\n   * @param {string} env Envelope of the jwt\n   * @param {TokenPayload} pay Payload of the jwt\n   * @constructor\n   */\n  constructor(env?: string, pay?: TokenPayload) {\n    this.envelope = env;\n    this.payload = pay;\n  }\n\n  getEnvelope() {\n    return this.envelope;\n  }\n\n  getPayload() {\n    return this.payload;\n  }\n\n  /**\n   * Create a simple class to extract user ID from an ID Token\n   *\n   * @return The user ID\n   */\n  getUserId() {\n    const payload = this.getPayload();\n    if (payload && payload.sub) {\n      return payload.sub;\n    }\n    return null;\n  }\n\n  /**\n   * Returns attributes from the login ticket.  This can contain\n   * various information about the user session.\n   *\n   * @return The envelope and payload\n   */\n  getAttributes() {\n    return {envelope: this.getEnvelope(), payload: this.getPayload()};\n  }\n}\n\nexport interface TokenPayload {\n  /**\n   * The Issuer Identifier for the Issuer of the response. Always\n   * https://accounts.google.com or accounts.google.com for Google ID tokens.\n   */\n  iss: string;\n\n  /**\n   * Access token hash. Provides validation that the access token is tied to the\n   * identity token. If the ID token is issued with an access token in the\n   * server flow, this is always included. This can be used as an alternate\n   * mechanism to protect against cross-site request forgery attacks, but if you\n   * follow Step 1 and Step 3 it is not necessary to verify the access token.\n   */\n  at_hash?: string;\n\n  /**\n   * True if the user's e-mail address has been verified; otherwise false.\n   */\n  email_verified?: boolean;\n\n  /**\n   * An identifier for the user, unique among all Google accounts and never\n   * reused. A Google account can have multiple emails at different points in\n   * time, but the sub value is never changed. Use sub within your application\n   * as the unique-identifier key for the user.\n   */\n  sub: string;\n\n  /**\n   * The client_id of the authorized presenter. This claim is only needed when\n   * the party requesting the ID token is not the same as the audience of the ID\n   * token. This may be the case at Google for hybrid apps where a web\n   * application and Android app have a different client_id but share the same\n   * project.\n   */\n  azp?: string;\n\n  /**\n   * The user's email address. This may not be unique and is not suitable for\n   * use as a primary key. Provided only if your scope included the string\n   * \"email\".\n   */\n  email?: string;\n\n  /**\n   * The URL of the user's profile page. Might be provided when:\n   * - The request scope included the string \"profile\"\n   * - The ID token is returned from a token refresh\n   * - When profile claims are present, you can use them to update your app's\n   * user records. Note that this claim is never guaranteed to be present.\n   */\n  profile?: string;\n\n  /**\n   * The URL of the user's profile picture. Might be provided when:\n   * - The request scope included the string \"profile\"\n   * - The ID token is returned from a token refresh\n   * - When picture claims are present, you can use them to update your app's\n   * user records. Note that this claim is never guaranteed to be present.\n   */\n  picture?: string;\n\n  /**\n   * The user's full name, in a displayable form. Might be provided when:\n   * - The request scope included the string \"profile\"\n   * - The ID token is returned from a token refresh\n   * - When name claims are present, you can use them to update your app's user\n   * records. Note that this claim is never guaranteed to be present.\n   */\n  name?: string;\n\n  /**\n   * The user's given name, in a displayable form. Might be provided when:\n   * - The request scope included the string \"profile\"\n   * - The ID token is returned from a token refresh\n   * - When name claims are present, you can use them to update your app's user\n   * records. Note that this claim is never guaranteed to be present.\n   */\n  given_name?: string;\n\n  /**\n   * The user's family name, in a displayable form. Might be provided when:\n   * - The request scope included the string \"profile\"\n   * - The ID token is returned from a token refresh\n   * - When name claims are present, you can use them to update your app's user\n   * records. Note that this claim is never guaranteed to be present.\n   */\n  family_name?: string;\n\n  /**\n   * Identifies the audience that this ID token is intended for. It must be one\n   * of the OAuth 2.0 client IDs of your application.\n   */\n  aud: string;\n\n  /**\n   * The time the ID token was issued, represented in Unix time (integer\n   * seconds).\n   */\n  iat: number;\n\n  /**\n   * The time the ID token expires, represented in Unix time (integer seconds).\n   */\n  exp: number;\n\n  /**\n   * The value of the nonce supplied by your app in the authentication request.\n   * You should enforce protection against replay attacks by ensuring it is\n   * presented only once.\n   */\n  nonce?: string;\n\n  /**\n   * The hosted G Suite domain of the user. Provided only if the user belongs to\n   * a hosted domain.\n   */\n  hd?: string;\n}\n\n    \n\n\n\n\n\n\n\n                   \n    \n         result-matching \"\"\n        \n    \n    \n        No results matching \"\"\n    \n\n"},"interfaces/Transporter.html":{"url":"interfaces/Transporter.html","title":"interface - Transporter","body":"\n                   \n\n\n\n\n\n\n\n\n\n\n\n\n\n  Interfaces\n  Transporter\n\n\n\n        \n            Info\n        \n        \n            Source\n        \n\n\n\n    \n        \n            File\n        \n        \n            src/transporters.ts\n        \n\n\n\n        \n            Index\n            \n                \n                    \n                        \n                            Methods\n                        \n                    \n                    \n                        \n                            \n                                \n                                    request\n                                \n                                \n                                    request\n                                \n                                \n                                    request\n                                \n                            \n                        \n                    \n                \n            \n        \n\n            \n    \n        \n            Methods\n        \n        \n            \n                \n                    \n                        \n                        \n                            \n                            request\n                            \n                            \n                        \n                    \n                \n                \n                    \nrequest(opts: AxiosRequestConfig)\n                    \n                \n\n\n                        \n                            \n                                    Defined in src/transporters.ts:28\n                            \n                        \n\n                        \n                            \n                                Type parameters :\n                                \n                                        T\n                                \n                            \n                        \n\n                \n                    \n\n                            \n                                    Parameters :\n                                    \n                                        \n                                            \n                                                Name\n                                                    Type\n                                                Optional\n                                            \n                                        \n                                        \n                                                \n                                                        opts\n                                                        \n                                                                    AxiosRequestConfig\n                                                        \n                                                    \n                                                    \n                                                            No\n                                                    \n                                                    \n\n                                                \n                                        \n                                    \n                            \n                            \n                            \n                            \n                                Returns :     AxiosPromise\n\n                            \n                                \n                                    \n                                \n                    \n                \n            \n        \n        \n            \n                \n                    \n                        \n                        \n                            \n                            request\n                            \n                            \n                        \n                    \n                \n                \n                    \nrequest(opts: AxiosRequestConfig, callback?: BodyResponseCallback)\n                    \n                \n\n\n                        \n                            \n                                    Defined in src/transporters.ts:29\n                            \n                        \n\n                        \n                            \n                                Type parameters :\n                                \n                                        T\n                                \n                            \n                        \n\n                \n                    \n\n                            \n                                    Parameters :\n                                    \n                                        \n                                            \n                                                Name\n                                                    Type\n                                                Optional\n                                            \n                                        \n                                        \n                                                \n                                                        opts\n                                                        \n                                                                    AxiosRequestConfig\n                                                        \n                                                    \n                                                    \n                                                            No\n                                                    \n                                                    \n\n                                                \n                                                \n                                                        callback\n                                                        \n                                                                    BodyResponseCallback\n                                                        \n                                                    \n                                                    \n                                                            Yes\n                                                    \n                                                    \n\n                                                \n                                        \n                                    \n                            \n                            \n                            \n                            \n                                Returns :     void\n\n                            \n                                \n                                    \n                                \n                    \n                \n            \n        \n        \n            \n                \n                    \n                        \n                        \n                            \n                            request\n                            \n                            \n                        \n                    \n                \n                \n                    \nrequest(opts: AxiosRequestConfig, callback?: BodyResponseCallback)\n                    \n                \n\n\n                        \n                            \n                                    Defined in src/transporters.ts:31\n                            \n                        \n\n                        \n                            \n                                Type parameters :\n                                \n                                        T\n                                \n                            \n                        \n\n                \n                    \n\n                            \n                                    Parameters :\n                                    \n                                        \n                                            \n                                                Name\n                                                    Type\n                                                Optional\n                                            \n                                        \n                                        \n                                                \n                                                        opts\n                                                        \n                                                                    AxiosRequestConfig\n                                                        \n                                                    \n                                                    \n                                                            No\n                                                    \n                                                    \n\n                                                \n                                                \n                                                        callback\n                                                        \n                                                                    BodyResponseCallback\n                                                        \n                                                    \n                                                    \n                                                            Yes\n                                                    \n                                                    \n\n                                                \n                                        \n                                    \n                            \n                            \n                            \n                            \n                                Returns :     AxiosPromise | void\n\n                            \n                                \n                                    \n                                \n                    \n                \n            \n        \n\n\n\n    \n\n\n    \n        import axios, {AxiosError, AxiosPromise, AxiosRequestConfig, AxiosResponse} from 'axios';\nimport {validate} from './options';\n\n// tslint:disable-next-line variable-name\nconst HttpsProxyAgent = require('https-proxy-agent');\n\n// tslint:disable-next-line no-var-requires\nconst pkg = require('../../package.json');\nconst PRODUCT_NAME = 'google-api-nodejs-client';\n\nexport interface Transporter {\n  request(opts: AxiosRequestConfig): AxiosPromise;\n  request(opts: AxiosRequestConfig, callback?: BodyResponseCallback):\n      void;\n  request(opts: AxiosRequestConfig, callback?: BodyResponseCallback):\n      AxiosPromise|void;\n}\n\nexport interface BodyResponseCallback {\n  // The `body` object is a truly dynamic type.  It must be `any`.\n  (err: Error|null, res?: AxiosResponse|null): void;\n}\n\nexport interface RequestError extends AxiosError {\n  errors: Error[];\n}\n\n/**\n * Axios will use XHR if it is available. In the case of Electron,\n * since XHR is there it will try to use that. This leads to OPTIONS\n * preflight requests which googleapis DOES NOT like. This line of\n * code pins the adapter to ensure it uses node.\n * https://github.com/google/google-api-nodejs-client/issues/1083\n */\naxios.defaults.adapter = require('axios/lib/adapters/http');\n\nexport class DefaultTransporter {\n  /**\n   * Default user agent.\n   */\n  static readonly USER_AGENT = `${PRODUCT_NAME}/${pkg.version}`;\n\n  /**\n   * Configures request options before making a request.\n   * @param opts AxiosRequestConfig options.\n   * @return Configured options.\n   */\n  configure(opts: AxiosRequestConfig = {}): AxiosRequestConfig {\n    // set transporter user agent\n    opts.headers = opts.headers || {};\n    const uaValue: string = opts.headers['User-Agent'];\n    if (!uaValue) {\n      opts.headers['User-Agent'] = DefaultTransporter.USER_AGENT;\n    } else if (!uaValue.includes(`${PRODUCT_NAME}/`)) {\n      opts.headers['User-Agent'] =\n          `${uaValue} ${DefaultTransporter.USER_AGENT}`;\n    }\n    return opts;\n  }\n\n  /**\n   * Makes a request using Axios with given options.\n   * @param opts AxiosRequestConfig options.\n   * @param callback optional callback that contains AxiosResponse object.\n   * @return AxiosPromise, assuming no callback is passed.\n   */\n  request(opts: AxiosRequestConfig): AxiosPromise;\n  request(opts: AxiosRequestConfig, callback?: BodyResponseCallback):\n      void;\n  request(opts: AxiosRequestConfig, callback?: BodyResponseCallback):\n      AxiosPromise|void {\n    // ensure the user isn't passing in request-style options\n    opts = this.configure(opts);\n    try {\n      validate(opts);\n    } catch (e) {\n      if (callback) {\n        return callback(e);\n      } else {\n        throw e;\n      }\n    }\n\n    // If the user configured an `HTTPS_PROXY` environment variable, create\n    // a custom agent to proxy the request.\n    const proxy = process.env.HTTPS_PROXY || process.env.https_proxy;\n    if (proxy) {\n      opts.httpsAgent = new HttpsProxyAgent(proxy);\n      opts.proxy = false;\n    }\n\n    if (callback) {\n      axios(opts).then(\n          r => {\n            callback(null, r);\n          },\n          e => {\n            callback(this.processError(e));\n          });\n    } else {\n      return axios(opts).catch(e => {\n        throw this.processError(e);\n      });\n    }\n  }\n\n  /**\n   * Changes the error to include details from the body.\n   */\n  private processError(e: AxiosError): RequestError {\n    const res = e.response;\n    const err = e as RequestError;\n    const body = res ? res.data : null;\n    if (res && body && body.error && res.status !== 200) {\n      if (typeof body.error === 'string') {\n        err.message = body.error;\n        err.code = res.status.toString();\n      } else if (Array.isArray(body.error.errors)) {\n        err.message =\n            body.error.errors.map((err2: Error) => err2.message).join('\\n');\n        err.code = body.error.code;\n        err.errors = body.error.errors;\n      } else {\n        err.message = body.error.message;\n        err.code = body.error.code || res.status;\n      }\n    } else if (res && res.status >= 400) {\n      // Consider all 4xx and 5xx responses errors.\n      err.message = body;\n      err.code = res.status.toString();\n    }\n    return err;\n  }\n}\n\n    \n\n\n\n\n\n\n\n                   \n    \n         result-matching \"\"\n        \n    \n    \n        No results matching \"\"\n    \n\n"},"interfaces/UserRefreshClientOptions.html":{"url":"interfaces/UserRefreshClientOptions.html","title":"interface - UserRefreshClientOptions","body":"\n                   \n\n\n\n\n\n\n\n\n\n\n\n\n\n  Interfaces\n  UserRefreshClientOptions\n\n\n\n        \n            Info\n        \n        \n            Source\n        \n\n\n\n    \n        \n            File\n        \n        \n            src/auth/refreshclient.ts\n        \n\n\n            \n                Extends\n            \n            \n                    RefreshOptions\n            \n\n        \n            Index\n            \n                \n                    \n                        \n                            Properties\n                        \n                    \n                    \n                        \n                            \n                                \n                                            Optional\n                                        clientId\n                                \n                                \n                                            Optional\n                                        clientSecret\n                                \n                                \n                                            Optional\n                                        refreshToken\n                                \n                            \n                        \n                    \n                \n            \n        \n\n\n\n            \n                Properties\n                    \n                        \n                                \n                                    \n                                        \n                                        clientId\n                                    \n                                \n                                \n                                    \n                                        clientId:     string\n\n                                    \n                                \n\n\n                                    \n                                        \n                                            Type :     string\n\n                                        \n                                    \n\n                                    \n                                        \n                                            Optional\n                                        \n                                    \n\n\n\n\n                        \n                    \n                    \n                        \n                                \n                                    \n                                        \n                                        clientSecret\n                                    \n                                \n                                \n                                    \n                                        clientSecret:     string\n\n                                    \n                                \n\n\n                                    \n                                        \n                                            Type :     string\n\n                                        \n                                    \n\n                                    \n                                        \n                                            Optional\n                                        \n                                    \n\n\n\n\n                        \n                    \n                    \n                        \n                                \n                                    \n                                        \n                                        refreshToken\n                                    \n                                \n                                \n                                    \n                                        refreshToken:     string\n\n                                    \n                                \n\n\n                                    \n                                        \n                                            Type :     string\n\n                                        \n                                    \n\n                                    \n                                        \n                                            Optional\n                                        \n                                    \n\n\n\n\n                        \n                    \n            \n    \n\n\n    \n        import * as stream from 'stream';\nimport {JWTInput} from './credentials';\nimport {GetTokenResponse, OAuth2Client, RefreshOptions} from './oauth2client';\n\nexport interface UserRefreshClientOptions extends RefreshOptions {\n  clientId?: string;\n  clientSecret?: string;\n  refreshToken?: string;\n}\n\nexport class UserRefreshClient extends OAuth2Client {\n  // TODO: refactor tests to make this private\n  // In a future gts release, the _propertyName rule will be lifted.\n  // This is also a hard one because `this.refreshToken` is a function.\n  _refreshToken?: string|null;\n\n  /**\n   * User Refresh Token credentials.\n   *\n   * @param clientId The authentication client ID.\n   * @param clientSecret The authentication client secret.\n   * @param refreshToken The authentication refresh token.\n   */\n  constructor(clientId?: string, clientSecret?: string, refreshToken?: string);\n  constructor(options: UserRefreshClientOptions);\n  constructor(clientId?: string, clientSecret?: string, refreshToken?: string);\n  constructor(\n      optionsOrClientId?: string|UserRefreshClientOptions,\n      clientSecret?: string, refreshToken?: string,\n      eagerRefreshThresholdMillis?: number) {\n    const opts = (optionsOrClientId && typeof optionsOrClientId === 'object') ?\n        optionsOrClientId :\n        {\n          clientId: optionsOrClientId,\n          clientSecret,\n          refreshToken,\n          eagerRefreshThresholdMillis\n        };\n    super({\n      clientId: opts.clientId,\n      clientSecret: opts.clientSecret,\n      eagerRefreshThresholdMillis: opts.eagerRefreshThresholdMillis\n    });\n    this._refreshToken = opts.refreshToken;\n  }\n\n  /**\n   * Refreshes the access token.\n   * @param refreshToken An ignored refreshToken..\n   * @param callback Optional callback.\n   */\n  protected async refreshTokenNoCache(refreshToken?: string|\n                                      null): Promise {\n    return super.refreshTokenNoCache(this._refreshToken);\n  }\n\n  /**\n   * Create a UserRefreshClient credentials instance using the given input\n   * options.\n   * @param json The input object.\n   */\n  fromJSON(json: JWTInput): void {\n    if (!json) {\n      throw new Error(\n          'Must pass in a JSON object containing the user refresh token');\n    }\n    if (json.type !== 'authorized_user') {\n      throw new Error(\n          'The incoming JSON object does not have the \"authorized_user\" type');\n    }\n    if (!json.client_id) {\n      throw new Error(\n          'The incoming JSON object does not contain a client_id field');\n    }\n    if (!json.client_secret) {\n      throw new Error(\n          'The incoming JSON object does not contain a client_secret field');\n    }\n    if (!json.refresh_token) {\n      throw new Error(\n          'The incoming JSON object does not contain a refresh_token field');\n    }\n    this._clientId = json.client_id;\n    this._clientSecret = json.client_secret;\n    this._refreshToken = json.refresh_token;\n    this.credentials.refresh_token = json.refresh_token;\n  }\n\n  /**\n   * Create a UserRefreshClient credentials instance using the given input\n   * stream.\n   * @param inputStream The input stream.\n   * @param callback Optional callback.\n   */\n  fromStream(inputStream: stream.Readable): Promise;\n  fromStream(inputStream: stream.Readable, callback: (err?: Error) => void):\n      void;\n  fromStream(inputStream: stream.Readable, callback?: (err?: Error) => void):\n      void|Promise {\n    if (callback) {\n      this.fromStreamAsync(inputStream).then(r => callback(), callback);\n    } else {\n      return this.fromStreamAsync(inputStream);\n    }\n  }\n\n  private async fromStreamAsync(inputStream: stream.Readable): Promise {\n    return new Promise((resolve, reject) => {\n      if (!inputStream) {\n        return reject(new Error(\n            'Must pass in a stream containing the user refresh token.'));\n      }\n      let s = '';\n      inputStream.setEncoding('utf8')\n          .on('error', reject)\n          .on('data', (chunk) => s += chunk)\n          .on('end', () => {\n            try {\n              const data = JSON.parse(s);\n              this.fromJSON(data);\n              return resolve();\n            } catch (err) {\n              return reject(err);\n            }\n          });\n    });\n  }\n}\n\n    \n\n\n\n\n\n\n\n                   \n    \n         result-matching \"\"\n        \n    \n    \n        No results matching \"\"\n    \n\n"},"interfaces/VerifyIdTokenOptions.html":{"url":"interfaces/VerifyIdTokenOptions.html","title":"interface - VerifyIdTokenOptions","body":"\n                   \n\n\n\n\n\n\n\n\n\n\n\n\n\n  Interfaces\n  VerifyIdTokenOptions\n\n\n\n        \n            Info\n        \n        \n            Source\n        \n\n\n\n    \n        \n            File\n        \n        \n            src/auth/oauth2client.ts\n        \n\n\n\n        \n            Index\n            \n                \n                    \n                        \n                            Properties\n                        \n                    \n                    \n                        \n                            \n                                \n                                        audience\n                                \n                                \n                                        idToken\n                                \n                                \n                                            Optional\n                                        maxExpiry\n                                \n                            \n                        \n                    \n                \n            \n        \n\n\n\n            \n                Properties\n                    \n                        \n                                \n                                    \n                                        \n                                        audience\n                                    \n                                \n                                \n                                    \n                                        audience:     string | string[]\n\n                                    \n                                \n\n\n                                    \n                                        \n                                            Type :     string | string[]\n\n                                        \n                                    \n\n\n\n\n\n                        \n                    \n                    \n                        \n                                \n                                    \n                                        \n                                        idToken\n                                    \n                                \n                                \n                                    \n                                        idToken:     string\n\n                                    \n                                \n\n\n                                    \n                                        \n                                            Type :     string\n\n                                        \n                                    \n\n\n\n\n\n                        \n                    \n                    \n                        \n                                \n                                    \n                                        \n                                        maxExpiry\n                                    \n                                \n                                \n                                    \n                                        maxExpiry:     number\n\n                                    \n                                \n\n\n                                    \n                                        \n                                            Type :     number\n\n                                        \n                                    \n\n                                    \n                                        \n                                            Optional\n                                        \n                                    \n\n\n\n\n                        \n                    \n            \n    \n\n\n    \n        import {AxiosError, AxiosPromise, AxiosRequestConfig, AxiosResponse} from 'axios';\nimport * as crypto from 'crypto';\nimport * as querystring from 'querystring';\nimport * as stream from 'stream';\nimport * as messages from '../messages';\nimport {PemVerifier} from './../pemverifier';\nimport {BodyResponseCallback} from './../transporters';\nimport {AuthClient} from './authclient';\nimport {CredentialRequest, Credentials} from './credentials';\nimport {LoginTicket, TokenPayload} from './loginticket';\n\nexport type Certificates = {\n  [index: string]: string\n};\n\nexport type Headers = {\n  [index: string]: string\n};\n\nexport enum CodeChallengeMethod {\n  Plain = 'plain',\n  S256 = 'S256'\n}\n\nexport interface GetTokenOptions {\n  code: string;\n  codeVerifier?: string;\n  /**\n   * The client ID for your application. The value passed into the constructor\n   * will be used if not provided. Must match any client_id option passed to\n   * a corresponding call to generateAuthUrl.\n   */\n  client_id?: string;\n  /**\n   * Determines where the API server redirects the user after the user\n   * completes the authorization flow. The value passed into the constructor\n   * will be used if not provided. Must match any redirect_uri option passed to\n   * a corresponding call to generateAuthUrl.\n   */\n  redirect_uri?: string;\n}\n\nexport interface TokenInfo {\n  /**\n   * The application that is the intended user of the access token.\n   */\n  aud: string;\n\n  /**\n   * This value lets you correlate profile information from multiple Google\n   * APIs. It is only present in the response if you included the profile scope\n   * in your request in step 1. The field value is an immutable identifier for\n   * the logged-in user that can be used to create and manage user sessions in\n   * your application. The identifier is the same regardless of which client ID\n   * is used to retrieve it. This enables multiple applications in the same\n   * organization to correlate profile information.\n   */\n  user_id?: string;\n\n  /**\n   * An array of scopes that the user granted access to.\n   */\n  scopes: string[];\n\n  /**\n   * The datetime when the token becomes invalid.\n   */\n  expiry_date: number;\n\n  /**\n   * An identifier for the user, unique among all Google accounts and never\n   * reused. A Google account can have multiple emails at different points in\n   * time, but the sub value is never changed. Use sub within your application\n   * as the unique-identifier key for the user.\n   */\n  sub?: string;\n\n  /**\n   * The client_id of the authorized presenter. This claim is only needed when\n   * the party requesting the ID token is not the same as the audience of the ID\n   * token. This may be the case at Google for hybrid apps where a web\n   * application and Android app have a different client_id but share the same\n   * project.\n   */\n  azp?: string;\n\n  /**\n   * Indicates whether your application can refresh access tokens\n   * when the user is not present at the browser. Valid parameter values are\n   * 'online', which is the default value, and 'offline'. Set the value to\n   * 'offline' if your application needs to refresh access tokens when the user\n   * is not present at the browser. This value instructs the Google\n   * authorization server to return a refresh token and an access token the\n   * first time that your application exchanges an authorization code for\n   * tokens.\n   */\n  access_type?: string;\n}\n\ninterface TokenInfoRequest {\n  aud: string;\n  user_id?: string;\n  scope: string;\n  expires_in: number;\n  azp?: string;\n  sub?: string;\n  exp?: number;\n  access_type?: string;\n}\n\nexport interface GenerateAuthUrlOpts {\n  /**\n   * Recommended. Indicates whether your application can refresh access tokens\n   * when the user is not present at the browser. Valid parameter values are\n   * 'online', which is the default value, and 'offline'. Set the value to\n   * 'offline' if your application needs to refresh access tokens when the user\n   * is not present at the browser. This value instructs the Google\n   * authorization server to return a refresh token and an access token the\n   * first time that your application exchanges an authorization code for\n   * tokens.\n   */\n  access_type?: string;\n\n  /**\n   * The hd (hosted domain) parameter streamlines the login process for G Suite\n   * hosted accounts. By including the domain of the G Suite user (for example,\n   * mycollege.edu), you can indicate that the account selection UI should be\n   * optimized for accounts at that domain. To optimize for G Suite accounts\n   * generally instead of just one domain, use an asterisk: hd=*.\n   * Don't rely on this UI optimization to control who can access your app,\n   * as client-side requests can be modified. Be sure to validate that the\n   * returned ID token has an hd claim value that matches what you expect\n   * (e.g. mycolledge.edu). Unlike the request parameter, the ID token claim is\n   * contained within a security token from Google, so the value can be trusted.\n   */\n  hd?: string;\n\n  /**\n   * The 'response_type' will always be set to 'CODE'.\n   */\n  response_type?: string;\n\n  /**\n   * The client ID for your application. The value passed into the constructor\n   * will be used if not provided. You can find this value in the API Console.\n   */\n  client_id?: string;\n\n  /**\n   * Determines where the API server redirects the user after the user\n   * completes the authorization flow. The value must exactly match one of the\n   * 'redirect_uri' values listed for your project in the API Console. Note that\n   * the http or https scheme, case, and trailing slash ('/') must all match.\n   * The value passed into the constructor will be used if not provided.\n   */\n  redirect_uri?: string;\n\n  /**\n   * Required. A space-delimited list of scopes that identify the resources that\n   * your application could access on the user's behalf. These values inform the\n   * consent screen that Google displays to the user. Scopes enable your\n   * application to only request access to the resources that it needs while\n   * also enabling users to control the amount of access that they grant to your\n   * application. Thus, there is an inverse relationship between the number of\n   * scopes requested and the likelihood of obtaining user consent. The\n   * OAuth 2.0 API Scopes document provides a full list of scopes that you might\n   * use to access Google APIs. We recommend that your application request\n   * access to authorization scopes in context whenever possible. By requesting\n   * access to user data in context, via incremental authorization, you help\n   * users to more easily understand why your application needs the access it is\n   * requesting.\n   */\n  scope?: string[]|string;\n\n  /**\n   * Recommended. Specifies any string value that your application uses to\n   * maintain state between your authorization request and the authorization\n   * server's response. The server returns the exact value that you send as a\n   * name=value pair in the hash (#) fragment of the 'redirect_uri' after the\n   * user consents to or denies your application's access request. You can use\n   * this parameter for several purposes, such as directing the user to the\n   * correct resource in your application, sending nonces, and mitigating\n   * cross-site request forgery. Since your redirect_uri can be guessed, using a\n   * state value can increase your assurance that an incoming connection is the\n   * result of an authentication request. If you generate a random string or\n   * encode the hash of a cookie or another value that captures the client's\n   * state, you can validate the response to additionally ensure that the\n   * request and response originated in the same browser, providing protection\n   * against attacks such as cross-site request forgery. See the OpenID Connect\n   * documentation for an example of how to create and confirm a state token.\n   */\n  state?: string;\n\n  /**\n   * Optional. Enables applications to use incremental authorization to request\n   * access to additional scopes in context. If you set this parameter's value\n   * to true and the authorization request is granted, then the new access token\n   * will also cover any scopes to which the user previously granted the\n   * application access. See the incremental authorization section for examples.\n   */\n  include_granted_scopes?: boolean;\n\n  /**\n   * Optional. If your application knows which user is trying to authenticate,\n   * it can use this parameter to provide a hint to the Google Authentication\n   * Server. The server uses the hint to simplify the login flow either by\n   * prefilling the email field in the sign-in form or by selecting the\n   * appropriate multi-login session. Set the parameter value to an email\n   * address or sub identifier, which is equivalent to the user's Google ID.\n   */\n  login_hint?: string;\n\n  /**\n   * Optional. A space-delimited, case-sensitive list of prompts to present the\n   * user. If you don't specify this parameter, the user will be prompted only\n   * the first time your app requests access.  Possible values are:\n   *\n   * 'none' - Donot display any authentication or consent screens. Must not be\n   *        specified with other values.\n   * 'consent' - \tPrompt the user for consent.\n   * 'select_account' - Prompt the user to select an account.\n   */\n  prompt?: string;\n\n  /**\n   * Recommended. Specifies what method was used to encode a 'code_verifier'\n   * that will be used during authorization code exchange. This parameter must\n   * be used with the 'code_challenge' parameter. The value of the\n   * 'code_challenge_method' defaults to \"plain\" if not present in the request\n   * that includes a 'code_challenge'. The only supported values for this\n   * parameter are \"S256\" or \"plain\".\n   */\n  code_challenge_method?: CodeChallengeMethod;\n\n  /**\n   * Recommended. Specifies an encoded 'code_verifier' that will be used as a\n   * server-side challenge during authorization code exchange. This parameter\n   * must be used with the 'code_challenge' parameter described above.\n   */\n  code_challenge?: string;\n}\n\nexport interface GetTokenCallback {\n  (err: AxiosError|null, token?: Credentials|null,\n   res?: AxiosResponse|null): void;\n}\n\nexport interface GetTokenResponse {\n  tokens: Credentials;\n  res: AxiosResponse|null;\n}\n\nexport interface GetAccessTokenCallback {\n  (err: AxiosError|null, token?: string|null, res?: AxiosResponse|null): void;\n}\n\nexport interface GetAccessTokenResponse {\n  token?: string|null;\n  res?: AxiosResponse|null;\n}\n\nexport interface RefreshAccessTokenCallback {\n  (err: AxiosError|null, credentials?: Credentials|null,\n   res?: AxiosResponse|null): void;\n}\n\nexport interface RefreshAccessTokenResponse {\n  credentials: Credentials;\n  res: AxiosResponse|null;\n}\n\nexport interface RequestMetadataResponse {\n  headers: Headers;\n  res?: AxiosResponse|null;\n}\n\nexport interface RequestMetadataCallback {\n  (err: AxiosError|null, headers?: Headers,\n   res?: AxiosResponse|null): void;\n}\n\nexport interface GetFederatedSignonCertsCallback {\n  (err: AxiosError|null, certs?: Certificates,\n   response?: AxiosResponse|null): void;\n}\n\nexport interface FederatedSignonCertsResponse {\n  certs: Certificates;\n  res?: AxiosResponse|null;\n}\n\nexport interface RevokeCredentialsResult {\n  success: boolean;\n}\n\nexport interface VerifyIdTokenOptions {\n  idToken: string;\n  audience: string|string[];\n  maxExpiry?: number;\n}\n\nexport interface OAuth2ClientOptions extends RefreshOptions {\n  clientId?: string;\n  clientSecret?: string;\n  redirectUri?: string;\n}\n\nexport interface RefreshOptions {\n  // Eagerly refresh unexpired tokens when they are within this many\n  // milliseconds from expiring\".\n  // Defaults to a value of 300000 (5 minutes).\n  eagerRefreshThresholdMillis?: number;\n}\n\nexport class OAuth2Client extends AuthClient {\n  private redirectUri?: string;\n  private certificateCache?: Certificates;\n  private certificateExpiry: Date|null = null;\n  protected refreshTokenPromises = new Map>();\n\n  // TODO: refactor tests to make this private\n  _clientId?: string;\n\n  // TODO: refactor tests to make this private\n  _clientSecret?: string;\n\n  apiKey?: string;\n\n  projectId?: string;\n\n  eagerRefreshThresholdMillis: number;\n\n  /**\n   * Handles OAuth2 flow for Google APIs.\n   *\n   * @param clientId The authentication client ID.\n   * @param clientSecret The authentication client secret.\n   * @param redirectUri The URI to redirect to after completing the auth\n   * request.\n   * @param opts optional options for overriding the given parameters.\n   * @constructor\n   */\n  constructor(options?: OAuth2ClientOptions);\n  constructor(clientId?: string, clientSecret?: string, redirectUri?: string);\n  constructor(\n      optionsOrClientId?: string|OAuth2ClientOptions, clientSecret?: string,\n      redirectUri?: string) {\n    super();\n    const opts = (optionsOrClientId && typeof optionsOrClientId === 'object') ?\n        optionsOrClientId :\n        {clientId: optionsOrClientId, clientSecret, redirectUri};\n    this._clientId = opts.clientId;\n    this._clientSecret = opts.clientSecret;\n    this.redirectUri = opts.redirectUri;\n    this.eagerRefreshThresholdMillis =\n        opts.eagerRefreshThresholdMillis || 5 * 60 * 1000;\n  }\n\n  protected static readonly GOOGLE_TOKEN_INFO_URL =\n      'https://oauth2.googleapis.com/tokeninfo';\n\n  /**\n   * The base URL for auth endpoints.\n   */\n  private static readonly GOOGLE_OAUTH2_AUTH_BASE_URL_ =\n      'https://accounts.google.com/o/oauth2/v2/auth';\n\n  /**\n   * The base endpoint for token retrieval.\n   */\n  private static readonly GOOGLE_OAUTH2_TOKEN_URL_ =\n      'https://oauth2.googleapis.com/token';\n\n  /**\n   * The base endpoint to revoke tokens.\n   */\n  private static readonly GOOGLE_OAUTH2_REVOKE_URL_ =\n      'https://oauth2.googleapis.com/revoke';\n\n  /**\n   * Google Sign on certificates.\n   */\n  private static readonly GOOGLE_OAUTH2_FEDERATED_SIGNON_CERTS_URL_ =\n      'https://www.googleapis.com/oauth2/v1/certs';\n\n  /**\n   * Clock skew - five minutes in seconds\n   */\n  private static readonly CLOCK_SKEW_SECS_ = 300;\n\n  /**\n   * Max Token Lifetime is one day in seconds\n   */\n  private static readonly MAX_TOKEN_LIFETIME_SECS_ = 86400;\n\n  /**\n   * The allowed oauth token issuers.\n   */\n  private static readonly ISSUERS_ =\n      ['accounts.google.com', 'https://accounts.google.com'];\n\n  /**\n   * Generates URL for consent page landing.\n   * @param opts Options.\n   * @return URL to consent page.\n   */\n  generateAuthUrl(opts: GenerateAuthUrlOpts = {}) {\n    if (opts.code_challenge_method && !opts.code_challenge) {\n      throw new Error(\n          'If a code_challenge_method is provided, code_challenge must be included.');\n    }\n    opts.response_type = opts.response_type || 'code';\n    opts.client_id = opts.client_id || this._clientId;\n    opts.redirect_uri = opts.redirect_uri || this.redirectUri;\n    // Allow scopes to be passed either as array or a string\n    if (opts.scope instanceof Array) {\n      opts.scope = opts.scope.join(' ');\n    }\n    const rootUrl = OAuth2Client.GOOGLE_OAUTH2_AUTH_BASE_URL_;\n    return rootUrl + '?' + querystring.stringify(opts);\n  }\n\n  /**\n   * Convenience method to automatically generate a code_verifier, and it's\n   * resulting SHA256. If used, this must be paired with a S256\n   * code_challenge_method.\n   */\n  generateCodeVerifier() {\n    // base64 encoding uses 6 bits per character, and we want to generate128\n    // characters. 6*128/8 = 96.\n    const randomString = crypto.randomBytes(96).toString('base64');\n    // The valid characters in the code_verifier are [A-Z]/[a-z]/[0-9]/\n    // \"-\"/\".\"/\"_\"/\"~\". Base64 encoded strings are pretty close, so we're just\n    // swapping out a few chars.\n    const codeVerifier =\n        randomString.replace(/\\+/g, '~').replace(/=/g, '_').replace(/\\//g, '-');\n    // Generate the base64 encoded SHA256\n    const unencodedCodeChallenge =\n        crypto.createHash('sha256').update(codeVerifier).digest('base64');\n    // We need to use base64UrlEncoding instead of standard base64\n    const codeChallenge = unencodedCodeChallenge.split('=')[0]\n                              .replace(/\\+/g, '-')\n                              .replace(/\\//g, '_');\n    return {codeVerifier, codeChallenge};\n  }\n\n  /**\n   * Gets the access token for the given code.\n   * @param code The authorization code.\n   * @param callback Optional callback fn.\n   */\n  getToken(code: string): Promise;\n  getToken(options: GetTokenOptions): Promise;\n  getToken(code: string, callback: GetTokenCallback): void;\n  getToken(options: GetTokenOptions, callback: GetTokenCallback): void;\n  getToken(codeOrOptions: string|GetTokenOptions, callback?: GetTokenCallback):\n      Promise|void {\n    const options = (typeof codeOrOptions === 'string') ?\n        {code: codeOrOptions} :\n        codeOrOptions;\n    if (callback) {\n      this.getTokenAsync(options).then(\n          r => callback(null, r.tokens, r.res),\n          e => callback(e, null, e.response));\n    } else {\n      return this.getTokenAsync(options);\n    }\n  }\n\n  private async getTokenAsync(options: GetTokenOptions):\n      Promise {\n    const url = OAuth2Client.GOOGLE_OAUTH2_TOKEN_URL_;\n    const values = {\n      code: options.code,\n      client_id: options.client_id || this._clientId,\n      client_secret: this._clientSecret,\n      redirect_uri: options.redirect_uri || this.redirectUri,\n      grant_type: 'authorization_code',\n      code_verifier: options.codeVerifier\n    };\n    const res = await this.transporter.request({\n      method: 'POST',\n      url,\n      data: querystring.stringify(values),\n      headers: {'Content-Type': 'application/x-www-form-urlencoded'}\n    });\n    const tokens = res.data as Credentials;\n    if (res.data && res.data.expires_in) {\n      tokens.expiry_date =\n          ((new Date()).getTime() + (res.data.expires_in * 1000));\n      delete (tokens as CredentialRequest).expires_in;\n    }\n    this.emit('tokens', tokens);\n    return {tokens, res};\n  }\n\n  /**\n   * Refreshes the access token.\n   * @param refresh_token Existing refresh token.\n   * @private\n   */\n  protected async refreshToken(refreshToken?: string|\n                               null): Promise {\n    if (!refreshToken) {\n      return this.refreshTokenNoCache(refreshToken);\n    }\n    // If a request to refresh using the same token has started,\n    // return the same promise.\n    if (this.refreshTokenPromises.has(refreshToken)) {\n      return this.refreshTokenPromises.get(refreshToken)!;\n    }\n\n    const p = this.refreshTokenNoCache(refreshToken)\n                  .then(\n                      r => {\n                        this.refreshTokenPromises.delete(refreshToken);\n                        return r;\n                      },\n                      e => {\n                        this.refreshTokenPromises.delete(refreshToken);\n                        throw e;\n                      });\n    this.refreshTokenPromises.set(refreshToken, p);\n    return p;\n  }\n\n  protected async refreshTokenNoCache(refreshToken?: string|\n                                      null): Promise {\n    const url = OAuth2Client.GOOGLE_OAUTH2_TOKEN_URL_;\n    const data = {\n      refresh_token: refreshToken,\n      client_id: this._clientId,\n      client_secret: this._clientSecret,\n      grant_type: 'refresh_token'\n    };\n\n    // request for new token\n    const res = await this.transporter.request({\n      method: 'POST',\n      url,\n      data: querystring.stringify(data),\n      headers: {'Content-Type': 'application/x-www-form-urlencoded'}\n    });\n\n    const tokens = res.data as Credentials;\n    // TODO: de-duplicate this code from a few spots\n    if (res.data && res.data.expires_in) {\n      tokens.expiry_date =\n          ((new Date()).getTime() + (res.data.expires_in * 1000));\n      delete (tokens as CredentialRequest).expires_in;\n    }\n    this.emit('tokens', tokens);\n    return {tokens, res};\n  }\n\n  /**\n   * Retrieves the access token using refresh token\n   *\n   * @deprecated use getRequestHeaders instead.\n   * @param callback callback\n   */\n  refreshAccessToken(): Promise;\n  refreshAccessToken(callback: RefreshAccessTokenCallback): void;\n  refreshAccessToken(callback?: RefreshAccessTokenCallback):\n      Promise|void {\n    messages.warn(messages.REFRESH_ACCESS_TOKEN_DEPRECATED);\n    if (callback) {\n      this.refreshAccessTokenAsync().then(\n          r => callback(null, r.credentials, r.res), callback);\n    } else {\n      return this.refreshAccessTokenAsync();\n    }\n  }\n\n  private async refreshAccessTokenAsync() {\n    if (!this.credentials.refresh_token) {\n      throw new Error('No refresh token is set.');\n    }\n    const r = await this.refreshToken(this.credentials.refresh_token);\n    const tokens = r.tokens as Credentials;\n    tokens.refresh_token = this.credentials.refresh_token;\n    this.credentials = tokens;\n    return {credentials: this.credentials, res: r.res};\n  }\n\n  /**\n   * Get a non-expired access token, after refreshing if necessary\n   *\n   * @param callback Callback to call with the access token\n   */\n  getAccessToken(): Promise;\n  getAccessToken(callback: GetAccessTokenCallback): void;\n  getAccessToken(callback?: GetAccessTokenCallback):\n      Promise|void {\n    if (callback) {\n      this.getAccessTokenAsync().then(\n          r => callback(null, r.token, r.res), callback);\n    } else {\n      return this.getAccessTokenAsync();\n    }\n  }\n\n  private async getAccessTokenAsync(): Promise {\n    const shouldRefresh =\n        !this.credentials.access_token || this.isTokenExpiring();\n    if (shouldRefresh && this.credentials.refresh_token) {\n      if (!this.credentials.refresh_token) {\n        throw new Error('No refresh token is set.');\n      }\n\n      const r = await this.refreshAccessTokenAsync();\n      if (!r.credentials || (r.credentials && !r.credentials.access_token)) {\n        throw new Error('Could not refresh access token.');\n      }\n      return {token: r.credentials.access_token, res: r.res};\n    } else {\n      return {token: this.credentials.access_token};\n    }\n  }\n\n  /**\n   * Obtain the set of headers required to authenticate a request.\n   *\n   * @deprecated Use getRequestHeaders instead.\n   * @param url the Uri being authorized\n   * @param callback the func described above\n   */\n  getRequestMetadata(url?: string|null): Promise;\n  getRequestMetadata(url: string|null, callback: RequestMetadataCallback): void;\n  getRequestMetadata(url: string|null, callback?: RequestMetadataCallback):\n      Promise|void {\n    messages.warn(messages.OAUTH_GET_REQUEST_METADATA_DEPRECATED);\n    if (callback) {\n      this.getRequestMetadataAsync(url).then(\n          r => callback(null, r.headers, r.res), callback);\n    } else {\n      return this.getRequestMetadataAsync();\n    }\n  }\n\n  /**\n   * The main authentication interface.  It takes an optional url which when\n   * present is the endpoint being accessed, and returns a Promise which\n   * resolves with authorization header fields.\n   *\n   * In OAuth2Client, the result has the form:\n   * { Authorization: 'Bearer ' }\n   * @param url The optional url being authorized\n   */\n  async getRequestHeaders(url?: string): Promise {\n    const res = await this.getRequestMetadataAsync(url);\n    return res.headers;\n  }\n\n  protected async getRequestMetadataAsync(url?: string|null):\n      Promise {\n    const thisCreds = this.credentials;\n    if (!thisCreds.access_token && !thisCreds.refresh_token && !this.apiKey) {\n      throw new Error('No access, refresh token or API key is set.');\n    }\n\n    if (thisCreds.access_token && !this.isTokenExpiring()) {\n      thisCreds.token_type = thisCreds.token_type || 'Bearer';\n      const headers = {\n        Authorization: thisCreds.token_type + ' ' + thisCreds.access_token\n      };\n      return {headers};\n    }\n\n    if (this.apiKey) {\n      return {headers: {}};\n    }\n    let r: GetTokenResponse|null = null;\n    let tokens: Credentials|null = null;\n    try {\n      r = await this.refreshToken(thisCreds.refresh_token);\n      tokens = r.tokens;\n    } catch (err) {\n      const e = err as AxiosError;\n      if (e.response &&\n          (e.response.status === 403 || e.response.status === 404)) {\n        e.message = 'Could not refresh access token.';\n      }\n      throw e;\n    }\n\n    const credentials = this.credentials;\n    credentials.token_type = credentials.token_type || 'Bearer';\n    tokens.refresh_token = credentials.refresh_token;\n    this.credentials = tokens;\n    const headers = {\n      Authorization: credentials.token_type + ' ' + tokens.access_token\n    };\n    return {headers, res: r.res};\n  }\n\n  /**\n   * Revokes the access given to token.\n   * @param token The existing token to be revoked.\n   * @param callback Optional callback fn.\n   */\n  revokeToken(token: string): AxiosPromise;\n  revokeToken(\n      token: string,\n      callback: BodyResponseCallback): void;\n  revokeToken(\n      token: string, callback?: BodyResponseCallback):\n      AxiosPromise|void {\n    const opts = {\n      url: OAuth2Client.GOOGLE_OAUTH2_REVOKE_URL_ + '?' +\n          querystring.stringify({token}),\n      method: 'POST'\n    };\n    if (callback) {\n      this.transporter.request(opts).then(\n          r => callback(null, r), callback);\n    } else {\n      return this.transporter.request(opts);\n    }\n  }\n\n\n  /**\n   * Revokes access token and clears the credentials object\n   * @param callback callback\n   */\n  revokeCredentials(): AxiosPromise;\n  revokeCredentials(callback: BodyResponseCallback):\n      void;\n  revokeCredentials(callback?: BodyResponseCallback):\n      AxiosPromise|void {\n    if (callback) {\n      this.revokeCredentialsAsync().then(res => callback(null, res), callback);\n    } else {\n      return this.revokeCredentialsAsync();\n    }\n  }\n\n  private async revokeCredentialsAsync() {\n    const token = this.credentials.access_token;\n    this.credentials = {};\n    if (token) {\n      return this.revokeToken(token);\n    } else {\n      throw new Error('No access token to revoke.');\n    }\n  }\n\n  /**\n   * Provides a request implementation with OAuth 2.0 flow. If credentials have\n   * a refresh_token, in cases of HTTP 401 and 403 responses, it automatically\n   * asks for a new access token and replays the unsuccessful request.\n   * @param opts Request options.\n   * @param callback callback.\n   * @return Request object\n   */\n  request(opts: AxiosRequestConfig): AxiosPromise;\n  request(opts: AxiosRequestConfig, callback: BodyResponseCallback): void;\n  request(opts: AxiosRequestConfig, callback?: BodyResponseCallback):\n      AxiosPromise|void {\n    if (callback) {\n      this.requestAsync(opts).then(r => callback(null, r), e => {\n        return callback(e, e.response);\n      });\n    } else {\n      return this.requestAsync(opts);\n    }\n  }\n\n  protected async requestAsync(opts: AxiosRequestConfig, retry = false):\n      Promise> {\n    let r2: AxiosResponse;\n    try {\n      const r = await this.getRequestMetadataAsync(opts.url);\n      if (r.headers && r.headers.Authorization) {\n        opts.headers = opts.headers || {};\n        opts.headers.Authorization = r.headers.Authorization;\n      }\n\n      if (this.apiKey) {\n        opts.params = Object.assign(opts.params || {}, {key: this.apiKey});\n      }\n      r2 = await this.transporter.request(opts);\n    } catch (e) {\n      const res = (e as AxiosError).response;\n      if (res) {\n        const statusCode = res.status;\n        // Retry the request for metadata if the following criteria are true:\n        // - We haven't already retried.  It only makes sense to retry once.\n        // - The response was a 401 or a 403\n        // - The request didn't send a readableStream\n        // - An access_token and refresh_token were available, but no\n        //   expiry_date was availabe. This can happen when developers stash\n        //   the access_token and refresh_token for later use, but the\n        //   access_token fails on the first try because it's expired.\n        const mayRequireRefresh = this.credentials &&\n            this.credentials.access_token && this.credentials.refresh_token &&\n            !this.credentials.expiry_date;\n        const isReadableStream = res.config.data instanceof stream.Readable;\n        const isAuthErr = statusCode === 401 || statusCode === 403;\n        if (!retry && isAuthErr && !isReadableStream && mayRequireRefresh) {\n          await this.refreshAccessTokenAsync();\n          return this.requestAsync(opts, true);\n        }\n      }\n      throw e;\n    }\n    return r2;\n  }\n\n  /**\n   * Verify id token is token by checking the certs and audience\n   * @param options that contains all options.\n   * @param callback Callback supplying GoogleLogin if successful\n   */\n  verifyIdToken(options: VerifyIdTokenOptions): Promise;\n  verifyIdToken(\n      options: VerifyIdTokenOptions,\n      callback: (err: Error|null, login?: LoginTicket) => void): void;\n  verifyIdToken(\n      options: VerifyIdTokenOptions,\n      callback?: (err: Error|null, login?: LoginTicket) => void):\n      void|Promise {\n    // This function used to accept two arguments instead of an options object.\n    // Check the types to help users upgrade with less pain.\n    // This check can be removed after a 2.0 release.\n    if (callback && typeof callback !== 'function') {\n      throw new Error(\n          'This method accepts an options object as the first parameter, which includes the idToken, audience, and maxExpiry.');\n    }\n\n    if (callback) {\n      this.verifyIdTokenAsync(options).then(r => callback(null, r), callback);\n    } else {\n      return this.verifyIdTokenAsync(options);\n    }\n  }\n\n  private async verifyIdTokenAsync(options: VerifyIdTokenOptions):\n      Promise {\n    if (!options.idToken) {\n      throw new Error('The verifyIdToken method requires an ID Token');\n    }\n\n    const response = await this.getFederatedSignonCertsAsync();\n    const login = this.verifySignedJwtWithCerts(\n        options.idToken, response.certs, options.audience,\n        OAuth2Client.ISSUERS_, options.maxExpiry);\n\n    return login;\n  }\n\n  /**\n   * Obtains information about the provisioned access token.  Especially useful\n   * if you want to check the scopes that were provisioned to a given token.\n   *\n   * @param accessToken Required.  The Access Token for which you want to get\n   * user info.\n   */\n  async getTokenInfo(accessToken: string): Promise {\n    const {data} = await this.transporter.request({\n      method: 'GET',\n      url: OAuth2Client.GOOGLE_TOKEN_INFO_URL,\n      params: {access_token: accessToken}\n    });\n    const info = Object.assign(\n        {\n          expiry_date: ((new Date()).getTime() + (data.expires_in * 1000)),\n          scopes: data.scope.split(' ')\n        },\n        data);\n    delete info.expires_in;\n    delete info.scope;\n    return info;\n  }\n\n  /**\n   * Gets federated sign-on certificates to use for verifying identity tokens.\n   * Returns certs as array structure, where keys are key ids, and values\n   * are PEM encoded certificates.\n   * @param callback Callback supplying the certificates\n   */\n  getFederatedSignonCerts(): Promise;\n  getFederatedSignonCerts(callback: GetFederatedSignonCertsCallback): void;\n  getFederatedSignonCerts(callback?: GetFederatedSignonCertsCallback):\n      Promise|void {\n    if (callback) {\n      this.getFederatedSignonCertsAsync().then(\n          r => callback(null, r.certs, r.res), callback);\n    } else {\n      return this.getFederatedSignonCertsAsync();\n    }\n  }\n\n  async getFederatedSignonCertsAsync(): Promise {\n    const nowTime = (new Date()).getTime();\n    if (this.certificateExpiry &&\n        (nowTime = now + maxExpiry) {\n      throw new Error(\n          'Expiration time too far in future: ' + JSON.stringify(payload));\n    }\n\n    const earliest = iat - OAuth2Client.CLOCK_SKEW_SECS_;\n    const latest = exp + OAuth2Client.CLOCK_SKEW_SECS_;\n\n    if (now  latest) {\n      throw new Error(\n          'Token used too late, ' + now + ' > ' + latest + ': ' +\n          JSON.stringify(payload));\n    }\n\n    if (issuers && issuers.indexOf(payload.iss)  -1);\n      } else {\n        audVerified = (aud === requiredAudience);\n      }\n      if (!audVerified) {\n        throw new Error(\n            'Wrong recipient, payload audience != requiredAudience');\n      }\n    }\n    return new LoginTicket(envelope, payload);\n  }\n\n  /**\n   * This is a utils method to decode a base64 string\n   * @param b64String The string to base64 decode\n   * @return The decoded string\n   */\n  decodeBase64(b64String: string) {\n    const buffer = Buffer.from(b64String, 'base64');\n    return buffer.toString('utf8');\n  }\n\n  /**\n   * Returns true if a token is expired or will expire within\n   * eagerRefreshThresholdMillismilliseconds.\n   * If there is no expiry time, assumes the token is not expired or expiring.\n   */\n  protected isTokenExpiring(): boolean {\n    const expiryDate = this.credentials.expiry_date;\n    return expiryDate ? expiryDate \n    \n\n\n\n\n\n\n\n                   \n    \n         result-matching \"\"\n        \n    \n    \n        No results matching \"\"\n    \n\n"},"interfaces/Warning.html":{"url":"interfaces/Warning.html","title":"interface - Warning","body":"\n                   \n\n\n\n\n\n\n\n\n\n\n\n\n\n  Interfaces\n  Warning\n\n\n\n        \n            Info\n        \n        \n            Source\n        \n\n\n\n    \n        \n            File\n        \n        \n            src/messages.ts\n        \n\n\n\n        \n            Index\n            \n                \n                    \n                        \n                            Properties\n                        \n                    \n                    \n                        \n                            \n                                \n                                        code\n                                \n                                \n                                        message\n                                \n                                \n                                        type\n                                \n                                \n                                            Optional\n                                        warned\n                                \n                            \n                        \n                    \n                \n            \n        \n\n\n\n            \n                Properties\n                    \n                        \n                                \n                                    \n                                        \n                                        code\n                                    \n                                \n                                \n                                    \n                                        code:     string\n\n                                    \n                                \n\n\n                                    \n                                        \n                                            Type :     string\n\n                                        \n                                    \n\n\n\n\n\n                        \n                    \n                    \n                        \n                                \n                                    \n                                        \n                                        message\n                                    \n                                \n                                \n                                    \n                                        message:     string\n\n                                    \n                                \n\n\n                                    \n                                        \n                                            Type :     string\n\n                                        \n                                    \n\n\n\n\n\n                        \n                    \n                    \n                        \n                                \n                                    \n                                        \n                                        type\n                                    \n                                \n                                \n                                    \n                                        type:     WarningTypes\n\n                                    \n                                \n\n\n                                    \n                                        \n                                            Type :     WarningTypes\n\n                                        \n                                    \n\n\n\n\n\n                        \n                    \n                    \n                        \n                                \n                                    \n                                        \n                                        warned\n                                    \n                                \n                                \n                                    \n                                        warned:     boolean\n\n                                    \n                                \n\n\n                                    \n                                        \n                                            Type :     boolean\n\n                                        \n                                    \n\n                                    \n                                        \n                                            Optional\n                                        \n                                    \n\n\n\n\n                        \n                    \n            \n    \n\n\n    \n        import * as semver from 'semver';\n\nexport enum WarningTypes {\n  WARNING = 'Warning',\n  DEPRECATION = 'DeprecationWarning'\n}\n\nexport function warn(warning: Warning) {\n  // Only show a given warning once\n  if (warning.warned) {\n    return;\n  }\n  warning.warned = true;\n  if (semver.satisfies(process.version, '>=8')) {\n    // @types/node doesn't recognize the emitWarning syntax which\n    // accepts a config object, so `as any` it is\n    // https://nodejs.org/docs/latest-v8.x/api/process.html#process_process_emitwarning_warning_options\n    // tslint:disable-next-line no-any\n    process.emitWarning(warning.message, warning as any);\n  } else {\n    // This path can be removed once we drop support for Node 6.\n    // https://nodejs.org/docs/latest-v6.x/api/process.html#process_process_emitwarning_warning_name_ctor\n    process.emitWarning(warning.message, warning.type);\n  }\n}\n\nexport interface Warning {\n  code: string;\n  type: WarningTypes;\n  message: string;\n  warned?: boolean;\n}\n\nexport const PROBLEMATIC_CREDENTIALS_WARNING = {\n  code: 'google-auth-library:00001',\n  type: WarningTypes.WARNING,\n  message: [\n    'Your application has authenticated using end user credentials from Google',\n    'Cloud SDK. We recommend that most server applications use service accounts',\n    'instead. If your application continues to use end user credentials from',\n    'Cloud SDK, you might receive a \"quota exceeded\" or \"API not enabled\" error.',\n    'For more information about service accounts, see',\n    'https://cloud.google.com/docs/authentication/.'\n  ].join(' ')\n};\n\nexport const DEFAULT_PROJECT_ID_DEPRECATED = {\n  code: 'google-auth-library:DEP002',\n  type: WarningTypes.DEPRECATION,\n  message: [\n    'The `getDefaultProjectId` method has been deprecated, and will be removed',\n    'in the 3.0 release of google-auth-library. Please use the `getProjectId`',\n    'method instead.'\n  ].join(' ')\n};\n\nexport const COMPUTE_CREATE_SCOPED_DEPRECATED = {\n  code: 'google-auth-library:DEP003',\n  type: WarningTypes.DEPRECATION,\n  message: [\n    'The `createScopedRequired` method on the `Compute` class has been deprecated,',\n    'and will be removed in the 3.0 release of google-auth-library.'\n  ].join(' ')\n};\n\nexport const JWT_CREATE_SCOPED_DEPRECATED = {\n  code: 'google-auth-library:DEP004',\n  type: WarningTypes.DEPRECATION,\n  message: [\n    'The `createScopedRequired` method on the `JWT` class has been deprecated,',\n    'and will be removed in the 3.0 release of google-auth-library.'\n  ].join(' ')\n};\n\nexport const IAM_CREATE_SCOPED_DEPRECATED = {\n  code: 'google-auth-library:DEP005',\n  type: WarningTypes.DEPRECATION,\n  message: [\n    'The `createScopedRequired` method on the `IAM` class has been deprecated,',\n    'and will be removed in the 3.0 release of google-auth-library.'\n  ].join(' ')\n};\n\nexport const JWT_ACCESS_CREATE_SCOPED_DEPRECATED = {\n  code: 'google-auth-library:DEP006',\n  type: WarningTypes.DEPRECATION,\n  message: [\n    'The `createScopedRequired` method on the `JWTAccess` class has been deprecated,',\n    'and will be removed in the 3.0 release of google-auth-library.'\n  ].join(' ')\n};\n\nexport const REFRESH_ACCESS_TOKEN_DEPRECATED = {\n  code: 'google-auth-library:DEP007',\n  type: WarningTypes.DEPRECATION,\n  message: [\n    'The `refreshAccessToken` method has been deprecated, and will be removed',\n    'in the 3.0 release of google-auth-library. Please use the `getRequestHeaders`',\n    'method instead.'\n  ].join(' ')\n};\nexport const OAUTH_GET_REQUEST_METADATA_DEPRECATED = {\n  code: 'google-auth-library:DEP004',\n  type: WarningTypes.DEPRECATION,\n  message: [\n    'The `getRequestMetadata` method on the `OAuth2` class has been deprecated,',\n    'and will be removed in the 3.0 release of google-auth-library. Please use',\n    'the `getRequestHeaders` method instead.'\n  ].join(' ')\n};\n\nexport const IAM_GET_REQUEST_METADATA_DEPRECATED = {\n  code: 'google-auth-library:DEP005',\n  type: WarningTypes.DEPRECATION,\n  message: [\n    'The `getRequestMetadata` method on the `IAM` class has been deprecated,',\n    'and will be removed in the 3.0 release of google-auth-library. Please use',\n    'the `getRequestHeaders` method instead.'\n  ].join(' ')\n};\n\nexport const JWT_ACCESS_GET_REQUEST_METADATA_DEPRECATED = {\n  code: 'google-auth-library:DEP006',\n  type: WarningTypes.DEPRECATION,\n  message: [\n    'The `getRequestMetadata` method on the `JWTAccess` class has been deprecated,',\n    'and will be removed in the 3.0 release of google-auth-library. Please use',\n    'the `getRequestHeaders` method instead.'\n  ].join(' ')\n};\n\n    \n\n\n\n\n\n\n\n                   \n    \n         result-matching \"\"\n        \n    \n    \n        No results matching \"\"\n    \n\n"},"changelog.html":{"url":"changelog.html","title":"getting-started - changelog","body":"\n                   \n\nChangelog\nnpm history\nv2.0.1\nImplementation Changes\n\nfix: verifyIdToken will never return null (#488)\nUpdate the url to application default credentials (#470)\nUpdate omitted parameter 'hd' (#467)\n\nDependencies\n\nchore(deps): update dependency nock to v10 (#501)\nchore(deps): update dependency sinon to v7 (#502)\nchore(deps): update dependency typescript to v3.1.3 (#503)\nchore(deps): update dependency gh-pages to v2 (#499)\nchore(deps): update dependency typedoc to ^0.13.0 (#497)\n\nDocumentation\n\ndocs: Remove code format from Application Default Credentials (#483)\ndocs: replace google/ with googleapis/ in URIs (#472)\nFix typo in readme (#469)\nUpdate samples and docs for 2.0 (#459)\n\nInternal / Testing Changes\n\nchore: update issue templates (#509)\nchore: remove old issue template (#507)\nbuild: run tests on node11 (#506)\nchore(build): drop hard rejection and update gts in the kitchen test (#504)\nchores(build): do not collect sponge.xml from windows builds (#500)\nchores(build): run codecov on continuous builds (#495)\nchore: update new issue template (#494)\nbuild: fix codecov uploading on Kokoro (#490)\ntest: move kitchen sink tests to system-test (#489)\nUpdate kokoro config (#482)\nfix: export additional typescript types (#479)\nDon't publish sourcemaps (#478)\ntest: remove appveyor config (#477)\nEnable prefer-const in the eslint config (#473)\nEnable no-var in eslint (#471)\nUpdate CI config (#468)\nRetry npm install in CI (#465)\nUpdate Kokoro config (#462)\n\nv2.0.0\nWell hello 2.0 &#x1F389;  This release has multiple breaking changes.   It also has a lot of bug fixes.\nBreaking Changes\nSupport for node.js 4.x and 9.x has been dropped\nThese versions of node.js are no longer supported.\nThe getRequestMetadata method has been deprecated\nThe getRequestMetadata method has been deprecated on the IAM, OAuth2, JWT, and JWTAccess classes.  The getRequestHeaders method should be used instead.  The methods have a subtle difference:  the getRequestMetadata method returns an object with a headers property, which contains the authorization header.  The getRequestHeaders method simply returns the headers.\nOld code\nconst client = await auth.getClient();\nconst res = await client.getRequestMetadata();\nconst headers = res.headers;New code\nconst client = await auth.getClient();\nconst headers = await client.getRequestHeaders();The createScopedRequired method has been deprecated\nThe createScopedRequired method has been deprecated on multiple classes.  The createScopedRequired and createScoped methods on the JWT class were largely in place to help inform clients when scopes were required in an application default credential scenario.  Instead of checking if scopes are required after creating the client, instead scopes should just be passed either into the GoogleAuth.getClient method, or directly into the JWT constructor.\nOld code\nauth.getApplicationDefault(function(err, authClient) {\n   if (err) {\n     return callback(err);\n   }\n  if (authClient.createScopedRequired && authClient.createScopedRequired()) {\n    authClient = authClient.createScoped([\n      'https://www.googleapis.com/auth/cloud-platform'\n    ]);\n  }\n  callback(null, authClient);\n});New code\nconst client = await auth.getClient({\n  scopes: ['https://www.googleapis.com/auth/cloud-platform']\n});The refreshAccessToken method has been deprecated\nThe OAuth2.refreshAccessToken method has been deprecated.  The getAccessToken, getRequestMetadata, and request methods will all refresh the token if needed automatically.   There is no need to ever manually refresh the token.\nAs always, if you run into any problems... please let us know!\nFeatures\n\nSet private_key_id in JWT access token header like other google auth libraries. (#450)\n\nBug Fixes\n\nfix: support HTTPS proxies (#405)\nfix: export missing interfaces (#437)\nfix: Use new auth URIs (#434)\ndocs: Fix broken link (#423)\nfix: surface file read streams (#413)\nfix: prevent unhandled rejections by avoid .catch (#404)\nfix: use gcp-metadata for compute credentials (#409)\nAdd Code of Conduct\nfix: Warn when using user credentials from the Cloud SDK (#399)\nfix: use Buffer.from instead of new Buffer (#400)\nfix: Fix link format in README.md (#385)\n\nBreaking changes\n\nchore: deprecate getRequestMetadata (#414)\nfix: deprecate the createScopedRequired methods (#410)\nfix: drop support for node.js 4.x and 9.x (#417)\nfix: deprecate the refreshAccessToken methods (#411)\nfix: deprecate the getDefaultProjectId method (#402)\nfix: drop support for node.js 4 (#401)\n\nBuild / Test changes\n\nRun synth to make build tools consistent (#455)\nAdd a package.json for samples and cleanup README (#454)\nchore(deps): update dependency typedoc to ^0.12.0 (#453)\nchore: move examples => samples + synth (#448)\nchore(deps): update dependency nyc to v13 (#452)\nchore(deps): update dependency pify to v4 (#447)\nchore(deps): update dependency assert-rejects to v1 (#446)\nchore: ignore package-lock.json (#445)\nchore: update renovate config (#442)\nchore(deps): lock file maintenance (#443)\nchore: remove greenkeeper badge (#440)\ntest: throw on deprecation\nchore: add intelli-espower-loader for running tests (#430)\nchore(deps): update dependency typescript to v3 (#432)\nchore(deps): lock file maintenance (#431)\ntest: use strictEqual in tests (#425)\nchore(deps): lock file maintenance (#428)\nchore: Configure Renovate (#424)\nchore: Update gts to the latest version &#x1F680; (#422)\nchore: update gcp-metadata for isAvailable fix (#420)\nrefactor: use assert.reject in the tests (#415)\nrefactor: cleanup types for certificates (#412)\ntest: run tests with hard-rejection (#397)\ncleanup: straighten nested try-catch (#394)\ntest: getDefaultProjectId should prefer config (#388)\nchore(package): Update gts to the latest version &#x1F680; (#387)\nchore(package): update sinon to version 6.0.0 (#386)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n                   \n    \n         result-matching \"\"\n        \n    \n    \n        No results matching \"\"\n    \n\n"},"dependencies.html":{"url":"dependencies.html","title":"package-dependencies - dependencies","body":"\n                   \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n    \n        Dependencies\n    \n    \n        \n            axios : ^0.18.0\n        \n            gcp-metadata : ^0.7.0\n        \n            gtoken : ^2.3.0\n        \n            https-proxy-agent : ^2.2.1\n        \n            jws : ^3.1.5\n        \n            lru-cache : ^5.0.0\n        \n            semver : ^5.5.0\n    \n\n\n\n\n\n                   \n    \n         result-matching \"\"\n        \n    \n    \n        No results matching \"\"\n    \n\n"},"miscellaneous/enumerations.html":{"url":"miscellaneous/enumerations.html","title":"miscellaneous-enumerations - enumerations","body":"\n                   \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  Miscellaneous\n  Enumerations\n\n\n\n    Index\n    \n        \n            \n                \n                    \n                        \n                            CodeChallengeMethod(src/.../oauth2client.ts)\n                        \n                        \n                            GCPEnv(src/.../envDetect.ts)\n                        \n                        \n                            WarningTypes(src/.../messages.ts)\n                        \n                    \n                \n            \n        \n    \n\n\n    src/auth/oauth2client.ts\n    \n        \n            \n                \n                    \n                        \n                        CodeChallengeMethod\n                    \n                \n                        \n                            \n                                Plain\n                            \n                        \n                        \n                            \n                                Value : plain\n                            \n                        \n                        \n                            \n                                S256\n                            \n                        \n                        \n                            \n                                Value : S256\n                            \n                        \n            \n        \n\n    src/auth/envDetect.ts\n    \n        \n            \n                \n                    \n                        \n                        GCPEnv\n                    \n                \n                        \n                            \n                                APP_ENGINE\n                            \n                        \n                        \n                            \n                                Value : APP_ENGINE\n                            \n                        \n                        \n                            \n                                KUBERNETES_ENGINE\n                            \n                        \n                        \n                            \n                                Value : KUBERNETES_ENGINE\n                            \n                        \n                        \n                            \n                                CLOUD_FUNCTIONS\n                            \n                        \n                        \n                            \n                                Value : CLOUD_FUNCTIONS\n                            \n                        \n                        \n                            \n                                COMPUTE_ENGINE\n                            \n                        \n                        \n                            \n                                Value : COMPUTE_ENGINE\n                            \n                        \n                        \n                            \n                                NONE\n                            \n                        \n                        \n                            \n                                Value : NONE\n                            \n                        \n            \n        \n\n    src/messages.ts\n    \n        \n            \n                \n                    \n                        \n                        WarningTypes\n                    \n                \n                        \n                            \n                                WARNING\n                            \n                        \n                        \n                            \n                                Value : Warning\n                            \n                        \n                        \n                            \n                                DEPRECATION\n                            \n                        \n                        \n                            \n                                Value : DeprecationWarning\n                            \n                        \n            \n        \n\n\n\n\n                   \n    \n         result-matching \"\"\n        \n    \n    \n        No results matching \"\"\n    \n\n"},"miscellaneous/functions.html":{"url":"miscellaneous/functions.html","title":"miscellaneous-functions - functions","body":"\n                   \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  Miscellaneous\n  Functions\n\n\n\n    Index\n    \n        \n            \n                \n                    \n                        \n                            clear(src/.../envDetect.ts)\n                        \n                        \n                            getEnv(src/.../envDetect.ts)\n                        \n                        \n                            isAppEngine(src/.../envDetect.ts)\n                        \n                        \n                            isCloudFunction(src/.../envDetect.ts)\n                        \n                        \n                            isComputeEngine(src/.../envDetect.ts)\n                        \n                        \n                            isKubernetesEngine(src/.../envDetect.ts)\n                        \n                        \n                            validate(src/.../options.ts)\n                        \n                        \n                            warn(src/.../messages.ts)\n                        \n                    \n                \n            \n        \n    \n\n\n    src/auth/envDetect.ts\n    \n            \n            \n                \n                    \n                        \n                        \n                            \n                            clear\n                            \n                            \n                        \n                    \n                \n                \n                    \nclear()\n                    \n                \n\n\n\n\n            \n        \n        \n            \n                \n                    \n                        \n                        \n                            \n                            getEnv\n                            \n                            \n                        \n                    \n                \n                \n                    \ngetEnv()\n                    \n                \n\n\n\n\n            \n        \n        \n            \n                \n                    \n                        \n                        \n                            \n                            isAppEngine\n                            \n                            \n                        \n                    \n                \n                \n                    \nisAppEngine()\n                    \n                \n\n\n\n\n            \n        \n        \n            \n                \n                    \n                        \n                        \n                            \n                            isCloudFunction\n                            \n                            \n                        \n                    \n                \n                \n                    \nisCloudFunction()\n                    \n                \n\n\n\n\n            \n        \n        \n            \n                \n                    \n                        \n                        \n                            \n                            isComputeEngine\n                            \n                            \n                        \n                    \n                \n                \n                    \nisComputeEngine()\n                    \n                \n\n\n\n\n            \n        \n        \n            \n                \n                    \n                        \n                        \n                            \n                            isKubernetesEngine\n                            \n                            \n                        \n                    \n                \n                \n                    \nisKubernetesEngine()\n                    \n                \n\n\n\n\n            \n        \n\n    src/options.ts\n    \n            \n            \n                \n                    \n                        \n                        \n                            \n                            validate\n                            \n                            \n                        \n                    \n                \n                \n                    \nvalidate(options: any)\n                    \n                \n\n\n\n\n                \n                    \n                            Copyright 2017 Google Inc. All Rights Reserved.\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n  http://www.apache.org/licenses/LICENSE-2.0Unless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n\n\n                            \n                                    Parameters :\n                                    \n                                        \n                                            \n                                                Name\n                                                    Type\n                                                Optional\n                                            \n                                        \n                                        \n                                                \n                                                        options\n                                                        \n                                                                    any\n                                                        \n                                                    \n                                                    \n                                                            No\n                                                    \n                                                    \n\n                                                \n                                        \n                                    \n                            \n                            \n                            \n                    \n                \n            \n        \n\n    src/messages.ts\n    \n            \n            \n                \n                    \n                        \n                        \n                            \n                            warn\n                            \n                            \n                        \n                    \n                \n                \n                    \nwarn(warning)\n                    \n                \n\n\n\n\n                \n                    \n\n                            \n                                    Parameters :\n                                    \n                                        \n                                            \n                                                Name\n                                                Optional\n                                            \n                                        \n                                        \n                                                \n                                                        warning\n                                                    \n                                                    \n                                                            No\n                                                    \n                                                    \n\n                                                \n                                        \n                                    \n                            \n                            \n                            \n                    \n                \n            \n        \n\n\n\n\n                   \n    \n         result-matching \"\"\n        \n    \n    \n        No results matching \"\"\n    \n\n"},"index.html":{"url":"index.html","title":"getting-started - index","body":"\n                   \n\n\n\nGoogle Auth Library\n\n\n\n\n\nThis is Google's officially supported node.js client library for using OAuth 2.0 authorization and authentication with Google APIs.\nInstallation\nThis library is distributed on npm. To add it as a dependency, run the following command:\n$ npm install google-auth-libraryUpgrading to 1.x\nThe 1.x release includes a variety of bug fixes, new features, and breaking changes. Please take care, and see the release notes for a list of breaking changes, and the upgrade guide.\nWays to authenticate\nThis library provides a variety of ways to authenticate to your Google services.\n\nApplication Default Credentials - Use Application Default Credentials when you use a single identity for all users in your application. Especially useful for applications running on Google Cloud.\nOAuth 2 - Use OAuth2 when you need to perform actions on behalf of the end user.\nJSON Web Tokens - Use JWT when you are using a single identity for all users. Especially useful for server->server or server->API communication.\nGoogle Compute - Directly use a service account on Google Cloud Platform. Useful for server->server or server->API communication.\n\nApplication Default Credentials\nThis library provides an implementation of Application Default Credentials for Node.js. The Application Default Credentials provide a simple way to get authorization credentials for use in calling Google APIs.\nThey are best suited for cases when the call needs to have the same identity and authorization level for the application independent of the user. This is the recommended approach to authorize calls to Cloud APIs, particularly when you're building an application that uses Google Cloud Platform.\nDownload your Service Account Credentials JSON file\nTo use Application Default Credentials, You first need to download a set of JSON credentials for your project. Go to APIs & Auth > Credentials in the Google Developers Console and select Service account from the Add credentials dropdown.\n\nThis file is your only copy of these credentials. It should never be\ncommitted with your source code, and should be stored securely.\n\nOnce downloaded, store the path to this file in the GOOGLE_APPLICATION_CREDENTIALS environment variable.\nEnable the API you want to use\nBefore making your API call, you must be sure the API you're calling has been enabled. Go to APIs & Auth > APIs in the Google Developers Console and enable the APIs you'd like to call. For the example below, you must enable the DNS API.\nChoosing the correct credential type automatically\nRather than manually creating an OAuth2 client, JWT client, or Compute client, the auth library can create the correct credential type for you, depending upon the environment your code is running under.\nFor example, a JWT auth client will be created when your code is running on your local developer machine, and a Compute client will be created when the same code is running on Google Cloud Platform. If you need a specific set of scopes, you can pass those in the form of a string or an array into the auth.getClient method.\nThe code below shows how to retrieve a default credential type, depending upon the runtime environment.\nconst {auth} = require('google-auth-library');\n\n/**\n * Instead of specifying the type of client you'd like to use (JWT, OAuth2, etc)\n * this library will automatically choose the right client based on the environment.\n */\nasync function main() {\n  const client = await auth.getClient({\n    scopes: 'https://www.googleapis.com/auth/cloud-platform'\n  });\n  const projectId = await auth.getProjectId();\n  const url = `https://www.googleapis.com/dns/v1/projects/${projectId}`;\n  const res = await client.request({ url });\n  console.log(res.data);\n}\n\nmain().catch(console.error);OAuth2\nThis library comes with an OAuth2 client that allows you to retrieve an access token and refreshes the token and retry the request seamlessly if you also provide an expiry_date and the token is expired. The basics of Google's OAuth2 implementation is explained on Google Authorization and Authentication documentation.\nIn the following examples, you may need a CLIENT_ID, CLIENT_SECRET and REDIRECT_URL. You can find these pieces of information by going to the Developer Console, clicking your project > APIs & auth > credentials.\nFor more information about OAuth2 and how it works, see here.\nA complete OAuth2 example\nLet's take a look at a complete example.\nconst {OAuth2Client} = require('google-auth-library');\nconst http = require('http');\nconst url = require('url');\nconst querystring = require('querystring');\nconst opn = require('opn');\n\n// Download your OAuth2 configuration from the Google\nconst keys = require('./keys.json');\n\n/**\n * Start by acquiring a pre-authenticated oAuth2 client.\n */\nasync function main() {\n  try {\n    const oAuth2Client = await getAuthenticatedClient();\n    // Make a simple request to the Google Plus API using our pre-authenticated client. The `request()` method\n    // takes an AxiosRequestConfig object.  Visit https://github.com/axios/axios#request-config.\n    const url = 'https://www.googleapis.com/plus/v1/people?query=pizza';\n    const res = await oAuth2Client.request({url})\n    console.log(res.data);\n  } catch (e) {\n    console.error(e);\n  }\n  process.exit();\n}\n\n/**\n * Create a new OAuth2Client, and go through the OAuth2 content\n * workflow.  Return the full client to the callback.\n */\nfunction getAuthenticatedClient() {\n  return new Promise((resolve, reject) => {\n    // create an oAuth client to authorize the API call.  Secrets are kept in a `keys.json` file,\n    // which should be downloaded from the Google Developers Console.\n    const oAuth2Client = new OAuth2Client(\n      keys.web.client_id,\n      keys.web.client_secret,\n      keys.web.redirect_uris[0]\n    );\n\n    // Generate the url that will be used for the consent dialog.\n    const authorizeUrl = oAuth2Client.generateAuthUrl({\n      access_type: 'offline',\n      scope: 'https://www.googleapis.com/auth/plus.me'\n    });\n\n    // Open an http server to accept the oauth callback. In this simple example, the\n    // only request to our webserver is to /oauth2callback?code=\n    const server = http.createServer(async (req, res) => {\n      if (req.url.indexOf('/oauth2callback') > -1) {\n        // acquire the code from the querystring, and close the web server.\n        const qs = querystring.parse(url.parse(req.url).query);\n        console.log(`Code is ${qs.code}`);\n        res.end('Authentication successful! Please return to the console.');\n        server.close();\n\n        // Now that we have the code, use that to acquire tokens.\n        const r = await oAuth2Client.getToken(qs.code)\n        // Make sure to set the credentials on the OAuth2 client.\n        oAuth2Client.setCredentials(r.tokens);\n        console.info('Tokens acquired.');\n        resolve(oAuth2Client);\n      }\n    }).listen(3000, () => {\n      // open the browser to the authorize url to start the workflow\n      opn(authorizeUrl);\n    });\n  });\n}\n\nmain();Handling token events\nThis library will automatically obtain an access_token, and automatically refresh the access_token if a refresh_token is present.  The refresh_token is only returned on the first authorization, so if you want to make sure you store it safely. An easy way to make sure you always store the most recent tokens is to use the tokens event:\nconst client = await auth.getClient();\n\nclient.on('tokens', (tokens) => {\n  if (tokens.refresh_token) {\n    // store the refresh_token in my database!\n    console.log(tokens.refresh_token);\n  }\n  console.log(tokens.access_token);\n});\n\nconst url = `https://www.googleapis.com/dns/v1/projects/${projectId}`;\nconst res = await client.request({ url });\n// The `tokens` event would now be raised if this was the first requestRetrieve access token\nWith the code returned, you can ask for an access token as shown below:\nconst tokens = await oauth2Client.getToken(code);\n// Now tokens contains an access_token and an optional refresh_token. Save them.\noauth2Client.setCredentials(tokens);Manually refreshing access token\nIf you need to manually refresh the access_token associated with your OAuth2 client, ensure the call to generateAuthUrl sets the access_type to offline.  The refresh token will only be returned for the first authorization by the user.  To force consent, set the prompt property to consent:\n// Generate the url that will be used for the consent dialog.\nconst authorizeUrl = oAuth2Client.generateAuthUrl({\n  // To get a refresh token, you MUST set access_type to `offline`.\n  access_type: 'offline',\n  // set the appropriate scopes\n  scope: 'https://www.googleapis.com/auth/plus.me',\n  // A refresh token is only returned the first time the user\n  // consents to providing access.  For illustration purposes,\n  // setting the prompt to 'consent' will force this consent\n  // every time, forcing a refresh_token to be returned.\n  prompt: 'consent'\n});If a refresh_token is set again on OAuth2Client.credentials.refresh_token, you can can refreshAccessToken():\nconst tokens = await oauth2Client.refreshAccessToken();\n// your access_token is now refreshed and stored in oauth2Client\n// store these new tokens in a safe place (e.g. database)Checking access_token information\nAfter obtaining and storing an access_token, at a later time you may want to go check the expiration date,\noriginal scopes, or audience for the token.  To get the token info, you can use the getTokenInfo method:\n// after acquiring an oAuth2Client...\nconst tokenInfo = await oAuth2Client.getTokenInfo('my-access-token');\n\n// take a look at the scopes originally provisioned for the access token\nconsole.log(tokenInfo.scopes);This method will throw if the token is invalid.\nOAuth2 with Installed Apps (Electron)\nIf you're authenticating with OAuth2 from an installed application (like Electron), you may not want to embed your client_secret inside of the application sources. To work around this restriction, you can choose the iOS application type when creating your OAuth2 credentials in the Google Developers console:\n\nIf using the iOS type, when creating the OAuth2 client you won't need to pass a client_secret into the constructor:\nconst oAuth2Client = new OAuth2Client({\n  clientId: ,\n  redirectUri: \n});JSON Web Tokens\nThe Google Developers Console provides a .json file that you can use to configure a JWT auth client and authenticate your requests, for example when using a service account.\nconst {JWT} = require('google-auth-library');\nconst keys = require('./jwt.keys.json');\n\nasync function main() {\n  const client = new JWT(\n    keys.client_email,\n    null,\n    keys.private_key,\n    ['https://www.googleapis.com/auth/cloud-platform'],\n  );\n  const url = `https://www.googleapis.com/dns/v1/projects/${keys.project_id}`;\n  const res = await client.request({url});\n  console.log(res.data);\n}\n\nmain().catch(console.error);The parameters for the JWT auth client including how to use it with a .pem file are explained in samples/jwt.js.\nLoading credentials from environment variables\nInstead of loading credentials from a key file, you can also provide them using an environment variable and the GoogleAuth.fromJSON() method.  This is particularly convenient for systems that deploy directly from source control (Heroku, App Engine, etc).\nStart by exporting your credentials:\n$ export CREDS='{\n  \"type\": \"service_account\",\n  \"project_id\": \"your-project-id\",\n  \"private_key_id\": \"your-private-key-id\",\n  \"private_key\": \"your-private-key\",\n  \"client_email\": \"your-client-email\",\n  \"client_id\": \"your-client-id\",\n  \"auth_uri\": \"https://accounts.google.com/o/oauth2/auth\",\n  \"token_uri\": \"https://accounts.google.com/o/oauth2/token\",\n  \"auth_provider_x509_cert_url\": \"https://www.googleapis.com/oauth2/v1/certs\",\n  \"client_x509_cert_url\": \"your-cert-url\"\n}'Now you can create a new client from the credentials:\nconst {auth} = require('google-auth-library');\n\n// load the environment variable with our keys\nconst keysEnvVar = process.env['CREDS'];\nif (!keysEnvVar) {\n  throw new Error('The $CREDS environment variable was not found!');\n}\nconst keys = JSON.parse(keysEnvVar);\n\nasync function main() {\n  // load the JWT or UserRefreshClient from the keys\n  const client = auth.fromJSON(keys);\n  client.scopes = ['https://www.googleapis.com/auth/cloud-platform'];\n  const url = `https://www.googleapis.com/dns/v1/projects/${keys.project_id}`;\n  const res = await client.request({url});\n  console.log(res.data);\n}\n\nmain().catch(console.error);Using a Proxy\nYou can set the HTTPS_PROXY or https_proxy environment variables to proxy HTTPS requests. When HTTPS_PROXY or https_proxy are set, they will be used to proxy SSL requests that do not have an explicit proxy configuration option present.\nCompute\nIf your application is running on Google Cloud Platform, you can authenticate using the default service account or by specifying a specific service account.\nNote: In most cases, you will want to use Application Default Credentials.  Direct use of the Compute class is for very specific scenarios.\nconst {Compute} = require('google-auth-library');\n\nasync function main() {\n  const client = new Compute({\n    // Specifying the service account email is optional.\n    serviceAccountEmail: 'my-service-account@example.com'\n  });\n  const projectId = 'your-project-id';\n  const url = `https://www.googleapis.com/dns/v1/projects/${project_id}`;\n  const res = await client.request({url});\n  console.log(res.data);\n}\n\nmain().catch(console.error);Questions/problems?\n\nAsk your development related questions on Stack Overflow.\nIf you've found an bug/issue, please file it on GitHub.\n\nContributing\nSee CONTRIBUTING.\nLicense\nThis library is licensed under Apache 2.0. Full license text is available in LICENSE.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n                   \n    \n         result-matching \"\"\n        \n    \n    \n        No results matching \"\"\n    \n\n"},"license.html":{"url":"license.html","title":"getting-started - license","body":"\n                   \n\n                             Apache License\n                       Version 2.0, January 2004\n                    http://www.apache.org/licenses/   TERMS AND CONDITIONS FOR USE, REPRODUCTION, AND DISTRIBUTION\n\nDefinitions.\n\"License\" shall mean the terms and conditions for use, reproduction,\nand distribution as defined by Sections 1 through 9 of this document.\n\"Licensor\" shall mean the copyright owner or entity authorized by\nthe copyright owner that is granting the License.\n\"Legal Entity\" shall mean the union of the acting entity and all\nother entities that control, are controlled by, or are under common\ncontrol with that entity. For the purposes of this definition,\n\"control\" means (i) the power, direct or indirect, to cause the\ndirection or management of such entity, whether by contract or\notherwise, or (ii) ownership of fifty percent (50%) or more of the\noutstanding shares, or (iii) beneficial ownership of such entity.\n\"You\" (or \"Your\") shall mean an individual or Legal Entity\nexercising permissions granted by this License.\n\"Source\" form shall mean the preferred form for making modifications,\nincluding but not limited to software source code, documentation\nsource, and configuration files.\n\"Object\" form shall mean any form resulting from mechanical\ntransformation or translation of a Source form, including but\nnot limited to compiled object code, generated documentation,\nand conversions to other media types.\n\"Work\" shall mean the work of authorship, whether in Source or\nObject form, made available under the License, as indicated by a\ncopyright notice that is included in or attached to the work\n(an example is provided in the Appendix below).\n\"Derivative Works\" shall mean any work, whether in Source or Object\nform, that is based on (or derived from) the Work and for which the\neditorial revisions, annotations, elaborations, or other modifications\nrepresent, as a whole, an original work of authorship. For the purposes\nof this License, Derivative Works shall not include works that remain\nseparable from, or merely link (or bind by name) to the interfaces of,\nthe Work and Derivative Works thereof.\n\"Contribution\" shall mean any work of authorship, including\nthe original version of the Work and any modifications or additions\nto that Work or Derivative Works thereof, that is intentionally\nsubmitted to Licensor for inclusion in the Work by the copyright owner\nor by an individual or Legal Entity authorized to submit on behalf of\nthe copyright owner. For the purposes of this definition, \"submitted\"\nmeans any form of electronic, verbal, or written communication sent\nto the Licensor or its representatives, including but not limited to\ncommunication on electronic mailing lists, source code control systems,\nand issue tracking systems that are managed by, or on behalf of, the\nLicensor for the purpose of discussing and improving the Work, but\nexcluding communication that is conspicuously marked or otherwise\ndesignated in writing by the copyright owner as \"Not a Contribution.\"\n\"Contributor\" shall mean Licensor and any individual or Legal Entity\non behalf of whom a Contribution has been received by Licensor and\nsubsequently incorporated within the Work.\n\nGrant of Copyright License. Subject to the terms and conditions of\nthis License, each Contributor hereby grants to You a perpetual,\nworldwide, non-exclusive, no-charge, royalty-free, irrevocable\ncopyright license to reproduce, prepare Derivative Works of,\npublicly display, publicly perform, sublicense, and distribute the\nWork and such Derivative Works in Source or Object form.\n\nGrant of Patent License. Subject to the terms and conditions of\nthis License, each Contributor hereby grants to You a perpetual,\nworldwide, non-exclusive, no-charge, royalty-free, irrevocable\n(except as stated in this section) patent license to make, have made,\nuse, offer to sell, sell, import, and otherwise transfer the Work,\nwhere such license applies only to those patent claims licensable\nby such Contributor that are necessarily infringed by their\nContribution(s) alone or by combination of their Contribution(s)\nwith the Work to which such Contribution(s) was submitted. If You\ninstitute patent litigation against any entity (including a\ncross-claim or counterclaim in a lawsuit) alleging that the Work\nor a Contribution incorporated within the Work constitutes direct\nor contributory patent infringement, then any patent licenses\ngranted to You under this License for that Work shall terminate\nas of the date such litigation is filed.\n\nRedistribution. You may reproduce and distribute copies of the\nWork or Derivative Works thereof in any medium, with or without\nmodifications, and in Source or Object form, provided that You\nmeet the following conditions:\n(a) You must give any other recipients of the Work or\nDerivative Works a copy of this License; and(b) You must cause any modified files to carry prominent notices\nstating that You changed the files; and(c) You must retain, in the Source form of any Derivative Works\nthat You distribute, all copyright, patent, trademark, and\nattribution notices from the Source form of the Work,\nexcluding those notices that do not pertain to any part of\nthe Derivative Works; and(d) If the Work includes a \"NOTICE\" text file as part of its\ndistribution, then any Derivative Works that You distribute must\ninclude a readable copy of the attribution notices contained\nwithin such NOTICE file, excluding those notices that do not\npertain to any part of the Derivative Works, in at least one\nof the following places: within a NOTICE text file distributed\nas part of the Derivative Works; within the Source form or\ndocumentation, if provided along with the Derivative Works; or,\nwithin a display generated by the Derivative Works, if and\nwherever such third-party notices normally appear. The contents\nof the NOTICE file are for informational purposes only and\ndo not modify the License. You may add Your own attribution\nnotices within Derivative Works that You distribute, alongside\nor as an addendum to the NOTICE text from the Work, provided\nthat such additional attribution notices cannot be construed\nas modifying the License.You may add Your own copyright statement to Your modifications and\nmay provide additional or different license terms and conditions\nfor use, reproduction, or distribution of Your modifications, or\nfor any such Derivative Works as a whole, provided Your use,\nreproduction, and distribution of the Work otherwise complies with\nthe conditions stated in this License.\n\nSubmission of Contributions. Unless You explicitly state otherwise,\nany Contribution intentionally submitted for inclusion in the Work\nby You to the Licensor shall be under the terms and conditions of\nthis License, without any additional terms or conditions.\nNotwithstanding the above, nothing herein shall supersede or modify\nthe terms of any separate license agreement you may have executed\nwith Licensor regarding such Contributions.\n\nTrademarks. This License does not grant permission to use the trade\nnames, trademarks, service marks, or product names of the Licensor,\nexcept as required for reasonable and customary use in describing the\norigin of the Work and reproducing the content of the NOTICE file.\n\nDisclaimer of Warranty. Unless required by applicable law or\nagreed to in writing, Licensor provides the Work (and each\nContributor provides its Contributions) on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or\nimplied, including, without limitation, any warranties or conditions\nof TITLE, NON-INFRINGEMENT, MERCHANTABILITY, or FITNESS FOR A\nPARTICULAR PURPOSE. You are solely responsible for determining the\nappropriateness of using or redistributing the Work and assume any\nrisks associated with Your exercise of permissions under this License.\n\nLimitation of Liability. In no event and under no legal theory,\nwhether in tort (including negligence), contract, or otherwise,\nunless required by applicable law (such as deliberate and grossly\nnegligent acts) or agreed to in writing, shall any Contributor be\nliable to You for damages, including any direct, indirect, special,\nincidental, or consequential damages of any character arising as a\nresult of this License or out of the use or inability to use the\nWork (including but not limited to damages for loss of goodwill,\nwork stoppage, computer failure or malfunction, or any and all\nother commercial damages or losses), even if such Contributor\nhas been advised of the possibility of such damages.\n\nAccepting Warranty or Additional Liability. While redistributing\nthe Work or Derivative Works thereof, You may choose to offer,\nand charge a fee for, acceptance of support, warranty, indemnity,\nor other liability obligations and/or rights consistent with this\nLicense. However, in accepting such obligations, You may act only\non Your own behalf and on Your sole responsibility, not on behalf\nof any other Contributor, and only if You agree to indemnify,\ndefend, and hold each Contributor harmless for any liability\nincurred by, or claims asserted against, such Contributor by reason\nof your accepting any such warranty or additional liability.\nEND OF TERMS AND CONDITIONS\nAPPENDIX: How to apply the Apache License to your work.\nTo apply the Apache License to your work, attach the following\nboilerplate notice, with the fields enclosed by brackets \"[]\"\nreplaced with your own identifying information. (Don't include\nthe brackets!)  The text should be enclosed in the appropriate\ncomment syntax for the file format. We also recommend that a\nfile or class name and description of purpose be included on the\nsame \"printed page\" as the copyright notice for easier\nidentification within third-party archives.\nCopyright [yyyy] [name of copyright owner]\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n http://www.apache.org/licenses/LICENSE-2.0\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n                   \n    \n         result-matching \"\"\n        \n    \n    \n        No results matching \"\"\n    \n\n"},"modules.html":{"url":"modules.html","title":"modules - modules","body":"\n                   \n\n\n\n\n    Modules\n\n\n    \n    \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n                   \n    \n         result-matching \"\"\n        \n    \n    \n        No results matching \"\"\n    \n\n"},"overview.html":{"url":"overview.html","title":"overview - overview","body":"\n                   \n\n\n\n    Overview\n\n\n\n    \n        \n            \n                \n                    \n                    10 Classes\n                \n            \n        \n        \n            \n                \n                    \n                    37 Interfaces\n                \n            \n        \n    \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n                   \n    \n         result-matching \"\"\n        \n    \n    \n        No results matching \"\"\n    \n\n"},"miscellaneous/typealiases.html":{"url":"miscellaneous/typealiases.html","title":"miscellaneous-typealiases - typealiases","body":"\n                   \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  Miscellaneous\n  Type aliases\n\n\n\n    Index\n    \n        \n            \n                \n                    \n                        \n                            Certificates(src/.../oauth2client.ts)\n                        \n                        \n                            Claims(src/.../jwtaccess.ts)\n                        \n                        \n                            Headers(src/.../oauth2client.ts)\n                        \n                    \n                \n            \n        \n    \n\n\n    src/auth/oauth2client.ts\n    \n        \n            \n                \n                    \n                        \n                        Certificates\n                    \n                \n                \n                    \n                        Certificates:     literal type\n\n                    \n                \n            \n        \n        \n            \n                \n                    \n                        \n                        Headers\n                    \n                \n                \n                    \n                        Headers:     literal type\n\n                    \n                \n            \n        \n\n    src/auth/jwtaccess.ts\n    \n        \n            \n                \n                    \n                        \n                        Claims\n                    \n                \n                \n                    \n                        Claims:     literal type\n\n                    \n                \n            \n        \n\n\n\n\n                   \n    \n         result-matching \"\"\n        \n    \n    \n        No results matching \"\"\n    \n\n"},"miscellaneous/variables.html":{"url":"miscellaneous/variables.html","title":"miscellaneous-variables - variables","body":"\n                   \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  Miscellaneous\n  Variables\n\n\n\n    Index\n    \n        \n            \n                \n                    \n                        \n                            auth(src/.../index.ts)\n                        \n                        \n                            CLOUD_SDK_CLIENT_ID(src/.../googleauth.ts)\n                        \n                        \n                            COMPUTE_CREATE_SCOPED_DEPRECATED(src/.../messages.ts)\n                        \n                        \n                            DEFAULT_HEADER(src/.../jwtaccess.ts)\n                        \n                        \n                            DEFAULT_PROJECT_ID_DEPRECATED(src/.../messages.ts)\n                        \n                        \n                            env(src/.../envDetect.ts)\n                        \n                        \n                            HttpsProxyAgent(src/.../transporters.ts)\n                        \n                        \n                            IAM_CREATE_SCOPED_DEPRECATED(src/.../messages.ts)\n                        \n                        \n                            IAM_GET_REQUEST_METADATA_DEPRECATED(src/.../messages.ts)\n                        \n                        \n                            JWT_ACCESS_CREATE_SCOPED_DEPRECATED(src/.../messages.ts)\n                        \n                        \n                            JWT_ACCESS_GET_REQUEST_METADATA_DEPRECATED(src/.../messages.ts)\n                        \n                        \n                            JWT_CREATE_SCOPED_DEPRECATED(src/.../messages.ts)\n                        \n                        \n                            OAUTH_GET_REQUEST_METADATA_DEPRECATED(src/.../messages.ts)\n                        \n                        \n                            pkg(src/.../transporters.ts)\n                        \n                        \n                            PROBLEMATIC_CREDENTIALS_WARNING(src/.../messages.ts)\n                        \n                        \n                            PRODUCT_NAME(src/.../transporters.ts)\n                        \n                        \n                            REFRESH_ACCESS_TOKEN_DEPRECATED(src/.../messages.ts)\n                        \n                    \n                \n            \n        \n    \n\n\n    src/index.ts\n    \n            \n            \n                \n                    \n                        \n                        \n                            \n                            auth\n                            \n                            \n                        \n                    \n                \n                \n                    \n                        auth:     \n\n                    \n                \n                    \n                        \n                            Default value : new GoogleAuth()\n                        \n                    \n\n\n            \n        \n\n    src/auth/googleauth.ts\n    \n            \n            \n                \n                    \n                        \n                        \n                            \n                            CLOUD_SDK_CLIENT_ID\n                            \n                            \n                        \n                    \n                \n                \n                    \n                        CLOUD_SDK_CLIENT_ID:     string\n\n                    \n                \n                    \n                        \n                            Type :     string\n\n                        \n                    \n                    \n                        \n                            Default value : '764086051850-6qr4p6gpi6hn506pt8ejuq83di341hur.apps.googleusercontent.com'\n                        \n                    \n\n\n            \n        \n\n    src/messages.ts\n    \n            \n            \n                \n                    \n                        \n                        \n                            \n                            COMPUTE_CREATE_SCOPED_DEPRECATED\n                            \n                            \n                        \n                    \n                \n                \n                    \n                        COMPUTE_CREATE_SCOPED_DEPRECATED:     object\n\n                    \n                \n                    \n                        \n                            Type :     object\n\n                        \n                    \n                    \n                        \n                            Default value : {\n  code: 'google-auth-library:DEP003',\n  type: WarningTypes.DEPRECATION,\n  message: [\n    'The `createScopedRequired` method on the `Compute` class has been deprecated,',\n    'and will be removed in the 3.0 release of google-auth-library.'\n  ].join(' ')\n}\n                        \n                    \n\n\n            \n        \n        \n            \n                \n                    \n                        \n                        \n                            \n                            DEFAULT_PROJECT_ID_DEPRECATED\n                            \n                            \n                        \n                    \n                \n                \n                    \n                        DEFAULT_PROJECT_ID_DEPRECATED:     object\n\n                    \n                \n                    \n                        \n                            Type :     object\n\n                        \n                    \n                    \n                        \n                            Default value : {\n  code: 'google-auth-library:DEP002',\n  type: WarningTypes.DEPRECATION,\n  message: [\n    'The `getDefaultProjectId` method has been deprecated, and will be removed',\n    'in the 3.0 release of google-auth-library. Please use the `getProjectId`',\n    'method instead.'\n  ].join(' ')\n}\n                        \n                    \n\n\n            \n        \n        \n            \n                \n                    \n                        \n                        \n                            \n                            IAM_CREATE_SCOPED_DEPRECATED\n                            \n                            \n                        \n                    \n                \n                \n                    \n                        IAM_CREATE_SCOPED_DEPRECATED:     object\n\n                    \n                \n                    \n                        \n                            Type :     object\n\n                        \n                    \n                    \n                        \n                            Default value : {\n  code: 'google-auth-library:DEP005',\n  type: WarningTypes.DEPRECATION,\n  message: [\n    'The `createScopedRequired` method on the `IAM` class has been deprecated,',\n    'and will be removed in the 3.0 release of google-auth-library.'\n  ].join(' ')\n}\n                        \n                    \n\n\n            \n        \n        \n            \n                \n                    \n                        \n                        \n                            \n                            IAM_GET_REQUEST_METADATA_DEPRECATED\n                            \n                            \n                        \n                    \n                \n                \n                    \n                        IAM_GET_REQUEST_METADATA_DEPRECATED:     object\n\n                    \n                \n                    \n                        \n                            Type :     object\n\n                        \n                    \n                    \n                        \n                            Default value : {\n  code: 'google-auth-library:DEP005',\n  type: WarningTypes.DEPRECATION,\n  message: [\n    'The `getRequestMetadata` method on the `IAM` class has been deprecated,',\n    'and will be removed in the 3.0 release of google-auth-library. Please use',\n    'the `getRequestHeaders` method instead.'\n  ].join(' ')\n}\n                        \n                    \n\n\n            \n        \n        \n            \n                \n                    \n                        \n                        \n                            \n                            JWT_ACCESS_CREATE_SCOPED_DEPRECATED\n                            \n                            \n                        \n                    \n                \n                \n                    \n                        JWT_ACCESS_CREATE_SCOPED_DEPRECATED:     object\n\n                    \n                \n                    \n                        \n                            Type :     object\n\n                        \n                    \n                    \n                        \n                            Default value : {\n  code: 'google-auth-library:DEP006',\n  type: WarningTypes.DEPRECATION,\n  message: [\n    'The `createScopedRequired` method on the `JWTAccess` class has been deprecated,',\n    'and will be removed in the 3.0 release of google-auth-library.'\n  ].join(' ')\n}\n                        \n                    \n\n\n            \n        \n        \n            \n                \n                    \n                        \n                        \n                            \n                            JWT_ACCESS_GET_REQUEST_METADATA_DEPRECATED\n                            \n                            \n                        \n                    \n                \n                \n                    \n                        JWT_ACCESS_GET_REQUEST_METADATA_DEPRECATED:     object\n\n                    \n                \n                    \n                        \n                            Type :     object\n\n                        \n                    \n                    \n                        \n                            Default value : {\n  code: 'google-auth-library:DEP006',\n  type: WarningTypes.DEPRECATION,\n  message: [\n    'The `getRequestMetadata` method on the `JWTAccess` class has been deprecated,',\n    'and will be removed in the 3.0 release of google-auth-library. Please use',\n    'the `getRequestHeaders` method instead.'\n  ].join(' ')\n}\n                        \n                    \n\n\n            \n        \n        \n            \n                \n                    \n                        \n                        \n                            \n                            JWT_CREATE_SCOPED_DEPRECATED\n                            \n                            \n                        \n                    \n                \n                \n                    \n                        JWT_CREATE_SCOPED_DEPRECATED:     object\n\n                    \n                \n                    \n                        \n                            Type :     object\n\n                        \n                    \n                    \n                        \n                            Default value : {\n  code: 'google-auth-library:DEP004',\n  type: WarningTypes.DEPRECATION,\n  message: [\n    'The `createScopedRequired` method on the `JWT` class has been deprecated,',\n    'and will be removed in the 3.0 release of google-auth-library.'\n  ].join(' ')\n}\n                        \n                    \n\n\n            \n        \n        \n            \n                \n                    \n                        \n                        \n                            \n                            OAUTH_GET_REQUEST_METADATA_DEPRECATED\n                            \n                            \n                        \n                    \n                \n                \n                    \n                        OAUTH_GET_REQUEST_METADATA_DEPRECATED:     object\n\n                    \n                \n                    \n                        \n                            Type :     object\n\n                        \n                    \n                    \n                        \n                            Default value : {\n  code: 'google-auth-library:DEP004',\n  type: WarningTypes.DEPRECATION,\n  message: [\n    'The `getRequestMetadata` method on the `OAuth2` class has been deprecated,',\n    'and will be removed in the 3.0 release of google-auth-library. Please use',\n    'the `getRequestHeaders` method instead.'\n  ].join(' ')\n}\n                        \n                    \n\n\n            \n        \n        \n            \n                \n                    \n                        \n                        \n                            \n                            PROBLEMATIC_CREDENTIALS_WARNING\n                            \n                            \n                        \n                    \n                \n                \n                    \n                        PROBLEMATIC_CREDENTIALS_WARNING:     object\n\n                    \n                \n                    \n                        \n                            Type :     object\n\n                        \n                    \n                    \n                        \n                            Default value : {\n  code: 'google-auth-library:00001',\n  type: WarningTypes.WARNING,\n  message: [\n    'Your application has authenticated using end user credentials from Google',\n    'Cloud SDK. We recommend that most server applications use service accounts',\n    'instead. If your application continues to use end user credentials from',\n    'Cloud SDK, you might receive a \"quota exceeded\" or \"API not enabled\" error.',\n    'For more information about service accounts, see',\n    'https://cloud.google.com/docs/authentication/.'\n  ].join(' ')\n}\n                        \n                    \n\n\n            \n        \n        \n            \n                \n                    \n                        \n                        \n                            \n                            REFRESH_ACCESS_TOKEN_DEPRECATED\n                            \n                            \n                        \n                    \n                \n                \n                    \n                        REFRESH_ACCESS_TOKEN_DEPRECATED:     object\n\n                    \n                \n                    \n                        \n                            Type :     object\n\n                        \n                    \n                    \n                        \n                            Default value : {\n  code: 'google-auth-library:DEP007',\n  type: WarningTypes.DEPRECATION,\n  message: [\n    'The `refreshAccessToken` method has been deprecated, and will be removed',\n    'in the 3.0 release of google-auth-library. Please use the `getRequestHeaders`',\n    'method instead.'\n  ].join(' ')\n}\n                        \n                    \n\n\n            \n        \n\n    src/auth/jwtaccess.ts\n    \n            \n            \n                \n                    \n                        \n                        \n                            \n                            DEFAULT_HEADER\n                            \n                            \n                        \n                    \n                \n                \n                    \n                        DEFAULT_HEADER:     jws.Header\n\n                    \n                \n                    \n                        \n                            Type :     jws.Header\n\n                        \n                    \n                    \n                        \n                            Default value : {\n  alg: 'RS256',\n  typ: 'JWT'\n}\n                        \n                    \n\n\n            \n        \n\n    src/auth/envDetect.ts\n    \n            \n            \n                \n                    \n                        \n                        \n                            \n                            env\n                            \n                            \n                        \n                    \n                \n                \n                    \n                        env:     GCPEnv | undefined\n\n                    \n                \n                    \n                        \n                            Type :     GCPEnv | undefined\n\n                        \n                    \n\n\n            \n        \n\n    src/transporters.ts\n    \n            \n            \n                \n                    \n                        \n                        \n                            \n                            HttpsProxyAgent\n                            \n                            \n                        \n                    \n                \n                \n                    \n                        HttpsProxyAgent:     \n\n                    \n                \n                    \n                        \n                            Default value : require('https-proxy-agent')\n                        \n                    \n\n\n            \n        \n        \n            \n                \n                    \n                        \n                        \n                            \n                            pkg\n                            \n                            \n                        \n                    \n                \n                \n                    \n                        pkg:     \n\n                    \n                \n                    \n                        \n                            Default value : require('../../package.json')\n                        \n                    \n\n\n            \n        \n        \n            \n                \n                    \n                        \n                        \n                            \n                            PRODUCT_NAME\n                            \n                            \n                        \n                    \n                \n                \n                    \n                        PRODUCT_NAME:     string\n\n                    \n                \n                    \n                        \n                            Type :     string\n\n                        \n                    \n                    \n                        \n                            Default value : 'google-api-nodejs-client'\n                        \n                    \n\n\n            \n        \n\n\n\n\n                   \n    \n         result-matching \"\"\n        \n    \n    \n        No results matching \"\"\n    \n\n"}}
}
